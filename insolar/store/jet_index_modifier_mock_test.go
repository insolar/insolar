package store

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/insolar"
)

// JetIndexModifierMock implements JetIndexModifier
type JetIndexModifierMock struct {
	t minimock.Tester

	funcAdd          func(id insolar.ID, jetID insolar.JetID)
	inspectFuncAdd   func(id insolar.ID, jetID insolar.JetID)
	afterAddCounter  uint64
	beforeAddCounter uint64
	AddMock          mJetIndexModifierMockAdd

	funcDelete          func(id insolar.ID, jetID insolar.JetID)
	inspectFuncDelete   func(id insolar.ID, jetID insolar.JetID)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mJetIndexModifierMockDelete
}

// NewJetIndexModifierMock returns a mock for JetIndexModifier
func NewJetIndexModifierMock(t minimock.Tester) *JetIndexModifierMock {
	m := &JetIndexModifierMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddMock = mJetIndexModifierMockAdd{mock: m}
	m.AddMock.callArgs = []*JetIndexModifierMockAddParams{}

	m.DeleteMock = mJetIndexModifierMockDelete{mock: m}
	m.DeleteMock.callArgs = []*JetIndexModifierMockDeleteParams{}

	return m
}

type mJetIndexModifierMockAdd struct {
	mock               *JetIndexModifierMock
	defaultExpectation *JetIndexModifierMockAddExpectation
	expectations       []*JetIndexModifierMockAddExpectation

	callArgs []*JetIndexModifierMockAddParams
	mutex    sync.RWMutex
}

// JetIndexModifierMockAddExpectation specifies expectation struct of the JetIndexModifier.Add
type JetIndexModifierMockAddExpectation struct {
	mock   *JetIndexModifierMock
	params *JetIndexModifierMockAddParams

	Counter uint64
}

// JetIndexModifierMockAddParams contains parameters of the JetIndexModifier.Add
type JetIndexModifierMockAddParams struct {
	id    insolar.ID
	jetID insolar.JetID
}

// Expect sets up expected params for JetIndexModifier.Add
func (mmAdd *mJetIndexModifierMockAdd) Expect(id insolar.ID, jetID insolar.JetID) *mJetIndexModifierMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("JetIndexModifierMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &JetIndexModifierMockAddExpectation{}
	}

	mmAdd.defaultExpectation.params = &JetIndexModifierMockAddParams{id, jetID}
	for _, e := range mmAdd.expectations {
		if minimock.Equal(e.params, mmAdd.defaultExpectation.params) {
			mmAdd.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAdd.defaultExpectation.params)
		}
	}

	return mmAdd
}

// Inspect accepts an inspector function that has same arguments as the JetIndexModifier.Add
func (mmAdd *mJetIndexModifierMockAdd) Inspect(f func(id insolar.ID, jetID insolar.JetID)) *mJetIndexModifierMockAdd {
	if mmAdd.mock.inspectFuncAdd != nil {
		mmAdd.mock.t.Fatalf("Inspect function is already set for JetIndexModifierMock.Add")
	}

	mmAdd.mock.inspectFuncAdd = f

	return mmAdd
}

// Return sets up results that will be returned by JetIndexModifier.Add
func (mmAdd *mJetIndexModifierMockAdd) Return() *JetIndexModifierMock {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("JetIndexModifierMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &JetIndexModifierMockAddExpectation{mock: mmAdd.mock}
	}

	return mmAdd.mock
}

//Set uses given function f to mock the JetIndexModifier.Add method
func (mmAdd *mJetIndexModifierMockAdd) Set(f func(id insolar.ID, jetID insolar.JetID)) *JetIndexModifierMock {
	if mmAdd.defaultExpectation != nil {
		mmAdd.mock.t.Fatalf("Default expectation is already set for the JetIndexModifier.Add method")
	}

	if len(mmAdd.expectations) > 0 {
		mmAdd.mock.t.Fatalf("Some expectations are already set for the JetIndexModifier.Add method")
	}

	mmAdd.mock.funcAdd = f
	return mmAdd.mock
}

// Add implements JetIndexModifier
func (mmAdd *JetIndexModifierMock) Add(id insolar.ID, jetID insolar.JetID) {
	mm_atomic.AddUint64(&mmAdd.beforeAddCounter, 1)
	defer mm_atomic.AddUint64(&mmAdd.afterAddCounter, 1)

	if mmAdd.inspectFuncAdd != nil {
		mmAdd.inspectFuncAdd(id, jetID)
	}

	params := &JetIndexModifierMockAddParams{id, jetID}

	// Record call args
	mmAdd.AddMock.mutex.Lock()
	mmAdd.AddMock.callArgs = append(mmAdd.AddMock.callArgs, params)
	mmAdd.AddMock.mutex.Unlock()

	for _, e := range mmAdd.AddMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAdd.AddMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAdd.AddMock.defaultExpectation.Counter, 1)
		want := mmAdd.AddMock.defaultExpectation.params
		got := JetIndexModifierMockAddParams{id, jetID}
		if want != nil && !minimock.Equal(*want, got) {
			mmAdd.t.Errorf("JetIndexModifierMock.Add got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmAdd.funcAdd != nil {
		mmAdd.funcAdd(id, jetID)
		return
	}
	mmAdd.t.Fatalf("Unexpected call to JetIndexModifierMock.Add. %v %v", id, jetID)

}

// AddAfterCounter returns a count of finished JetIndexModifierMock.Add invocations
func (mmAdd *JetIndexModifierMock) AddAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAdd.afterAddCounter)
}

// AddBeforeCounter returns a count of JetIndexModifierMock.Add invocations
func (mmAdd *JetIndexModifierMock) AddBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAdd.beforeAddCounter)
}

// Calls returns a list of arguments used in each call to JetIndexModifierMock.Add.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAdd *mJetIndexModifierMockAdd) Calls() []*JetIndexModifierMockAddParams {
	mmAdd.mutex.RLock()

	argCopy := make([]*JetIndexModifierMockAddParams, len(mmAdd.callArgs))
	copy(argCopy, mmAdd.callArgs)

	mmAdd.mutex.RUnlock()

	return argCopy
}

// MinimockAddDone returns true if the count of the Add invocations corresponds
// the number of defined expectations
func (m *JetIndexModifierMock) MinimockAddDone() bool {
	for _, e := range m.AddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAdd != nil && mm_atomic.LoadUint64(&m.afterAddCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddInspect logs each unmet expectation
func (m *JetIndexModifierMock) MinimockAddInspect() {
	for _, e := range m.AddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to JetIndexModifierMock.Add with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddCounter) < 1 {
		if m.AddMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to JetIndexModifierMock.Add")
		} else {
			m.t.Errorf("Expected call to JetIndexModifierMock.Add with params: %#v", *m.AddMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAdd != nil && mm_atomic.LoadUint64(&m.afterAddCounter) < 1 {
		m.t.Error("Expected call to JetIndexModifierMock.Add")
	}
}

type mJetIndexModifierMockDelete struct {
	mock               *JetIndexModifierMock
	defaultExpectation *JetIndexModifierMockDeleteExpectation
	expectations       []*JetIndexModifierMockDeleteExpectation

	callArgs []*JetIndexModifierMockDeleteParams
	mutex    sync.RWMutex
}

// JetIndexModifierMockDeleteExpectation specifies expectation struct of the JetIndexModifier.Delete
type JetIndexModifierMockDeleteExpectation struct {
	mock   *JetIndexModifierMock
	params *JetIndexModifierMockDeleteParams

	Counter uint64
}

// JetIndexModifierMockDeleteParams contains parameters of the JetIndexModifier.Delete
type JetIndexModifierMockDeleteParams struct {
	id    insolar.ID
	jetID insolar.JetID
}

// Expect sets up expected params for JetIndexModifier.Delete
func (mmDelete *mJetIndexModifierMockDelete) Expect(id insolar.ID, jetID insolar.JetID) *mJetIndexModifierMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("JetIndexModifierMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &JetIndexModifierMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &JetIndexModifierMockDeleteParams{id, jetID}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the JetIndexModifier.Delete
func (mmDelete *mJetIndexModifierMockDelete) Inspect(f func(id insolar.ID, jetID insolar.JetID)) *mJetIndexModifierMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for JetIndexModifierMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by JetIndexModifier.Delete
func (mmDelete *mJetIndexModifierMockDelete) Return() *JetIndexModifierMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("JetIndexModifierMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &JetIndexModifierMockDeleteExpectation{mock: mmDelete.mock}
	}

	return mmDelete.mock
}

//Set uses given function f to mock the JetIndexModifier.Delete method
func (mmDelete *mJetIndexModifierMockDelete) Set(f func(id insolar.ID, jetID insolar.JetID)) *JetIndexModifierMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the JetIndexModifier.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the JetIndexModifier.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// Delete implements JetIndexModifier
func (mmDelete *JetIndexModifierMock) Delete(id insolar.ID, jetID insolar.JetID) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(id, jetID)
	}

	params := &JetIndexModifierMockDeleteParams{id, jetID}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		want := mmDelete.DeleteMock.defaultExpectation.params
		got := JetIndexModifierMockDeleteParams{id, jetID}
		if want != nil && !minimock.Equal(*want, got) {
			mmDelete.t.Errorf("JetIndexModifierMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmDelete.funcDelete != nil {
		mmDelete.funcDelete(id, jetID)
		return
	}
	mmDelete.t.Fatalf("Unexpected call to JetIndexModifierMock.Delete. %v %v", id, jetID)

}

// DeleteAfterCounter returns a count of finished JetIndexModifierMock.Delete invocations
func (mmDelete *JetIndexModifierMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of JetIndexModifierMock.Delete invocations
func (mmDelete *JetIndexModifierMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to JetIndexModifierMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mJetIndexModifierMockDelete) Calls() []*JetIndexModifierMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*JetIndexModifierMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *JetIndexModifierMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *JetIndexModifierMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to JetIndexModifierMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to JetIndexModifierMock.Delete")
		} else {
			m.t.Errorf("Expected call to JetIndexModifierMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to JetIndexModifierMock.Delete")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *JetIndexModifierMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddInspect()

		m.MinimockDeleteInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *JetIndexModifierMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *JetIndexModifierMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddDone() &&
		m.MinimockDeleteDone()
}
