package insolar

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
)

// LoggerMock implements Logger
type LoggerMock struct {
	t minimock.Tester

	funcCopy          func() (l1 LoggerBuilder)
	inspectFuncCopy   func()
	afterCopyCounter  uint64
	beforeCopyCounter uint64
	CopyMock          mLoggerMockCopy

	funcDebug          func(p1 ...interface{})
	inspectFuncDebug   func(p1 ...interface{})
	afterDebugCounter  uint64
	beforeDebugCounter uint64
	DebugMock          mLoggerMockDebug

	funcDebugf          func(s1 string, p1 ...interface{})
	inspectFuncDebugf   func(s1 string, p1 ...interface{})
	afterDebugfCounter  uint64
	beforeDebugfCounter uint64
	DebugfMock          mLoggerMockDebugf

	funcEmbeddable          func() (e1 EmbeddedLogger)
	inspectFuncEmbeddable   func()
	afterEmbeddableCounter  uint64
	beforeEmbeddableCounter uint64
	EmbeddableMock          mLoggerMockEmbeddable

	funcError          func(p1 ...interface{})
	inspectFuncError   func(p1 ...interface{})
	afterErrorCounter  uint64
	beforeErrorCounter uint64
	ErrorMock          mLoggerMockError

	funcErrorf          func(s1 string, p1 ...interface{})
	inspectFuncErrorf   func(s1 string, p1 ...interface{})
	afterErrorfCounter  uint64
	beforeErrorfCounter uint64
	ErrorfMock          mLoggerMockErrorf

	funcEvent          func(level LogLevel, args ...interface{})
	inspectFuncEvent   func(level LogLevel, args ...interface{})
	afterEventCounter  uint64
	beforeEventCounter uint64
	EventMock          mLoggerMockEvent

	funcEventf          func(level LogLevel, fmt string, args ...interface{})
	inspectFuncEventf   func(level LogLevel, fmt string, args ...interface{})
	afterEventfCounter  uint64
	beforeEventfCounter uint64
	EventfMock          mLoggerMockEventf

	funcFatal          func(p1 ...interface{})
	inspectFuncFatal   func(p1 ...interface{})
	afterFatalCounter  uint64
	beforeFatalCounter uint64
	FatalMock          mLoggerMockFatal

	funcFatalf          func(s1 string, p1 ...interface{})
	inspectFuncFatalf   func(s1 string, p1 ...interface{})
	afterFatalfCounter  uint64
	beforeFatalfCounter uint64
	FatalfMock          mLoggerMockFatalf

	funcInfo          func(p1 ...interface{})
	inspectFuncInfo   func(p1 ...interface{})
	afterInfoCounter  uint64
	beforeInfoCounter uint64
	InfoMock          mLoggerMockInfo

	funcInfof          func(s1 string, p1 ...interface{})
	inspectFuncInfof   func(s1 string, p1 ...interface{})
	afterInfofCounter  uint64
	beforeInfofCounter uint64
	InfofMock          mLoggerMockInfof

	funcIs          func(level LogLevel) (b1 bool)
	inspectFuncIs   func(level LogLevel)
	afterIsCounter  uint64
	beforeIsCounter uint64
	IsMock          mLoggerMockIs

	funcLevel          func(lvl LogLevel) (l1 Logger)
	inspectFuncLevel   func(lvl LogLevel)
	afterLevelCounter  uint64
	beforeLevelCounter uint64
	LevelMock          mLoggerMockLevel

	funcPanic          func(p1 ...interface{})
	inspectFuncPanic   func(p1 ...interface{})
	afterPanicCounter  uint64
	beforePanicCounter uint64
	PanicMock          mLoggerMockPanic

	funcPanicf          func(s1 string, p1 ...interface{})
	inspectFuncPanicf   func(s1 string, p1 ...interface{})
	afterPanicfCounter  uint64
	beforePanicfCounter uint64
	PanicfMock          mLoggerMockPanicf

	funcWarn          func(p1 ...interface{})
	inspectFuncWarn   func(p1 ...interface{})
	afterWarnCounter  uint64
	beforeWarnCounter uint64
	WarnMock          mLoggerMockWarn

	funcWarnf          func(s1 string, p1 ...interface{})
	inspectFuncWarnf   func(s1 string, p1 ...interface{})
	afterWarnfCounter  uint64
	beforeWarnfCounter uint64
	WarnfMock          mLoggerMockWarnf

	funcWithField          func(s1 string, p1 interface{}) (l1 Logger)
	inspectFuncWithField   func(s1 string, p1 interface{})
	afterWithFieldCounter  uint64
	beforeWithFieldCounter uint64
	WithFieldMock          mLoggerMockWithField

	funcWithFields          func(m1 map[string]interface{}) (l1 Logger)
	inspectFuncWithFields   func(m1 map[string]interface{})
	afterWithFieldsCounter  uint64
	beforeWithFieldsCounter uint64
	WithFieldsMock          mLoggerMockWithFields
}

// NewLoggerMock returns a mock for Logger
func NewLoggerMock(t minimock.Tester) *LoggerMock {
	m := &LoggerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CopyMock = mLoggerMockCopy{mock: m}

	m.DebugMock = mLoggerMockDebug{mock: m}
	m.DebugMock.callArgs = []*LoggerMockDebugParams{}

	m.DebugfMock = mLoggerMockDebugf{mock: m}
	m.DebugfMock.callArgs = []*LoggerMockDebugfParams{}

	m.EmbeddableMock = mLoggerMockEmbeddable{mock: m}

	m.ErrorMock = mLoggerMockError{mock: m}
	m.ErrorMock.callArgs = []*LoggerMockErrorParams{}

	m.ErrorfMock = mLoggerMockErrorf{mock: m}
	m.ErrorfMock.callArgs = []*LoggerMockErrorfParams{}

	m.EventMock = mLoggerMockEvent{mock: m}
	m.EventMock.callArgs = []*LoggerMockEventParams{}

	m.EventfMock = mLoggerMockEventf{mock: m}
	m.EventfMock.callArgs = []*LoggerMockEventfParams{}

	m.FatalMock = mLoggerMockFatal{mock: m}
	m.FatalMock.callArgs = []*LoggerMockFatalParams{}

	m.FatalfMock = mLoggerMockFatalf{mock: m}
	m.FatalfMock.callArgs = []*LoggerMockFatalfParams{}

	m.InfoMock = mLoggerMockInfo{mock: m}
	m.InfoMock.callArgs = []*LoggerMockInfoParams{}

	m.InfofMock = mLoggerMockInfof{mock: m}
	m.InfofMock.callArgs = []*LoggerMockInfofParams{}

	m.IsMock = mLoggerMockIs{mock: m}
	m.IsMock.callArgs = []*LoggerMockIsParams{}

	m.LevelMock = mLoggerMockLevel{mock: m}
	m.LevelMock.callArgs = []*LoggerMockLevelParams{}

	m.PanicMock = mLoggerMockPanic{mock: m}
	m.PanicMock.callArgs = []*LoggerMockPanicParams{}

	m.PanicfMock = mLoggerMockPanicf{mock: m}
	m.PanicfMock.callArgs = []*LoggerMockPanicfParams{}

	m.WarnMock = mLoggerMockWarn{mock: m}
	m.WarnMock.callArgs = []*LoggerMockWarnParams{}

	m.WarnfMock = mLoggerMockWarnf{mock: m}
	m.WarnfMock.callArgs = []*LoggerMockWarnfParams{}

	m.WithFieldMock = mLoggerMockWithField{mock: m}
	m.WithFieldMock.callArgs = []*LoggerMockWithFieldParams{}

	m.WithFieldsMock = mLoggerMockWithFields{mock: m}
	m.WithFieldsMock.callArgs = []*LoggerMockWithFieldsParams{}

	return m
}

type mLoggerMockCopy struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockCopyExpectation
	expectations       []*LoggerMockCopyExpectation
}

// LoggerMockCopyExpectation specifies expectation struct of the Logger.Copy
type LoggerMockCopyExpectation struct {
	mock *LoggerMock

	results *LoggerMockCopyResults
	Counter uint64
}

// LoggerMockCopyResults contains results of the Logger.Copy
type LoggerMockCopyResults struct {
	l1 LoggerBuilder
}

// Expect sets up expected params for Logger.Copy
func (mmCopy *mLoggerMockCopy) Expect() *mLoggerMockCopy {
	if mmCopy.mock.funcCopy != nil {
		mmCopy.mock.t.Fatalf("LoggerMock.Copy mock is already set by Set")
	}

	if mmCopy.defaultExpectation == nil {
		mmCopy.defaultExpectation = &LoggerMockCopyExpectation{}
	}

	return mmCopy
}

// Inspect accepts an inspector function that has same arguments as the Logger.Copy
func (mmCopy *mLoggerMockCopy) Inspect(f func()) *mLoggerMockCopy {
	if mmCopy.mock.inspectFuncCopy != nil {
		mmCopy.mock.t.Fatalf("Inspect function is already set for LoggerMock.Copy")
	}

	mmCopy.mock.inspectFuncCopy = f

	return mmCopy
}

// Return sets up results that will be returned by Logger.Copy
func (mmCopy *mLoggerMockCopy) Return(l1 LoggerBuilder) *LoggerMock {
	if mmCopy.mock.funcCopy != nil {
		mmCopy.mock.t.Fatalf("LoggerMock.Copy mock is already set by Set")
	}

	if mmCopy.defaultExpectation == nil {
		mmCopy.defaultExpectation = &LoggerMockCopyExpectation{mock: mmCopy.mock}
	}
	mmCopy.defaultExpectation.results = &LoggerMockCopyResults{l1}
	return mmCopy.mock
}

//Set uses given function f to mock the Logger.Copy method
func (mmCopy *mLoggerMockCopy) Set(f func() (l1 LoggerBuilder)) *LoggerMock {
	if mmCopy.defaultExpectation != nil {
		mmCopy.mock.t.Fatalf("Default expectation is already set for the Logger.Copy method")
	}

	if len(mmCopy.expectations) > 0 {
		mmCopy.mock.t.Fatalf("Some expectations are already set for the Logger.Copy method")
	}

	mmCopy.mock.funcCopy = f
	return mmCopy.mock
}

// Copy implements Logger
func (mmCopy *LoggerMock) Copy() (l1 LoggerBuilder) {
	mm_atomic.AddUint64(&mmCopy.beforeCopyCounter, 1)
	defer mm_atomic.AddUint64(&mmCopy.afterCopyCounter, 1)

	if mmCopy.inspectFuncCopy != nil {
		mmCopy.inspectFuncCopy()
	}

	if mmCopy.CopyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCopy.CopyMock.defaultExpectation.Counter, 1)

		results := mmCopy.CopyMock.defaultExpectation.results
		if results == nil {
			mmCopy.t.Fatal("No results are set for the LoggerMock.Copy")
		}
		return (*results).l1
	}
	if mmCopy.funcCopy != nil {
		return mmCopy.funcCopy()
	}
	mmCopy.t.Fatalf("Unexpected call to LoggerMock.Copy.")
	return
}

// CopyAfterCounter returns a count of finished LoggerMock.Copy invocations
func (mmCopy *LoggerMock) CopyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopy.afterCopyCounter)
}

// CopyBeforeCounter returns a count of LoggerMock.Copy invocations
func (mmCopy *LoggerMock) CopyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopy.beforeCopyCounter)
}

// MinimockCopyDone returns true if the count of the Copy invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockCopyDone() bool {
	for _, e := range m.CopyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopy != nil && mm_atomic.LoadUint64(&m.afterCopyCounter) < 1 {
		return false
	}
	return true
}

// MinimockCopyInspect logs each unmet expectation
func (m *LoggerMock) MinimockCopyInspect() {
	for _, e := range m.CopyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LoggerMock.Copy")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Copy")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopy != nil && mm_atomic.LoadUint64(&m.afterCopyCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Copy")
	}
}

type mLoggerMockDebug struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockDebugExpectation
	expectations       []*LoggerMockDebugExpectation

	callArgs []*LoggerMockDebugParams
	mutex    sync.RWMutex
}

// LoggerMockDebugExpectation specifies expectation struct of the Logger.Debug
type LoggerMockDebugExpectation struct {
	mock   *LoggerMock
	params *LoggerMockDebugParams

	Counter uint64
}

// LoggerMockDebugParams contains parameters of the Logger.Debug
type LoggerMockDebugParams struct {
	p1 []interface{}
}

// Expect sets up expected params for Logger.Debug
func (mmDebug *mLoggerMockDebug) Expect(p1 ...interface{}) *mLoggerMockDebug {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &LoggerMockDebugExpectation{}
	}

	mmDebug.defaultExpectation.params = &LoggerMockDebugParams{p1}
	for _, e := range mmDebug.expectations {
		if minimock.Equal(e.params, mmDebug.defaultExpectation.params) {
			mmDebug.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDebug.defaultExpectation.params)
		}
	}

	return mmDebug
}

// Inspect accepts an inspector function that has same arguments as the Logger.Debug
func (mmDebug *mLoggerMockDebug) Inspect(f func(p1 ...interface{})) *mLoggerMockDebug {
	if mmDebug.mock.inspectFuncDebug != nil {
		mmDebug.mock.t.Fatalf("Inspect function is already set for LoggerMock.Debug")
	}

	mmDebug.mock.inspectFuncDebug = f

	return mmDebug
}

// Return sets up results that will be returned by Logger.Debug
func (mmDebug *mLoggerMockDebug) Return() *LoggerMock {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &LoggerMockDebugExpectation{mock: mmDebug.mock}
	}

	return mmDebug.mock
}

//Set uses given function f to mock the Logger.Debug method
func (mmDebug *mLoggerMockDebug) Set(f func(p1 ...interface{})) *LoggerMock {
	if mmDebug.defaultExpectation != nil {
		mmDebug.mock.t.Fatalf("Default expectation is already set for the Logger.Debug method")
	}

	if len(mmDebug.expectations) > 0 {
		mmDebug.mock.t.Fatalf("Some expectations are already set for the Logger.Debug method")
	}

	mmDebug.mock.funcDebug = f
	return mmDebug.mock
}

// Debug implements Logger
func (mmDebug *LoggerMock) Debug(p1 ...interface{}) {
	mm_atomic.AddUint64(&mmDebug.beforeDebugCounter, 1)
	defer mm_atomic.AddUint64(&mmDebug.afterDebugCounter, 1)

	if mmDebug.inspectFuncDebug != nil {
		mmDebug.inspectFuncDebug(p1...)
	}

	params := &LoggerMockDebugParams{p1}

	// Record call args
	mmDebug.DebugMock.mutex.Lock()
	mmDebug.DebugMock.callArgs = append(mmDebug.DebugMock.callArgs, params)
	mmDebug.DebugMock.mutex.Unlock()

	for _, e := range mmDebug.DebugMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDebug.DebugMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDebug.DebugMock.defaultExpectation.Counter, 1)
		want := mmDebug.DebugMock.defaultExpectation.params
		got := LoggerMockDebugParams{p1}
		if want != nil && !minimock.Equal(*want, got) {
			mmDebug.t.Errorf("LoggerMock.Debug got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmDebug.funcDebug != nil {
		mmDebug.funcDebug(p1...)
		return
	}
	mmDebug.t.Fatalf("Unexpected call to LoggerMock.Debug. %v", p1)

}

// DebugAfterCounter returns a count of finished LoggerMock.Debug invocations
func (mmDebug *LoggerMock) DebugAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebug.afterDebugCounter)
}

// DebugBeforeCounter returns a count of LoggerMock.Debug invocations
func (mmDebug *LoggerMock) DebugBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebug.beforeDebugCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Debug.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDebug *mLoggerMockDebug) Calls() []*LoggerMockDebugParams {
	mmDebug.mutex.RLock()

	argCopy := make([]*LoggerMockDebugParams, len(mmDebug.callArgs))
	copy(argCopy, mmDebug.callArgs)

	mmDebug.mutex.RUnlock()

	return argCopy
}

// MinimockDebugDone returns true if the count of the Debug invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockDebugDone() bool {
	for _, e := range m.DebugMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DebugMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDebugCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDebug != nil && mm_atomic.LoadUint64(&m.afterDebugCounter) < 1 {
		return false
	}
	return true
}

// MinimockDebugInspect logs each unmet expectation
func (m *LoggerMock) MinimockDebugInspect() {
	for _, e := range m.DebugMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Debug with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DebugMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDebugCounter) < 1 {
		if m.DebugMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Debug")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Debug with params: %#v", *m.DebugMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDebug != nil && mm_atomic.LoadUint64(&m.afterDebugCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Debug")
	}
}

type mLoggerMockDebugf struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockDebugfExpectation
	expectations       []*LoggerMockDebugfExpectation

	callArgs []*LoggerMockDebugfParams
	mutex    sync.RWMutex
}

// LoggerMockDebugfExpectation specifies expectation struct of the Logger.Debugf
type LoggerMockDebugfExpectation struct {
	mock   *LoggerMock
	params *LoggerMockDebugfParams

	Counter uint64
}

// LoggerMockDebugfParams contains parameters of the Logger.Debugf
type LoggerMockDebugfParams struct {
	s1 string
	p1 []interface{}
}

// Expect sets up expected params for Logger.Debugf
func (mmDebugf *mLoggerMockDebugf) Expect(s1 string, p1 ...interface{}) *mLoggerMockDebugf {
	if mmDebugf.mock.funcDebugf != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by Set")
	}

	if mmDebugf.defaultExpectation == nil {
		mmDebugf.defaultExpectation = &LoggerMockDebugfExpectation{}
	}

	mmDebugf.defaultExpectation.params = &LoggerMockDebugfParams{s1, p1}
	for _, e := range mmDebugf.expectations {
		if minimock.Equal(e.params, mmDebugf.defaultExpectation.params) {
			mmDebugf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDebugf.defaultExpectation.params)
		}
	}

	return mmDebugf
}

// Inspect accepts an inspector function that has same arguments as the Logger.Debugf
func (mmDebugf *mLoggerMockDebugf) Inspect(f func(s1 string, p1 ...interface{})) *mLoggerMockDebugf {
	if mmDebugf.mock.inspectFuncDebugf != nil {
		mmDebugf.mock.t.Fatalf("Inspect function is already set for LoggerMock.Debugf")
	}

	mmDebugf.mock.inspectFuncDebugf = f

	return mmDebugf
}

// Return sets up results that will be returned by Logger.Debugf
func (mmDebugf *mLoggerMockDebugf) Return() *LoggerMock {
	if mmDebugf.mock.funcDebugf != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by Set")
	}

	if mmDebugf.defaultExpectation == nil {
		mmDebugf.defaultExpectation = &LoggerMockDebugfExpectation{mock: mmDebugf.mock}
	}

	return mmDebugf.mock
}

//Set uses given function f to mock the Logger.Debugf method
func (mmDebugf *mLoggerMockDebugf) Set(f func(s1 string, p1 ...interface{})) *LoggerMock {
	if mmDebugf.defaultExpectation != nil {
		mmDebugf.mock.t.Fatalf("Default expectation is already set for the Logger.Debugf method")
	}

	if len(mmDebugf.expectations) > 0 {
		mmDebugf.mock.t.Fatalf("Some expectations are already set for the Logger.Debugf method")
	}

	mmDebugf.mock.funcDebugf = f
	return mmDebugf.mock
}

// Debugf implements Logger
func (mmDebugf *LoggerMock) Debugf(s1 string, p1 ...interface{}) {
	mm_atomic.AddUint64(&mmDebugf.beforeDebugfCounter, 1)
	defer mm_atomic.AddUint64(&mmDebugf.afterDebugfCounter, 1)

	if mmDebugf.inspectFuncDebugf != nil {
		mmDebugf.inspectFuncDebugf(s1, p1...)
	}

	params := &LoggerMockDebugfParams{s1, p1}

	// Record call args
	mmDebugf.DebugfMock.mutex.Lock()
	mmDebugf.DebugfMock.callArgs = append(mmDebugf.DebugfMock.callArgs, params)
	mmDebugf.DebugfMock.mutex.Unlock()

	for _, e := range mmDebugf.DebugfMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDebugf.DebugfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDebugf.DebugfMock.defaultExpectation.Counter, 1)
		want := mmDebugf.DebugfMock.defaultExpectation.params
		got := LoggerMockDebugfParams{s1, p1}
		if want != nil && !minimock.Equal(*want, got) {
			mmDebugf.t.Errorf("LoggerMock.Debugf got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmDebugf.funcDebugf != nil {
		mmDebugf.funcDebugf(s1, p1...)
		return
	}
	mmDebugf.t.Fatalf("Unexpected call to LoggerMock.Debugf. %v %v", s1, p1)

}

// DebugfAfterCounter returns a count of finished LoggerMock.Debugf invocations
func (mmDebugf *LoggerMock) DebugfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebugf.afterDebugfCounter)
}

// DebugfBeforeCounter returns a count of LoggerMock.Debugf invocations
func (mmDebugf *LoggerMock) DebugfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebugf.beforeDebugfCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Debugf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDebugf *mLoggerMockDebugf) Calls() []*LoggerMockDebugfParams {
	mmDebugf.mutex.RLock()

	argCopy := make([]*LoggerMockDebugfParams, len(mmDebugf.callArgs))
	copy(argCopy, mmDebugf.callArgs)

	mmDebugf.mutex.RUnlock()

	return argCopy
}

// MinimockDebugfDone returns true if the count of the Debugf invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockDebugfDone() bool {
	for _, e := range m.DebugfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DebugfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDebugfCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDebugf != nil && mm_atomic.LoadUint64(&m.afterDebugfCounter) < 1 {
		return false
	}
	return true
}

// MinimockDebugfInspect logs each unmet expectation
func (m *LoggerMock) MinimockDebugfInspect() {
	for _, e := range m.DebugfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Debugf with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DebugfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDebugfCounter) < 1 {
		if m.DebugfMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Debugf")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Debugf with params: %#v", *m.DebugfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDebugf != nil && mm_atomic.LoadUint64(&m.afterDebugfCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Debugf")
	}
}

type mLoggerMockEmbeddable struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockEmbeddableExpectation
	expectations       []*LoggerMockEmbeddableExpectation
}

// LoggerMockEmbeddableExpectation specifies expectation struct of the Logger.Embeddable
type LoggerMockEmbeddableExpectation struct {
	mock *LoggerMock

	results *LoggerMockEmbeddableResults
	Counter uint64
}

// LoggerMockEmbeddableResults contains results of the Logger.Embeddable
type LoggerMockEmbeddableResults struct {
	e1 EmbeddedLogger
}

// Expect sets up expected params for Logger.Embeddable
func (mmEmbeddable *mLoggerMockEmbeddable) Expect() *mLoggerMockEmbeddable {
	if mmEmbeddable.mock.funcEmbeddable != nil {
		mmEmbeddable.mock.t.Fatalf("LoggerMock.Embeddable mock is already set by Set")
	}

	if mmEmbeddable.defaultExpectation == nil {
		mmEmbeddable.defaultExpectation = &LoggerMockEmbeddableExpectation{}
	}

	return mmEmbeddable
}

// Inspect accepts an inspector function that has same arguments as the Logger.Embeddable
func (mmEmbeddable *mLoggerMockEmbeddable) Inspect(f func()) *mLoggerMockEmbeddable {
	if mmEmbeddable.mock.inspectFuncEmbeddable != nil {
		mmEmbeddable.mock.t.Fatalf("Inspect function is already set for LoggerMock.Embeddable")
	}

	mmEmbeddable.mock.inspectFuncEmbeddable = f

	return mmEmbeddable
}

// Return sets up results that will be returned by Logger.Embeddable
func (mmEmbeddable *mLoggerMockEmbeddable) Return(e1 EmbeddedLogger) *LoggerMock {
	if mmEmbeddable.mock.funcEmbeddable != nil {
		mmEmbeddable.mock.t.Fatalf("LoggerMock.Embeddable mock is already set by Set")
	}

	if mmEmbeddable.defaultExpectation == nil {
		mmEmbeddable.defaultExpectation = &LoggerMockEmbeddableExpectation{mock: mmEmbeddable.mock}
	}
	mmEmbeddable.defaultExpectation.results = &LoggerMockEmbeddableResults{e1}
	return mmEmbeddable.mock
}

//Set uses given function f to mock the Logger.Embeddable method
func (mmEmbeddable *mLoggerMockEmbeddable) Set(f func() (e1 EmbeddedLogger)) *LoggerMock {
	if mmEmbeddable.defaultExpectation != nil {
		mmEmbeddable.mock.t.Fatalf("Default expectation is already set for the Logger.Embeddable method")
	}

	if len(mmEmbeddable.expectations) > 0 {
		mmEmbeddable.mock.t.Fatalf("Some expectations are already set for the Logger.Embeddable method")
	}

	mmEmbeddable.mock.funcEmbeddable = f
	return mmEmbeddable.mock
}

// Embeddable implements Logger
func (mmEmbeddable *LoggerMock) Embeddable() (e1 EmbeddedLogger) {
	mm_atomic.AddUint64(&mmEmbeddable.beforeEmbeddableCounter, 1)
	defer mm_atomic.AddUint64(&mmEmbeddable.afterEmbeddableCounter, 1)

	if mmEmbeddable.inspectFuncEmbeddable != nil {
		mmEmbeddable.inspectFuncEmbeddable()
	}

	if mmEmbeddable.EmbeddableMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEmbeddable.EmbeddableMock.defaultExpectation.Counter, 1)

		results := mmEmbeddable.EmbeddableMock.defaultExpectation.results
		if results == nil {
			mmEmbeddable.t.Fatal("No results are set for the LoggerMock.Embeddable")
		}
		return (*results).e1
	}
	if mmEmbeddable.funcEmbeddable != nil {
		return mmEmbeddable.funcEmbeddable()
	}
	mmEmbeddable.t.Fatalf("Unexpected call to LoggerMock.Embeddable.")
	return
}

// EmbeddableAfterCounter returns a count of finished LoggerMock.Embeddable invocations
func (mmEmbeddable *LoggerMock) EmbeddableAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEmbeddable.afterEmbeddableCounter)
}

// EmbeddableBeforeCounter returns a count of LoggerMock.Embeddable invocations
func (mmEmbeddable *LoggerMock) EmbeddableBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEmbeddable.beforeEmbeddableCounter)
}

// MinimockEmbeddableDone returns true if the count of the Embeddable invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockEmbeddableDone() bool {
	for _, e := range m.EmbeddableMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EmbeddableMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEmbeddableCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEmbeddable != nil && mm_atomic.LoadUint64(&m.afterEmbeddableCounter) < 1 {
		return false
	}
	return true
}

// MinimockEmbeddableInspect logs each unmet expectation
func (m *LoggerMock) MinimockEmbeddableInspect() {
	for _, e := range m.EmbeddableMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LoggerMock.Embeddable")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EmbeddableMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEmbeddableCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Embeddable")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEmbeddable != nil && mm_atomic.LoadUint64(&m.afterEmbeddableCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Embeddable")
	}
}

type mLoggerMockError struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockErrorExpectation
	expectations       []*LoggerMockErrorExpectation

	callArgs []*LoggerMockErrorParams
	mutex    sync.RWMutex
}

// LoggerMockErrorExpectation specifies expectation struct of the Logger.Error
type LoggerMockErrorExpectation struct {
	mock   *LoggerMock
	params *LoggerMockErrorParams

	Counter uint64
}

// LoggerMockErrorParams contains parameters of the Logger.Error
type LoggerMockErrorParams struct {
	p1 []interface{}
}

// Expect sets up expected params for Logger.Error
func (mmError *mLoggerMockError) Expect(p1 ...interface{}) *mLoggerMockError {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &LoggerMockErrorExpectation{}
	}

	mmError.defaultExpectation.params = &LoggerMockErrorParams{p1}
	for _, e := range mmError.expectations {
		if minimock.Equal(e.params, mmError.defaultExpectation.params) {
			mmError.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmError.defaultExpectation.params)
		}
	}

	return mmError
}

// Inspect accepts an inspector function that has same arguments as the Logger.Error
func (mmError *mLoggerMockError) Inspect(f func(p1 ...interface{})) *mLoggerMockError {
	if mmError.mock.inspectFuncError != nil {
		mmError.mock.t.Fatalf("Inspect function is already set for LoggerMock.Error")
	}

	mmError.mock.inspectFuncError = f

	return mmError
}

// Return sets up results that will be returned by Logger.Error
func (mmError *mLoggerMockError) Return() *LoggerMock {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &LoggerMockErrorExpectation{mock: mmError.mock}
	}

	return mmError.mock
}

//Set uses given function f to mock the Logger.Error method
func (mmError *mLoggerMockError) Set(f func(p1 ...interface{})) *LoggerMock {
	if mmError.defaultExpectation != nil {
		mmError.mock.t.Fatalf("Default expectation is already set for the Logger.Error method")
	}

	if len(mmError.expectations) > 0 {
		mmError.mock.t.Fatalf("Some expectations are already set for the Logger.Error method")
	}

	mmError.mock.funcError = f
	return mmError.mock
}

// Error implements Logger
func (mmError *LoggerMock) Error(p1 ...interface{}) {
	mm_atomic.AddUint64(&mmError.beforeErrorCounter, 1)
	defer mm_atomic.AddUint64(&mmError.afterErrorCounter, 1)

	if mmError.inspectFuncError != nil {
		mmError.inspectFuncError(p1...)
	}

	params := &LoggerMockErrorParams{p1}

	// Record call args
	mmError.ErrorMock.mutex.Lock()
	mmError.ErrorMock.callArgs = append(mmError.ErrorMock.callArgs, params)
	mmError.ErrorMock.mutex.Unlock()

	for _, e := range mmError.ErrorMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmError.ErrorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmError.ErrorMock.defaultExpectation.Counter, 1)
		want := mmError.ErrorMock.defaultExpectation.params
		got := LoggerMockErrorParams{p1}
		if want != nil && !minimock.Equal(*want, got) {
			mmError.t.Errorf("LoggerMock.Error got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmError.funcError != nil {
		mmError.funcError(p1...)
		return
	}
	mmError.t.Fatalf("Unexpected call to LoggerMock.Error. %v", p1)

}

// ErrorAfterCounter returns a count of finished LoggerMock.Error invocations
func (mmError *LoggerMock) ErrorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmError.afterErrorCounter)
}

// ErrorBeforeCounter returns a count of LoggerMock.Error invocations
func (mmError *LoggerMock) ErrorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmError.beforeErrorCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Error.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmError *mLoggerMockError) Calls() []*LoggerMockErrorParams {
	mmError.mutex.RLock()

	argCopy := make([]*LoggerMockErrorParams, len(mmError.callArgs))
	copy(argCopy, mmError.callArgs)

	mmError.mutex.RUnlock()

	return argCopy
}

// MinimockErrorDone returns true if the count of the Error invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockErrorDone() bool {
	for _, e := range m.ErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcError != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		return false
	}
	return true
}

// MinimockErrorInspect logs each unmet expectation
func (m *LoggerMock) MinimockErrorInspect() {
	for _, e := range m.ErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Error with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		if m.ErrorMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Error")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Error with params: %#v", *m.ErrorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcError != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Error")
	}
}

type mLoggerMockErrorf struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockErrorfExpectation
	expectations       []*LoggerMockErrorfExpectation

	callArgs []*LoggerMockErrorfParams
	mutex    sync.RWMutex
}

// LoggerMockErrorfExpectation specifies expectation struct of the Logger.Errorf
type LoggerMockErrorfExpectation struct {
	mock   *LoggerMock
	params *LoggerMockErrorfParams

	Counter uint64
}

// LoggerMockErrorfParams contains parameters of the Logger.Errorf
type LoggerMockErrorfParams struct {
	s1 string
	p1 []interface{}
}

// Expect sets up expected params for Logger.Errorf
func (mmErrorf *mLoggerMockErrorf) Expect(s1 string, p1 ...interface{}) *mLoggerMockErrorf {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by Set")
	}

	if mmErrorf.defaultExpectation == nil {
		mmErrorf.defaultExpectation = &LoggerMockErrorfExpectation{}
	}

	mmErrorf.defaultExpectation.params = &LoggerMockErrorfParams{s1, p1}
	for _, e := range mmErrorf.expectations {
		if minimock.Equal(e.params, mmErrorf.defaultExpectation.params) {
			mmErrorf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmErrorf.defaultExpectation.params)
		}
	}

	return mmErrorf
}

// Inspect accepts an inspector function that has same arguments as the Logger.Errorf
func (mmErrorf *mLoggerMockErrorf) Inspect(f func(s1 string, p1 ...interface{})) *mLoggerMockErrorf {
	if mmErrorf.mock.inspectFuncErrorf != nil {
		mmErrorf.mock.t.Fatalf("Inspect function is already set for LoggerMock.Errorf")
	}

	mmErrorf.mock.inspectFuncErrorf = f

	return mmErrorf
}

// Return sets up results that will be returned by Logger.Errorf
func (mmErrorf *mLoggerMockErrorf) Return() *LoggerMock {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by Set")
	}

	if mmErrorf.defaultExpectation == nil {
		mmErrorf.defaultExpectation = &LoggerMockErrorfExpectation{mock: mmErrorf.mock}
	}

	return mmErrorf.mock
}

//Set uses given function f to mock the Logger.Errorf method
func (mmErrorf *mLoggerMockErrorf) Set(f func(s1 string, p1 ...interface{})) *LoggerMock {
	if mmErrorf.defaultExpectation != nil {
		mmErrorf.mock.t.Fatalf("Default expectation is already set for the Logger.Errorf method")
	}

	if len(mmErrorf.expectations) > 0 {
		mmErrorf.mock.t.Fatalf("Some expectations are already set for the Logger.Errorf method")
	}

	mmErrorf.mock.funcErrorf = f
	return mmErrorf.mock
}

// Errorf implements Logger
func (mmErrorf *LoggerMock) Errorf(s1 string, p1 ...interface{}) {
	mm_atomic.AddUint64(&mmErrorf.beforeErrorfCounter, 1)
	defer mm_atomic.AddUint64(&mmErrorf.afterErrorfCounter, 1)

	if mmErrorf.inspectFuncErrorf != nil {
		mmErrorf.inspectFuncErrorf(s1, p1...)
	}

	params := &LoggerMockErrorfParams{s1, p1}

	// Record call args
	mmErrorf.ErrorfMock.mutex.Lock()
	mmErrorf.ErrorfMock.callArgs = append(mmErrorf.ErrorfMock.callArgs, params)
	mmErrorf.ErrorfMock.mutex.Unlock()

	for _, e := range mmErrorf.ErrorfMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmErrorf.ErrorfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmErrorf.ErrorfMock.defaultExpectation.Counter, 1)
		want := mmErrorf.ErrorfMock.defaultExpectation.params
		got := LoggerMockErrorfParams{s1, p1}
		if want != nil && !minimock.Equal(*want, got) {
			mmErrorf.t.Errorf("LoggerMock.Errorf got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmErrorf.funcErrorf != nil {
		mmErrorf.funcErrorf(s1, p1...)
		return
	}
	mmErrorf.t.Fatalf("Unexpected call to LoggerMock.Errorf. %v %v", s1, p1)

}

// ErrorfAfterCounter returns a count of finished LoggerMock.Errorf invocations
func (mmErrorf *LoggerMock) ErrorfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmErrorf.afterErrorfCounter)
}

// ErrorfBeforeCounter returns a count of LoggerMock.Errorf invocations
func (mmErrorf *LoggerMock) ErrorfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmErrorf.beforeErrorfCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Errorf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmErrorf *mLoggerMockErrorf) Calls() []*LoggerMockErrorfParams {
	mmErrorf.mutex.RLock()

	argCopy := make([]*LoggerMockErrorfParams, len(mmErrorf.callArgs))
	copy(argCopy, mmErrorf.callArgs)

	mmErrorf.mutex.RUnlock()

	return argCopy
}

// MinimockErrorfDone returns true if the count of the Errorf invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockErrorfDone() bool {
	for _, e := range m.ErrorfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterErrorfCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcErrorf != nil && mm_atomic.LoadUint64(&m.afterErrorfCounter) < 1 {
		return false
	}
	return true
}

// MinimockErrorfInspect logs each unmet expectation
func (m *LoggerMock) MinimockErrorfInspect() {
	for _, e := range m.ErrorfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Errorf with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterErrorfCounter) < 1 {
		if m.ErrorfMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Errorf")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Errorf with params: %#v", *m.ErrorfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcErrorf != nil && mm_atomic.LoadUint64(&m.afterErrorfCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Errorf")
	}
}

type mLoggerMockEvent struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockEventExpectation
	expectations       []*LoggerMockEventExpectation

	callArgs []*LoggerMockEventParams
	mutex    sync.RWMutex
}

// LoggerMockEventExpectation specifies expectation struct of the Logger.Event
type LoggerMockEventExpectation struct {
	mock   *LoggerMock
	params *LoggerMockEventParams

	Counter uint64
}

// LoggerMockEventParams contains parameters of the Logger.Event
type LoggerMockEventParams struct {
	level LogLevel
	args  []interface{}
}

// Expect sets up expected params for Logger.Event
func (mmEvent *mLoggerMockEvent) Expect(level LogLevel, args ...interface{}) *mLoggerMockEvent {
	if mmEvent.mock.funcEvent != nil {
		mmEvent.mock.t.Fatalf("LoggerMock.Event mock is already set by Set")
	}

	if mmEvent.defaultExpectation == nil {
		mmEvent.defaultExpectation = &LoggerMockEventExpectation{}
	}

	mmEvent.defaultExpectation.params = &LoggerMockEventParams{level, args}
	for _, e := range mmEvent.expectations {
		if minimock.Equal(e.params, mmEvent.defaultExpectation.params) {
			mmEvent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEvent.defaultExpectation.params)
		}
	}

	return mmEvent
}

// Inspect accepts an inspector function that has same arguments as the Logger.Event
func (mmEvent *mLoggerMockEvent) Inspect(f func(level LogLevel, args ...interface{})) *mLoggerMockEvent {
	if mmEvent.mock.inspectFuncEvent != nil {
		mmEvent.mock.t.Fatalf("Inspect function is already set for LoggerMock.Event")
	}

	mmEvent.mock.inspectFuncEvent = f

	return mmEvent
}

// Return sets up results that will be returned by Logger.Event
func (mmEvent *mLoggerMockEvent) Return() *LoggerMock {
	if mmEvent.mock.funcEvent != nil {
		mmEvent.mock.t.Fatalf("LoggerMock.Event mock is already set by Set")
	}

	if mmEvent.defaultExpectation == nil {
		mmEvent.defaultExpectation = &LoggerMockEventExpectation{mock: mmEvent.mock}
	}

	return mmEvent.mock
}

//Set uses given function f to mock the Logger.Event method
func (mmEvent *mLoggerMockEvent) Set(f func(level LogLevel, args ...interface{})) *LoggerMock {
	if mmEvent.defaultExpectation != nil {
		mmEvent.mock.t.Fatalf("Default expectation is already set for the Logger.Event method")
	}

	if len(mmEvent.expectations) > 0 {
		mmEvent.mock.t.Fatalf("Some expectations are already set for the Logger.Event method")
	}

	mmEvent.mock.funcEvent = f
	return mmEvent.mock
}

// Event implements Logger
func (mmEvent *LoggerMock) Event(level LogLevel, args ...interface{}) {
	mm_atomic.AddUint64(&mmEvent.beforeEventCounter, 1)
	defer mm_atomic.AddUint64(&mmEvent.afterEventCounter, 1)

	if mmEvent.inspectFuncEvent != nil {
		mmEvent.inspectFuncEvent(level, args...)
	}

	params := &LoggerMockEventParams{level, args}

	// Record call args
	mmEvent.EventMock.mutex.Lock()
	mmEvent.EventMock.callArgs = append(mmEvent.EventMock.callArgs, params)
	mmEvent.EventMock.mutex.Unlock()

	for _, e := range mmEvent.EventMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmEvent.EventMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEvent.EventMock.defaultExpectation.Counter, 1)
		want := mmEvent.EventMock.defaultExpectation.params
		got := LoggerMockEventParams{level, args}
		if want != nil && !minimock.Equal(*want, got) {
			mmEvent.t.Errorf("LoggerMock.Event got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmEvent.funcEvent != nil {
		mmEvent.funcEvent(level, args...)
		return
	}
	mmEvent.t.Fatalf("Unexpected call to LoggerMock.Event. %v %v", level, args)

}

// EventAfterCounter returns a count of finished LoggerMock.Event invocations
func (mmEvent *LoggerMock) EventAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEvent.afterEventCounter)
}

// EventBeforeCounter returns a count of LoggerMock.Event invocations
func (mmEvent *LoggerMock) EventBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEvent.beforeEventCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Event.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEvent *mLoggerMockEvent) Calls() []*LoggerMockEventParams {
	mmEvent.mutex.RLock()

	argCopy := make([]*LoggerMockEventParams, len(mmEvent.callArgs))
	copy(argCopy, mmEvent.callArgs)

	mmEvent.mutex.RUnlock()

	return argCopy
}

// MinimockEventDone returns true if the count of the Event invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockEventDone() bool {
	for _, e := range m.EventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EventMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEventCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEvent != nil && mm_atomic.LoadUint64(&m.afterEventCounter) < 1 {
		return false
	}
	return true
}

// MinimockEventInspect logs each unmet expectation
func (m *LoggerMock) MinimockEventInspect() {
	for _, e := range m.EventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Event with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EventMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEventCounter) < 1 {
		if m.EventMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Event")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Event with params: %#v", *m.EventMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEvent != nil && mm_atomic.LoadUint64(&m.afterEventCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Event")
	}
}

type mLoggerMockEventf struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockEventfExpectation
	expectations       []*LoggerMockEventfExpectation

	callArgs []*LoggerMockEventfParams
	mutex    sync.RWMutex
}

// LoggerMockEventfExpectation specifies expectation struct of the Logger.Eventf
type LoggerMockEventfExpectation struct {
	mock   *LoggerMock
	params *LoggerMockEventfParams

	Counter uint64
}

// LoggerMockEventfParams contains parameters of the Logger.Eventf
type LoggerMockEventfParams struct {
	level LogLevel
	fmt   string
	args  []interface{}
}

// Expect sets up expected params for Logger.Eventf
func (mmEventf *mLoggerMockEventf) Expect(level LogLevel, fmt string, args ...interface{}) *mLoggerMockEventf {
	if mmEventf.mock.funcEventf != nil {
		mmEventf.mock.t.Fatalf("LoggerMock.Eventf mock is already set by Set")
	}

	if mmEventf.defaultExpectation == nil {
		mmEventf.defaultExpectation = &LoggerMockEventfExpectation{}
	}

	mmEventf.defaultExpectation.params = &LoggerMockEventfParams{level, fmt, args}
	for _, e := range mmEventf.expectations {
		if minimock.Equal(e.params, mmEventf.defaultExpectation.params) {
			mmEventf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEventf.defaultExpectation.params)
		}
	}

	return mmEventf
}

// Inspect accepts an inspector function that has same arguments as the Logger.Eventf
func (mmEventf *mLoggerMockEventf) Inspect(f func(level LogLevel, fmt string, args ...interface{})) *mLoggerMockEventf {
	if mmEventf.mock.inspectFuncEventf != nil {
		mmEventf.mock.t.Fatalf("Inspect function is already set for LoggerMock.Eventf")
	}

	mmEventf.mock.inspectFuncEventf = f

	return mmEventf
}

// Return sets up results that will be returned by Logger.Eventf
func (mmEventf *mLoggerMockEventf) Return() *LoggerMock {
	if mmEventf.mock.funcEventf != nil {
		mmEventf.mock.t.Fatalf("LoggerMock.Eventf mock is already set by Set")
	}

	if mmEventf.defaultExpectation == nil {
		mmEventf.defaultExpectation = &LoggerMockEventfExpectation{mock: mmEventf.mock}
	}

	return mmEventf.mock
}

//Set uses given function f to mock the Logger.Eventf method
func (mmEventf *mLoggerMockEventf) Set(f func(level LogLevel, fmt string, args ...interface{})) *LoggerMock {
	if mmEventf.defaultExpectation != nil {
		mmEventf.mock.t.Fatalf("Default expectation is already set for the Logger.Eventf method")
	}

	if len(mmEventf.expectations) > 0 {
		mmEventf.mock.t.Fatalf("Some expectations are already set for the Logger.Eventf method")
	}

	mmEventf.mock.funcEventf = f
	return mmEventf.mock
}

// Eventf implements Logger
func (mmEventf *LoggerMock) Eventf(level LogLevel, fmt string, args ...interface{}) {
	mm_atomic.AddUint64(&mmEventf.beforeEventfCounter, 1)
	defer mm_atomic.AddUint64(&mmEventf.afterEventfCounter, 1)

	if mmEventf.inspectFuncEventf != nil {
		mmEventf.inspectFuncEventf(level, fmt, args...)
	}

	params := &LoggerMockEventfParams{level, fmt, args}

	// Record call args
	mmEventf.EventfMock.mutex.Lock()
	mmEventf.EventfMock.callArgs = append(mmEventf.EventfMock.callArgs, params)
	mmEventf.EventfMock.mutex.Unlock()

	for _, e := range mmEventf.EventfMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmEventf.EventfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEventf.EventfMock.defaultExpectation.Counter, 1)
		want := mmEventf.EventfMock.defaultExpectation.params
		got := LoggerMockEventfParams{level, fmt, args}
		if want != nil && !minimock.Equal(*want, got) {
			mmEventf.t.Errorf("LoggerMock.Eventf got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmEventf.funcEventf != nil {
		mmEventf.funcEventf(level, fmt, args...)
		return
	}
	mmEventf.t.Fatalf("Unexpected call to LoggerMock.Eventf. %v %v %v", level, fmt, args)

}

// EventfAfterCounter returns a count of finished LoggerMock.Eventf invocations
func (mmEventf *LoggerMock) EventfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEventf.afterEventfCounter)
}

// EventfBeforeCounter returns a count of LoggerMock.Eventf invocations
func (mmEventf *LoggerMock) EventfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEventf.beforeEventfCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Eventf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEventf *mLoggerMockEventf) Calls() []*LoggerMockEventfParams {
	mmEventf.mutex.RLock()

	argCopy := make([]*LoggerMockEventfParams, len(mmEventf.callArgs))
	copy(argCopy, mmEventf.callArgs)

	mmEventf.mutex.RUnlock()

	return argCopy
}

// MinimockEventfDone returns true if the count of the Eventf invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockEventfDone() bool {
	for _, e := range m.EventfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EventfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEventfCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEventf != nil && mm_atomic.LoadUint64(&m.afterEventfCounter) < 1 {
		return false
	}
	return true
}

// MinimockEventfInspect logs each unmet expectation
func (m *LoggerMock) MinimockEventfInspect() {
	for _, e := range m.EventfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Eventf with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EventfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEventfCounter) < 1 {
		if m.EventfMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Eventf")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Eventf with params: %#v", *m.EventfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEventf != nil && mm_atomic.LoadUint64(&m.afterEventfCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Eventf")
	}
}

type mLoggerMockFatal struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockFatalExpectation
	expectations       []*LoggerMockFatalExpectation

	callArgs []*LoggerMockFatalParams
	mutex    sync.RWMutex
}

// LoggerMockFatalExpectation specifies expectation struct of the Logger.Fatal
type LoggerMockFatalExpectation struct {
	mock   *LoggerMock
	params *LoggerMockFatalParams

	Counter uint64
}

// LoggerMockFatalParams contains parameters of the Logger.Fatal
type LoggerMockFatalParams struct {
	p1 []interface{}
}

// Expect sets up expected params for Logger.Fatal
func (mmFatal *mLoggerMockFatal) Expect(p1 ...interface{}) *mLoggerMockFatal {
	if mmFatal.mock.funcFatal != nil {
		mmFatal.mock.t.Fatalf("LoggerMock.Fatal mock is already set by Set")
	}

	if mmFatal.defaultExpectation == nil {
		mmFatal.defaultExpectation = &LoggerMockFatalExpectation{}
	}

	mmFatal.defaultExpectation.params = &LoggerMockFatalParams{p1}
	for _, e := range mmFatal.expectations {
		if minimock.Equal(e.params, mmFatal.defaultExpectation.params) {
			mmFatal.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFatal.defaultExpectation.params)
		}
	}

	return mmFatal
}

// Inspect accepts an inspector function that has same arguments as the Logger.Fatal
func (mmFatal *mLoggerMockFatal) Inspect(f func(p1 ...interface{})) *mLoggerMockFatal {
	if mmFatal.mock.inspectFuncFatal != nil {
		mmFatal.mock.t.Fatalf("Inspect function is already set for LoggerMock.Fatal")
	}

	mmFatal.mock.inspectFuncFatal = f

	return mmFatal
}

// Return sets up results that will be returned by Logger.Fatal
func (mmFatal *mLoggerMockFatal) Return() *LoggerMock {
	if mmFatal.mock.funcFatal != nil {
		mmFatal.mock.t.Fatalf("LoggerMock.Fatal mock is already set by Set")
	}

	if mmFatal.defaultExpectation == nil {
		mmFatal.defaultExpectation = &LoggerMockFatalExpectation{mock: mmFatal.mock}
	}

	return mmFatal.mock
}

//Set uses given function f to mock the Logger.Fatal method
func (mmFatal *mLoggerMockFatal) Set(f func(p1 ...interface{})) *LoggerMock {
	if mmFatal.defaultExpectation != nil {
		mmFatal.mock.t.Fatalf("Default expectation is already set for the Logger.Fatal method")
	}

	if len(mmFatal.expectations) > 0 {
		mmFatal.mock.t.Fatalf("Some expectations are already set for the Logger.Fatal method")
	}

	mmFatal.mock.funcFatal = f
	return mmFatal.mock
}

// Fatal implements Logger
func (mmFatal *LoggerMock) Fatal(p1 ...interface{}) {
	mm_atomic.AddUint64(&mmFatal.beforeFatalCounter, 1)
	defer mm_atomic.AddUint64(&mmFatal.afterFatalCounter, 1)

	if mmFatal.inspectFuncFatal != nil {
		mmFatal.inspectFuncFatal(p1...)
	}

	params := &LoggerMockFatalParams{p1}

	// Record call args
	mmFatal.FatalMock.mutex.Lock()
	mmFatal.FatalMock.callArgs = append(mmFatal.FatalMock.callArgs, params)
	mmFatal.FatalMock.mutex.Unlock()

	for _, e := range mmFatal.FatalMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmFatal.FatalMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFatal.FatalMock.defaultExpectation.Counter, 1)
		want := mmFatal.FatalMock.defaultExpectation.params
		got := LoggerMockFatalParams{p1}
		if want != nil && !minimock.Equal(*want, got) {
			mmFatal.t.Errorf("LoggerMock.Fatal got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmFatal.funcFatal != nil {
		mmFatal.funcFatal(p1...)
		return
	}
	mmFatal.t.Fatalf("Unexpected call to LoggerMock.Fatal. %v", p1)

}

// FatalAfterCounter returns a count of finished LoggerMock.Fatal invocations
func (mmFatal *LoggerMock) FatalAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFatal.afterFatalCounter)
}

// FatalBeforeCounter returns a count of LoggerMock.Fatal invocations
func (mmFatal *LoggerMock) FatalBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFatal.beforeFatalCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Fatal.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFatal *mLoggerMockFatal) Calls() []*LoggerMockFatalParams {
	mmFatal.mutex.RLock()

	argCopy := make([]*LoggerMockFatalParams, len(mmFatal.callArgs))
	copy(argCopy, mmFatal.callArgs)

	mmFatal.mutex.RUnlock()

	return argCopy
}

// MinimockFatalDone returns true if the count of the Fatal invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockFatalDone() bool {
	for _, e := range m.FatalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FatalMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFatalCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFatal != nil && mm_atomic.LoadUint64(&m.afterFatalCounter) < 1 {
		return false
	}
	return true
}

// MinimockFatalInspect logs each unmet expectation
func (m *LoggerMock) MinimockFatalInspect() {
	for _, e := range m.FatalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Fatal with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FatalMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFatalCounter) < 1 {
		if m.FatalMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Fatal")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Fatal with params: %#v", *m.FatalMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFatal != nil && mm_atomic.LoadUint64(&m.afterFatalCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Fatal")
	}
}

type mLoggerMockFatalf struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockFatalfExpectation
	expectations       []*LoggerMockFatalfExpectation

	callArgs []*LoggerMockFatalfParams
	mutex    sync.RWMutex
}

// LoggerMockFatalfExpectation specifies expectation struct of the Logger.Fatalf
type LoggerMockFatalfExpectation struct {
	mock   *LoggerMock
	params *LoggerMockFatalfParams

	Counter uint64
}

// LoggerMockFatalfParams contains parameters of the Logger.Fatalf
type LoggerMockFatalfParams struct {
	s1 string
	p1 []interface{}
}

// Expect sets up expected params for Logger.Fatalf
func (mmFatalf *mLoggerMockFatalf) Expect(s1 string, p1 ...interface{}) *mLoggerMockFatalf {
	if mmFatalf.mock.funcFatalf != nil {
		mmFatalf.mock.t.Fatalf("LoggerMock.Fatalf mock is already set by Set")
	}

	if mmFatalf.defaultExpectation == nil {
		mmFatalf.defaultExpectation = &LoggerMockFatalfExpectation{}
	}

	mmFatalf.defaultExpectation.params = &LoggerMockFatalfParams{s1, p1}
	for _, e := range mmFatalf.expectations {
		if minimock.Equal(e.params, mmFatalf.defaultExpectation.params) {
			mmFatalf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFatalf.defaultExpectation.params)
		}
	}

	return mmFatalf
}

// Inspect accepts an inspector function that has same arguments as the Logger.Fatalf
func (mmFatalf *mLoggerMockFatalf) Inspect(f func(s1 string, p1 ...interface{})) *mLoggerMockFatalf {
	if mmFatalf.mock.inspectFuncFatalf != nil {
		mmFatalf.mock.t.Fatalf("Inspect function is already set for LoggerMock.Fatalf")
	}

	mmFatalf.mock.inspectFuncFatalf = f

	return mmFatalf
}

// Return sets up results that will be returned by Logger.Fatalf
func (mmFatalf *mLoggerMockFatalf) Return() *LoggerMock {
	if mmFatalf.mock.funcFatalf != nil {
		mmFatalf.mock.t.Fatalf("LoggerMock.Fatalf mock is already set by Set")
	}

	if mmFatalf.defaultExpectation == nil {
		mmFatalf.defaultExpectation = &LoggerMockFatalfExpectation{mock: mmFatalf.mock}
	}

	return mmFatalf.mock
}

//Set uses given function f to mock the Logger.Fatalf method
func (mmFatalf *mLoggerMockFatalf) Set(f func(s1 string, p1 ...interface{})) *LoggerMock {
	if mmFatalf.defaultExpectation != nil {
		mmFatalf.mock.t.Fatalf("Default expectation is already set for the Logger.Fatalf method")
	}

	if len(mmFatalf.expectations) > 0 {
		mmFatalf.mock.t.Fatalf("Some expectations are already set for the Logger.Fatalf method")
	}

	mmFatalf.mock.funcFatalf = f
	return mmFatalf.mock
}

// Fatalf implements Logger
func (mmFatalf *LoggerMock) Fatalf(s1 string, p1 ...interface{}) {
	mm_atomic.AddUint64(&mmFatalf.beforeFatalfCounter, 1)
	defer mm_atomic.AddUint64(&mmFatalf.afterFatalfCounter, 1)

	if mmFatalf.inspectFuncFatalf != nil {
		mmFatalf.inspectFuncFatalf(s1, p1...)
	}

	params := &LoggerMockFatalfParams{s1, p1}

	// Record call args
	mmFatalf.FatalfMock.mutex.Lock()
	mmFatalf.FatalfMock.callArgs = append(mmFatalf.FatalfMock.callArgs, params)
	mmFatalf.FatalfMock.mutex.Unlock()

	for _, e := range mmFatalf.FatalfMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmFatalf.FatalfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFatalf.FatalfMock.defaultExpectation.Counter, 1)
		want := mmFatalf.FatalfMock.defaultExpectation.params
		got := LoggerMockFatalfParams{s1, p1}
		if want != nil && !minimock.Equal(*want, got) {
			mmFatalf.t.Errorf("LoggerMock.Fatalf got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmFatalf.funcFatalf != nil {
		mmFatalf.funcFatalf(s1, p1...)
		return
	}
	mmFatalf.t.Fatalf("Unexpected call to LoggerMock.Fatalf. %v %v", s1, p1)

}

// FatalfAfterCounter returns a count of finished LoggerMock.Fatalf invocations
func (mmFatalf *LoggerMock) FatalfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFatalf.afterFatalfCounter)
}

// FatalfBeforeCounter returns a count of LoggerMock.Fatalf invocations
func (mmFatalf *LoggerMock) FatalfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFatalf.beforeFatalfCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Fatalf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFatalf *mLoggerMockFatalf) Calls() []*LoggerMockFatalfParams {
	mmFatalf.mutex.RLock()

	argCopy := make([]*LoggerMockFatalfParams, len(mmFatalf.callArgs))
	copy(argCopy, mmFatalf.callArgs)

	mmFatalf.mutex.RUnlock()

	return argCopy
}

// MinimockFatalfDone returns true if the count of the Fatalf invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockFatalfDone() bool {
	for _, e := range m.FatalfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FatalfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFatalfCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFatalf != nil && mm_atomic.LoadUint64(&m.afterFatalfCounter) < 1 {
		return false
	}
	return true
}

// MinimockFatalfInspect logs each unmet expectation
func (m *LoggerMock) MinimockFatalfInspect() {
	for _, e := range m.FatalfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Fatalf with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FatalfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFatalfCounter) < 1 {
		if m.FatalfMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Fatalf")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Fatalf with params: %#v", *m.FatalfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFatalf != nil && mm_atomic.LoadUint64(&m.afterFatalfCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Fatalf")
	}
}

type mLoggerMockInfo struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockInfoExpectation
	expectations       []*LoggerMockInfoExpectation

	callArgs []*LoggerMockInfoParams
	mutex    sync.RWMutex
}

// LoggerMockInfoExpectation specifies expectation struct of the Logger.Info
type LoggerMockInfoExpectation struct {
	mock   *LoggerMock
	params *LoggerMockInfoParams

	Counter uint64
}

// LoggerMockInfoParams contains parameters of the Logger.Info
type LoggerMockInfoParams struct {
	p1 []interface{}
}

// Expect sets up expected params for Logger.Info
func (mmInfo *mLoggerMockInfo) Expect(p1 ...interface{}) *mLoggerMockInfo {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &LoggerMockInfoExpectation{}
	}

	mmInfo.defaultExpectation.params = &LoggerMockInfoParams{p1}
	for _, e := range mmInfo.expectations {
		if minimock.Equal(e.params, mmInfo.defaultExpectation.params) {
			mmInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInfo.defaultExpectation.params)
		}
	}

	return mmInfo
}

// Inspect accepts an inspector function that has same arguments as the Logger.Info
func (mmInfo *mLoggerMockInfo) Inspect(f func(p1 ...interface{})) *mLoggerMockInfo {
	if mmInfo.mock.inspectFuncInfo != nil {
		mmInfo.mock.t.Fatalf("Inspect function is already set for LoggerMock.Info")
	}

	mmInfo.mock.inspectFuncInfo = f

	return mmInfo
}

// Return sets up results that will be returned by Logger.Info
func (mmInfo *mLoggerMockInfo) Return() *LoggerMock {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &LoggerMockInfoExpectation{mock: mmInfo.mock}
	}

	return mmInfo.mock
}

//Set uses given function f to mock the Logger.Info method
func (mmInfo *mLoggerMockInfo) Set(f func(p1 ...interface{})) *LoggerMock {
	if mmInfo.defaultExpectation != nil {
		mmInfo.mock.t.Fatalf("Default expectation is already set for the Logger.Info method")
	}

	if len(mmInfo.expectations) > 0 {
		mmInfo.mock.t.Fatalf("Some expectations are already set for the Logger.Info method")
	}

	mmInfo.mock.funcInfo = f
	return mmInfo.mock
}

// Info implements Logger
func (mmInfo *LoggerMock) Info(p1 ...interface{}) {
	mm_atomic.AddUint64(&mmInfo.beforeInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmInfo.afterInfoCounter, 1)

	if mmInfo.inspectFuncInfo != nil {
		mmInfo.inspectFuncInfo(p1...)
	}

	params := &LoggerMockInfoParams{p1}

	// Record call args
	mmInfo.InfoMock.mutex.Lock()
	mmInfo.InfoMock.callArgs = append(mmInfo.InfoMock.callArgs, params)
	mmInfo.InfoMock.mutex.Unlock()

	for _, e := range mmInfo.InfoMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmInfo.InfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInfo.InfoMock.defaultExpectation.Counter, 1)
		want := mmInfo.InfoMock.defaultExpectation.params
		got := LoggerMockInfoParams{p1}
		if want != nil && !minimock.Equal(*want, got) {
			mmInfo.t.Errorf("LoggerMock.Info got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmInfo.funcInfo != nil {
		mmInfo.funcInfo(p1...)
		return
	}
	mmInfo.t.Fatalf("Unexpected call to LoggerMock.Info. %v", p1)

}

// InfoAfterCounter returns a count of finished LoggerMock.Info invocations
func (mmInfo *LoggerMock) InfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfo.afterInfoCounter)
}

// InfoBeforeCounter returns a count of LoggerMock.Info invocations
func (mmInfo *LoggerMock) InfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfo.beforeInfoCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Info.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInfo *mLoggerMockInfo) Calls() []*LoggerMockInfoParams {
	mmInfo.mutex.RLock()

	argCopy := make([]*LoggerMockInfoParams, len(mmInfo.callArgs))
	copy(argCopy, mmInfo.callArgs)

	mmInfo.mutex.RUnlock()

	return argCopy
}

// MinimockInfoDone returns true if the count of the Info invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockInfoDone() bool {
	for _, e := range m.InfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InfoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInfoCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInfo != nil && mm_atomic.LoadUint64(&m.afterInfoCounter) < 1 {
		return false
	}
	return true
}

// MinimockInfoInspect logs each unmet expectation
func (m *LoggerMock) MinimockInfoInspect() {
	for _, e := range m.InfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Info with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InfoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInfoCounter) < 1 {
		if m.InfoMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Info")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Info with params: %#v", *m.InfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInfo != nil && mm_atomic.LoadUint64(&m.afterInfoCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Info")
	}
}

type mLoggerMockInfof struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockInfofExpectation
	expectations       []*LoggerMockInfofExpectation

	callArgs []*LoggerMockInfofParams
	mutex    sync.RWMutex
}

// LoggerMockInfofExpectation specifies expectation struct of the Logger.Infof
type LoggerMockInfofExpectation struct {
	mock   *LoggerMock
	params *LoggerMockInfofParams

	Counter uint64
}

// LoggerMockInfofParams contains parameters of the Logger.Infof
type LoggerMockInfofParams struct {
	s1 string
	p1 []interface{}
}

// Expect sets up expected params for Logger.Infof
func (mmInfof *mLoggerMockInfof) Expect(s1 string, p1 ...interface{}) *mLoggerMockInfof {
	if mmInfof.mock.funcInfof != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by Set")
	}

	if mmInfof.defaultExpectation == nil {
		mmInfof.defaultExpectation = &LoggerMockInfofExpectation{}
	}

	mmInfof.defaultExpectation.params = &LoggerMockInfofParams{s1, p1}
	for _, e := range mmInfof.expectations {
		if minimock.Equal(e.params, mmInfof.defaultExpectation.params) {
			mmInfof.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInfof.defaultExpectation.params)
		}
	}

	return mmInfof
}

// Inspect accepts an inspector function that has same arguments as the Logger.Infof
func (mmInfof *mLoggerMockInfof) Inspect(f func(s1 string, p1 ...interface{})) *mLoggerMockInfof {
	if mmInfof.mock.inspectFuncInfof != nil {
		mmInfof.mock.t.Fatalf("Inspect function is already set for LoggerMock.Infof")
	}

	mmInfof.mock.inspectFuncInfof = f

	return mmInfof
}

// Return sets up results that will be returned by Logger.Infof
func (mmInfof *mLoggerMockInfof) Return() *LoggerMock {
	if mmInfof.mock.funcInfof != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by Set")
	}

	if mmInfof.defaultExpectation == nil {
		mmInfof.defaultExpectation = &LoggerMockInfofExpectation{mock: mmInfof.mock}
	}

	return mmInfof.mock
}

//Set uses given function f to mock the Logger.Infof method
func (mmInfof *mLoggerMockInfof) Set(f func(s1 string, p1 ...interface{})) *LoggerMock {
	if mmInfof.defaultExpectation != nil {
		mmInfof.mock.t.Fatalf("Default expectation is already set for the Logger.Infof method")
	}

	if len(mmInfof.expectations) > 0 {
		mmInfof.mock.t.Fatalf("Some expectations are already set for the Logger.Infof method")
	}

	mmInfof.mock.funcInfof = f
	return mmInfof.mock
}

// Infof implements Logger
func (mmInfof *LoggerMock) Infof(s1 string, p1 ...interface{}) {
	mm_atomic.AddUint64(&mmInfof.beforeInfofCounter, 1)
	defer mm_atomic.AddUint64(&mmInfof.afterInfofCounter, 1)

	if mmInfof.inspectFuncInfof != nil {
		mmInfof.inspectFuncInfof(s1, p1...)
	}

	params := &LoggerMockInfofParams{s1, p1}

	// Record call args
	mmInfof.InfofMock.mutex.Lock()
	mmInfof.InfofMock.callArgs = append(mmInfof.InfofMock.callArgs, params)
	mmInfof.InfofMock.mutex.Unlock()

	for _, e := range mmInfof.InfofMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmInfof.InfofMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInfof.InfofMock.defaultExpectation.Counter, 1)
		want := mmInfof.InfofMock.defaultExpectation.params
		got := LoggerMockInfofParams{s1, p1}
		if want != nil && !minimock.Equal(*want, got) {
			mmInfof.t.Errorf("LoggerMock.Infof got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmInfof.funcInfof != nil {
		mmInfof.funcInfof(s1, p1...)
		return
	}
	mmInfof.t.Fatalf("Unexpected call to LoggerMock.Infof. %v %v", s1, p1)

}

// InfofAfterCounter returns a count of finished LoggerMock.Infof invocations
func (mmInfof *LoggerMock) InfofAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfof.afterInfofCounter)
}

// InfofBeforeCounter returns a count of LoggerMock.Infof invocations
func (mmInfof *LoggerMock) InfofBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfof.beforeInfofCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Infof.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInfof *mLoggerMockInfof) Calls() []*LoggerMockInfofParams {
	mmInfof.mutex.RLock()

	argCopy := make([]*LoggerMockInfofParams, len(mmInfof.callArgs))
	copy(argCopy, mmInfof.callArgs)

	mmInfof.mutex.RUnlock()

	return argCopy
}

// MinimockInfofDone returns true if the count of the Infof invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockInfofDone() bool {
	for _, e := range m.InfofMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InfofMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInfofCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInfof != nil && mm_atomic.LoadUint64(&m.afterInfofCounter) < 1 {
		return false
	}
	return true
}

// MinimockInfofInspect logs each unmet expectation
func (m *LoggerMock) MinimockInfofInspect() {
	for _, e := range m.InfofMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Infof with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InfofMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInfofCounter) < 1 {
		if m.InfofMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Infof")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Infof with params: %#v", *m.InfofMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInfof != nil && mm_atomic.LoadUint64(&m.afterInfofCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Infof")
	}
}

type mLoggerMockIs struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockIsExpectation
	expectations       []*LoggerMockIsExpectation

	callArgs []*LoggerMockIsParams
	mutex    sync.RWMutex
}

// LoggerMockIsExpectation specifies expectation struct of the Logger.Is
type LoggerMockIsExpectation struct {
	mock    *LoggerMock
	params  *LoggerMockIsParams
	results *LoggerMockIsResults
	Counter uint64
}

// LoggerMockIsParams contains parameters of the Logger.Is
type LoggerMockIsParams struct {
	level LogLevel
}

// LoggerMockIsResults contains results of the Logger.Is
type LoggerMockIsResults struct {
	b1 bool
}

// Expect sets up expected params for Logger.Is
func (mmIs *mLoggerMockIs) Expect(level LogLevel) *mLoggerMockIs {
	if mmIs.mock.funcIs != nil {
		mmIs.mock.t.Fatalf("LoggerMock.Is mock is already set by Set")
	}

	if mmIs.defaultExpectation == nil {
		mmIs.defaultExpectation = &LoggerMockIsExpectation{}
	}

	mmIs.defaultExpectation.params = &LoggerMockIsParams{level}
	for _, e := range mmIs.expectations {
		if minimock.Equal(e.params, mmIs.defaultExpectation.params) {
			mmIs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIs.defaultExpectation.params)
		}
	}

	return mmIs
}

// Inspect accepts an inspector function that has same arguments as the Logger.Is
func (mmIs *mLoggerMockIs) Inspect(f func(level LogLevel)) *mLoggerMockIs {
	if mmIs.mock.inspectFuncIs != nil {
		mmIs.mock.t.Fatalf("Inspect function is already set for LoggerMock.Is")
	}

	mmIs.mock.inspectFuncIs = f

	return mmIs
}

// Return sets up results that will be returned by Logger.Is
func (mmIs *mLoggerMockIs) Return(b1 bool) *LoggerMock {
	if mmIs.mock.funcIs != nil {
		mmIs.mock.t.Fatalf("LoggerMock.Is mock is already set by Set")
	}

	if mmIs.defaultExpectation == nil {
		mmIs.defaultExpectation = &LoggerMockIsExpectation{mock: mmIs.mock}
	}
	mmIs.defaultExpectation.results = &LoggerMockIsResults{b1}
	return mmIs.mock
}

//Set uses given function f to mock the Logger.Is method
func (mmIs *mLoggerMockIs) Set(f func(level LogLevel) (b1 bool)) *LoggerMock {
	if mmIs.defaultExpectation != nil {
		mmIs.mock.t.Fatalf("Default expectation is already set for the Logger.Is method")
	}

	if len(mmIs.expectations) > 0 {
		mmIs.mock.t.Fatalf("Some expectations are already set for the Logger.Is method")
	}

	mmIs.mock.funcIs = f
	return mmIs.mock
}

// When sets expectation for the Logger.Is which will trigger the result defined by the following
// Then helper
func (mmIs *mLoggerMockIs) When(level LogLevel) *LoggerMockIsExpectation {
	if mmIs.mock.funcIs != nil {
		mmIs.mock.t.Fatalf("LoggerMock.Is mock is already set by Set")
	}

	expectation := &LoggerMockIsExpectation{
		mock:   mmIs.mock,
		params: &LoggerMockIsParams{level},
	}
	mmIs.expectations = append(mmIs.expectations, expectation)
	return expectation
}

// Then sets up Logger.Is return parameters for the expectation previously defined by the When method
func (e *LoggerMockIsExpectation) Then(b1 bool) *LoggerMock {
	e.results = &LoggerMockIsResults{b1}
	return e.mock
}

// Is implements Logger
func (mmIs *LoggerMock) Is(level LogLevel) (b1 bool) {
	mm_atomic.AddUint64(&mmIs.beforeIsCounter, 1)
	defer mm_atomic.AddUint64(&mmIs.afterIsCounter, 1)

	if mmIs.inspectFuncIs != nil {
		mmIs.inspectFuncIs(level)
	}

	params := &LoggerMockIsParams{level}

	// Record call args
	mmIs.IsMock.mutex.Lock()
	mmIs.IsMock.callArgs = append(mmIs.IsMock.callArgs, params)
	mmIs.IsMock.mutex.Unlock()

	for _, e := range mmIs.IsMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmIs.IsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIs.IsMock.defaultExpectation.Counter, 1)
		want := mmIs.IsMock.defaultExpectation.params
		got := LoggerMockIsParams{level}
		if want != nil && !minimock.Equal(*want, got) {
			mmIs.t.Errorf("LoggerMock.Is got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmIs.IsMock.defaultExpectation.results
		if results == nil {
			mmIs.t.Fatal("No results are set for the LoggerMock.Is")
		}
		return (*results).b1
	}
	if mmIs.funcIs != nil {
		return mmIs.funcIs(level)
	}
	mmIs.t.Fatalf("Unexpected call to LoggerMock.Is. %v", level)
	return
}

// IsAfterCounter returns a count of finished LoggerMock.Is invocations
func (mmIs *LoggerMock) IsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIs.afterIsCounter)
}

// IsBeforeCounter returns a count of LoggerMock.Is invocations
func (mmIs *LoggerMock) IsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIs.beforeIsCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Is.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIs *mLoggerMockIs) Calls() []*LoggerMockIsParams {
	mmIs.mutex.RLock()

	argCopy := make([]*LoggerMockIsParams, len(mmIs.callArgs))
	copy(argCopy, mmIs.callArgs)

	mmIs.mutex.RUnlock()

	return argCopy
}

// MinimockIsDone returns true if the count of the Is invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockIsDone() bool {
	for _, e := range m.IsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIs != nil && mm_atomic.LoadUint64(&m.afterIsCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsInspect logs each unmet expectation
func (m *LoggerMock) MinimockIsInspect() {
	for _, e := range m.IsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Is with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsCounter) < 1 {
		if m.IsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Is")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Is with params: %#v", *m.IsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIs != nil && mm_atomic.LoadUint64(&m.afterIsCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Is")
	}
}

type mLoggerMockLevel struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockLevelExpectation
	expectations       []*LoggerMockLevelExpectation

	callArgs []*LoggerMockLevelParams
	mutex    sync.RWMutex
}

// LoggerMockLevelExpectation specifies expectation struct of the Logger.Level
type LoggerMockLevelExpectation struct {
	mock    *LoggerMock
	params  *LoggerMockLevelParams
	results *LoggerMockLevelResults
	Counter uint64
}

// LoggerMockLevelParams contains parameters of the Logger.Level
type LoggerMockLevelParams struct {
	lvl LogLevel
}

// LoggerMockLevelResults contains results of the Logger.Level
type LoggerMockLevelResults struct {
	l1 Logger
}

// Expect sets up expected params for Logger.Level
func (mmLevel *mLoggerMockLevel) Expect(lvl LogLevel) *mLoggerMockLevel {
	if mmLevel.mock.funcLevel != nil {
		mmLevel.mock.t.Fatalf("LoggerMock.Level mock is already set by Set")
	}

	if mmLevel.defaultExpectation == nil {
		mmLevel.defaultExpectation = &LoggerMockLevelExpectation{}
	}

	mmLevel.defaultExpectation.params = &LoggerMockLevelParams{lvl}
	for _, e := range mmLevel.expectations {
		if minimock.Equal(e.params, mmLevel.defaultExpectation.params) {
			mmLevel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLevel.defaultExpectation.params)
		}
	}

	return mmLevel
}

// Inspect accepts an inspector function that has same arguments as the Logger.Level
func (mmLevel *mLoggerMockLevel) Inspect(f func(lvl LogLevel)) *mLoggerMockLevel {
	if mmLevel.mock.inspectFuncLevel != nil {
		mmLevel.mock.t.Fatalf("Inspect function is already set for LoggerMock.Level")
	}

	mmLevel.mock.inspectFuncLevel = f

	return mmLevel
}

// Return sets up results that will be returned by Logger.Level
func (mmLevel *mLoggerMockLevel) Return(l1 Logger) *LoggerMock {
	if mmLevel.mock.funcLevel != nil {
		mmLevel.mock.t.Fatalf("LoggerMock.Level mock is already set by Set")
	}

	if mmLevel.defaultExpectation == nil {
		mmLevel.defaultExpectation = &LoggerMockLevelExpectation{mock: mmLevel.mock}
	}
	mmLevel.defaultExpectation.results = &LoggerMockLevelResults{l1}
	return mmLevel.mock
}

//Set uses given function f to mock the Logger.Level method
func (mmLevel *mLoggerMockLevel) Set(f func(lvl LogLevel) (l1 Logger)) *LoggerMock {
	if mmLevel.defaultExpectation != nil {
		mmLevel.mock.t.Fatalf("Default expectation is already set for the Logger.Level method")
	}

	if len(mmLevel.expectations) > 0 {
		mmLevel.mock.t.Fatalf("Some expectations are already set for the Logger.Level method")
	}

	mmLevel.mock.funcLevel = f
	return mmLevel.mock
}

// When sets expectation for the Logger.Level which will trigger the result defined by the following
// Then helper
func (mmLevel *mLoggerMockLevel) When(lvl LogLevel) *LoggerMockLevelExpectation {
	if mmLevel.mock.funcLevel != nil {
		mmLevel.mock.t.Fatalf("LoggerMock.Level mock is already set by Set")
	}

	expectation := &LoggerMockLevelExpectation{
		mock:   mmLevel.mock,
		params: &LoggerMockLevelParams{lvl},
	}
	mmLevel.expectations = append(mmLevel.expectations, expectation)
	return expectation
}

// Then sets up Logger.Level return parameters for the expectation previously defined by the When method
func (e *LoggerMockLevelExpectation) Then(l1 Logger) *LoggerMock {
	e.results = &LoggerMockLevelResults{l1}
	return e.mock
}

// Level implements Logger
func (mmLevel *LoggerMock) Level(lvl LogLevel) (l1 Logger) {
	mm_atomic.AddUint64(&mmLevel.beforeLevelCounter, 1)
	defer mm_atomic.AddUint64(&mmLevel.afterLevelCounter, 1)

	if mmLevel.inspectFuncLevel != nil {
		mmLevel.inspectFuncLevel(lvl)
	}

	params := &LoggerMockLevelParams{lvl}

	// Record call args
	mmLevel.LevelMock.mutex.Lock()
	mmLevel.LevelMock.callArgs = append(mmLevel.LevelMock.callArgs, params)
	mmLevel.LevelMock.mutex.Unlock()

	for _, e := range mmLevel.LevelMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.l1
		}
	}

	if mmLevel.LevelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLevel.LevelMock.defaultExpectation.Counter, 1)
		want := mmLevel.LevelMock.defaultExpectation.params
		got := LoggerMockLevelParams{lvl}
		if want != nil && !minimock.Equal(*want, got) {
			mmLevel.t.Errorf("LoggerMock.Level got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmLevel.LevelMock.defaultExpectation.results
		if results == nil {
			mmLevel.t.Fatal("No results are set for the LoggerMock.Level")
		}
		return (*results).l1
	}
	if mmLevel.funcLevel != nil {
		return mmLevel.funcLevel(lvl)
	}
	mmLevel.t.Fatalf("Unexpected call to LoggerMock.Level. %v", lvl)
	return
}

// LevelAfterCounter returns a count of finished LoggerMock.Level invocations
func (mmLevel *LoggerMock) LevelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLevel.afterLevelCounter)
}

// LevelBeforeCounter returns a count of LoggerMock.Level invocations
func (mmLevel *LoggerMock) LevelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLevel.beforeLevelCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Level.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLevel *mLoggerMockLevel) Calls() []*LoggerMockLevelParams {
	mmLevel.mutex.RLock()

	argCopy := make([]*LoggerMockLevelParams, len(mmLevel.callArgs))
	copy(argCopy, mmLevel.callArgs)

	mmLevel.mutex.RUnlock()

	return argCopy
}

// MinimockLevelDone returns true if the count of the Level invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockLevelDone() bool {
	for _, e := range m.LevelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LevelMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLevelCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLevel != nil && mm_atomic.LoadUint64(&m.afterLevelCounter) < 1 {
		return false
	}
	return true
}

// MinimockLevelInspect logs each unmet expectation
func (m *LoggerMock) MinimockLevelInspect() {
	for _, e := range m.LevelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Level with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LevelMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLevelCounter) < 1 {
		if m.LevelMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Level")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Level with params: %#v", *m.LevelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLevel != nil && mm_atomic.LoadUint64(&m.afterLevelCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Level")
	}
}

type mLoggerMockPanic struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockPanicExpectation
	expectations       []*LoggerMockPanicExpectation

	callArgs []*LoggerMockPanicParams
	mutex    sync.RWMutex
}

// LoggerMockPanicExpectation specifies expectation struct of the Logger.Panic
type LoggerMockPanicExpectation struct {
	mock   *LoggerMock
	params *LoggerMockPanicParams

	Counter uint64
}

// LoggerMockPanicParams contains parameters of the Logger.Panic
type LoggerMockPanicParams struct {
	p1 []interface{}
}

// Expect sets up expected params for Logger.Panic
func (mmPanic *mLoggerMockPanic) Expect(p1 ...interface{}) *mLoggerMockPanic {
	if mmPanic.mock.funcPanic != nil {
		mmPanic.mock.t.Fatalf("LoggerMock.Panic mock is already set by Set")
	}

	if mmPanic.defaultExpectation == nil {
		mmPanic.defaultExpectation = &LoggerMockPanicExpectation{}
	}

	mmPanic.defaultExpectation.params = &LoggerMockPanicParams{p1}
	for _, e := range mmPanic.expectations {
		if minimock.Equal(e.params, mmPanic.defaultExpectation.params) {
			mmPanic.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPanic.defaultExpectation.params)
		}
	}

	return mmPanic
}

// Inspect accepts an inspector function that has same arguments as the Logger.Panic
func (mmPanic *mLoggerMockPanic) Inspect(f func(p1 ...interface{})) *mLoggerMockPanic {
	if mmPanic.mock.inspectFuncPanic != nil {
		mmPanic.mock.t.Fatalf("Inspect function is already set for LoggerMock.Panic")
	}

	mmPanic.mock.inspectFuncPanic = f

	return mmPanic
}

// Return sets up results that will be returned by Logger.Panic
func (mmPanic *mLoggerMockPanic) Return() *LoggerMock {
	if mmPanic.mock.funcPanic != nil {
		mmPanic.mock.t.Fatalf("LoggerMock.Panic mock is already set by Set")
	}

	if mmPanic.defaultExpectation == nil {
		mmPanic.defaultExpectation = &LoggerMockPanicExpectation{mock: mmPanic.mock}
	}

	return mmPanic.mock
}

//Set uses given function f to mock the Logger.Panic method
func (mmPanic *mLoggerMockPanic) Set(f func(p1 ...interface{})) *LoggerMock {
	if mmPanic.defaultExpectation != nil {
		mmPanic.mock.t.Fatalf("Default expectation is already set for the Logger.Panic method")
	}

	if len(mmPanic.expectations) > 0 {
		mmPanic.mock.t.Fatalf("Some expectations are already set for the Logger.Panic method")
	}

	mmPanic.mock.funcPanic = f
	return mmPanic.mock
}

// Panic implements Logger
func (mmPanic *LoggerMock) Panic(p1 ...interface{}) {
	mm_atomic.AddUint64(&mmPanic.beforePanicCounter, 1)
	defer mm_atomic.AddUint64(&mmPanic.afterPanicCounter, 1)

	if mmPanic.inspectFuncPanic != nil {
		mmPanic.inspectFuncPanic(p1...)
	}

	params := &LoggerMockPanicParams{p1}

	// Record call args
	mmPanic.PanicMock.mutex.Lock()
	mmPanic.PanicMock.callArgs = append(mmPanic.PanicMock.callArgs, params)
	mmPanic.PanicMock.mutex.Unlock()

	for _, e := range mmPanic.PanicMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmPanic.PanicMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPanic.PanicMock.defaultExpectation.Counter, 1)
		want := mmPanic.PanicMock.defaultExpectation.params
		got := LoggerMockPanicParams{p1}
		if want != nil && !minimock.Equal(*want, got) {
			mmPanic.t.Errorf("LoggerMock.Panic got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmPanic.funcPanic != nil {
		mmPanic.funcPanic(p1...)
		return
	}
	mmPanic.t.Fatalf("Unexpected call to LoggerMock.Panic. %v", p1)

}

// PanicAfterCounter returns a count of finished LoggerMock.Panic invocations
func (mmPanic *LoggerMock) PanicAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPanic.afterPanicCounter)
}

// PanicBeforeCounter returns a count of LoggerMock.Panic invocations
func (mmPanic *LoggerMock) PanicBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPanic.beforePanicCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Panic.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPanic *mLoggerMockPanic) Calls() []*LoggerMockPanicParams {
	mmPanic.mutex.RLock()

	argCopy := make([]*LoggerMockPanicParams, len(mmPanic.callArgs))
	copy(argCopy, mmPanic.callArgs)

	mmPanic.mutex.RUnlock()

	return argCopy
}

// MinimockPanicDone returns true if the count of the Panic invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockPanicDone() bool {
	for _, e := range m.PanicMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PanicMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPanicCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPanic != nil && mm_atomic.LoadUint64(&m.afterPanicCounter) < 1 {
		return false
	}
	return true
}

// MinimockPanicInspect logs each unmet expectation
func (m *LoggerMock) MinimockPanicInspect() {
	for _, e := range m.PanicMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Panic with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PanicMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPanicCounter) < 1 {
		if m.PanicMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Panic")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Panic with params: %#v", *m.PanicMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPanic != nil && mm_atomic.LoadUint64(&m.afterPanicCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Panic")
	}
}

type mLoggerMockPanicf struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockPanicfExpectation
	expectations       []*LoggerMockPanicfExpectation

	callArgs []*LoggerMockPanicfParams
	mutex    sync.RWMutex
}

// LoggerMockPanicfExpectation specifies expectation struct of the Logger.Panicf
type LoggerMockPanicfExpectation struct {
	mock   *LoggerMock
	params *LoggerMockPanicfParams

	Counter uint64
}

// LoggerMockPanicfParams contains parameters of the Logger.Panicf
type LoggerMockPanicfParams struct {
	s1 string
	p1 []interface{}
}

// Expect sets up expected params for Logger.Panicf
func (mmPanicf *mLoggerMockPanicf) Expect(s1 string, p1 ...interface{}) *mLoggerMockPanicf {
	if mmPanicf.mock.funcPanicf != nil {
		mmPanicf.mock.t.Fatalf("LoggerMock.Panicf mock is already set by Set")
	}

	if mmPanicf.defaultExpectation == nil {
		mmPanicf.defaultExpectation = &LoggerMockPanicfExpectation{}
	}

	mmPanicf.defaultExpectation.params = &LoggerMockPanicfParams{s1, p1}
	for _, e := range mmPanicf.expectations {
		if minimock.Equal(e.params, mmPanicf.defaultExpectation.params) {
			mmPanicf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPanicf.defaultExpectation.params)
		}
	}

	return mmPanicf
}

// Inspect accepts an inspector function that has same arguments as the Logger.Panicf
func (mmPanicf *mLoggerMockPanicf) Inspect(f func(s1 string, p1 ...interface{})) *mLoggerMockPanicf {
	if mmPanicf.mock.inspectFuncPanicf != nil {
		mmPanicf.mock.t.Fatalf("Inspect function is already set for LoggerMock.Panicf")
	}

	mmPanicf.mock.inspectFuncPanicf = f

	return mmPanicf
}

// Return sets up results that will be returned by Logger.Panicf
func (mmPanicf *mLoggerMockPanicf) Return() *LoggerMock {
	if mmPanicf.mock.funcPanicf != nil {
		mmPanicf.mock.t.Fatalf("LoggerMock.Panicf mock is already set by Set")
	}

	if mmPanicf.defaultExpectation == nil {
		mmPanicf.defaultExpectation = &LoggerMockPanicfExpectation{mock: mmPanicf.mock}
	}

	return mmPanicf.mock
}

//Set uses given function f to mock the Logger.Panicf method
func (mmPanicf *mLoggerMockPanicf) Set(f func(s1 string, p1 ...interface{})) *LoggerMock {
	if mmPanicf.defaultExpectation != nil {
		mmPanicf.mock.t.Fatalf("Default expectation is already set for the Logger.Panicf method")
	}

	if len(mmPanicf.expectations) > 0 {
		mmPanicf.mock.t.Fatalf("Some expectations are already set for the Logger.Panicf method")
	}

	mmPanicf.mock.funcPanicf = f
	return mmPanicf.mock
}

// Panicf implements Logger
func (mmPanicf *LoggerMock) Panicf(s1 string, p1 ...interface{}) {
	mm_atomic.AddUint64(&mmPanicf.beforePanicfCounter, 1)
	defer mm_atomic.AddUint64(&mmPanicf.afterPanicfCounter, 1)

	if mmPanicf.inspectFuncPanicf != nil {
		mmPanicf.inspectFuncPanicf(s1, p1...)
	}

	params := &LoggerMockPanicfParams{s1, p1}

	// Record call args
	mmPanicf.PanicfMock.mutex.Lock()
	mmPanicf.PanicfMock.callArgs = append(mmPanicf.PanicfMock.callArgs, params)
	mmPanicf.PanicfMock.mutex.Unlock()

	for _, e := range mmPanicf.PanicfMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmPanicf.PanicfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPanicf.PanicfMock.defaultExpectation.Counter, 1)
		want := mmPanicf.PanicfMock.defaultExpectation.params
		got := LoggerMockPanicfParams{s1, p1}
		if want != nil && !minimock.Equal(*want, got) {
			mmPanicf.t.Errorf("LoggerMock.Panicf got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmPanicf.funcPanicf != nil {
		mmPanicf.funcPanicf(s1, p1...)
		return
	}
	mmPanicf.t.Fatalf("Unexpected call to LoggerMock.Panicf. %v %v", s1, p1)

}

// PanicfAfterCounter returns a count of finished LoggerMock.Panicf invocations
func (mmPanicf *LoggerMock) PanicfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPanicf.afterPanicfCounter)
}

// PanicfBeforeCounter returns a count of LoggerMock.Panicf invocations
func (mmPanicf *LoggerMock) PanicfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPanicf.beforePanicfCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Panicf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPanicf *mLoggerMockPanicf) Calls() []*LoggerMockPanicfParams {
	mmPanicf.mutex.RLock()

	argCopy := make([]*LoggerMockPanicfParams, len(mmPanicf.callArgs))
	copy(argCopy, mmPanicf.callArgs)

	mmPanicf.mutex.RUnlock()

	return argCopy
}

// MinimockPanicfDone returns true if the count of the Panicf invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockPanicfDone() bool {
	for _, e := range m.PanicfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PanicfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPanicfCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPanicf != nil && mm_atomic.LoadUint64(&m.afterPanicfCounter) < 1 {
		return false
	}
	return true
}

// MinimockPanicfInspect logs each unmet expectation
func (m *LoggerMock) MinimockPanicfInspect() {
	for _, e := range m.PanicfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Panicf with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PanicfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPanicfCounter) < 1 {
		if m.PanicfMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Panicf")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Panicf with params: %#v", *m.PanicfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPanicf != nil && mm_atomic.LoadUint64(&m.afterPanicfCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Panicf")
	}
}

type mLoggerMockWarn struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockWarnExpectation
	expectations       []*LoggerMockWarnExpectation

	callArgs []*LoggerMockWarnParams
	mutex    sync.RWMutex
}

// LoggerMockWarnExpectation specifies expectation struct of the Logger.Warn
type LoggerMockWarnExpectation struct {
	mock   *LoggerMock
	params *LoggerMockWarnParams

	Counter uint64
}

// LoggerMockWarnParams contains parameters of the Logger.Warn
type LoggerMockWarnParams struct {
	p1 []interface{}
}

// Expect sets up expected params for Logger.Warn
func (mmWarn *mLoggerMockWarn) Expect(p1 ...interface{}) *mLoggerMockWarn {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Set")
	}

	if mmWarn.defaultExpectation == nil {
		mmWarn.defaultExpectation = &LoggerMockWarnExpectation{}
	}

	mmWarn.defaultExpectation.params = &LoggerMockWarnParams{p1}
	for _, e := range mmWarn.expectations {
		if minimock.Equal(e.params, mmWarn.defaultExpectation.params) {
			mmWarn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWarn.defaultExpectation.params)
		}
	}

	return mmWarn
}

// Inspect accepts an inspector function that has same arguments as the Logger.Warn
func (mmWarn *mLoggerMockWarn) Inspect(f func(p1 ...interface{})) *mLoggerMockWarn {
	if mmWarn.mock.inspectFuncWarn != nil {
		mmWarn.mock.t.Fatalf("Inspect function is already set for LoggerMock.Warn")
	}

	mmWarn.mock.inspectFuncWarn = f

	return mmWarn
}

// Return sets up results that will be returned by Logger.Warn
func (mmWarn *mLoggerMockWarn) Return() *LoggerMock {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Set")
	}

	if mmWarn.defaultExpectation == nil {
		mmWarn.defaultExpectation = &LoggerMockWarnExpectation{mock: mmWarn.mock}
	}

	return mmWarn.mock
}

//Set uses given function f to mock the Logger.Warn method
func (mmWarn *mLoggerMockWarn) Set(f func(p1 ...interface{})) *LoggerMock {
	if mmWarn.defaultExpectation != nil {
		mmWarn.mock.t.Fatalf("Default expectation is already set for the Logger.Warn method")
	}

	if len(mmWarn.expectations) > 0 {
		mmWarn.mock.t.Fatalf("Some expectations are already set for the Logger.Warn method")
	}

	mmWarn.mock.funcWarn = f
	return mmWarn.mock
}

// Warn implements Logger
func (mmWarn *LoggerMock) Warn(p1 ...interface{}) {
	mm_atomic.AddUint64(&mmWarn.beforeWarnCounter, 1)
	defer mm_atomic.AddUint64(&mmWarn.afterWarnCounter, 1)

	if mmWarn.inspectFuncWarn != nil {
		mmWarn.inspectFuncWarn(p1...)
	}

	params := &LoggerMockWarnParams{p1}

	// Record call args
	mmWarn.WarnMock.mutex.Lock()
	mmWarn.WarnMock.callArgs = append(mmWarn.WarnMock.callArgs, params)
	mmWarn.WarnMock.mutex.Unlock()

	for _, e := range mmWarn.WarnMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmWarn.WarnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWarn.WarnMock.defaultExpectation.Counter, 1)
		want := mmWarn.WarnMock.defaultExpectation.params
		got := LoggerMockWarnParams{p1}
		if want != nil && !minimock.Equal(*want, got) {
			mmWarn.t.Errorf("LoggerMock.Warn got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmWarn.funcWarn != nil {
		mmWarn.funcWarn(p1...)
		return
	}
	mmWarn.t.Fatalf("Unexpected call to LoggerMock.Warn. %v", p1)

}

// WarnAfterCounter returns a count of finished LoggerMock.Warn invocations
func (mmWarn *LoggerMock) WarnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarn.afterWarnCounter)
}

// WarnBeforeCounter returns a count of LoggerMock.Warn invocations
func (mmWarn *LoggerMock) WarnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarn.beforeWarnCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Warn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWarn *mLoggerMockWarn) Calls() []*LoggerMockWarnParams {
	mmWarn.mutex.RLock()

	argCopy := make([]*LoggerMockWarnParams, len(mmWarn.callArgs))
	copy(argCopy, mmWarn.callArgs)

	mmWarn.mutex.RUnlock()

	return argCopy
}

// MinimockWarnDone returns true if the count of the Warn invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockWarnDone() bool {
	for _, e := range m.WarnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WarnMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWarnCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWarn != nil && mm_atomic.LoadUint64(&m.afterWarnCounter) < 1 {
		return false
	}
	return true
}

// MinimockWarnInspect logs each unmet expectation
func (m *LoggerMock) MinimockWarnInspect() {
	for _, e := range m.WarnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Warn with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WarnMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWarnCounter) < 1 {
		if m.WarnMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Warn")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Warn with params: %#v", *m.WarnMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWarn != nil && mm_atomic.LoadUint64(&m.afterWarnCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Warn")
	}
}

type mLoggerMockWarnf struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockWarnfExpectation
	expectations       []*LoggerMockWarnfExpectation

	callArgs []*LoggerMockWarnfParams
	mutex    sync.RWMutex
}

// LoggerMockWarnfExpectation specifies expectation struct of the Logger.Warnf
type LoggerMockWarnfExpectation struct {
	mock   *LoggerMock
	params *LoggerMockWarnfParams

	Counter uint64
}

// LoggerMockWarnfParams contains parameters of the Logger.Warnf
type LoggerMockWarnfParams struct {
	s1 string
	p1 []interface{}
}

// Expect sets up expected params for Logger.Warnf
func (mmWarnf *mLoggerMockWarnf) Expect(s1 string, p1 ...interface{}) *mLoggerMockWarnf {
	if mmWarnf.mock.funcWarnf != nil {
		mmWarnf.mock.t.Fatalf("LoggerMock.Warnf mock is already set by Set")
	}

	if mmWarnf.defaultExpectation == nil {
		mmWarnf.defaultExpectation = &LoggerMockWarnfExpectation{}
	}

	mmWarnf.defaultExpectation.params = &LoggerMockWarnfParams{s1, p1}
	for _, e := range mmWarnf.expectations {
		if minimock.Equal(e.params, mmWarnf.defaultExpectation.params) {
			mmWarnf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWarnf.defaultExpectation.params)
		}
	}

	return mmWarnf
}

// Inspect accepts an inspector function that has same arguments as the Logger.Warnf
func (mmWarnf *mLoggerMockWarnf) Inspect(f func(s1 string, p1 ...interface{})) *mLoggerMockWarnf {
	if mmWarnf.mock.inspectFuncWarnf != nil {
		mmWarnf.mock.t.Fatalf("Inspect function is already set for LoggerMock.Warnf")
	}

	mmWarnf.mock.inspectFuncWarnf = f

	return mmWarnf
}

// Return sets up results that will be returned by Logger.Warnf
func (mmWarnf *mLoggerMockWarnf) Return() *LoggerMock {
	if mmWarnf.mock.funcWarnf != nil {
		mmWarnf.mock.t.Fatalf("LoggerMock.Warnf mock is already set by Set")
	}

	if mmWarnf.defaultExpectation == nil {
		mmWarnf.defaultExpectation = &LoggerMockWarnfExpectation{mock: mmWarnf.mock}
	}

	return mmWarnf.mock
}

//Set uses given function f to mock the Logger.Warnf method
func (mmWarnf *mLoggerMockWarnf) Set(f func(s1 string, p1 ...interface{})) *LoggerMock {
	if mmWarnf.defaultExpectation != nil {
		mmWarnf.mock.t.Fatalf("Default expectation is already set for the Logger.Warnf method")
	}

	if len(mmWarnf.expectations) > 0 {
		mmWarnf.mock.t.Fatalf("Some expectations are already set for the Logger.Warnf method")
	}

	mmWarnf.mock.funcWarnf = f
	return mmWarnf.mock
}

// Warnf implements Logger
func (mmWarnf *LoggerMock) Warnf(s1 string, p1 ...interface{}) {
	mm_atomic.AddUint64(&mmWarnf.beforeWarnfCounter, 1)
	defer mm_atomic.AddUint64(&mmWarnf.afterWarnfCounter, 1)

	if mmWarnf.inspectFuncWarnf != nil {
		mmWarnf.inspectFuncWarnf(s1, p1...)
	}

	params := &LoggerMockWarnfParams{s1, p1}

	// Record call args
	mmWarnf.WarnfMock.mutex.Lock()
	mmWarnf.WarnfMock.callArgs = append(mmWarnf.WarnfMock.callArgs, params)
	mmWarnf.WarnfMock.mutex.Unlock()

	for _, e := range mmWarnf.WarnfMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmWarnf.WarnfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWarnf.WarnfMock.defaultExpectation.Counter, 1)
		want := mmWarnf.WarnfMock.defaultExpectation.params
		got := LoggerMockWarnfParams{s1, p1}
		if want != nil && !minimock.Equal(*want, got) {
			mmWarnf.t.Errorf("LoggerMock.Warnf got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmWarnf.funcWarnf != nil {
		mmWarnf.funcWarnf(s1, p1...)
		return
	}
	mmWarnf.t.Fatalf("Unexpected call to LoggerMock.Warnf. %v %v", s1, p1)

}

// WarnfAfterCounter returns a count of finished LoggerMock.Warnf invocations
func (mmWarnf *LoggerMock) WarnfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarnf.afterWarnfCounter)
}

// WarnfBeforeCounter returns a count of LoggerMock.Warnf invocations
func (mmWarnf *LoggerMock) WarnfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarnf.beforeWarnfCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Warnf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWarnf *mLoggerMockWarnf) Calls() []*LoggerMockWarnfParams {
	mmWarnf.mutex.RLock()

	argCopy := make([]*LoggerMockWarnfParams, len(mmWarnf.callArgs))
	copy(argCopy, mmWarnf.callArgs)

	mmWarnf.mutex.RUnlock()

	return argCopy
}

// MinimockWarnfDone returns true if the count of the Warnf invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockWarnfDone() bool {
	for _, e := range m.WarnfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WarnfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWarnfCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWarnf != nil && mm_atomic.LoadUint64(&m.afterWarnfCounter) < 1 {
		return false
	}
	return true
}

// MinimockWarnfInspect logs each unmet expectation
func (m *LoggerMock) MinimockWarnfInspect() {
	for _, e := range m.WarnfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Warnf with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WarnfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWarnfCounter) < 1 {
		if m.WarnfMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Warnf")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Warnf with params: %#v", *m.WarnfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWarnf != nil && mm_atomic.LoadUint64(&m.afterWarnfCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Warnf")
	}
}

type mLoggerMockWithField struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockWithFieldExpectation
	expectations       []*LoggerMockWithFieldExpectation

	callArgs []*LoggerMockWithFieldParams
	mutex    sync.RWMutex
}

// LoggerMockWithFieldExpectation specifies expectation struct of the Logger.WithField
type LoggerMockWithFieldExpectation struct {
	mock    *LoggerMock
	params  *LoggerMockWithFieldParams
	results *LoggerMockWithFieldResults
	Counter uint64
}

// LoggerMockWithFieldParams contains parameters of the Logger.WithField
type LoggerMockWithFieldParams struct {
	s1 string
	p1 interface{}
}

// LoggerMockWithFieldResults contains results of the Logger.WithField
type LoggerMockWithFieldResults struct {
	l1 Logger
}

// Expect sets up expected params for Logger.WithField
func (mmWithField *mLoggerMockWithField) Expect(s1 string, p1 interface{}) *mLoggerMockWithField {
	if mmWithField.mock.funcWithField != nil {
		mmWithField.mock.t.Fatalf("LoggerMock.WithField mock is already set by Set")
	}

	if mmWithField.defaultExpectation == nil {
		mmWithField.defaultExpectation = &LoggerMockWithFieldExpectation{}
	}

	mmWithField.defaultExpectation.params = &LoggerMockWithFieldParams{s1, p1}
	for _, e := range mmWithField.expectations {
		if minimock.Equal(e.params, mmWithField.defaultExpectation.params) {
			mmWithField.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWithField.defaultExpectation.params)
		}
	}

	return mmWithField
}

// Inspect accepts an inspector function that has same arguments as the Logger.WithField
func (mmWithField *mLoggerMockWithField) Inspect(f func(s1 string, p1 interface{})) *mLoggerMockWithField {
	if mmWithField.mock.inspectFuncWithField != nil {
		mmWithField.mock.t.Fatalf("Inspect function is already set for LoggerMock.WithField")
	}

	mmWithField.mock.inspectFuncWithField = f

	return mmWithField
}

// Return sets up results that will be returned by Logger.WithField
func (mmWithField *mLoggerMockWithField) Return(l1 Logger) *LoggerMock {
	if mmWithField.mock.funcWithField != nil {
		mmWithField.mock.t.Fatalf("LoggerMock.WithField mock is already set by Set")
	}

	if mmWithField.defaultExpectation == nil {
		mmWithField.defaultExpectation = &LoggerMockWithFieldExpectation{mock: mmWithField.mock}
	}
	mmWithField.defaultExpectation.results = &LoggerMockWithFieldResults{l1}
	return mmWithField.mock
}

//Set uses given function f to mock the Logger.WithField method
func (mmWithField *mLoggerMockWithField) Set(f func(s1 string, p1 interface{}) (l1 Logger)) *LoggerMock {
	if mmWithField.defaultExpectation != nil {
		mmWithField.mock.t.Fatalf("Default expectation is already set for the Logger.WithField method")
	}

	if len(mmWithField.expectations) > 0 {
		mmWithField.mock.t.Fatalf("Some expectations are already set for the Logger.WithField method")
	}

	mmWithField.mock.funcWithField = f
	return mmWithField.mock
}

// When sets expectation for the Logger.WithField which will trigger the result defined by the following
// Then helper
func (mmWithField *mLoggerMockWithField) When(s1 string, p1 interface{}) *LoggerMockWithFieldExpectation {
	if mmWithField.mock.funcWithField != nil {
		mmWithField.mock.t.Fatalf("LoggerMock.WithField mock is already set by Set")
	}

	expectation := &LoggerMockWithFieldExpectation{
		mock:   mmWithField.mock,
		params: &LoggerMockWithFieldParams{s1, p1},
	}
	mmWithField.expectations = append(mmWithField.expectations, expectation)
	return expectation
}

// Then sets up Logger.WithField return parameters for the expectation previously defined by the When method
func (e *LoggerMockWithFieldExpectation) Then(l1 Logger) *LoggerMock {
	e.results = &LoggerMockWithFieldResults{l1}
	return e.mock
}

// WithField implements Logger
func (mmWithField *LoggerMock) WithField(s1 string, p1 interface{}) (l1 Logger) {
	mm_atomic.AddUint64(&mmWithField.beforeWithFieldCounter, 1)
	defer mm_atomic.AddUint64(&mmWithField.afterWithFieldCounter, 1)

	if mmWithField.inspectFuncWithField != nil {
		mmWithField.inspectFuncWithField(s1, p1)
	}

	params := &LoggerMockWithFieldParams{s1, p1}

	// Record call args
	mmWithField.WithFieldMock.mutex.Lock()
	mmWithField.WithFieldMock.callArgs = append(mmWithField.WithFieldMock.callArgs, params)
	mmWithField.WithFieldMock.mutex.Unlock()

	for _, e := range mmWithField.WithFieldMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.l1
		}
	}

	if mmWithField.WithFieldMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWithField.WithFieldMock.defaultExpectation.Counter, 1)
		want := mmWithField.WithFieldMock.defaultExpectation.params
		got := LoggerMockWithFieldParams{s1, p1}
		if want != nil && !minimock.Equal(*want, got) {
			mmWithField.t.Errorf("LoggerMock.WithField got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmWithField.WithFieldMock.defaultExpectation.results
		if results == nil {
			mmWithField.t.Fatal("No results are set for the LoggerMock.WithField")
		}
		return (*results).l1
	}
	if mmWithField.funcWithField != nil {
		return mmWithField.funcWithField(s1, p1)
	}
	mmWithField.t.Fatalf("Unexpected call to LoggerMock.WithField. %v %v", s1, p1)
	return
}

// WithFieldAfterCounter returns a count of finished LoggerMock.WithField invocations
func (mmWithField *LoggerMock) WithFieldAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithField.afterWithFieldCounter)
}

// WithFieldBeforeCounter returns a count of LoggerMock.WithField invocations
func (mmWithField *LoggerMock) WithFieldBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithField.beforeWithFieldCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.WithField.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWithField *mLoggerMockWithField) Calls() []*LoggerMockWithFieldParams {
	mmWithField.mutex.RLock()

	argCopy := make([]*LoggerMockWithFieldParams, len(mmWithField.callArgs))
	copy(argCopy, mmWithField.callArgs)

	mmWithField.mutex.RUnlock()

	return argCopy
}

// MinimockWithFieldDone returns true if the count of the WithField invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockWithFieldDone() bool {
	for _, e := range m.WithFieldMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithFieldMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithFieldCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithField != nil && mm_atomic.LoadUint64(&m.afterWithFieldCounter) < 1 {
		return false
	}
	return true
}

// MinimockWithFieldInspect logs each unmet expectation
func (m *LoggerMock) MinimockWithFieldInspect() {
	for _, e := range m.WithFieldMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.WithField with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithFieldMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithFieldCounter) < 1 {
		if m.WithFieldMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.WithField")
		} else {
			m.t.Errorf("Expected call to LoggerMock.WithField with params: %#v", *m.WithFieldMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithField != nil && mm_atomic.LoadUint64(&m.afterWithFieldCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.WithField")
	}
}

type mLoggerMockWithFields struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockWithFieldsExpectation
	expectations       []*LoggerMockWithFieldsExpectation

	callArgs []*LoggerMockWithFieldsParams
	mutex    sync.RWMutex
}

// LoggerMockWithFieldsExpectation specifies expectation struct of the Logger.WithFields
type LoggerMockWithFieldsExpectation struct {
	mock    *LoggerMock
	params  *LoggerMockWithFieldsParams
	results *LoggerMockWithFieldsResults
	Counter uint64
}

// LoggerMockWithFieldsParams contains parameters of the Logger.WithFields
type LoggerMockWithFieldsParams struct {
	m1 map[string]interface{}
}

// LoggerMockWithFieldsResults contains results of the Logger.WithFields
type LoggerMockWithFieldsResults struct {
	l1 Logger
}

// Expect sets up expected params for Logger.WithFields
func (mmWithFields *mLoggerMockWithFields) Expect(m1 map[string]interface{}) *mLoggerMockWithFields {
	if mmWithFields.mock.funcWithFields != nil {
		mmWithFields.mock.t.Fatalf("LoggerMock.WithFields mock is already set by Set")
	}

	if mmWithFields.defaultExpectation == nil {
		mmWithFields.defaultExpectation = &LoggerMockWithFieldsExpectation{}
	}

	mmWithFields.defaultExpectation.params = &LoggerMockWithFieldsParams{m1}
	for _, e := range mmWithFields.expectations {
		if minimock.Equal(e.params, mmWithFields.defaultExpectation.params) {
			mmWithFields.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWithFields.defaultExpectation.params)
		}
	}

	return mmWithFields
}

// Inspect accepts an inspector function that has same arguments as the Logger.WithFields
func (mmWithFields *mLoggerMockWithFields) Inspect(f func(m1 map[string]interface{})) *mLoggerMockWithFields {
	if mmWithFields.mock.inspectFuncWithFields != nil {
		mmWithFields.mock.t.Fatalf("Inspect function is already set for LoggerMock.WithFields")
	}

	mmWithFields.mock.inspectFuncWithFields = f

	return mmWithFields
}

// Return sets up results that will be returned by Logger.WithFields
func (mmWithFields *mLoggerMockWithFields) Return(l1 Logger) *LoggerMock {
	if mmWithFields.mock.funcWithFields != nil {
		mmWithFields.mock.t.Fatalf("LoggerMock.WithFields mock is already set by Set")
	}

	if mmWithFields.defaultExpectation == nil {
		mmWithFields.defaultExpectation = &LoggerMockWithFieldsExpectation{mock: mmWithFields.mock}
	}
	mmWithFields.defaultExpectation.results = &LoggerMockWithFieldsResults{l1}
	return mmWithFields.mock
}

//Set uses given function f to mock the Logger.WithFields method
func (mmWithFields *mLoggerMockWithFields) Set(f func(m1 map[string]interface{}) (l1 Logger)) *LoggerMock {
	if mmWithFields.defaultExpectation != nil {
		mmWithFields.mock.t.Fatalf("Default expectation is already set for the Logger.WithFields method")
	}

	if len(mmWithFields.expectations) > 0 {
		mmWithFields.mock.t.Fatalf("Some expectations are already set for the Logger.WithFields method")
	}

	mmWithFields.mock.funcWithFields = f
	return mmWithFields.mock
}

// When sets expectation for the Logger.WithFields which will trigger the result defined by the following
// Then helper
func (mmWithFields *mLoggerMockWithFields) When(m1 map[string]interface{}) *LoggerMockWithFieldsExpectation {
	if mmWithFields.mock.funcWithFields != nil {
		mmWithFields.mock.t.Fatalf("LoggerMock.WithFields mock is already set by Set")
	}

	expectation := &LoggerMockWithFieldsExpectation{
		mock:   mmWithFields.mock,
		params: &LoggerMockWithFieldsParams{m1},
	}
	mmWithFields.expectations = append(mmWithFields.expectations, expectation)
	return expectation
}

// Then sets up Logger.WithFields return parameters for the expectation previously defined by the When method
func (e *LoggerMockWithFieldsExpectation) Then(l1 Logger) *LoggerMock {
	e.results = &LoggerMockWithFieldsResults{l1}
	return e.mock
}

// WithFields implements Logger
func (mmWithFields *LoggerMock) WithFields(m1 map[string]interface{}) (l1 Logger) {
	mm_atomic.AddUint64(&mmWithFields.beforeWithFieldsCounter, 1)
	defer mm_atomic.AddUint64(&mmWithFields.afterWithFieldsCounter, 1)

	if mmWithFields.inspectFuncWithFields != nil {
		mmWithFields.inspectFuncWithFields(m1)
	}

	params := &LoggerMockWithFieldsParams{m1}

	// Record call args
	mmWithFields.WithFieldsMock.mutex.Lock()
	mmWithFields.WithFieldsMock.callArgs = append(mmWithFields.WithFieldsMock.callArgs, params)
	mmWithFields.WithFieldsMock.mutex.Unlock()

	for _, e := range mmWithFields.WithFieldsMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.l1
		}
	}

	if mmWithFields.WithFieldsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWithFields.WithFieldsMock.defaultExpectation.Counter, 1)
		want := mmWithFields.WithFieldsMock.defaultExpectation.params
		got := LoggerMockWithFieldsParams{m1}
		if want != nil && !minimock.Equal(*want, got) {
			mmWithFields.t.Errorf("LoggerMock.WithFields got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmWithFields.WithFieldsMock.defaultExpectation.results
		if results == nil {
			mmWithFields.t.Fatal("No results are set for the LoggerMock.WithFields")
		}
		return (*results).l1
	}
	if mmWithFields.funcWithFields != nil {
		return mmWithFields.funcWithFields(m1)
	}
	mmWithFields.t.Fatalf("Unexpected call to LoggerMock.WithFields. %v", m1)
	return
}

// WithFieldsAfterCounter returns a count of finished LoggerMock.WithFields invocations
func (mmWithFields *LoggerMock) WithFieldsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithFields.afterWithFieldsCounter)
}

// WithFieldsBeforeCounter returns a count of LoggerMock.WithFields invocations
func (mmWithFields *LoggerMock) WithFieldsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithFields.beforeWithFieldsCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.WithFields.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWithFields *mLoggerMockWithFields) Calls() []*LoggerMockWithFieldsParams {
	mmWithFields.mutex.RLock()

	argCopy := make([]*LoggerMockWithFieldsParams, len(mmWithFields.callArgs))
	copy(argCopy, mmWithFields.callArgs)

	mmWithFields.mutex.RUnlock()

	return argCopy
}

// MinimockWithFieldsDone returns true if the count of the WithFields invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockWithFieldsDone() bool {
	for _, e := range m.WithFieldsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithFieldsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithFieldsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithFields != nil && mm_atomic.LoadUint64(&m.afterWithFieldsCounter) < 1 {
		return false
	}
	return true
}

// MinimockWithFieldsInspect logs each unmet expectation
func (m *LoggerMock) MinimockWithFieldsInspect() {
	for _, e := range m.WithFieldsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.WithFields with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithFieldsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithFieldsCounter) < 1 {
		if m.WithFieldsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.WithFields")
		} else {
			m.t.Errorf("Expected call to LoggerMock.WithFields with params: %#v", *m.WithFieldsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithFields != nil && mm_atomic.LoadUint64(&m.afterWithFieldsCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.WithFields")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LoggerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCopyInspect()

		m.MinimockDebugInspect()

		m.MinimockDebugfInspect()

		m.MinimockEmbeddableInspect()

		m.MinimockErrorInspect()

		m.MinimockErrorfInspect()

		m.MinimockEventInspect()

		m.MinimockEventfInspect()

		m.MinimockFatalInspect()

		m.MinimockFatalfInspect()

		m.MinimockInfoInspect()

		m.MinimockInfofInspect()

		m.MinimockIsInspect()

		m.MinimockLevelInspect()

		m.MinimockPanicInspect()

		m.MinimockPanicfInspect()

		m.MinimockWarnInspect()

		m.MinimockWarnfInspect()

		m.MinimockWithFieldInspect()

		m.MinimockWithFieldsInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LoggerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LoggerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCopyDone() &&
		m.MinimockDebugDone() &&
		m.MinimockDebugfDone() &&
		m.MinimockEmbeddableDone() &&
		m.MinimockErrorDone() &&
		m.MinimockErrorfDone() &&
		m.MinimockEventDone() &&
		m.MinimockEventfDone() &&
		m.MinimockFatalDone() &&
		m.MinimockFatalfDone() &&
		m.MinimockInfoDone() &&
		m.MinimockInfofDone() &&
		m.MinimockIsDone() &&
		m.MinimockLevelDone() &&
		m.MinimockPanicDone() &&
		m.MinimockPanicfDone() &&
		m.MinimockWarnDone() &&
		m.MinimockWarnfDone() &&
		m.MinimockWithFieldDone() &&
		m.MinimockWithFieldsDone()
}
