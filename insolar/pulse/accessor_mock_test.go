package pulse

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/insolar"
)

// AccessorMock implements Accessor
type AccessorMock struct {
	t minimock.Tester

	funcForPulseNumber          func(ctx context.Context, p1 insolar.PulseNumber) (p2 insolar.Pulse, err error)
	inspectFuncForPulseNumber   func(ctx context.Context, p1 insolar.PulseNumber)
	afterForPulseNumberCounter  uint64
	beforeForPulseNumberCounter uint64
	ForPulseNumberMock          mAccessorMockForPulseNumber

	funcLatest          func(ctx context.Context) (p1 insolar.Pulse, err error)
	inspectFuncLatest   func(ctx context.Context)
	afterLatestCounter  uint64
	beforeLatestCounter uint64
	LatestMock          mAccessorMockLatest
}

// NewAccessorMock returns a mock for Accessor
func NewAccessorMock(t minimock.Tester) *AccessorMock {
	m := &AccessorMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ForPulseNumberMock = mAccessorMockForPulseNumber{mock: m}
	m.ForPulseNumberMock.callArgs = []*AccessorMockForPulseNumberParams{}

	m.LatestMock = mAccessorMockLatest{mock: m}
	m.LatestMock.callArgs = []*AccessorMockLatestParams{}

	return m
}

type mAccessorMockForPulseNumber struct {
	mock               *AccessorMock
	defaultExpectation *AccessorMockForPulseNumberExpectation
	expectations       []*AccessorMockForPulseNumberExpectation

	callArgs []*AccessorMockForPulseNumberParams
	mutex    sync.RWMutex
}

// AccessorMockForPulseNumberExpectation specifies expectation struct of the Accessor.ForPulseNumber
type AccessorMockForPulseNumberExpectation struct {
	mock    *AccessorMock
	params  *AccessorMockForPulseNumberParams
	results *AccessorMockForPulseNumberResults
	Counter uint64
}

// AccessorMockForPulseNumberParams contains parameters of the Accessor.ForPulseNumber
type AccessorMockForPulseNumberParams struct {
	ctx context.Context
	p1  insolar.PulseNumber
}

// AccessorMockForPulseNumberResults contains results of the Accessor.ForPulseNumber
type AccessorMockForPulseNumberResults struct {
	p2  insolar.Pulse
	err error
}

// Expect sets up expected params for Accessor.ForPulseNumber
func (mmForPulseNumber *mAccessorMockForPulseNumber) Expect(ctx context.Context, p1 insolar.PulseNumber) *mAccessorMockForPulseNumber {
	if mmForPulseNumber.mock.funcForPulseNumber != nil {
		mmForPulseNumber.mock.t.Fatalf("AccessorMock.ForPulseNumber mock is already set by Set")
	}

	if mmForPulseNumber.defaultExpectation == nil {
		mmForPulseNumber.defaultExpectation = &AccessorMockForPulseNumberExpectation{}
	}

	mmForPulseNumber.defaultExpectation.params = &AccessorMockForPulseNumberParams{ctx, p1}
	for _, e := range mmForPulseNumber.expectations {
		if minimock.Equal(e.params, mmForPulseNumber.defaultExpectation.params) {
			mmForPulseNumber.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmForPulseNumber.defaultExpectation.params)
		}
	}

	return mmForPulseNumber
}

// Inspect accepts an inspector function that has same arguments as the Accessor.ForPulseNumber
func (mmForPulseNumber *mAccessorMockForPulseNumber) Inspect(f func(ctx context.Context, p1 insolar.PulseNumber)) *mAccessorMockForPulseNumber {
	if mmForPulseNumber.mock.inspectFuncForPulseNumber != nil {
		mmForPulseNumber.mock.t.Fatalf("Inspect function is already set for AccessorMock.ForPulseNumber")
	}

	mmForPulseNumber.mock.inspectFuncForPulseNumber = f

	return mmForPulseNumber
}

// Return sets up results that will be returned by Accessor.ForPulseNumber
func (mmForPulseNumber *mAccessorMockForPulseNumber) Return(p2 insolar.Pulse, err error) *AccessorMock {
	if mmForPulseNumber.mock.funcForPulseNumber != nil {
		mmForPulseNumber.mock.t.Fatalf("AccessorMock.ForPulseNumber mock is already set by Set")
	}

	if mmForPulseNumber.defaultExpectation == nil {
		mmForPulseNumber.defaultExpectation = &AccessorMockForPulseNumberExpectation{mock: mmForPulseNumber.mock}
	}
	mmForPulseNumber.defaultExpectation.results = &AccessorMockForPulseNumberResults{p2, err}
	return mmForPulseNumber.mock
}

//Set uses given function f to mock the Accessor.ForPulseNumber method
func (mmForPulseNumber *mAccessorMockForPulseNumber) Set(f func(ctx context.Context, p1 insolar.PulseNumber) (p2 insolar.Pulse, err error)) *AccessorMock {
	if mmForPulseNumber.defaultExpectation != nil {
		mmForPulseNumber.mock.t.Fatalf("Default expectation is already set for the Accessor.ForPulseNumber method")
	}

	if len(mmForPulseNumber.expectations) > 0 {
		mmForPulseNumber.mock.t.Fatalf("Some expectations are already set for the Accessor.ForPulseNumber method")
	}

	mmForPulseNumber.mock.funcForPulseNumber = f
	return mmForPulseNumber.mock
}

// When sets expectation for the Accessor.ForPulseNumber which will trigger the result defined by the following
// Then helper
func (mmForPulseNumber *mAccessorMockForPulseNumber) When(ctx context.Context, p1 insolar.PulseNumber) *AccessorMockForPulseNumberExpectation {
	if mmForPulseNumber.mock.funcForPulseNumber != nil {
		mmForPulseNumber.mock.t.Fatalf("AccessorMock.ForPulseNumber mock is already set by Set")
	}

	expectation := &AccessorMockForPulseNumberExpectation{
		mock:   mmForPulseNumber.mock,
		params: &AccessorMockForPulseNumberParams{ctx, p1},
	}
	mmForPulseNumber.expectations = append(mmForPulseNumber.expectations, expectation)
	return expectation
}

// Then sets up Accessor.ForPulseNumber return parameters for the expectation previously defined by the When method
func (e *AccessorMockForPulseNumberExpectation) Then(p2 insolar.Pulse, err error) *AccessorMock {
	e.results = &AccessorMockForPulseNumberResults{p2, err}
	return e.mock
}

// ForPulseNumber implements Accessor
func (mmForPulseNumber *AccessorMock) ForPulseNumber(ctx context.Context, p1 insolar.PulseNumber) (p2 insolar.Pulse, err error) {
	mm_atomic.AddUint64(&mmForPulseNumber.beforeForPulseNumberCounter, 1)
	defer mm_atomic.AddUint64(&mmForPulseNumber.afterForPulseNumberCounter, 1)

	if mmForPulseNumber.inspectFuncForPulseNumber != nil {
		mmForPulseNumber.inspectFuncForPulseNumber(ctx, p1)
	}

	params := &AccessorMockForPulseNumberParams{ctx, p1}

	// Record call args
	mmForPulseNumber.ForPulseNumberMock.mutex.Lock()
	mmForPulseNumber.ForPulseNumberMock.callArgs = append(mmForPulseNumber.ForPulseNumberMock.callArgs, params)
	mmForPulseNumber.ForPulseNumberMock.mutex.Unlock()

	for _, e := range mmForPulseNumber.ForPulseNumberMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p2, e.results.err
		}
	}

	if mmForPulseNumber.ForPulseNumberMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmForPulseNumber.ForPulseNumberMock.defaultExpectation.Counter, 1)
		want := mmForPulseNumber.ForPulseNumberMock.defaultExpectation.params
		got := AccessorMockForPulseNumberParams{ctx, p1}
		if want != nil && !minimock.Equal(*want, got) {
			mmForPulseNumber.t.Errorf("AccessorMock.ForPulseNumber got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmForPulseNumber.ForPulseNumberMock.defaultExpectation.results
		if results == nil {
			mmForPulseNumber.t.Fatal("No results are set for the AccessorMock.ForPulseNumber")
		}
		return (*results).p2, (*results).err
	}
	if mmForPulseNumber.funcForPulseNumber != nil {
		return mmForPulseNumber.funcForPulseNumber(ctx, p1)
	}
	mmForPulseNumber.t.Fatalf("Unexpected call to AccessorMock.ForPulseNumber. %v %v", ctx, p1)
	return
}

// ForPulseNumberAfterCounter returns a count of finished AccessorMock.ForPulseNumber invocations
func (mmForPulseNumber *AccessorMock) ForPulseNumberAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmForPulseNumber.afterForPulseNumberCounter)
}

// ForPulseNumberBeforeCounter returns a count of AccessorMock.ForPulseNumber invocations
func (mmForPulseNumber *AccessorMock) ForPulseNumberBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmForPulseNumber.beforeForPulseNumberCounter)
}

// Calls returns a list of arguments used in each call to AccessorMock.ForPulseNumber.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmForPulseNumber *mAccessorMockForPulseNumber) Calls() []*AccessorMockForPulseNumberParams {
	mmForPulseNumber.mutex.RLock()

	argCopy := make([]*AccessorMockForPulseNumberParams, len(mmForPulseNumber.callArgs))
	copy(argCopy, mmForPulseNumber.callArgs)

	mmForPulseNumber.mutex.RUnlock()

	return argCopy
}

// MinimockForPulseNumberDone returns true if the count of the ForPulseNumber invocations corresponds
// the number of defined expectations
func (m *AccessorMock) MinimockForPulseNumberDone() bool {
	for _, e := range m.ForPulseNumberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ForPulseNumberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterForPulseNumberCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcForPulseNumber != nil && mm_atomic.LoadUint64(&m.afterForPulseNumberCounter) < 1 {
		return false
	}
	return true
}

// MinimockForPulseNumberInspect logs each unmet expectation
func (m *AccessorMock) MinimockForPulseNumberInspect() {
	for _, e := range m.ForPulseNumberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AccessorMock.ForPulseNumber with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ForPulseNumberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterForPulseNumberCounter) < 1 {
		if m.ForPulseNumberMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AccessorMock.ForPulseNumber")
		} else {
			m.t.Errorf("Expected call to AccessorMock.ForPulseNumber with params: %#v", *m.ForPulseNumberMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcForPulseNumber != nil && mm_atomic.LoadUint64(&m.afterForPulseNumberCounter) < 1 {
		m.t.Error("Expected call to AccessorMock.ForPulseNumber")
	}
}

type mAccessorMockLatest struct {
	mock               *AccessorMock
	defaultExpectation *AccessorMockLatestExpectation
	expectations       []*AccessorMockLatestExpectation

	callArgs []*AccessorMockLatestParams
	mutex    sync.RWMutex
}

// AccessorMockLatestExpectation specifies expectation struct of the Accessor.Latest
type AccessorMockLatestExpectation struct {
	mock    *AccessorMock
	params  *AccessorMockLatestParams
	results *AccessorMockLatestResults
	Counter uint64
}

// AccessorMockLatestParams contains parameters of the Accessor.Latest
type AccessorMockLatestParams struct {
	ctx context.Context
}

// AccessorMockLatestResults contains results of the Accessor.Latest
type AccessorMockLatestResults struct {
	p1  insolar.Pulse
	err error
}

// Expect sets up expected params for Accessor.Latest
func (mmLatest *mAccessorMockLatest) Expect(ctx context.Context) *mAccessorMockLatest {
	if mmLatest.mock.funcLatest != nil {
		mmLatest.mock.t.Fatalf("AccessorMock.Latest mock is already set by Set")
	}

	if mmLatest.defaultExpectation == nil {
		mmLatest.defaultExpectation = &AccessorMockLatestExpectation{}
	}

	mmLatest.defaultExpectation.params = &AccessorMockLatestParams{ctx}
	for _, e := range mmLatest.expectations {
		if minimock.Equal(e.params, mmLatest.defaultExpectation.params) {
			mmLatest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLatest.defaultExpectation.params)
		}
	}

	return mmLatest
}

// Inspect accepts an inspector function that has same arguments as the Accessor.Latest
func (mmLatest *mAccessorMockLatest) Inspect(f func(ctx context.Context)) *mAccessorMockLatest {
	if mmLatest.mock.inspectFuncLatest != nil {
		mmLatest.mock.t.Fatalf("Inspect function is already set for AccessorMock.Latest")
	}

	mmLatest.mock.inspectFuncLatest = f

	return mmLatest
}

// Return sets up results that will be returned by Accessor.Latest
func (mmLatest *mAccessorMockLatest) Return(p1 insolar.Pulse, err error) *AccessorMock {
	if mmLatest.mock.funcLatest != nil {
		mmLatest.mock.t.Fatalf("AccessorMock.Latest mock is already set by Set")
	}

	if mmLatest.defaultExpectation == nil {
		mmLatest.defaultExpectation = &AccessorMockLatestExpectation{mock: mmLatest.mock}
	}
	mmLatest.defaultExpectation.results = &AccessorMockLatestResults{p1, err}
	return mmLatest.mock
}

//Set uses given function f to mock the Accessor.Latest method
func (mmLatest *mAccessorMockLatest) Set(f func(ctx context.Context) (p1 insolar.Pulse, err error)) *AccessorMock {
	if mmLatest.defaultExpectation != nil {
		mmLatest.mock.t.Fatalf("Default expectation is already set for the Accessor.Latest method")
	}

	if len(mmLatest.expectations) > 0 {
		mmLatest.mock.t.Fatalf("Some expectations are already set for the Accessor.Latest method")
	}

	mmLatest.mock.funcLatest = f
	return mmLatest.mock
}

// When sets expectation for the Accessor.Latest which will trigger the result defined by the following
// Then helper
func (mmLatest *mAccessorMockLatest) When(ctx context.Context) *AccessorMockLatestExpectation {
	if mmLatest.mock.funcLatest != nil {
		mmLatest.mock.t.Fatalf("AccessorMock.Latest mock is already set by Set")
	}

	expectation := &AccessorMockLatestExpectation{
		mock:   mmLatest.mock,
		params: &AccessorMockLatestParams{ctx},
	}
	mmLatest.expectations = append(mmLatest.expectations, expectation)
	return expectation
}

// Then sets up Accessor.Latest return parameters for the expectation previously defined by the When method
func (e *AccessorMockLatestExpectation) Then(p1 insolar.Pulse, err error) *AccessorMock {
	e.results = &AccessorMockLatestResults{p1, err}
	return e.mock
}

// Latest implements Accessor
func (mmLatest *AccessorMock) Latest(ctx context.Context) (p1 insolar.Pulse, err error) {
	mm_atomic.AddUint64(&mmLatest.beforeLatestCounter, 1)
	defer mm_atomic.AddUint64(&mmLatest.afterLatestCounter, 1)

	if mmLatest.inspectFuncLatest != nil {
		mmLatest.inspectFuncLatest(ctx)
	}

	params := &AccessorMockLatestParams{ctx}

	// Record call args
	mmLatest.LatestMock.mutex.Lock()
	mmLatest.LatestMock.callArgs = append(mmLatest.LatestMock.callArgs, params)
	mmLatest.LatestMock.mutex.Unlock()

	for _, e := range mmLatest.LatestMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmLatest.LatestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLatest.LatestMock.defaultExpectation.Counter, 1)
		want := mmLatest.LatestMock.defaultExpectation.params
		got := AccessorMockLatestParams{ctx}
		if want != nil && !minimock.Equal(*want, got) {
			mmLatest.t.Errorf("AccessorMock.Latest got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmLatest.LatestMock.defaultExpectation.results
		if results == nil {
			mmLatest.t.Fatal("No results are set for the AccessorMock.Latest")
		}
		return (*results).p1, (*results).err
	}
	if mmLatest.funcLatest != nil {
		return mmLatest.funcLatest(ctx)
	}
	mmLatest.t.Fatalf("Unexpected call to AccessorMock.Latest. %v", ctx)
	return
}

// LatestAfterCounter returns a count of finished AccessorMock.Latest invocations
func (mmLatest *AccessorMock) LatestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLatest.afterLatestCounter)
}

// LatestBeforeCounter returns a count of AccessorMock.Latest invocations
func (mmLatest *AccessorMock) LatestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLatest.beforeLatestCounter)
}

// Calls returns a list of arguments used in each call to AccessorMock.Latest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLatest *mAccessorMockLatest) Calls() []*AccessorMockLatestParams {
	mmLatest.mutex.RLock()

	argCopy := make([]*AccessorMockLatestParams, len(mmLatest.callArgs))
	copy(argCopy, mmLatest.callArgs)

	mmLatest.mutex.RUnlock()

	return argCopy
}

// MinimockLatestDone returns true if the count of the Latest invocations corresponds
// the number of defined expectations
func (m *AccessorMock) MinimockLatestDone() bool {
	for _, e := range m.LatestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LatestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLatestCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLatest != nil && mm_atomic.LoadUint64(&m.afterLatestCounter) < 1 {
		return false
	}
	return true
}

// MinimockLatestInspect logs each unmet expectation
func (m *AccessorMock) MinimockLatestInspect() {
	for _, e := range m.LatestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AccessorMock.Latest with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LatestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLatestCounter) < 1 {
		if m.LatestMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AccessorMock.Latest")
		} else {
			m.t.Errorf("Expected call to AccessorMock.Latest with params: %#v", *m.LatestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLatest != nil && mm_atomic.LoadUint64(&m.afterLatestCounter) < 1 {
		m.t.Error("Expected call to AccessorMock.Latest")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AccessorMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockForPulseNumberInspect()

		m.MinimockLatestInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AccessorMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AccessorMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockForPulseNumberDone() &&
		m.MinimockLatestDone()
}
