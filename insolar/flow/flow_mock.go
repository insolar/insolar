package flow

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// FlowMock implements Flow
type FlowMock struct {
	t minimock.Tester

	funcContinue          func(ctx context.Context)
	inspectFuncContinue   func(ctx context.Context)
	afterContinueCounter  uint64
	beforeContinueCounter uint64
	ContinueMock          mFlowMockContinue

	funcHandle          func(ctx context.Context, h1 Handle) (err error)
	inspectFuncHandle   func(ctx context.Context, h1 Handle)
	afterHandleCounter  uint64
	beforeHandleCounter uint64
	HandleMock          mFlowMockHandle

	funcMigrate          func(ctx context.Context, h1 Handle) (err error)
	inspectFuncMigrate   func(ctx context.Context, h1 Handle)
	afterMigrateCounter  uint64
	beforeMigrateCounter uint64
	MigrateMock          mFlowMockMigrate

	funcProcedure          func(ctx context.Context, proc Procedure, cancelable bool) (err error)
	inspectFuncProcedure   func(ctx context.Context, proc Procedure, cancelable bool)
	afterProcedureCounter  uint64
	beforeProcedureCounter uint64
	ProcedureMock          mFlowMockProcedure
}

// NewFlowMock returns a mock for Flow
func NewFlowMock(t minimock.Tester) *FlowMock {
	m := &FlowMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ContinueMock = mFlowMockContinue{mock: m}
	m.ContinueMock.callArgs = []*FlowMockContinueParams{}

	m.HandleMock = mFlowMockHandle{mock: m}
	m.HandleMock.callArgs = []*FlowMockHandleParams{}

	m.MigrateMock = mFlowMockMigrate{mock: m}
	m.MigrateMock.callArgs = []*FlowMockMigrateParams{}

	m.ProcedureMock = mFlowMockProcedure{mock: m}
	m.ProcedureMock.callArgs = []*FlowMockProcedureParams{}

	return m
}

type mFlowMockContinue struct {
	mock               *FlowMock
	defaultExpectation *FlowMockContinueExpectation
	expectations       []*FlowMockContinueExpectation

	callArgs []*FlowMockContinueParams
	mutex    sync.RWMutex
}

// FlowMockContinueExpectation specifies expectation struct of the Flow.Continue
type FlowMockContinueExpectation struct {
	mock   *FlowMock
	params *FlowMockContinueParams

	Counter uint64
}

// FlowMockContinueParams contains parameters of the Flow.Continue
type FlowMockContinueParams struct {
	ctx context.Context
}

// Expect sets up expected params for Flow.Continue
func (mmContinue *mFlowMockContinue) Expect(ctx context.Context) *mFlowMockContinue {
	if mmContinue.mock.funcContinue != nil {
		mmContinue.mock.t.Fatalf("FlowMock.Continue mock is already set by Set")
	}

	if mmContinue.defaultExpectation == nil {
		mmContinue.defaultExpectation = &FlowMockContinueExpectation{}
	}

	mmContinue.defaultExpectation.params = &FlowMockContinueParams{ctx}
	for _, e := range mmContinue.expectations {
		if minimock.Equal(e.params, mmContinue.defaultExpectation.params) {
			mmContinue.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmContinue.defaultExpectation.params)
		}
	}

	return mmContinue
}

// Inspect accepts an inspector function that has same arguments as the Flow.Continue
func (mmContinue *mFlowMockContinue) Inspect(f func(ctx context.Context)) *mFlowMockContinue {
	if mmContinue.mock.inspectFuncContinue != nil {
		mmContinue.mock.t.Fatalf("Inspect function is already set for FlowMock.Continue")
	}

	mmContinue.mock.inspectFuncContinue = f

	return mmContinue
}

// Return sets up results that will be returned by Flow.Continue
func (mmContinue *mFlowMockContinue) Return() *FlowMock {
	if mmContinue.mock.funcContinue != nil {
		mmContinue.mock.t.Fatalf("FlowMock.Continue mock is already set by Set")
	}

	if mmContinue.defaultExpectation == nil {
		mmContinue.defaultExpectation = &FlowMockContinueExpectation{mock: mmContinue.mock}
	}

	return mmContinue.mock
}

//Set uses given function f to mock the Flow.Continue method
func (mmContinue *mFlowMockContinue) Set(f func(ctx context.Context)) *FlowMock {
	if mmContinue.defaultExpectation != nil {
		mmContinue.mock.t.Fatalf("Default expectation is already set for the Flow.Continue method")
	}

	if len(mmContinue.expectations) > 0 {
		mmContinue.mock.t.Fatalf("Some expectations are already set for the Flow.Continue method")
	}

	mmContinue.mock.funcContinue = f
	return mmContinue.mock
}

// Continue implements Flow
func (mmContinue *FlowMock) Continue(ctx context.Context) {
	mm_atomic.AddUint64(&mmContinue.beforeContinueCounter, 1)
	defer mm_atomic.AddUint64(&mmContinue.afterContinueCounter, 1)

	if mmContinue.inspectFuncContinue != nil {
		mmContinue.inspectFuncContinue(ctx)
	}

	mm_params := &FlowMockContinueParams{ctx}

	// Record call args
	mmContinue.ContinueMock.mutex.Lock()
	mmContinue.ContinueMock.callArgs = append(mmContinue.ContinueMock.callArgs, mm_params)
	mmContinue.ContinueMock.mutex.Unlock()

	for _, e := range mmContinue.ContinueMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmContinue.ContinueMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmContinue.ContinueMock.defaultExpectation.Counter, 1)
		mm_want := mmContinue.ContinueMock.defaultExpectation.params
		mm_got := FlowMockContinueParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmContinue.t.Errorf("FlowMock.Continue got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmContinue.funcContinue != nil {
		mmContinue.funcContinue(ctx)
		return
	}
	mmContinue.t.Fatalf("Unexpected call to FlowMock.Continue. %v", ctx)

}

// ContinueAfterCounter returns a count of finished FlowMock.Continue invocations
func (mmContinue *FlowMock) ContinueAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContinue.afterContinueCounter)
}

// ContinueBeforeCounter returns a count of FlowMock.Continue invocations
func (mmContinue *FlowMock) ContinueBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContinue.beforeContinueCounter)
}

// Calls returns a list of arguments used in each call to FlowMock.Continue.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmContinue *mFlowMockContinue) Calls() []*FlowMockContinueParams {
	mmContinue.mutex.RLock()

	argCopy := make([]*FlowMockContinueParams, len(mmContinue.callArgs))
	copy(argCopy, mmContinue.callArgs)

	mmContinue.mutex.RUnlock()

	return argCopy
}

// MinimockContinueDone returns true if the count of the Continue invocations corresponds
// the number of defined expectations
func (m *FlowMock) MinimockContinueDone() bool {
	for _, e := range m.ContinueMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ContinueMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterContinueCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcContinue != nil && mm_atomic.LoadUint64(&m.afterContinueCounter) < 1 {
		return false
	}
	return true
}

// MinimockContinueInspect logs each unmet expectation
func (m *FlowMock) MinimockContinueInspect() {
	for _, e := range m.ContinueMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FlowMock.Continue with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ContinueMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterContinueCounter) < 1 {
		if m.ContinueMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FlowMock.Continue")
		} else {
			m.t.Errorf("Expected call to FlowMock.Continue with params: %#v", *m.ContinueMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcContinue != nil && mm_atomic.LoadUint64(&m.afterContinueCounter) < 1 {
		m.t.Error("Expected call to FlowMock.Continue")
	}
}

type mFlowMockHandle struct {
	mock               *FlowMock
	defaultExpectation *FlowMockHandleExpectation
	expectations       []*FlowMockHandleExpectation

	callArgs []*FlowMockHandleParams
	mutex    sync.RWMutex
}

// FlowMockHandleExpectation specifies expectation struct of the Flow.Handle
type FlowMockHandleExpectation struct {
	mock    *FlowMock
	params  *FlowMockHandleParams
	results *FlowMockHandleResults
	Counter uint64
}

// FlowMockHandleParams contains parameters of the Flow.Handle
type FlowMockHandleParams struct {
	ctx context.Context
	h1  Handle
}

// FlowMockHandleResults contains results of the Flow.Handle
type FlowMockHandleResults struct {
	err error
}

// Expect sets up expected params for Flow.Handle
func (mmHandle *mFlowMockHandle) Expect(ctx context.Context, h1 Handle) *mFlowMockHandle {
	if mmHandle.mock.funcHandle != nil {
		mmHandle.mock.t.Fatalf("FlowMock.Handle mock is already set by Set")
	}

	if mmHandle.defaultExpectation == nil {
		mmHandle.defaultExpectation = &FlowMockHandleExpectation{}
	}

	mmHandle.defaultExpectation.params = &FlowMockHandleParams{ctx, h1}
	for _, e := range mmHandle.expectations {
		if minimock.Equal(e.params, mmHandle.defaultExpectation.params) {
			mmHandle.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHandle.defaultExpectation.params)
		}
	}

	return mmHandle
}

// Inspect accepts an inspector function that has same arguments as the Flow.Handle
func (mmHandle *mFlowMockHandle) Inspect(f func(ctx context.Context, h1 Handle)) *mFlowMockHandle {
	if mmHandle.mock.inspectFuncHandle != nil {
		mmHandle.mock.t.Fatalf("Inspect function is already set for FlowMock.Handle")
	}

	mmHandle.mock.inspectFuncHandle = f

	return mmHandle
}

// Return sets up results that will be returned by Flow.Handle
func (mmHandle *mFlowMockHandle) Return(err error) *FlowMock {
	if mmHandle.mock.funcHandle != nil {
		mmHandle.mock.t.Fatalf("FlowMock.Handle mock is already set by Set")
	}

	if mmHandle.defaultExpectation == nil {
		mmHandle.defaultExpectation = &FlowMockHandleExpectation{mock: mmHandle.mock}
	}
	mmHandle.defaultExpectation.results = &FlowMockHandleResults{err}
	return mmHandle.mock
}

//Set uses given function f to mock the Flow.Handle method
func (mmHandle *mFlowMockHandle) Set(f func(ctx context.Context, h1 Handle) (err error)) *FlowMock {
	if mmHandle.defaultExpectation != nil {
		mmHandle.mock.t.Fatalf("Default expectation is already set for the Flow.Handle method")
	}

	if len(mmHandle.expectations) > 0 {
		mmHandle.mock.t.Fatalf("Some expectations are already set for the Flow.Handle method")
	}

	mmHandle.mock.funcHandle = f
	return mmHandle.mock
}

// When sets expectation for the Flow.Handle which will trigger the result defined by the following
// Then helper
func (mmHandle *mFlowMockHandle) When(ctx context.Context, h1 Handle) *FlowMockHandleExpectation {
	if mmHandle.mock.funcHandle != nil {
		mmHandle.mock.t.Fatalf("FlowMock.Handle mock is already set by Set")
	}

	expectation := &FlowMockHandleExpectation{
		mock:   mmHandle.mock,
		params: &FlowMockHandleParams{ctx, h1},
	}
	mmHandle.expectations = append(mmHandle.expectations, expectation)
	return expectation
}

// Then sets up Flow.Handle return parameters for the expectation previously defined by the When method
func (e *FlowMockHandleExpectation) Then(err error) *FlowMock {
	e.results = &FlowMockHandleResults{err}
	return e.mock
}

// Handle implements Flow
func (mmHandle *FlowMock) Handle(ctx context.Context, h1 Handle) (err error) {
	mm_atomic.AddUint64(&mmHandle.beforeHandleCounter, 1)
	defer mm_atomic.AddUint64(&mmHandle.afterHandleCounter, 1)

	if mmHandle.inspectFuncHandle != nil {
		mmHandle.inspectFuncHandle(ctx, h1)
	}

	mm_params := &FlowMockHandleParams{ctx, h1}

	// Record call args
	mmHandle.HandleMock.mutex.Lock()
	mmHandle.HandleMock.callArgs = append(mmHandle.HandleMock.callArgs, mm_params)
	mmHandle.HandleMock.mutex.Unlock()

	for _, e := range mmHandle.HandleMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmHandle.HandleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHandle.HandleMock.defaultExpectation.Counter, 1)
		mm_want := mmHandle.HandleMock.defaultExpectation.params
		mm_got := FlowMockHandleParams{ctx, h1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHandle.t.Errorf("FlowMock.Handle got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHandle.HandleMock.defaultExpectation.results
		if mm_results == nil {
			mmHandle.t.Fatal("No results are set for the FlowMock.Handle")
		}
		return (*mm_results).err
	}
	if mmHandle.funcHandle != nil {
		return mmHandle.funcHandle(ctx, h1)
	}
	mmHandle.t.Fatalf("Unexpected call to FlowMock.Handle. %v %v", ctx, h1)
	return
}

// HandleAfterCounter returns a count of finished FlowMock.Handle invocations
func (mmHandle *FlowMock) HandleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHandle.afterHandleCounter)
}

// HandleBeforeCounter returns a count of FlowMock.Handle invocations
func (mmHandle *FlowMock) HandleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHandle.beforeHandleCounter)
}

// Calls returns a list of arguments used in each call to FlowMock.Handle.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHandle *mFlowMockHandle) Calls() []*FlowMockHandleParams {
	mmHandle.mutex.RLock()

	argCopy := make([]*FlowMockHandleParams, len(mmHandle.callArgs))
	copy(argCopy, mmHandle.callArgs)

	mmHandle.mutex.RUnlock()

	return argCopy
}

// MinimockHandleDone returns true if the count of the Handle invocations corresponds
// the number of defined expectations
func (m *FlowMock) MinimockHandleDone() bool {
	for _, e := range m.HandleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HandleMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHandleCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHandle != nil && mm_atomic.LoadUint64(&m.afterHandleCounter) < 1 {
		return false
	}
	return true
}

// MinimockHandleInspect logs each unmet expectation
func (m *FlowMock) MinimockHandleInspect() {
	for _, e := range m.HandleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FlowMock.Handle with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HandleMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHandleCounter) < 1 {
		if m.HandleMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FlowMock.Handle")
		} else {
			m.t.Errorf("Expected call to FlowMock.Handle with params: %#v", *m.HandleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHandle != nil && mm_atomic.LoadUint64(&m.afterHandleCounter) < 1 {
		m.t.Error("Expected call to FlowMock.Handle")
	}
}

type mFlowMockMigrate struct {
	mock               *FlowMock
	defaultExpectation *FlowMockMigrateExpectation
	expectations       []*FlowMockMigrateExpectation

	callArgs []*FlowMockMigrateParams
	mutex    sync.RWMutex
}

// FlowMockMigrateExpectation specifies expectation struct of the Flow.Migrate
type FlowMockMigrateExpectation struct {
	mock    *FlowMock
	params  *FlowMockMigrateParams
	results *FlowMockMigrateResults
	Counter uint64
}

// FlowMockMigrateParams contains parameters of the Flow.Migrate
type FlowMockMigrateParams struct {
	ctx context.Context
	h1  Handle
}

// FlowMockMigrateResults contains results of the Flow.Migrate
type FlowMockMigrateResults struct {
	err error
}

// Expect sets up expected params for Flow.Migrate
func (mmMigrate *mFlowMockMigrate) Expect(ctx context.Context, h1 Handle) *mFlowMockMigrate {
	if mmMigrate.mock.funcMigrate != nil {
		mmMigrate.mock.t.Fatalf("FlowMock.Migrate mock is already set by Set")
	}

	if mmMigrate.defaultExpectation == nil {
		mmMigrate.defaultExpectation = &FlowMockMigrateExpectation{}
	}

	mmMigrate.defaultExpectation.params = &FlowMockMigrateParams{ctx, h1}
	for _, e := range mmMigrate.expectations {
		if minimock.Equal(e.params, mmMigrate.defaultExpectation.params) {
			mmMigrate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMigrate.defaultExpectation.params)
		}
	}

	return mmMigrate
}

// Inspect accepts an inspector function that has same arguments as the Flow.Migrate
func (mmMigrate *mFlowMockMigrate) Inspect(f func(ctx context.Context, h1 Handle)) *mFlowMockMigrate {
	if mmMigrate.mock.inspectFuncMigrate != nil {
		mmMigrate.mock.t.Fatalf("Inspect function is already set for FlowMock.Migrate")
	}

	mmMigrate.mock.inspectFuncMigrate = f

	return mmMigrate
}

// Return sets up results that will be returned by Flow.Migrate
func (mmMigrate *mFlowMockMigrate) Return(err error) *FlowMock {
	if mmMigrate.mock.funcMigrate != nil {
		mmMigrate.mock.t.Fatalf("FlowMock.Migrate mock is already set by Set")
	}

	if mmMigrate.defaultExpectation == nil {
		mmMigrate.defaultExpectation = &FlowMockMigrateExpectation{mock: mmMigrate.mock}
	}
	mmMigrate.defaultExpectation.results = &FlowMockMigrateResults{err}
	return mmMigrate.mock
}

//Set uses given function f to mock the Flow.Migrate method
func (mmMigrate *mFlowMockMigrate) Set(f func(ctx context.Context, h1 Handle) (err error)) *FlowMock {
	if mmMigrate.defaultExpectation != nil {
		mmMigrate.mock.t.Fatalf("Default expectation is already set for the Flow.Migrate method")
	}

	if len(mmMigrate.expectations) > 0 {
		mmMigrate.mock.t.Fatalf("Some expectations are already set for the Flow.Migrate method")
	}

	mmMigrate.mock.funcMigrate = f
	return mmMigrate.mock
}

// When sets expectation for the Flow.Migrate which will trigger the result defined by the following
// Then helper
func (mmMigrate *mFlowMockMigrate) When(ctx context.Context, h1 Handle) *FlowMockMigrateExpectation {
	if mmMigrate.mock.funcMigrate != nil {
		mmMigrate.mock.t.Fatalf("FlowMock.Migrate mock is already set by Set")
	}

	expectation := &FlowMockMigrateExpectation{
		mock:   mmMigrate.mock,
		params: &FlowMockMigrateParams{ctx, h1},
	}
	mmMigrate.expectations = append(mmMigrate.expectations, expectation)
	return expectation
}

// Then sets up Flow.Migrate return parameters for the expectation previously defined by the When method
func (e *FlowMockMigrateExpectation) Then(err error) *FlowMock {
	e.results = &FlowMockMigrateResults{err}
	return e.mock
}

// Migrate implements Flow
func (mmMigrate *FlowMock) Migrate(ctx context.Context, h1 Handle) (err error) {
	mm_atomic.AddUint64(&mmMigrate.beforeMigrateCounter, 1)
	defer mm_atomic.AddUint64(&mmMigrate.afterMigrateCounter, 1)

	if mmMigrate.inspectFuncMigrate != nil {
		mmMigrate.inspectFuncMigrate(ctx, h1)
	}

	mm_params := &FlowMockMigrateParams{ctx, h1}

	// Record call args
	mmMigrate.MigrateMock.mutex.Lock()
	mmMigrate.MigrateMock.callArgs = append(mmMigrate.MigrateMock.callArgs, mm_params)
	mmMigrate.MigrateMock.mutex.Unlock()

	for _, e := range mmMigrate.MigrateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmMigrate.MigrateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMigrate.MigrateMock.defaultExpectation.Counter, 1)
		mm_want := mmMigrate.MigrateMock.defaultExpectation.params
		mm_got := FlowMockMigrateParams{ctx, h1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMigrate.t.Errorf("FlowMock.Migrate got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMigrate.MigrateMock.defaultExpectation.results
		if mm_results == nil {
			mmMigrate.t.Fatal("No results are set for the FlowMock.Migrate")
		}
		return (*mm_results).err
	}
	if mmMigrate.funcMigrate != nil {
		return mmMigrate.funcMigrate(ctx, h1)
	}
	mmMigrate.t.Fatalf("Unexpected call to FlowMock.Migrate. %v %v", ctx, h1)
	return
}

// MigrateAfterCounter returns a count of finished FlowMock.Migrate invocations
func (mmMigrate *FlowMock) MigrateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMigrate.afterMigrateCounter)
}

// MigrateBeforeCounter returns a count of FlowMock.Migrate invocations
func (mmMigrate *FlowMock) MigrateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMigrate.beforeMigrateCounter)
}

// Calls returns a list of arguments used in each call to FlowMock.Migrate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMigrate *mFlowMockMigrate) Calls() []*FlowMockMigrateParams {
	mmMigrate.mutex.RLock()

	argCopy := make([]*FlowMockMigrateParams, len(mmMigrate.callArgs))
	copy(argCopy, mmMigrate.callArgs)

	mmMigrate.mutex.RUnlock()

	return argCopy
}

// MinimockMigrateDone returns true if the count of the Migrate invocations corresponds
// the number of defined expectations
func (m *FlowMock) MinimockMigrateDone() bool {
	for _, e := range m.MigrateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MigrateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMigrateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMigrate != nil && mm_atomic.LoadUint64(&m.afterMigrateCounter) < 1 {
		return false
	}
	return true
}

// MinimockMigrateInspect logs each unmet expectation
func (m *FlowMock) MinimockMigrateInspect() {
	for _, e := range m.MigrateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FlowMock.Migrate with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MigrateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMigrateCounter) < 1 {
		if m.MigrateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FlowMock.Migrate")
		} else {
			m.t.Errorf("Expected call to FlowMock.Migrate with params: %#v", *m.MigrateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMigrate != nil && mm_atomic.LoadUint64(&m.afterMigrateCounter) < 1 {
		m.t.Error("Expected call to FlowMock.Migrate")
	}
}

type mFlowMockProcedure struct {
	mock               *FlowMock
	defaultExpectation *FlowMockProcedureExpectation
	expectations       []*FlowMockProcedureExpectation

	callArgs []*FlowMockProcedureParams
	mutex    sync.RWMutex
}

// FlowMockProcedureExpectation specifies expectation struct of the Flow.Procedure
type FlowMockProcedureExpectation struct {
	mock    *FlowMock
	params  *FlowMockProcedureParams
	results *FlowMockProcedureResults
	Counter uint64
}

// FlowMockProcedureParams contains parameters of the Flow.Procedure
type FlowMockProcedureParams struct {
	ctx        context.Context
	proc       Procedure
	cancelable bool
}

// FlowMockProcedureResults contains results of the Flow.Procedure
type FlowMockProcedureResults struct {
	err error
}

// Expect sets up expected params for Flow.Procedure
func (mmProcedure *mFlowMockProcedure) Expect(ctx context.Context, proc Procedure, cancelable bool) *mFlowMockProcedure {
	if mmProcedure.mock.funcProcedure != nil {
		mmProcedure.mock.t.Fatalf("FlowMock.Procedure mock is already set by Set")
	}

	if mmProcedure.defaultExpectation == nil {
		mmProcedure.defaultExpectation = &FlowMockProcedureExpectation{}
	}

	mmProcedure.defaultExpectation.params = &FlowMockProcedureParams{ctx, proc, cancelable}
	for _, e := range mmProcedure.expectations {
		if minimock.Equal(e.params, mmProcedure.defaultExpectation.params) {
			mmProcedure.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmProcedure.defaultExpectation.params)
		}
	}

	return mmProcedure
}

// Inspect accepts an inspector function that has same arguments as the Flow.Procedure
func (mmProcedure *mFlowMockProcedure) Inspect(f func(ctx context.Context, proc Procedure, cancelable bool)) *mFlowMockProcedure {
	if mmProcedure.mock.inspectFuncProcedure != nil {
		mmProcedure.mock.t.Fatalf("Inspect function is already set for FlowMock.Procedure")
	}

	mmProcedure.mock.inspectFuncProcedure = f

	return mmProcedure
}

// Return sets up results that will be returned by Flow.Procedure
func (mmProcedure *mFlowMockProcedure) Return(err error) *FlowMock {
	if mmProcedure.mock.funcProcedure != nil {
		mmProcedure.mock.t.Fatalf("FlowMock.Procedure mock is already set by Set")
	}

	if mmProcedure.defaultExpectation == nil {
		mmProcedure.defaultExpectation = &FlowMockProcedureExpectation{mock: mmProcedure.mock}
	}
	mmProcedure.defaultExpectation.results = &FlowMockProcedureResults{err}
	return mmProcedure.mock
}

//Set uses given function f to mock the Flow.Procedure method
func (mmProcedure *mFlowMockProcedure) Set(f func(ctx context.Context, proc Procedure, cancelable bool) (err error)) *FlowMock {
	if mmProcedure.defaultExpectation != nil {
		mmProcedure.mock.t.Fatalf("Default expectation is already set for the Flow.Procedure method")
	}

	if len(mmProcedure.expectations) > 0 {
		mmProcedure.mock.t.Fatalf("Some expectations are already set for the Flow.Procedure method")
	}

	mmProcedure.mock.funcProcedure = f
	return mmProcedure.mock
}

// When sets expectation for the Flow.Procedure which will trigger the result defined by the following
// Then helper
func (mmProcedure *mFlowMockProcedure) When(ctx context.Context, proc Procedure, cancelable bool) *FlowMockProcedureExpectation {
	if mmProcedure.mock.funcProcedure != nil {
		mmProcedure.mock.t.Fatalf("FlowMock.Procedure mock is already set by Set")
	}

	expectation := &FlowMockProcedureExpectation{
		mock:   mmProcedure.mock,
		params: &FlowMockProcedureParams{ctx, proc, cancelable},
	}
	mmProcedure.expectations = append(mmProcedure.expectations, expectation)
	return expectation
}

// Then sets up Flow.Procedure return parameters for the expectation previously defined by the When method
func (e *FlowMockProcedureExpectation) Then(err error) *FlowMock {
	e.results = &FlowMockProcedureResults{err}
	return e.mock
}

// Procedure implements Flow
func (mmProcedure *FlowMock) Procedure(ctx context.Context, proc Procedure, cancelable bool) (err error) {
	mm_atomic.AddUint64(&mmProcedure.beforeProcedureCounter, 1)
	defer mm_atomic.AddUint64(&mmProcedure.afterProcedureCounter, 1)

	if mmProcedure.inspectFuncProcedure != nil {
		mmProcedure.inspectFuncProcedure(ctx, proc, cancelable)
	}

	mm_params := &FlowMockProcedureParams{ctx, proc, cancelable}

	// Record call args
	mmProcedure.ProcedureMock.mutex.Lock()
	mmProcedure.ProcedureMock.callArgs = append(mmProcedure.ProcedureMock.callArgs, mm_params)
	mmProcedure.ProcedureMock.mutex.Unlock()

	for _, e := range mmProcedure.ProcedureMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmProcedure.ProcedureMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmProcedure.ProcedureMock.defaultExpectation.Counter, 1)
		mm_want := mmProcedure.ProcedureMock.defaultExpectation.params
		mm_got := FlowMockProcedureParams{ctx, proc, cancelable}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmProcedure.t.Errorf("FlowMock.Procedure got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmProcedure.ProcedureMock.defaultExpectation.results
		if mm_results == nil {
			mmProcedure.t.Fatal("No results are set for the FlowMock.Procedure")
		}
		return (*mm_results).err
	}
	if mmProcedure.funcProcedure != nil {
		return mmProcedure.funcProcedure(ctx, proc, cancelable)
	}
	mmProcedure.t.Fatalf("Unexpected call to FlowMock.Procedure. %v %v %v", ctx, proc, cancelable)
	return
}

// ProcedureAfterCounter returns a count of finished FlowMock.Procedure invocations
func (mmProcedure *FlowMock) ProcedureAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcedure.afterProcedureCounter)
}

// ProcedureBeforeCounter returns a count of FlowMock.Procedure invocations
func (mmProcedure *FlowMock) ProcedureBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcedure.beforeProcedureCounter)
}

// Calls returns a list of arguments used in each call to FlowMock.Procedure.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmProcedure *mFlowMockProcedure) Calls() []*FlowMockProcedureParams {
	mmProcedure.mutex.RLock()

	argCopy := make([]*FlowMockProcedureParams, len(mmProcedure.callArgs))
	copy(argCopy, mmProcedure.callArgs)

	mmProcedure.mutex.RUnlock()

	return argCopy
}

// MinimockProcedureDone returns true if the count of the Procedure invocations corresponds
// the number of defined expectations
func (m *FlowMock) MinimockProcedureDone() bool {
	for _, e := range m.ProcedureMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ProcedureMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterProcedureCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProcedure != nil && mm_atomic.LoadUint64(&m.afterProcedureCounter) < 1 {
		return false
	}
	return true
}

// MinimockProcedureInspect logs each unmet expectation
func (m *FlowMock) MinimockProcedureInspect() {
	for _, e := range m.ProcedureMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FlowMock.Procedure with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ProcedureMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterProcedureCounter) < 1 {
		if m.ProcedureMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FlowMock.Procedure")
		} else {
			m.t.Errorf("Expected call to FlowMock.Procedure with params: %#v", *m.ProcedureMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProcedure != nil && mm_atomic.LoadUint64(&m.afterProcedureCounter) < 1 {
		m.t.Error("Expected call to FlowMock.Procedure")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *FlowMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockContinueInspect()

		m.MinimockHandleInspect()

		m.MinimockMigrateInspect()

		m.MinimockProcedureInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *FlowMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *FlowMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockContinueDone() &&
		m.MinimockHandleDone() &&
		m.MinimockMigrateDone() &&
		m.MinimockProcedureDone()
}
