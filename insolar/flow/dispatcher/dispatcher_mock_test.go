package dispatcher

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/ThreeDotsLabs/watermill/message"
	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/insolar"
)

// DispatcherMock implements Dispatcher
type DispatcherMock struct {
	t minimock.Tester

	funcBeginPulse          func(ctx context.Context, pulse insolar.Pulse)
	inspectFuncBeginPulse   func(ctx context.Context, pulse insolar.Pulse)
	afterBeginPulseCounter  uint64
	beforeBeginPulseCounter uint64
	BeginPulseMock          mDispatcherMockBeginPulse

	funcClosePulse          func(ctx context.Context, pulse insolar.Pulse)
	inspectFuncClosePulse   func(ctx context.Context, pulse insolar.Pulse)
	afterClosePulseCounter  uint64
	beforeClosePulseCounter uint64
	ClosePulseMock          mDispatcherMockClosePulse

	funcProcess          func(msg *message.Message) (err error)
	inspectFuncProcess   func(msg *message.Message)
	afterProcessCounter  uint64
	beforeProcessCounter uint64
	ProcessMock          mDispatcherMockProcess
}

// NewDispatcherMock returns a mock for Dispatcher
func NewDispatcherMock(t minimock.Tester) *DispatcherMock {
	m := &DispatcherMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BeginPulseMock = mDispatcherMockBeginPulse{mock: m}
	m.BeginPulseMock.callArgs = []*DispatcherMockBeginPulseParams{}

	m.ClosePulseMock = mDispatcherMockClosePulse{mock: m}
	m.ClosePulseMock.callArgs = []*DispatcherMockClosePulseParams{}

	m.ProcessMock = mDispatcherMockProcess{mock: m}
	m.ProcessMock.callArgs = []*DispatcherMockProcessParams{}

	return m
}

type mDispatcherMockBeginPulse struct {
	mock               *DispatcherMock
	defaultExpectation *DispatcherMockBeginPulseExpectation
	expectations       []*DispatcherMockBeginPulseExpectation

	callArgs []*DispatcherMockBeginPulseParams
	mutex    sync.RWMutex
}

// DispatcherMockBeginPulseExpectation specifies expectation struct of the Dispatcher.BeginPulse
type DispatcherMockBeginPulseExpectation struct {
	mock   *DispatcherMock
	params *DispatcherMockBeginPulseParams

	Counter uint64
}

// DispatcherMockBeginPulseParams contains parameters of the Dispatcher.BeginPulse
type DispatcherMockBeginPulseParams struct {
	ctx   context.Context
	pulse insolar.Pulse
}

// Expect sets up expected params for Dispatcher.BeginPulse
func (mmBeginPulse *mDispatcherMockBeginPulse) Expect(ctx context.Context, pulse insolar.Pulse) *mDispatcherMockBeginPulse {
	if mmBeginPulse.mock.funcBeginPulse != nil {
		mmBeginPulse.mock.t.Fatalf("DispatcherMock.BeginPulse mock is already set by Set")
	}

	if mmBeginPulse.defaultExpectation == nil {
		mmBeginPulse.defaultExpectation = &DispatcherMockBeginPulseExpectation{}
	}

	mmBeginPulse.defaultExpectation.params = &DispatcherMockBeginPulseParams{ctx, pulse}
	for _, e := range mmBeginPulse.expectations {
		if minimock.Equal(e.params, mmBeginPulse.defaultExpectation.params) {
			mmBeginPulse.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBeginPulse.defaultExpectation.params)
		}
	}

	return mmBeginPulse
}

// Inspect accepts an inspector function that has same arguments as the Dispatcher.BeginPulse
func (mmBeginPulse *mDispatcherMockBeginPulse) Inspect(f func(ctx context.Context, pulse insolar.Pulse)) *mDispatcherMockBeginPulse {
	if mmBeginPulse.mock.inspectFuncBeginPulse != nil {
		mmBeginPulse.mock.t.Fatalf("Inspect function is already set for DispatcherMock.BeginPulse")
	}

	mmBeginPulse.mock.inspectFuncBeginPulse = f

	return mmBeginPulse
}

// Return sets up results that will be returned by Dispatcher.BeginPulse
func (mmBeginPulse *mDispatcherMockBeginPulse) Return() *DispatcherMock {
	if mmBeginPulse.mock.funcBeginPulse != nil {
		mmBeginPulse.mock.t.Fatalf("DispatcherMock.BeginPulse mock is already set by Set")
	}

	if mmBeginPulse.defaultExpectation == nil {
		mmBeginPulse.defaultExpectation = &DispatcherMockBeginPulseExpectation{mock: mmBeginPulse.mock}
	}

	return mmBeginPulse.mock
}

//Set uses given function f to mock the Dispatcher.BeginPulse method
func (mmBeginPulse *mDispatcherMockBeginPulse) Set(f func(ctx context.Context, pulse insolar.Pulse)) *DispatcherMock {
	if mmBeginPulse.defaultExpectation != nil {
		mmBeginPulse.mock.t.Fatalf("Default expectation is already set for the Dispatcher.BeginPulse method")
	}

	if len(mmBeginPulse.expectations) > 0 {
		mmBeginPulse.mock.t.Fatalf("Some expectations are already set for the Dispatcher.BeginPulse method")
	}

	mmBeginPulse.mock.funcBeginPulse = f
	return mmBeginPulse.mock
}

// BeginPulse implements Dispatcher
func (mmBeginPulse *DispatcherMock) BeginPulse(ctx context.Context, pulse insolar.Pulse) {
	mm_atomic.AddUint64(&mmBeginPulse.beforeBeginPulseCounter, 1)
	defer mm_atomic.AddUint64(&mmBeginPulse.afterBeginPulseCounter, 1)

	if mmBeginPulse.inspectFuncBeginPulse != nil {
		mmBeginPulse.inspectFuncBeginPulse(ctx, pulse)
	}

	params := &DispatcherMockBeginPulseParams{ctx, pulse}

	// Record call args
	mmBeginPulse.BeginPulseMock.mutex.Lock()
	mmBeginPulse.BeginPulseMock.callArgs = append(mmBeginPulse.BeginPulseMock.callArgs, params)
	mmBeginPulse.BeginPulseMock.mutex.Unlock()

	for _, e := range mmBeginPulse.BeginPulseMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmBeginPulse.BeginPulseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBeginPulse.BeginPulseMock.defaultExpectation.Counter, 1)
		want := mmBeginPulse.BeginPulseMock.defaultExpectation.params
		got := DispatcherMockBeginPulseParams{ctx, pulse}
		if want != nil && !minimock.Equal(*want, got) {
			mmBeginPulse.t.Errorf("DispatcherMock.BeginPulse got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmBeginPulse.funcBeginPulse != nil {
		mmBeginPulse.funcBeginPulse(ctx, pulse)
		return
	}
	mmBeginPulse.t.Fatalf("Unexpected call to DispatcherMock.BeginPulse. %v %v", ctx, pulse)

}

// BeginPulseAfterCounter returns a count of finished DispatcherMock.BeginPulse invocations
func (mmBeginPulse *DispatcherMock) BeginPulseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBeginPulse.afterBeginPulseCounter)
}

// BeginPulseBeforeCounter returns a count of DispatcherMock.BeginPulse invocations
func (mmBeginPulse *DispatcherMock) BeginPulseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBeginPulse.beforeBeginPulseCounter)
}

// Calls returns a list of arguments used in each call to DispatcherMock.BeginPulse.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBeginPulse *mDispatcherMockBeginPulse) Calls() []*DispatcherMockBeginPulseParams {
	mmBeginPulse.mutex.RLock()

	argCopy := make([]*DispatcherMockBeginPulseParams, len(mmBeginPulse.callArgs))
	copy(argCopy, mmBeginPulse.callArgs)

	mmBeginPulse.mutex.RUnlock()

	return argCopy
}

// MinimockBeginPulseDone returns true if the count of the BeginPulse invocations corresponds
// the number of defined expectations
func (m *DispatcherMock) MinimockBeginPulseDone() bool {
	for _, e := range m.BeginPulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BeginPulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBeginPulseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBeginPulse != nil && mm_atomic.LoadUint64(&m.afterBeginPulseCounter) < 1 {
		return false
	}
	return true
}

// MinimockBeginPulseInspect logs each unmet expectation
func (m *DispatcherMock) MinimockBeginPulseInspect() {
	for _, e := range m.BeginPulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DispatcherMock.BeginPulse with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BeginPulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBeginPulseCounter) < 1 {
		if m.BeginPulseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DispatcherMock.BeginPulse")
		} else {
			m.t.Errorf("Expected call to DispatcherMock.BeginPulse with params: %#v", *m.BeginPulseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBeginPulse != nil && mm_atomic.LoadUint64(&m.afterBeginPulseCounter) < 1 {
		m.t.Error("Expected call to DispatcherMock.BeginPulse")
	}
}

type mDispatcherMockClosePulse struct {
	mock               *DispatcherMock
	defaultExpectation *DispatcherMockClosePulseExpectation
	expectations       []*DispatcherMockClosePulseExpectation

	callArgs []*DispatcherMockClosePulseParams
	mutex    sync.RWMutex
}

// DispatcherMockClosePulseExpectation specifies expectation struct of the Dispatcher.ClosePulse
type DispatcherMockClosePulseExpectation struct {
	mock   *DispatcherMock
	params *DispatcherMockClosePulseParams

	Counter uint64
}

// DispatcherMockClosePulseParams contains parameters of the Dispatcher.ClosePulse
type DispatcherMockClosePulseParams struct {
	ctx   context.Context
	pulse insolar.Pulse
}

// Expect sets up expected params for Dispatcher.ClosePulse
func (mmClosePulse *mDispatcherMockClosePulse) Expect(ctx context.Context, pulse insolar.Pulse) *mDispatcherMockClosePulse {
	if mmClosePulse.mock.funcClosePulse != nil {
		mmClosePulse.mock.t.Fatalf("DispatcherMock.ClosePulse mock is already set by Set")
	}

	if mmClosePulse.defaultExpectation == nil {
		mmClosePulse.defaultExpectation = &DispatcherMockClosePulseExpectation{}
	}

	mmClosePulse.defaultExpectation.params = &DispatcherMockClosePulseParams{ctx, pulse}
	for _, e := range mmClosePulse.expectations {
		if minimock.Equal(e.params, mmClosePulse.defaultExpectation.params) {
			mmClosePulse.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmClosePulse.defaultExpectation.params)
		}
	}

	return mmClosePulse
}

// Inspect accepts an inspector function that has same arguments as the Dispatcher.ClosePulse
func (mmClosePulse *mDispatcherMockClosePulse) Inspect(f func(ctx context.Context, pulse insolar.Pulse)) *mDispatcherMockClosePulse {
	if mmClosePulse.mock.inspectFuncClosePulse != nil {
		mmClosePulse.mock.t.Fatalf("Inspect function is already set for DispatcherMock.ClosePulse")
	}

	mmClosePulse.mock.inspectFuncClosePulse = f

	return mmClosePulse
}

// Return sets up results that will be returned by Dispatcher.ClosePulse
func (mmClosePulse *mDispatcherMockClosePulse) Return() *DispatcherMock {
	if mmClosePulse.mock.funcClosePulse != nil {
		mmClosePulse.mock.t.Fatalf("DispatcherMock.ClosePulse mock is already set by Set")
	}

	if mmClosePulse.defaultExpectation == nil {
		mmClosePulse.defaultExpectation = &DispatcherMockClosePulseExpectation{mock: mmClosePulse.mock}
	}

	return mmClosePulse.mock
}

//Set uses given function f to mock the Dispatcher.ClosePulse method
func (mmClosePulse *mDispatcherMockClosePulse) Set(f func(ctx context.Context, pulse insolar.Pulse)) *DispatcherMock {
	if mmClosePulse.defaultExpectation != nil {
		mmClosePulse.mock.t.Fatalf("Default expectation is already set for the Dispatcher.ClosePulse method")
	}

	if len(mmClosePulse.expectations) > 0 {
		mmClosePulse.mock.t.Fatalf("Some expectations are already set for the Dispatcher.ClosePulse method")
	}

	mmClosePulse.mock.funcClosePulse = f
	return mmClosePulse.mock
}

// ClosePulse implements Dispatcher
func (mmClosePulse *DispatcherMock) ClosePulse(ctx context.Context, pulse insolar.Pulse) {
	mm_atomic.AddUint64(&mmClosePulse.beforeClosePulseCounter, 1)
	defer mm_atomic.AddUint64(&mmClosePulse.afterClosePulseCounter, 1)

	if mmClosePulse.inspectFuncClosePulse != nil {
		mmClosePulse.inspectFuncClosePulse(ctx, pulse)
	}

	params := &DispatcherMockClosePulseParams{ctx, pulse}

	// Record call args
	mmClosePulse.ClosePulseMock.mutex.Lock()
	mmClosePulse.ClosePulseMock.callArgs = append(mmClosePulse.ClosePulseMock.callArgs, params)
	mmClosePulse.ClosePulseMock.mutex.Unlock()

	for _, e := range mmClosePulse.ClosePulseMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmClosePulse.ClosePulseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClosePulse.ClosePulseMock.defaultExpectation.Counter, 1)
		want := mmClosePulse.ClosePulseMock.defaultExpectation.params
		got := DispatcherMockClosePulseParams{ctx, pulse}
		if want != nil && !minimock.Equal(*want, got) {
			mmClosePulse.t.Errorf("DispatcherMock.ClosePulse got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmClosePulse.funcClosePulse != nil {
		mmClosePulse.funcClosePulse(ctx, pulse)
		return
	}
	mmClosePulse.t.Fatalf("Unexpected call to DispatcherMock.ClosePulse. %v %v", ctx, pulse)

}

// ClosePulseAfterCounter returns a count of finished DispatcherMock.ClosePulse invocations
func (mmClosePulse *DispatcherMock) ClosePulseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClosePulse.afterClosePulseCounter)
}

// ClosePulseBeforeCounter returns a count of DispatcherMock.ClosePulse invocations
func (mmClosePulse *DispatcherMock) ClosePulseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClosePulse.beforeClosePulseCounter)
}

// Calls returns a list of arguments used in each call to DispatcherMock.ClosePulse.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmClosePulse *mDispatcherMockClosePulse) Calls() []*DispatcherMockClosePulseParams {
	mmClosePulse.mutex.RLock()

	argCopy := make([]*DispatcherMockClosePulseParams, len(mmClosePulse.callArgs))
	copy(argCopy, mmClosePulse.callArgs)

	mmClosePulse.mutex.RUnlock()

	return argCopy
}

// MinimockClosePulseDone returns true if the count of the ClosePulse invocations corresponds
// the number of defined expectations
func (m *DispatcherMock) MinimockClosePulseDone() bool {
	for _, e := range m.ClosePulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ClosePulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterClosePulseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClosePulse != nil && mm_atomic.LoadUint64(&m.afterClosePulseCounter) < 1 {
		return false
	}
	return true
}

// MinimockClosePulseInspect logs each unmet expectation
func (m *DispatcherMock) MinimockClosePulseInspect() {
	for _, e := range m.ClosePulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DispatcherMock.ClosePulse with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ClosePulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterClosePulseCounter) < 1 {
		if m.ClosePulseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DispatcherMock.ClosePulse")
		} else {
			m.t.Errorf("Expected call to DispatcherMock.ClosePulse with params: %#v", *m.ClosePulseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClosePulse != nil && mm_atomic.LoadUint64(&m.afterClosePulseCounter) < 1 {
		m.t.Error("Expected call to DispatcherMock.ClosePulse")
	}
}

type mDispatcherMockProcess struct {
	mock               *DispatcherMock
	defaultExpectation *DispatcherMockProcessExpectation
	expectations       []*DispatcherMockProcessExpectation

	callArgs []*DispatcherMockProcessParams
	mutex    sync.RWMutex
}

// DispatcherMockProcessExpectation specifies expectation struct of the Dispatcher.Process
type DispatcherMockProcessExpectation struct {
	mock    *DispatcherMock
	params  *DispatcherMockProcessParams
	results *DispatcherMockProcessResults
	Counter uint64
}

// DispatcherMockProcessParams contains parameters of the Dispatcher.Process
type DispatcherMockProcessParams struct {
	msg *message.Message
}

// DispatcherMockProcessResults contains results of the Dispatcher.Process
type DispatcherMockProcessResults struct {
	err error
}

// Expect sets up expected params for Dispatcher.Process
func (mmProcess *mDispatcherMockProcess) Expect(msg *message.Message) *mDispatcherMockProcess {
	if mmProcess.mock.funcProcess != nil {
		mmProcess.mock.t.Fatalf("DispatcherMock.Process mock is already set by Set")
	}

	if mmProcess.defaultExpectation == nil {
		mmProcess.defaultExpectation = &DispatcherMockProcessExpectation{}
	}

	mmProcess.defaultExpectation.params = &DispatcherMockProcessParams{msg}
	for _, e := range mmProcess.expectations {
		if minimock.Equal(e.params, mmProcess.defaultExpectation.params) {
			mmProcess.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmProcess.defaultExpectation.params)
		}
	}

	return mmProcess
}

// Inspect accepts an inspector function that has same arguments as the Dispatcher.Process
func (mmProcess *mDispatcherMockProcess) Inspect(f func(msg *message.Message)) *mDispatcherMockProcess {
	if mmProcess.mock.inspectFuncProcess != nil {
		mmProcess.mock.t.Fatalf("Inspect function is already set for DispatcherMock.Process")
	}

	mmProcess.mock.inspectFuncProcess = f

	return mmProcess
}

// Return sets up results that will be returned by Dispatcher.Process
func (mmProcess *mDispatcherMockProcess) Return(err error) *DispatcherMock {
	if mmProcess.mock.funcProcess != nil {
		mmProcess.mock.t.Fatalf("DispatcherMock.Process mock is already set by Set")
	}

	if mmProcess.defaultExpectation == nil {
		mmProcess.defaultExpectation = &DispatcherMockProcessExpectation{mock: mmProcess.mock}
	}
	mmProcess.defaultExpectation.results = &DispatcherMockProcessResults{err}
	return mmProcess.mock
}

//Set uses given function f to mock the Dispatcher.Process method
func (mmProcess *mDispatcherMockProcess) Set(f func(msg *message.Message) (err error)) *DispatcherMock {
	if mmProcess.defaultExpectation != nil {
		mmProcess.mock.t.Fatalf("Default expectation is already set for the Dispatcher.Process method")
	}

	if len(mmProcess.expectations) > 0 {
		mmProcess.mock.t.Fatalf("Some expectations are already set for the Dispatcher.Process method")
	}

	mmProcess.mock.funcProcess = f
	return mmProcess.mock
}

// When sets expectation for the Dispatcher.Process which will trigger the result defined by the following
// Then helper
func (mmProcess *mDispatcherMockProcess) When(msg *message.Message) *DispatcherMockProcessExpectation {
	if mmProcess.mock.funcProcess != nil {
		mmProcess.mock.t.Fatalf("DispatcherMock.Process mock is already set by Set")
	}

	expectation := &DispatcherMockProcessExpectation{
		mock:   mmProcess.mock,
		params: &DispatcherMockProcessParams{msg},
	}
	mmProcess.expectations = append(mmProcess.expectations, expectation)
	return expectation
}

// Then sets up Dispatcher.Process return parameters for the expectation previously defined by the When method
func (e *DispatcherMockProcessExpectation) Then(err error) *DispatcherMock {
	e.results = &DispatcherMockProcessResults{err}
	return e.mock
}

// Process implements Dispatcher
func (mmProcess *DispatcherMock) Process(msg *message.Message) (err error) {
	mm_atomic.AddUint64(&mmProcess.beforeProcessCounter, 1)
	defer mm_atomic.AddUint64(&mmProcess.afterProcessCounter, 1)

	if mmProcess.inspectFuncProcess != nil {
		mmProcess.inspectFuncProcess(msg)
	}

	params := &DispatcherMockProcessParams{msg}

	// Record call args
	mmProcess.ProcessMock.mutex.Lock()
	mmProcess.ProcessMock.callArgs = append(mmProcess.ProcessMock.callArgs, params)
	mmProcess.ProcessMock.mutex.Unlock()

	for _, e := range mmProcess.ProcessMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmProcess.ProcessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmProcess.ProcessMock.defaultExpectation.Counter, 1)
		want := mmProcess.ProcessMock.defaultExpectation.params
		got := DispatcherMockProcessParams{msg}
		if want != nil && !minimock.Equal(*want, got) {
			mmProcess.t.Errorf("DispatcherMock.Process got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmProcess.ProcessMock.defaultExpectation.results
		if results == nil {
			mmProcess.t.Fatal("No results are set for the DispatcherMock.Process")
		}
		return (*results).err
	}
	if mmProcess.funcProcess != nil {
		return mmProcess.funcProcess(msg)
	}
	mmProcess.t.Fatalf("Unexpected call to DispatcherMock.Process. %v", msg)
	return
}

// ProcessAfterCounter returns a count of finished DispatcherMock.Process invocations
func (mmProcess *DispatcherMock) ProcessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcess.afterProcessCounter)
}

// ProcessBeforeCounter returns a count of DispatcherMock.Process invocations
func (mmProcess *DispatcherMock) ProcessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcess.beforeProcessCounter)
}

// Calls returns a list of arguments used in each call to DispatcherMock.Process.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmProcess *mDispatcherMockProcess) Calls() []*DispatcherMockProcessParams {
	mmProcess.mutex.RLock()

	argCopy := make([]*DispatcherMockProcessParams, len(mmProcess.callArgs))
	copy(argCopy, mmProcess.callArgs)

	mmProcess.mutex.RUnlock()

	return argCopy
}

// MinimockProcessDone returns true if the count of the Process invocations corresponds
// the number of defined expectations
func (m *DispatcherMock) MinimockProcessDone() bool {
	for _, e := range m.ProcessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ProcessMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterProcessCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProcess != nil && mm_atomic.LoadUint64(&m.afterProcessCounter) < 1 {
		return false
	}
	return true
}

// MinimockProcessInspect logs each unmet expectation
func (m *DispatcherMock) MinimockProcessInspect() {
	for _, e := range m.ProcessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DispatcherMock.Process with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ProcessMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterProcessCounter) < 1 {
		if m.ProcessMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DispatcherMock.Process")
		} else {
			m.t.Errorf("Expected call to DispatcherMock.Process with params: %#v", *m.ProcessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProcess != nil && mm_atomic.LoadUint64(&m.afterProcessCounter) < 1 {
		m.t.Error("Expected call to DispatcherMock.Process")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *DispatcherMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockBeginPulseInspect()

		m.MinimockClosePulseInspect()

		m.MinimockProcessInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *DispatcherMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *DispatcherMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBeginPulseDone() &&
		m.MinimockClosePulseDone() &&
		m.MinimockProcessDone()
}
