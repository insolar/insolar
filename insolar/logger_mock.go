package insolar

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
)

// LoggerMock implements Logger
type LoggerMock struct {
	t minimock.Tester

	funcDebug          func(p1 ...interface{})
	inspectFuncDebug   func(p1 ...interface{})
	afterDebugCounter  uint64
	beforeDebugCounter uint64
	DebugMock          mLoggerMockDebug

	funcDebugf          func(s1 string, p1 ...interface{})
	inspectFuncDebugf   func(s1 string, p1 ...interface{})
	afterDebugfCounter  uint64
	beforeDebugfCounter uint64
	DebugfMock          mLoggerMockDebugf

	funcError          func(p1 ...interface{})
	inspectFuncError   func(p1 ...interface{})
	afterErrorCounter  uint64
	beforeErrorCounter uint64
	ErrorMock          mLoggerMockError

	funcErrorf          func(s1 string, p1 ...interface{})
	inspectFuncErrorf   func(s1 string, p1 ...interface{})
	afterErrorfCounter  uint64
	beforeErrorfCounter uint64
	ErrorfMock          mLoggerMockErrorf

	funcFatal          func(p1 ...interface{})
	inspectFuncFatal   func(p1 ...interface{})
	afterFatalCounter  uint64
	beforeFatalCounter uint64
	FatalMock          mLoggerMockFatal

	funcFatalf          func(s1 string, p1 ...interface{})
	inspectFuncFatalf   func(s1 string, p1 ...interface{})
	afterFatalfCounter  uint64
	beforeFatalfCounter uint64
	FatalfMock          mLoggerMockFatalf

	funcInfo          func(p1 ...interface{})
	inspectFuncInfo   func(p1 ...interface{})
	afterInfoCounter  uint64
	beforeInfoCounter uint64
	InfoMock          mLoggerMockInfo

	funcInfof          func(s1 string, p1 ...interface{})
	inspectFuncInfof   func(s1 string, p1 ...interface{})
	afterInfofCounter  uint64
	beforeInfofCounter uint64
	InfofMock          mLoggerMockInfof

	funcIs          func(level LogLevel) (b1 bool)
	inspectFuncIs   func(level LogLevel)
	afterIsCounter  uint64
	beforeIsCounter uint64
	IsMock          mLoggerMockIs

	funcPanic          func(p1 ...interface{})
	inspectFuncPanic   func(p1 ...interface{})
	afterPanicCounter  uint64
	beforePanicCounter uint64
	PanicMock          mLoggerMockPanic

	funcPanicf          func(s1 string, p1 ...interface{})
	inspectFuncPanicf   func(s1 string, p1 ...interface{})
	afterPanicfCounter  uint64
	beforePanicfCounter uint64
	PanicfMock          mLoggerMockPanicf

	funcWarn          func(p1 ...interface{})
	inspectFuncWarn   func(p1 ...interface{})
	afterWarnCounter  uint64
	beforeWarnCounter uint64
	WarnMock          mLoggerMockWarn

	funcWarnf          func(s1 string, p1 ...interface{})
	inspectFuncWarnf   func(s1 string, p1 ...interface{})
	afterWarnfCounter  uint64
	beforeWarnfCounter uint64
	WarnfMock          mLoggerMockWarnf

	funcWithCaller          func(flag bool) (l1 Logger)
	inspectFuncWithCaller   func(flag bool)
	afterWithCallerCounter  uint64
	beforeWithCallerCounter uint64
	WithCallerMock          mLoggerMockWithCaller

	funcWithField          func(s1 string, p1 interface{}) (l1 Logger)
	inspectFuncWithField   func(s1 string, p1 interface{})
	afterWithFieldCounter  uint64
	beforeWithFieldCounter uint64
	WithFieldMock          mLoggerMockWithField

	funcWithFields          func(m1 map[string]interface{}) (l1 Logger)
	inspectFuncWithFields   func(m1 map[string]interface{})
	afterWithFieldsCounter  uint64
	beforeWithFieldsCounter uint64
	WithFieldsMock          mLoggerMockWithFields

	funcWithFormat          func(format LogFormat) (l1 Logger, err error)
	inspectFuncWithFormat   func(format LogFormat)
	afterWithFormatCounter  uint64
	beforeWithFormatCounter uint64
	WithFormatMock          mLoggerMockWithFormat

	funcWithFuncName          func(flag bool) (l1 Logger)
	inspectFuncWithFuncName   func(flag bool)
	afterWithFuncNameCounter  uint64
	beforeWithFuncNameCounter uint64
	WithFuncNameMock          mLoggerMockWithFuncName

	funcWithLevel          func(s1 string) (l1 Logger, err error)
	inspectFuncWithLevel   func(s1 string)
	afterWithLevelCounter  uint64
	beforeWithLevelCounter uint64
	WithLevelMock          mLoggerMockWithLevel

	funcWithLevelNumber          func(level LogLevel) (l1 Logger, err error)
	inspectFuncWithLevelNumber   func(level LogLevel)
	afterWithLevelNumberCounter  uint64
	beforeWithLevelNumberCounter uint64
	WithLevelNumberMock          mLoggerMockWithLevelNumber

	funcWithOutput          func(w io.Writer) (l1 Logger)
	inspectFuncWithOutput   func(w io.Writer)
	afterWithOutputCounter  uint64
	beforeWithOutputCounter uint64
	WithOutputMock          mLoggerMockWithOutput

	funcWithSkipFrameCount          func(delta int) (l1 Logger)
	inspectFuncWithSkipFrameCount   func(delta int)
	afterWithSkipFrameCountCounter  uint64
	beforeWithSkipFrameCountCounter uint64
	WithSkipFrameCountMock          mLoggerMockWithSkipFrameCount
}

// NewLoggerMock returns a mock for Logger
func NewLoggerMock(t minimock.Tester) *LoggerMock {
	m := &LoggerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DebugMock = mLoggerMockDebug{mock: m}
	m.DebugMock.callArgs = []*LoggerMockDebugParams{}

	m.DebugfMock = mLoggerMockDebugf{mock: m}
	m.DebugfMock.callArgs = []*LoggerMockDebugfParams{}

	m.ErrorMock = mLoggerMockError{mock: m}
	m.ErrorMock.callArgs = []*LoggerMockErrorParams{}

	m.ErrorfMock = mLoggerMockErrorf{mock: m}
	m.ErrorfMock.callArgs = []*LoggerMockErrorfParams{}

	m.FatalMock = mLoggerMockFatal{mock: m}
	m.FatalMock.callArgs = []*LoggerMockFatalParams{}

	m.FatalfMock = mLoggerMockFatalf{mock: m}
	m.FatalfMock.callArgs = []*LoggerMockFatalfParams{}

	m.InfoMock = mLoggerMockInfo{mock: m}
	m.InfoMock.callArgs = []*LoggerMockInfoParams{}

	m.InfofMock = mLoggerMockInfof{mock: m}
	m.InfofMock.callArgs = []*LoggerMockInfofParams{}

	m.IsMock = mLoggerMockIs{mock: m}
	m.IsMock.callArgs = []*LoggerMockIsParams{}

	m.PanicMock = mLoggerMockPanic{mock: m}
	m.PanicMock.callArgs = []*LoggerMockPanicParams{}

	m.PanicfMock = mLoggerMockPanicf{mock: m}
	m.PanicfMock.callArgs = []*LoggerMockPanicfParams{}

	m.WarnMock = mLoggerMockWarn{mock: m}
	m.WarnMock.callArgs = []*LoggerMockWarnParams{}

	m.WarnfMock = mLoggerMockWarnf{mock: m}
	m.WarnfMock.callArgs = []*LoggerMockWarnfParams{}

	m.WithCallerMock = mLoggerMockWithCaller{mock: m}
	m.WithCallerMock.callArgs = []*LoggerMockWithCallerParams{}

	m.WithFieldMock = mLoggerMockWithField{mock: m}
	m.WithFieldMock.callArgs = []*LoggerMockWithFieldParams{}

	m.WithFieldsMock = mLoggerMockWithFields{mock: m}
	m.WithFieldsMock.callArgs = []*LoggerMockWithFieldsParams{}

	m.WithFormatMock = mLoggerMockWithFormat{mock: m}
	m.WithFormatMock.callArgs = []*LoggerMockWithFormatParams{}

	m.WithFuncNameMock = mLoggerMockWithFuncName{mock: m}
	m.WithFuncNameMock.callArgs = []*LoggerMockWithFuncNameParams{}

	m.WithLevelMock = mLoggerMockWithLevel{mock: m}
	m.WithLevelMock.callArgs = []*LoggerMockWithLevelParams{}

	m.WithLevelNumberMock = mLoggerMockWithLevelNumber{mock: m}
	m.WithLevelNumberMock.callArgs = []*LoggerMockWithLevelNumberParams{}

	m.WithOutputMock = mLoggerMockWithOutput{mock: m}
	m.WithOutputMock.callArgs = []*LoggerMockWithOutputParams{}

	m.WithSkipFrameCountMock = mLoggerMockWithSkipFrameCount{mock: m}
	m.WithSkipFrameCountMock.callArgs = []*LoggerMockWithSkipFrameCountParams{}

	return m
}

type mLoggerMockDebug struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockDebugExpectation
	expectations       []*LoggerMockDebugExpectation

	callArgs []*LoggerMockDebugParams
	mutex    sync.RWMutex
}

// LoggerMockDebugExpectation specifies expectation struct of the Logger.Debug
type LoggerMockDebugExpectation struct {
	mock   *LoggerMock
	params *LoggerMockDebugParams

	Counter uint64
}

// LoggerMockDebugParams contains parameters of the Logger.Debug
type LoggerMockDebugParams struct {
	p1 []interface{}
}

// Expect sets up expected params for Logger.Debug
func (mmDebug *mLoggerMockDebug) Expect(p1 ...interface{}) *mLoggerMockDebug {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &LoggerMockDebugExpectation{}
	}

	mmDebug.defaultExpectation.params = &LoggerMockDebugParams{p1}
	for _, e := range mmDebug.expectations {
		if minimock.Equal(e.params, mmDebug.defaultExpectation.params) {
			mmDebug.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDebug.defaultExpectation.params)
		}
	}

	return mmDebug
}

// Inspect accepts an inspector function that has same arguments as the Logger.Debug
func (mmDebug *mLoggerMockDebug) Inspect(f func(p1 ...interface{})) *mLoggerMockDebug {
	if mmDebug.mock.inspectFuncDebug != nil {
		mmDebug.mock.t.Fatalf("Inspect function is already set for LoggerMock.Debug")
	}

	mmDebug.mock.inspectFuncDebug = f

	return mmDebug
}

// Return sets up results that will be returned by Logger.Debug
func (mmDebug *mLoggerMockDebug) Return() *LoggerMock {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &LoggerMockDebugExpectation{mock: mmDebug.mock}
	}

	return mmDebug.mock
}

//Set uses given function f to mock the Logger.Debug method
func (mmDebug *mLoggerMockDebug) Set(f func(p1 ...interface{})) *LoggerMock {
	if mmDebug.defaultExpectation != nil {
		mmDebug.mock.t.Fatalf("Default expectation is already set for the Logger.Debug method")
	}

	if len(mmDebug.expectations) > 0 {
		mmDebug.mock.t.Fatalf("Some expectations are already set for the Logger.Debug method")
	}

	mmDebug.mock.funcDebug = f
	return mmDebug.mock
}

// Debug implements Logger
func (mmDebug *LoggerMock) Debug(p1 ...interface{}) {
	mm_atomic.AddUint64(&mmDebug.beforeDebugCounter, 1)
	defer mm_atomic.AddUint64(&mmDebug.afterDebugCounter, 1)

	if mmDebug.inspectFuncDebug != nil {
		mmDebug.inspectFuncDebug(p1...)
	}

	params := &LoggerMockDebugParams{p1}

	// Record call args
	mmDebug.DebugMock.mutex.Lock()
	mmDebug.DebugMock.callArgs = append(mmDebug.DebugMock.callArgs, params)
	mmDebug.DebugMock.mutex.Unlock()

	for _, e := range mmDebug.DebugMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDebug.DebugMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDebug.DebugMock.defaultExpectation.Counter, 1)
		want := mmDebug.DebugMock.defaultExpectation.params
		got := LoggerMockDebugParams{p1}
		if want != nil && !minimock.Equal(*want, got) {
			mmDebug.t.Errorf("LoggerMock.Debug got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmDebug.funcDebug != nil {
		mmDebug.funcDebug(p1...)
		return
	}
	mmDebug.t.Fatalf("Unexpected call to LoggerMock.Debug. %v", p1)

}

// DebugAfterCounter returns a count of finished LoggerMock.Debug invocations
func (mmDebug *LoggerMock) DebugAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebug.afterDebugCounter)
}

// DebugBeforeCounter returns a count of LoggerMock.Debug invocations
func (mmDebug *LoggerMock) DebugBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebug.beforeDebugCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Debug.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDebug *mLoggerMockDebug) Calls() []*LoggerMockDebugParams {
	mmDebug.mutex.RLock()

	argCopy := make([]*LoggerMockDebugParams, len(mmDebug.callArgs))
	copy(argCopy, mmDebug.callArgs)

	mmDebug.mutex.RUnlock()

	return argCopy
}

// MinimockDebugDone returns true if the count of the Debug invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockDebugDone() bool {
	for _, e := range m.DebugMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DebugMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDebugCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDebug != nil && mm_atomic.LoadUint64(&m.afterDebugCounter) < 1 {
		return false
	}
	return true
}

// MinimockDebugInspect logs each unmet expectation
func (m *LoggerMock) MinimockDebugInspect() {
	for _, e := range m.DebugMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Debug with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DebugMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDebugCounter) < 1 {
		if m.DebugMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Debug")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Debug with params: %#v", *m.DebugMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDebug != nil && mm_atomic.LoadUint64(&m.afterDebugCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Debug")
	}
}

type mLoggerMockDebugf struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockDebugfExpectation
	expectations       []*LoggerMockDebugfExpectation

	callArgs []*LoggerMockDebugfParams
	mutex    sync.RWMutex
}

// LoggerMockDebugfExpectation specifies expectation struct of the Logger.Debugf
type LoggerMockDebugfExpectation struct {
	mock   *LoggerMock
	params *LoggerMockDebugfParams

	Counter uint64
}

// LoggerMockDebugfParams contains parameters of the Logger.Debugf
type LoggerMockDebugfParams struct {
	s1 string
	p1 []interface{}
}

// Expect sets up expected params for Logger.Debugf
func (mmDebugf *mLoggerMockDebugf) Expect(s1 string, p1 ...interface{}) *mLoggerMockDebugf {
	if mmDebugf.mock.funcDebugf != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by Set")
	}

	if mmDebugf.defaultExpectation == nil {
		mmDebugf.defaultExpectation = &LoggerMockDebugfExpectation{}
	}

	mmDebugf.defaultExpectation.params = &LoggerMockDebugfParams{s1, p1}
	for _, e := range mmDebugf.expectations {
		if minimock.Equal(e.params, mmDebugf.defaultExpectation.params) {
			mmDebugf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDebugf.defaultExpectation.params)
		}
	}

	return mmDebugf
}

// Inspect accepts an inspector function that has same arguments as the Logger.Debugf
func (mmDebugf *mLoggerMockDebugf) Inspect(f func(s1 string, p1 ...interface{})) *mLoggerMockDebugf {
	if mmDebugf.mock.inspectFuncDebugf != nil {
		mmDebugf.mock.t.Fatalf("Inspect function is already set for LoggerMock.Debugf")
	}

	mmDebugf.mock.inspectFuncDebugf = f

	return mmDebugf
}

// Return sets up results that will be returned by Logger.Debugf
func (mmDebugf *mLoggerMockDebugf) Return() *LoggerMock {
	if mmDebugf.mock.funcDebugf != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by Set")
	}

	if mmDebugf.defaultExpectation == nil {
		mmDebugf.defaultExpectation = &LoggerMockDebugfExpectation{mock: mmDebugf.mock}
	}

	return mmDebugf.mock
}

//Set uses given function f to mock the Logger.Debugf method
func (mmDebugf *mLoggerMockDebugf) Set(f func(s1 string, p1 ...interface{})) *LoggerMock {
	if mmDebugf.defaultExpectation != nil {
		mmDebugf.mock.t.Fatalf("Default expectation is already set for the Logger.Debugf method")
	}

	if len(mmDebugf.expectations) > 0 {
		mmDebugf.mock.t.Fatalf("Some expectations are already set for the Logger.Debugf method")
	}

	mmDebugf.mock.funcDebugf = f
	return mmDebugf.mock
}

// Debugf implements Logger
func (mmDebugf *LoggerMock) Debugf(s1 string, p1 ...interface{}) {
	mm_atomic.AddUint64(&mmDebugf.beforeDebugfCounter, 1)
	defer mm_atomic.AddUint64(&mmDebugf.afterDebugfCounter, 1)

	if mmDebugf.inspectFuncDebugf != nil {
		mmDebugf.inspectFuncDebugf(s1, p1...)
	}

	params := &LoggerMockDebugfParams{s1, p1}

	// Record call args
	mmDebugf.DebugfMock.mutex.Lock()
	mmDebugf.DebugfMock.callArgs = append(mmDebugf.DebugfMock.callArgs, params)
	mmDebugf.DebugfMock.mutex.Unlock()

	for _, e := range mmDebugf.DebugfMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDebugf.DebugfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDebugf.DebugfMock.defaultExpectation.Counter, 1)
		want := mmDebugf.DebugfMock.defaultExpectation.params
		got := LoggerMockDebugfParams{s1, p1}
		if want != nil && !minimock.Equal(*want, got) {
			mmDebugf.t.Errorf("LoggerMock.Debugf got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmDebugf.funcDebugf != nil {
		mmDebugf.funcDebugf(s1, p1...)
		return
	}
	mmDebugf.t.Fatalf("Unexpected call to LoggerMock.Debugf. %v %v", s1, p1)

}

// DebugfAfterCounter returns a count of finished LoggerMock.Debugf invocations
func (mmDebugf *LoggerMock) DebugfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebugf.afterDebugfCounter)
}

// DebugfBeforeCounter returns a count of LoggerMock.Debugf invocations
func (mmDebugf *LoggerMock) DebugfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebugf.beforeDebugfCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Debugf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDebugf *mLoggerMockDebugf) Calls() []*LoggerMockDebugfParams {
	mmDebugf.mutex.RLock()

	argCopy := make([]*LoggerMockDebugfParams, len(mmDebugf.callArgs))
	copy(argCopy, mmDebugf.callArgs)

	mmDebugf.mutex.RUnlock()

	return argCopy
}

// MinimockDebugfDone returns true if the count of the Debugf invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockDebugfDone() bool {
	for _, e := range m.DebugfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DebugfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDebugfCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDebugf != nil && mm_atomic.LoadUint64(&m.afterDebugfCounter) < 1 {
		return false
	}
	return true
}

// MinimockDebugfInspect logs each unmet expectation
func (m *LoggerMock) MinimockDebugfInspect() {
	for _, e := range m.DebugfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Debugf with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DebugfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDebugfCounter) < 1 {
		if m.DebugfMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Debugf")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Debugf with params: %#v", *m.DebugfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDebugf != nil && mm_atomic.LoadUint64(&m.afterDebugfCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Debugf")
	}
}

type mLoggerMockError struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockErrorExpectation
	expectations       []*LoggerMockErrorExpectation

	callArgs []*LoggerMockErrorParams
	mutex    sync.RWMutex
}

// LoggerMockErrorExpectation specifies expectation struct of the Logger.Error
type LoggerMockErrorExpectation struct {
	mock   *LoggerMock
	params *LoggerMockErrorParams

	Counter uint64
}

// LoggerMockErrorParams contains parameters of the Logger.Error
type LoggerMockErrorParams struct {
	p1 []interface{}
}

// Expect sets up expected params for Logger.Error
func (mmError *mLoggerMockError) Expect(p1 ...interface{}) *mLoggerMockError {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &LoggerMockErrorExpectation{}
	}

	mmError.defaultExpectation.params = &LoggerMockErrorParams{p1}
	for _, e := range mmError.expectations {
		if minimock.Equal(e.params, mmError.defaultExpectation.params) {
			mmError.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmError.defaultExpectation.params)
		}
	}

	return mmError
}

// Inspect accepts an inspector function that has same arguments as the Logger.Error
func (mmError *mLoggerMockError) Inspect(f func(p1 ...interface{})) *mLoggerMockError {
	if mmError.mock.inspectFuncError != nil {
		mmError.mock.t.Fatalf("Inspect function is already set for LoggerMock.Error")
	}

	mmError.mock.inspectFuncError = f

	return mmError
}

// Return sets up results that will be returned by Logger.Error
func (mmError *mLoggerMockError) Return() *LoggerMock {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &LoggerMockErrorExpectation{mock: mmError.mock}
	}

	return mmError.mock
}

//Set uses given function f to mock the Logger.Error method
func (mmError *mLoggerMockError) Set(f func(p1 ...interface{})) *LoggerMock {
	if mmError.defaultExpectation != nil {
		mmError.mock.t.Fatalf("Default expectation is already set for the Logger.Error method")
	}

	if len(mmError.expectations) > 0 {
		mmError.mock.t.Fatalf("Some expectations are already set for the Logger.Error method")
	}

	mmError.mock.funcError = f
	return mmError.mock
}

// Error implements Logger
func (mmError *LoggerMock) Error(p1 ...interface{}) {
	mm_atomic.AddUint64(&mmError.beforeErrorCounter, 1)
	defer mm_atomic.AddUint64(&mmError.afterErrorCounter, 1)

	if mmError.inspectFuncError != nil {
		mmError.inspectFuncError(p1...)
	}

	params := &LoggerMockErrorParams{p1}

	// Record call args
	mmError.ErrorMock.mutex.Lock()
	mmError.ErrorMock.callArgs = append(mmError.ErrorMock.callArgs, params)
	mmError.ErrorMock.mutex.Unlock()

	for _, e := range mmError.ErrorMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmError.ErrorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmError.ErrorMock.defaultExpectation.Counter, 1)
		want := mmError.ErrorMock.defaultExpectation.params
		got := LoggerMockErrorParams{p1}
		if want != nil && !minimock.Equal(*want, got) {
			mmError.t.Errorf("LoggerMock.Error got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmError.funcError != nil {
		mmError.funcError(p1...)
		return
	}
	mmError.t.Fatalf("Unexpected call to LoggerMock.Error. %v", p1)

}

// ErrorAfterCounter returns a count of finished LoggerMock.Error invocations
func (mmError *LoggerMock) ErrorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmError.afterErrorCounter)
}

// ErrorBeforeCounter returns a count of LoggerMock.Error invocations
func (mmError *LoggerMock) ErrorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmError.beforeErrorCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Error.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmError *mLoggerMockError) Calls() []*LoggerMockErrorParams {
	mmError.mutex.RLock()

	argCopy := make([]*LoggerMockErrorParams, len(mmError.callArgs))
	copy(argCopy, mmError.callArgs)

	mmError.mutex.RUnlock()

	return argCopy
}

// MinimockErrorDone returns true if the count of the Error invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockErrorDone() bool {
	for _, e := range m.ErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcError != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		return false
	}
	return true
}

// MinimockErrorInspect logs each unmet expectation
func (m *LoggerMock) MinimockErrorInspect() {
	for _, e := range m.ErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Error with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		if m.ErrorMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Error")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Error with params: %#v", *m.ErrorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcError != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Error")
	}
}

type mLoggerMockErrorf struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockErrorfExpectation
	expectations       []*LoggerMockErrorfExpectation

	callArgs []*LoggerMockErrorfParams
	mutex    sync.RWMutex
}

// LoggerMockErrorfExpectation specifies expectation struct of the Logger.Errorf
type LoggerMockErrorfExpectation struct {
	mock   *LoggerMock
	params *LoggerMockErrorfParams

	Counter uint64
}

// LoggerMockErrorfParams contains parameters of the Logger.Errorf
type LoggerMockErrorfParams struct {
	s1 string
	p1 []interface{}
}

// Expect sets up expected params for Logger.Errorf
func (mmErrorf *mLoggerMockErrorf) Expect(s1 string, p1 ...interface{}) *mLoggerMockErrorf {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by Set")
	}

	if mmErrorf.defaultExpectation == nil {
		mmErrorf.defaultExpectation = &LoggerMockErrorfExpectation{}
	}

	mmErrorf.defaultExpectation.params = &LoggerMockErrorfParams{s1, p1}
	for _, e := range mmErrorf.expectations {
		if minimock.Equal(e.params, mmErrorf.defaultExpectation.params) {
			mmErrorf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmErrorf.defaultExpectation.params)
		}
	}

	return mmErrorf
}

// Inspect accepts an inspector function that has same arguments as the Logger.Errorf
func (mmErrorf *mLoggerMockErrorf) Inspect(f func(s1 string, p1 ...interface{})) *mLoggerMockErrorf {
	if mmErrorf.mock.inspectFuncErrorf != nil {
		mmErrorf.mock.t.Fatalf("Inspect function is already set for LoggerMock.Errorf")
	}

	mmErrorf.mock.inspectFuncErrorf = f

	return mmErrorf
}

// Return sets up results that will be returned by Logger.Errorf
func (mmErrorf *mLoggerMockErrorf) Return() *LoggerMock {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by Set")
	}

	if mmErrorf.defaultExpectation == nil {
		mmErrorf.defaultExpectation = &LoggerMockErrorfExpectation{mock: mmErrorf.mock}
	}

	return mmErrorf.mock
}

//Set uses given function f to mock the Logger.Errorf method
func (mmErrorf *mLoggerMockErrorf) Set(f func(s1 string, p1 ...interface{})) *LoggerMock {
	if mmErrorf.defaultExpectation != nil {
		mmErrorf.mock.t.Fatalf("Default expectation is already set for the Logger.Errorf method")
	}

	if len(mmErrorf.expectations) > 0 {
		mmErrorf.mock.t.Fatalf("Some expectations are already set for the Logger.Errorf method")
	}

	mmErrorf.mock.funcErrorf = f
	return mmErrorf.mock
}

// Errorf implements Logger
func (mmErrorf *LoggerMock) Errorf(s1 string, p1 ...interface{}) {
	mm_atomic.AddUint64(&mmErrorf.beforeErrorfCounter, 1)
	defer mm_atomic.AddUint64(&mmErrorf.afterErrorfCounter, 1)

	if mmErrorf.inspectFuncErrorf != nil {
		mmErrorf.inspectFuncErrorf(s1, p1...)
	}

	params := &LoggerMockErrorfParams{s1, p1}

	// Record call args
	mmErrorf.ErrorfMock.mutex.Lock()
	mmErrorf.ErrorfMock.callArgs = append(mmErrorf.ErrorfMock.callArgs, params)
	mmErrorf.ErrorfMock.mutex.Unlock()

	for _, e := range mmErrorf.ErrorfMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmErrorf.ErrorfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmErrorf.ErrorfMock.defaultExpectation.Counter, 1)
		want := mmErrorf.ErrorfMock.defaultExpectation.params
		got := LoggerMockErrorfParams{s1, p1}
		if want != nil && !minimock.Equal(*want, got) {
			mmErrorf.t.Errorf("LoggerMock.Errorf got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmErrorf.funcErrorf != nil {
		mmErrorf.funcErrorf(s1, p1...)
		return
	}
	mmErrorf.t.Fatalf("Unexpected call to LoggerMock.Errorf. %v %v", s1, p1)

}

// ErrorfAfterCounter returns a count of finished LoggerMock.Errorf invocations
func (mmErrorf *LoggerMock) ErrorfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmErrorf.afterErrorfCounter)
}

// ErrorfBeforeCounter returns a count of LoggerMock.Errorf invocations
func (mmErrorf *LoggerMock) ErrorfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmErrorf.beforeErrorfCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Errorf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmErrorf *mLoggerMockErrorf) Calls() []*LoggerMockErrorfParams {
	mmErrorf.mutex.RLock()

	argCopy := make([]*LoggerMockErrorfParams, len(mmErrorf.callArgs))
	copy(argCopy, mmErrorf.callArgs)

	mmErrorf.mutex.RUnlock()

	return argCopy
}

// MinimockErrorfDone returns true if the count of the Errorf invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockErrorfDone() bool {
	for _, e := range m.ErrorfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterErrorfCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcErrorf != nil && mm_atomic.LoadUint64(&m.afterErrorfCounter) < 1 {
		return false
	}
	return true
}

// MinimockErrorfInspect logs each unmet expectation
func (m *LoggerMock) MinimockErrorfInspect() {
	for _, e := range m.ErrorfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Errorf with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterErrorfCounter) < 1 {
		if m.ErrorfMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Errorf")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Errorf with params: %#v", *m.ErrorfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcErrorf != nil && mm_atomic.LoadUint64(&m.afterErrorfCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Errorf")
	}
}

type mLoggerMockFatal struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockFatalExpectation
	expectations       []*LoggerMockFatalExpectation

	callArgs []*LoggerMockFatalParams
	mutex    sync.RWMutex
}

// LoggerMockFatalExpectation specifies expectation struct of the Logger.Fatal
type LoggerMockFatalExpectation struct {
	mock   *LoggerMock
	params *LoggerMockFatalParams

	Counter uint64
}

// LoggerMockFatalParams contains parameters of the Logger.Fatal
type LoggerMockFatalParams struct {
	p1 []interface{}
}

// Expect sets up expected params for Logger.Fatal
func (mmFatal *mLoggerMockFatal) Expect(p1 ...interface{}) *mLoggerMockFatal {
	if mmFatal.mock.funcFatal != nil {
		mmFatal.mock.t.Fatalf("LoggerMock.Fatal mock is already set by Set")
	}

	if mmFatal.defaultExpectation == nil {
		mmFatal.defaultExpectation = &LoggerMockFatalExpectation{}
	}

	mmFatal.defaultExpectation.params = &LoggerMockFatalParams{p1}
	for _, e := range mmFatal.expectations {
		if minimock.Equal(e.params, mmFatal.defaultExpectation.params) {
			mmFatal.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFatal.defaultExpectation.params)
		}
	}

	return mmFatal
}

// Inspect accepts an inspector function that has same arguments as the Logger.Fatal
func (mmFatal *mLoggerMockFatal) Inspect(f func(p1 ...interface{})) *mLoggerMockFatal {
	if mmFatal.mock.inspectFuncFatal != nil {
		mmFatal.mock.t.Fatalf("Inspect function is already set for LoggerMock.Fatal")
	}

	mmFatal.mock.inspectFuncFatal = f

	return mmFatal
}

// Return sets up results that will be returned by Logger.Fatal
func (mmFatal *mLoggerMockFatal) Return() *LoggerMock {
	if mmFatal.mock.funcFatal != nil {
		mmFatal.mock.t.Fatalf("LoggerMock.Fatal mock is already set by Set")
	}

	if mmFatal.defaultExpectation == nil {
		mmFatal.defaultExpectation = &LoggerMockFatalExpectation{mock: mmFatal.mock}
	}

	return mmFatal.mock
}

//Set uses given function f to mock the Logger.Fatal method
func (mmFatal *mLoggerMockFatal) Set(f func(p1 ...interface{})) *LoggerMock {
	if mmFatal.defaultExpectation != nil {
		mmFatal.mock.t.Fatalf("Default expectation is already set for the Logger.Fatal method")
	}

	if len(mmFatal.expectations) > 0 {
		mmFatal.mock.t.Fatalf("Some expectations are already set for the Logger.Fatal method")
	}

	mmFatal.mock.funcFatal = f
	return mmFatal.mock
}

// Fatal implements Logger
func (mmFatal *LoggerMock) Fatal(p1 ...interface{}) {
	mm_atomic.AddUint64(&mmFatal.beforeFatalCounter, 1)
	defer mm_atomic.AddUint64(&mmFatal.afterFatalCounter, 1)

	if mmFatal.inspectFuncFatal != nil {
		mmFatal.inspectFuncFatal(p1...)
	}

	params := &LoggerMockFatalParams{p1}

	// Record call args
	mmFatal.FatalMock.mutex.Lock()
	mmFatal.FatalMock.callArgs = append(mmFatal.FatalMock.callArgs, params)
	mmFatal.FatalMock.mutex.Unlock()

	for _, e := range mmFatal.FatalMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmFatal.FatalMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFatal.FatalMock.defaultExpectation.Counter, 1)
		want := mmFatal.FatalMock.defaultExpectation.params
		got := LoggerMockFatalParams{p1}
		if want != nil && !minimock.Equal(*want, got) {
			mmFatal.t.Errorf("LoggerMock.Fatal got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmFatal.funcFatal != nil {
		mmFatal.funcFatal(p1...)
		return
	}
	mmFatal.t.Fatalf("Unexpected call to LoggerMock.Fatal. %v", p1)

}

// FatalAfterCounter returns a count of finished LoggerMock.Fatal invocations
func (mmFatal *LoggerMock) FatalAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFatal.afterFatalCounter)
}

// FatalBeforeCounter returns a count of LoggerMock.Fatal invocations
func (mmFatal *LoggerMock) FatalBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFatal.beforeFatalCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Fatal.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFatal *mLoggerMockFatal) Calls() []*LoggerMockFatalParams {
	mmFatal.mutex.RLock()

	argCopy := make([]*LoggerMockFatalParams, len(mmFatal.callArgs))
	copy(argCopy, mmFatal.callArgs)

	mmFatal.mutex.RUnlock()

	return argCopy
}

// MinimockFatalDone returns true if the count of the Fatal invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockFatalDone() bool {
	for _, e := range m.FatalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FatalMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFatalCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFatal != nil && mm_atomic.LoadUint64(&m.afterFatalCounter) < 1 {
		return false
	}
	return true
}

// MinimockFatalInspect logs each unmet expectation
func (m *LoggerMock) MinimockFatalInspect() {
	for _, e := range m.FatalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Fatal with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FatalMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFatalCounter) < 1 {
		if m.FatalMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Fatal")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Fatal with params: %#v", *m.FatalMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFatal != nil && mm_atomic.LoadUint64(&m.afterFatalCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Fatal")
	}
}

type mLoggerMockFatalf struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockFatalfExpectation
	expectations       []*LoggerMockFatalfExpectation

	callArgs []*LoggerMockFatalfParams
	mutex    sync.RWMutex
}

// LoggerMockFatalfExpectation specifies expectation struct of the Logger.Fatalf
type LoggerMockFatalfExpectation struct {
	mock   *LoggerMock
	params *LoggerMockFatalfParams

	Counter uint64
}

// LoggerMockFatalfParams contains parameters of the Logger.Fatalf
type LoggerMockFatalfParams struct {
	s1 string
	p1 []interface{}
}

// Expect sets up expected params for Logger.Fatalf
func (mmFatalf *mLoggerMockFatalf) Expect(s1 string, p1 ...interface{}) *mLoggerMockFatalf {
	if mmFatalf.mock.funcFatalf != nil {
		mmFatalf.mock.t.Fatalf("LoggerMock.Fatalf mock is already set by Set")
	}

	if mmFatalf.defaultExpectation == nil {
		mmFatalf.defaultExpectation = &LoggerMockFatalfExpectation{}
	}

	mmFatalf.defaultExpectation.params = &LoggerMockFatalfParams{s1, p1}
	for _, e := range mmFatalf.expectations {
		if minimock.Equal(e.params, mmFatalf.defaultExpectation.params) {
			mmFatalf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFatalf.defaultExpectation.params)
		}
	}

	return mmFatalf
}

// Inspect accepts an inspector function that has same arguments as the Logger.Fatalf
func (mmFatalf *mLoggerMockFatalf) Inspect(f func(s1 string, p1 ...interface{})) *mLoggerMockFatalf {
	if mmFatalf.mock.inspectFuncFatalf != nil {
		mmFatalf.mock.t.Fatalf("Inspect function is already set for LoggerMock.Fatalf")
	}

	mmFatalf.mock.inspectFuncFatalf = f

	return mmFatalf
}

// Return sets up results that will be returned by Logger.Fatalf
func (mmFatalf *mLoggerMockFatalf) Return() *LoggerMock {
	if mmFatalf.mock.funcFatalf != nil {
		mmFatalf.mock.t.Fatalf("LoggerMock.Fatalf mock is already set by Set")
	}

	if mmFatalf.defaultExpectation == nil {
		mmFatalf.defaultExpectation = &LoggerMockFatalfExpectation{mock: mmFatalf.mock}
	}

	return mmFatalf.mock
}

//Set uses given function f to mock the Logger.Fatalf method
func (mmFatalf *mLoggerMockFatalf) Set(f func(s1 string, p1 ...interface{})) *LoggerMock {
	if mmFatalf.defaultExpectation != nil {
		mmFatalf.mock.t.Fatalf("Default expectation is already set for the Logger.Fatalf method")
	}

	if len(mmFatalf.expectations) > 0 {
		mmFatalf.mock.t.Fatalf("Some expectations are already set for the Logger.Fatalf method")
	}

	mmFatalf.mock.funcFatalf = f
	return mmFatalf.mock
}

// Fatalf implements Logger
func (mmFatalf *LoggerMock) Fatalf(s1 string, p1 ...interface{}) {
	mm_atomic.AddUint64(&mmFatalf.beforeFatalfCounter, 1)
	defer mm_atomic.AddUint64(&mmFatalf.afterFatalfCounter, 1)

	if mmFatalf.inspectFuncFatalf != nil {
		mmFatalf.inspectFuncFatalf(s1, p1...)
	}

	params := &LoggerMockFatalfParams{s1, p1}

	// Record call args
	mmFatalf.FatalfMock.mutex.Lock()
	mmFatalf.FatalfMock.callArgs = append(mmFatalf.FatalfMock.callArgs, params)
	mmFatalf.FatalfMock.mutex.Unlock()

	for _, e := range mmFatalf.FatalfMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmFatalf.FatalfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFatalf.FatalfMock.defaultExpectation.Counter, 1)
		want := mmFatalf.FatalfMock.defaultExpectation.params
		got := LoggerMockFatalfParams{s1, p1}
		if want != nil && !minimock.Equal(*want, got) {
			mmFatalf.t.Errorf("LoggerMock.Fatalf got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmFatalf.funcFatalf != nil {
		mmFatalf.funcFatalf(s1, p1...)
		return
	}
	mmFatalf.t.Fatalf("Unexpected call to LoggerMock.Fatalf. %v %v", s1, p1)

}

// FatalfAfterCounter returns a count of finished LoggerMock.Fatalf invocations
func (mmFatalf *LoggerMock) FatalfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFatalf.afterFatalfCounter)
}

// FatalfBeforeCounter returns a count of LoggerMock.Fatalf invocations
func (mmFatalf *LoggerMock) FatalfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFatalf.beforeFatalfCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Fatalf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFatalf *mLoggerMockFatalf) Calls() []*LoggerMockFatalfParams {
	mmFatalf.mutex.RLock()

	argCopy := make([]*LoggerMockFatalfParams, len(mmFatalf.callArgs))
	copy(argCopy, mmFatalf.callArgs)

	mmFatalf.mutex.RUnlock()

	return argCopy
}

// MinimockFatalfDone returns true if the count of the Fatalf invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockFatalfDone() bool {
	for _, e := range m.FatalfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FatalfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFatalfCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFatalf != nil && mm_atomic.LoadUint64(&m.afterFatalfCounter) < 1 {
		return false
	}
	return true
}

// MinimockFatalfInspect logs each unmet expectation
func (m *LoggerMock) MinimockFatalfInspect() {
	for _, e := range m.FatalfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Fatalf with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FatalfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFatalfCounter) < 1 {
		if m.FatalfMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Fatalf")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Fatalf with params: %#v", *m.FatalfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFatalf != nil && mm_atomic.LoadUint64(&m.afterFatalfCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Fatalf")
	}
}

type mLoggerMockInfo struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockInfoExpectation
	expectations       []*LoggerMockInfoExpectation

	callArgs []*LoggerMockInfoParams
	mutex    sync.RWMutex
}

// LoggerMockInfoExpectation specifies expectation struct of the Logger.Info
type LoggerMockInfoExpectation struct {
	mock   *LoggerMock
	params *LoggerMockInfoParams

	Counter uint64
}

// LoggerMockInfoParams contains parameters of the Logger.Info
type LoggerMockInfoParams struct {
	p1 []interface{}
}

// Expect sets up expected params for Logger.Info
func (mmInfo *mLoggerMockInfo) Expect(p1 ...interface{}) *mLoggerMockInfo {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &LoggerMockInfoExpectation{}
	}

	mmInfo.defaultExpectation.params = &LoggerMockInfoParams{p1}
	for _, e := range mmInfo.expectations {
		if minimock.Equal(e.params, mmInfo.defaultExpectation.params) {
			mmInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInfo.defaultExpectation.params)
		}
	}

	return mmInfo
}

// Inspect accepts an inspector function that has same arguments as the Logger.Info
func (mmInfo *mLoggerMockInfo) Inspect(f func(p1 ...interface{})) *mLoggerMockInfo {
	if mmInfo.mock.inspectFuncInfo != nil {
		mmInfo.mock.t.Fatalf("Inspect function is already set for LoggerMock.Info")
	}

	mmInfo.mock.inspectFuncInfo = f

	return mmInfo
}

// Return sets up results that will be returned by Logger.Info
func (mmInfo *mLoggerMockInfo) Return() *LoggerMock {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &LoggerMockInfoExpectation{mock: mmInfo.mock}
	}

	return mmInfo.mock
}

//Set uses given function f to mock the Logger.Info method
func (mmInfo *mLoggerMockInfo) Set(f func(p1 ...interface{})) *LoggerMock {
	if mmInfo.defaultExpectation != nil {
		mmInfo.mock.t.Fatalf("Default expectation is already set for the Logger.Info method")
	}

	if len(mmInfo.expectations) > 0 {
		mmInfo.mock.t.Fatalf("Some expectations are already set for the Logger.Info method")
	}

	mmInfo.mock.funcInfo = f
	return mmInfo.mock
}

// Info implements Logger
func (mmInfo *LoggerMock) Info(p1 ...interface{}) {
	mm_atomic.AddUint64(&mmInfo.beforeInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmInfo.afterInfoCounter, 1)

	if mmInfo.inspectFuncInfo != nil {
		mmInfo.inspectFuncInfo(p1...)
	}

	params := &LoggerMockInfoParams{p1}

	// Record call args
	mmInfo.InfoMock.mutex.Lock()
	mmInfo.InfoMock.callArgs = append(mmInfo.InfoMock.callArgs, params)
	mmInfo.InfoMock.mutex.Unlock()

	for _, e := range mmInfo.InfoMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmInfo.InfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInfo.InfoMock.defaultExpectation.Counter, 1)
		want := mmInfo.InfoMock.defaultExpectation.params
		got := LoggerMockInfoParams{p1}
		if want != nil && !minimock.Equal(*want, got) {
			mmInfo.t.Errorf("LoggerMock.Info got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmInfo.funcInfo != nil {
		mmInfo.funcInfo(p1...)
		return
	}
	mmInfo.t.Fatalf("Unexpected call to LoggerMock.Info. %v", p1)

}

// InfoAfterCounter returns a count of finished LoggerMock.Info invocations
func (mmInfo *LoggerMock) InfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfo.afterInfoCounter)
}

// InfoBeforeCounter returns a count of LoggerMock.Info invocations
func (mmInfo *LoggerMock) InfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfo.beforeInfoCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Info.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInfo *mLoggerMockInfo) Calls() []*LoggerMockInfoParams {
	mmInfo.mutex.RLock()

	argCopy := make([]*LoggerMockInfoParams, len(mmInfo.callArgs))
	copy(argCopy, mmInfo.callArgs)

	mmInfo.mutex.RUnlock()

	return argCopy
}

// MinimockInfoDone returns true if the count of the Info invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockInfoDone() bool {
	for _, e := range m.InfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InfoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInfoCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInfo != nil && mm_atomic.LoadUint64(&m.afterInfoCounter) < 1 {
		return false
	}
	return true
}

// MinimockInfoInspect logs each unmet expectation
func (m *LoggerMock) MinimockInfoInspect() {
	for _, e := range m.InfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Info with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InfoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInfoCounter) < 1 {
		if m.InfoMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Info")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Info with params: %#v", *m.InfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInfo != nil && mm_atomic.LoadUint64(&m.afterInfoCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Info")
	}
}

type mLoggerMockInfof struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockInfofExpectation
	expectations       []*LoggerMockInfofExpectation

	callArgs []*LoggerMockInfofParams
	mutex    sync.RWMutex
}

// LoggerMockInfofExpectation specifies expectation struct of the Logger.Infof
type LoggerMockInfofExpectation struct {
	mock   *LoggerMock
	params *LoggerMockInfofParams

	Counter uint64
}

// LoggerMockInfofParams contains parameters of the Logger.Infof
type LoggerMockInfofParams struct {
	s1 string
	p1 []interface{}
}

// Expect sets up expected params for Logger.Infof
func (mmInfof *mLoggerMockInfof) Expect(s1 string, p1 ...interface{}) *mLoggerMockInfof {
	if mmInfof.mock.funcInfof != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by Set")
	}

	if mmInfof.defaultExpectation == nil {
		mmInfof.defaultExpectation = &LoggerMockInfofExpectation{}
	}

	mmInfof.defaultExpectation.params = &LoggerMockInfofParams{s1, p1}
	for _, e := range mmInfof.expectations {
		if minimock.Equal(e.params, mmInfof.defaultExpectation.params) {
			mmInfof.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInfof.defaultExpectation.params)
		}
	}

	return mmInfof
}

// Inspect accepts an inspector function that has same arguments as the Logger.Infof
func (mmInfof *mLoggerMockInfof) Inspect(f func(s1 string, p1 ...interface{})) *mLoggerMockInfof {
	if mmInfof.mock.inspectFuncInfof != nil {
		mmInfof.mock.t.Fatalf("Inspect function is already set for LoggerMock.Infof")
	}

	mmInfof.mock.inspectFuncInfof = f

	return mmInfof
}

// Return sets up results that will be returned by Logger.Infof
func (mmInfof *mLoggerMockInfof) Return() *LoggerMock {
	if mmInfof.mock.funcInfof != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by Set")
	}

	if mmInfof.defaultExpectation == nil {
		mmInfof.defaultExpectation = &LoggerMockInfofExpectation{mock: mmInfof.mock}
	}

	return mmInfof.mock
}

//Set uses given function f to mock the Logger.Infof method
func (mmInfof *mLoggerMockInfof) Set(f func(s1 string, p1 ...interface{})) *LoggerMock {
	if mmInfof.defaultExpectation != nil {
		mmInfof.mock.t.Fatalf("Default expectation is already set for the Logger.Infof method")
	}

	if len(mmInfof.expectations) > 0 {
		mmInfof.mock.t.Fatalf("Some expectations are already set for the Logger.Infof method")
	}

	mmInfof.mock.funcInfof = f
	return mmInfof.mock
}

// Infof implements Logger
func (mmInfof *LoggerMock) Infof(s1 string, p1 ...interface{}) {
	mm_atomic.AddUint64(&mmInfof.beforeInfofCounter, 1)
	defer mm_atomic.AddUint64(&mmInfof.afterInfofCounter, 1)

	if mmInfof.inspectFuncInfof != nil {
		mmInfof.inspectFuncInfof(s1, p1...)
	}

	params := &LoggerMockInfofParams{s1, p1}

	// Record call args
	mmInfof.InfofMock.mutex.Lock()
	mmInfof.InfofMock.callArgs = append(mmInfof.InfofMock.callArgs, params)
	mmInfof.InfofMock.mutex.Unlock()

	for _, e := range mmInfof.InfofMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmInfof.InfofMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInfof.InfofMock.defaultExpectation.Counter, 1)
		want := mmInfof.InfofMock.defaultExpectation.params
		got := LoggerMockInfofParams{s1, p1}
		if want != nil && !minimock.Equal(*want, got) {
			mmInfof.t.Errorf("LoggerMock.Infof got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmInfof.funcInfof != nil {
		mmInfof.funcInfof(s1, p1...)
		return
	}
	mmInfof.t.Fatalf("Unexpected call to LoggerMock.Infof. %v %v", s1, p1)

}

// InfofAfterCounter returns a count of finished LoggerMock.Infof invocations
func (mmInfof *LoggerMock) InfofAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfof.afterInfofCounter)
}

// InfofBeforeCounter returns a count of LoggerMock.Infof invocations
func (mmInfof *LoggerMock) InfofBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfof.beforeInfofCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Infof.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInfof *mLoggerMockInfof) Calls() []*LoggerMockInfofParams {
	mmInfof.mutex.RLock()

	argCopy := make([]*LoggerMockInfofParams, len(mmInfof.callArgs))
	copy(argCopy, mmInfof.callArgs)

	mmInfof.mutex.RUnlock()

	return argCopy
}

// MinimockInfofDone returns true if the count of the Infof invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockInfofDone() bool {
	for _, e := range m.InfofMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InfofMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInfofCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInfof != nil && mm_atomic.LoadUint64(&m.afterInfofCounter) < 1 {
		return false
	}
	return true
}

// MinimockInfofInspect logs each unmet expectation
func (m *LoggerMock) MinimockInfofInspect() {
	for _, e := range m.InfofMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Infof with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InfofMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInfofCounter) < 1 {
		if m.InfofMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Infof")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Infof with params: %#v", *m.InfofMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInfof != nil && mm_atomic.LoadUint64(&m.afterInfofCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Infof")
	}
}

type mLoggerMockIs struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockIsExpectation
	expectations       []*LoggerMockIsExpectation

	callArgs []*LoggerMockIsParams
	mutex    sync.RWMutex
}

// LoggerMockIsExpectation specifies expectation struct of the Logger.Is
type LoggerMockIsExpectation struct {
	mock    *LoggerMock
	params  *LoggerMockIsParams
	results *LoggerMockIsResults
	Counter uint64
}

// LoggerMockIsParams contains parameters of the Logger.Is
type LoggerMockIsParams struct {
	level LogLevel
}

// LoggerMockIsResults contains results of the Logger.Is
type LoggerMockIsResults struct {
	b1 bool
}

// Expect sets up expected params for Logger.Is
func (mmIs *mLoggerMockIs) Expect(level LogLevel) *mLoggerMockIs {
	if mmIs.mock.funcIs != nil {
		mmIs.mock.t.Fatalf("LoggerMock.Is mock is already set by Set")
	}

	if mmIs.defaultExpectation == nil {
		mmIs.defaultExpectation = &LoggerMockIsExpectation{}
	}

	mmIs.defaultExpectation.params = &LoggerMockIsParams{level}
	for _, e := range mmIs.expectations {
		if minimock.Equal(e.params, mmIs.defaultExpectation.params) {
			mmIs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIs.defaultExpectation.params)
		}
	}

	return mmIs
}

// Inspect accepts an inspector function that has same arguments as the Logger.Is
func (mmIs *mLoggerMockIs) Inspect(f func(level LogLevel)) *mLoggerMockIs {
	if mmIs.mock.inspectFuncIs != nil {
		mmIs.mock.t.Fatalf("Inspect function is already set for LoggerMock.Is")
	}

	mmIs.mock.inspectFuncIs = f

	return mmIs
}

// Return sets up results that will be returned by Logger.Is
func (mmIs *mLoggerMockIs) Return(b1 bool) *LoggerMock {
	if mmIs.mock.funcIs != nil {
		mmIs.mock.t.Fatalf("LoggerMock.Is mock is already set by Set")
	}

	if mmIs.defaultExpectation == nil {
		mmIs.defaultExpectation = &LoggerMockIsExpectation{mock: mmIs.mock}
	}
	mmIs.defaultExpectation.results = &LoggerMockIsResults{b1}
	return mmIs.mock
}

//Set uses given function f to mock the Logger.Is method
func (mmIs *mLoggerMockIs) Set(f func(level LogLevel) (b1 bool)) *LoggerMock {
	if mmIs.defaultExpectation != nil {
		mmIs.mock.t.Fatalf("Default expectation is already set for the Logger.Is method")
	}

	if len(mmIs.expectations) > 0 {
		mmIs.mock.t.Fatalf("Some expectations are already set for the Logger.Is method")
	}

	mmIs.mock.funcIs = f
	return mmIs.mock
}

// When sets expectation for the Logger.Is which will trigger the result defined by the following
// Then helper
func (mmIs *mLoggerMockIs) When(level LogLevel) *LoggerMockIsExpectation {
	if mmIs.mock.funcIs != nil {
		mmIs.mock.t.Fatalf("LoggerMock.Is mock is already set by Set")
	}

	expectation := &LoggerMockIsExpectation{
		mock:   mmIs.mock,
		params: &LoggerMockIsParams{level},
	}
	mmIs.expectations = append(mmIs.expectations, expectation)
	return expectation
}

// Then sets up Logger.Is return parameters for the expectation previously defined by the When method
func (e *LoggerMockIsExpectation) Then(b1 bool) *LoggerMock {
	e.results = &LoggerMockIsResults{b1}
	return e.mock
}

// Is implements Logger
func (mmIs *LoggerMock) Is(level LogLevel) (b1 bool) {
	mm_atomic.AddUint64(&mmIs.beforeIsCounter, 1)
	defer mm_atomic.AddUint64(&mmIs.afterIsCounter, 1)

	if mmIs.inspectFuncIs != nil {
		mmIs.inspectFuncIs(level)
	}

	params := &LoggerMockIsParams{level}

	// Record call args
	mmIs.IsMock.mutex.Lock()
	mmIs.IsMock.callArgs = append(mmIs.IsMock.callArgs, params)
	mmIs.IsMock.mutex.Unlock()

	for _, e := range mmIs.IsMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmIs.IsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIs.IsMock.defaultExpectation.Counter, 1)
		want := mmIs.IsMock.defaultExpectation.params
		got := LoggerMockIsParams{level}
		if want != nil && !minimock.Equal(*want, got) {
			mmIs.t.Errorf("LoggerMock.Is got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmIs.IsMock.defaultExpectation.results
		if results == nil {
			mmIs.t.Fatal("No results are set for the LoggerMock.Is")
		}
		return (*results).b1
	}
	if mmIs.funcIs != nil {
		return mmIs.funcIs(level)
	}
	mmIs.t.Fatalf("Unexpected call to LoggerMock.Is. %v", level)
	return
}

// IsAfterCounter returns a count of finished LoggerMock.Is invocations
func (mmIs *LoggerMock) IsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIs.afterIsCounter)
}

// IsBeforeCounter returns a count of LoggerMock.Is invocations
func (mmIs *LoggerMock) IsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIs.beforeIsCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Is.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIs *mLoggerMockIs) Calls() []*LoggerMockIsParams {
	mmIs.mutex.RLock()

	argCopy := make([]*LoggerMockIsParams, len(mmIs.callArgs))
	copy(argCopy, mmIs.callArgs)

	mmIs.mutex.RUnlock()

	return argCopy
}

// MinimockIsDone returns true if the count of the Is invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockIsDone() bool {
	for _, e := range m.IsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIs != nil && mm_atomic.LoadUint64(&m.afterIsCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsInspect logs each unmet expectation
func (m *LoggerMock) MinimockIsInspect() {
	for _, e := range m.IsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Is with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsCounter) < 1 {
		if m.IsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Is")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Is with params: %#v", *m.IsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIs != nil && mm_atomic.LoadUint64(&m.afterIsCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Is")
	}
}

type mLoggerMockPanic struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockPanicExpectation
	expectations       []*LoggerMockPanicExpectation

	callArgs []*LoggerMockPanicParams
	mutex    sync.RWMutex
}

// LoggerMockPanicExpectation specifies expectation struct of the Logger.Panic
type LoggerMockPanicExpectation struct {
	mock   *LoggerMock
	params *LoggerMockPanicParams

	Counter uint64
}

// LoggerMockPanicParams contains parameters of the Logger.Panic
type LoggerMockPanicParams struct {
	p1 []interface{}
}

// Expect sets up expected params for Logger.Panic
func (mmPanic *mLoggerMockPanic) Expect(p1 ...interface{}) *mLoggerMockPanic {
	if mmPanic.mock.funcPanic != nil {
		mmPanic.mock.t.Fatalf("LoggerMock.Panic mock is already set by Set")
	}

	if mmPanic.defaultExpectation == nil {
		mmPanic.defaultExpectation = &LoggerMockPanicExpectation{}
	}

	mmPanic.defaultExpectation.params = &LoggerMockPanicParams{p1}
	for _, e := range mmPanic.expectations {
		if minimock.Equal(e.params, mmPanic.defaultExpectation.params) {
			mmPanic.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPanic.defaultExpectation.params)
		}
	}

	return mmPanic
}

// Inspect accepts an inspector function that has same arguments as the Logger.Panic
func (mmPanic *mLoggerMockPanic) Inspect(f func(p1 ...interface{})) *mLoggerMockPanic {
	if mmPanic.mock.inspectFuncPanic != nil {
		mmPanic.mock.t.Fatalf("Inspect function is already set for LoggerMock.Panic")
	}

	mmPanic.mock.inspectFuncPanic = f

	return mmPanic
}

// Return sets up results that will be returned by Logger.Panic
func (mmPanic *mLoggerMockPanic) Return() *LoggerMock {
	if mmPanic.mock.funcPanic != nil {
		mmPanic.mock.t.Fatalf("LoggerMock.Panic mock is already set by Set")
	}

	if mmPanic.defaultExpectation == nil {
		mmPanic.defaultExpectation = &LoggerMockPanicExpectation{mock: mmPanic.mock}
	}

	return mmPanic.mock
}

//Set uses given function f to mock the Logger.Panic method
func (mmPanic *mLoggerMockPanic) Set(f func(p1 ...interface{})) *LoggerMock {
	if mmPanic.defaultExpectation != nil {
		mmPanic.mock.t.Fatalf("Default expectation is already set for the Logger.Panic method")
	}

	if len(mmPanic.expectations) > 0 {
		mmPanic.mock.t.Fatalf("Some expectations are already set for the Logger.Panic method")
	}

	mmPanic.mock.funcPanic = f
	return mmPanic.mock
}

// Panic implements Logger
func (mmPanic *LoggerMock) Panic(p1 ...interface{}) {
	mm_atomic.AddUint64(&mmPanic.beforePanicCounter, 1)
	defer mm_atomic.AddUint64(&mmPanic.afterPanicCounter, 1)

	if mmPanic.inspectFuncPanic != nil {
		mmPanic.inspectFuncPanic(p1...)
	}

	params := &LoggerMockPanicParams{p1}

	// Record call args
	mmPanic.PanicMock.mutex.Lock()
	mmPanic.PanicMock.callArgs = append(mmPanic.PanicMock.callArgs, params)
	mmPanic.PanicMock.mutex.Unlock()

	for _, e := range mmPanic.PanicMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmPanic.PanicMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPanic.PanicMock.defaultExpectation.Counter, 1)
		want := mmPanic.PanicMock.defaultExpectation.params
		got := LoggerMockPanicParams{p1}
		if want != nil && !minimock.Equal(*want, got) {
			mmPanic.t.Errorf("LoggerMock.Panic got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmPanic.funcPanic != nil {
		mmPanic.funcPanic(p1...)
		return
	}
	mmPanic.t.Fatalf("Unexpected call to LoggerMock.Panic. %v", p1)

}

// PanicAfterCounter returns a count of finished LoggerMock.Panic invocations
func (mmPanic *LoggerMock) PanicAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPanic.afterPanicCounter)
}

// PanicBeforeCounter returns a count of LoggerMock.Panic invocations
func (mmPanic *LoggerMock) PanicBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPanic.beforePanicCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Panic.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPanic *mLoggerMockPanic) Calls() []*LoggerMockPanicParams {
	mmPanic.mutex.RLock()

	argCopy := make([]*LoggerMockPanicParams, len(mmPanic.callArgs))
	copy(argCopy, mmPanic.callArgs)

	mmPanic.mutex.RUnlock()

	return argCopy
}

// MinimockPanicDone returns true if the count of the Panic invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockPanicDone() bool {
	for _, e := range m.PanicMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PanicMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPanicCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPanic != nil && mm_atomic.LoadUint64(&m.afterPanicCounter) < 1 {
		return false
	}
	return true
}

// MinimockPanicInspect logs each unmet expectation
func (m *LoggerMock) MinimockPanicInspect() {
	for _, e := range m.PanicMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Panic with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PanicMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPanicCounter) < 1 {
		if m.PanicMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Panic")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Panic with params: %#v", *m.PanicMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPanic != nil && mm_atomic.LoadUint64(&m.afterPanicCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Panic")
	}
}

type mLoggerMockPanicf struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockPanicfExpectation
	expectations       []*LoggerMockPanicfExpectation

	callArgs []*LoggerMockPanicfParams
	mutex    sync.RWMutex
}

// LoggerMockPanicfExpectation specifies expectation struct of the Logger.Panicf
type LoggerMockPanicfExpectation struct {
	mock   *LoggerMock
	params *LoggerMockPanicfParams

	Counter uint64
}

// LoggerMockPanicfParams contains parameters of the Logger.Panicf
type LoggerMockPanicfParams struct {
	s1 string
	p1 []interface{}
}

// Expect sets up expected params for Logger.Panicf
func (mmPanicf *mLoggerMockPanicf) Expect(s1 string, p1 ...interface{}) *mLoggerMockPanicf {
	if mmPanicf.mock.funcPanicf != nil {
		mmPanicf.mock.t.Fatalf("LoggerMock.Panicf mock is already set by Set")
	}

	if mmPanicf.defaultExpectation == nil {
		mmPanicf.defaultExpectation = &LoggerMockPanicfExpectation{}
	}

	mmPanicf.defaultExpectation.params = &LoggerMockPanicfParams{s1, p1}
	for _, e := range mmPanicf.expectations {
		if minimock.Equal(e.params, mmPanicf.defaultExpectation.params) {
			mmPanicf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPanicf.defaultExpectation.params)
		}
	}

	return mmPanicf
}

// Inspect accepts an inspector function that has same arguments as the Logger.Panicf
func (mmPanicf *mLoggerMockPanicf) Inspect(f func(s1 string, p1 ...interface{})) *mLoggerMockPanicf {
	if mmPanicf.mock.inspectFuncPanicf != nil {
		mmPanicf.mock.t.Fatalf("Inspect function is already set for LoggerMock.Panicf")
	}

	mmPanicf.mock.inspectFuncPanicf = f

	return mmPanicf
}

// Return sets up results that will be returned by Logger.Panicf
func (mmPanicf *mLoggerMockPanicf) Return() *LoggerMock {
	if mmPanicf.mock.funcPanicf != nil {
		mmPanicf.mock.t.Fatalf("LoggerMock.Panicf mock is already set by Set")
	}

	if mmPanicf.defaultExpectation == nil {
		mmPanicf.defaultExpectation = &LoggerMockPanicfExpectation{mock: mmPanicf.mock}
	}

	return mmPanicf.mock
}

//Set uses given function f to mock the Logger.Panicf method
func (mmPanicf *mLoggerMockPanicf) Set(f func(s1 string, p1 ...interface{})) *LoggerMock {
	if mmPanicf.defaultExpectation != nil {
		mmPanicf.mock.t.Fatalf("Default expectation is already set for the Logger.Panicf method")
	}

	if len(mmPanicf.expectations) > 0 {
		mmPanicf.mock.t.Fatalf("Some expectations are already set for the Logger.Panicf method")
	}

	mmPanicf.mock.funcPanicf = f
	return mmPanicf.mock
}

// Panicf implements Logger
func (mmPanicf *LoggerMock) Panicf(s1 string, p1 ...interface{}) {
	mm_atomic.AddUint64(&mmPanicf.beforePanicfCounter, 1)
	defer mm_atomic.AddUint64(&mmPanicf.afterPanicfCounter, 1)

	if mmPanicf.inspectFuncPanicf != nil {
		mmPanicf.inspectFuncPanicf(s1, p1...)
	}

	params := &LoggerMockPanicfParams{s1, p1}

	// Record call args
	mmPanicf.PanicfMock.mutex.Lock()
	mmPanicf.PanicfMock.callArgs = append(mmPanicf.PanicfMock.callArgs, params)
	mmPanicf.PanicfMock.mutex.Unlock()

	for _, e := range mmPanicf.PanicfMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmPanicf.PanicfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPanicf.PanicfMock.defaultExpectation.Counter, 1)
		want := mmPanicf.PanicfMock.defaultExpectation.params
		got := LoggerMockPanicfParams{s1, p1}
		if want != nil && !minimock.Equal(*want, got) {
			mmPanicf.t.Errorf("LoggerMock.Panicf got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmPanicf.funcPanicf != nil {
		mmPanicf.funcPanicf(s1, p1...)
		return
	}
	mmPanicf.t.Fatalf("Unexpected call to LoggerMock.Panicf. %v %v", s1, p1)

}

// PanicfAfterCounter returns a count of finished LoggerMock.Panicf invocations
func (mmPanicf *LoggerMock) PanicfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPanicf.afterPanicfCounter)
}

// PanicfBeforeCounter returns a count of LoggerMock.Panicf invocations
func (mmPanicf *LoggerMock) PanicfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPanicf.beforePanicfCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Panicf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPanicf *mLoggerMockPanicf) Calls() []*LoggerMockPanicfParams {
	mmPanicf.mutex.RLock()

	argCopy := make([]*LoggerMockPanicfParams, len(mmPanicf.callArgs))
	copy(argCopy, mmPanicf.callArgs)

	mmPanicf.mutex.RUnlock()

	return argCopy
}

// MinimockPanicfDone returns true if the count of the Panicf invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockPanicfDone() bool {
	for _, e := range m.PanicfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PanicfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPanicfCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPanicf != nil && mm_atomic.LoadUint64(&m.afterPanicfCounter) < 1 {
		return false
	}
	return true
}

// MinimockPanicfInspect logs each unmet expectation
func (m *LoggerMock) MinimockPanicfInspect() {
	for _, e := range m.PanicfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Panicf with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PanicfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPanicfCounter) < 1 {
		if m.PanicfMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Panicf")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Panicf with params: %#v", *m.PanicfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPanicf != nil && mm_atomic.LoadUint64(&m.afterPanicfCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Panicf")
	}
}

type mLoggerMockWarn struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockWarnExpectation
	expectations       []*LoggerMockWarnExpectation

	callArgs []*LoggerMockWarnParams
	mutex    sync.RWMutex
}

// LoggerMockWarnExpectation specifies expectation struct of the Logger.Warn
type LoggerMockWarnExpectation struct {
	mock   *LoggerMock
	params *LoggerMockWarnParams

	Counter uint64
}

// LoggerMockWarnParams contains parameters of the Logger.Warn
type LoggerMockWarnParams struct {
	p1 []interface{}
}

// Expect sets up expected params for Logger.Warn
func (mmWarn *mLoggerMockWarn) Expect(p1 ...interface{}) *mLoggerMockWarn {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Set")
	}

	if mmWarn.defaultExpectation == nil {
		mmWarn.defaultExpectation = &LoggerMockWarnExpectation{}
	}

	mmWarn.defaultExpectation.params = &LoggerMockWarnParams{p1}
	for _, e := range mmWarn.expectations {
		if minimock.Equal(e.params, mmWarn.defaultExpectation.params) {
			mmWarn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWarn.defaultExpectation.params)
		}
	}

	return mmWarn
}

// Inspect accepts an inspector function that has same arguments as the Logger.Warn
func (mmWarn *mLoggerMockWarn) Inspect(f func(p1 ...interface{})) *mLoggerMockWarn {
	if mmWarn.mock.inspectFuncWarn != nil {
		mmWarn.mock.t.Fatalf("Inspect function is already set for LoggerMock.Warn")
	}

	mmWarn.mock.inspectFuncWarn = f

	return mmWarn
}

// Return sets up results that will be returned by Logger.Warn
func (mmWarn *mLoggerMockWarn) Return() *LoggerMock {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Set")
	}

	if mmWarn.defaultExpectation == nil {
		mmWarn.defaultExpectation = &LoggerMockWarnExpectation{mock: mmWarn.mock}
	}

	return mmWarn.mock
}

//Set uses given function f to mock the Logger.Warn method
func (mmWarn *mLoggerMockWarn) Set(f func(p1 ...interface{})) *LoggerMock {
	if mmWarn.defaultExpectation != nil {
		mmWarn.mock.t.Fatalf("Default expectation is already set for the Logger.Warn method")
	}

	if len(mmWarn.expectations) > 0 {
		mmWarn.mock.t.Fatalf("Some expectations are already set for the Logger.Warn method")
	}

	mmWarn.mock.funcWarn = f
	return mmWarn.mock
}

// Warn implements Logger
func (mmWarn *LoggerMock) Warn(p1 ...interface{}) {
	mm_atomic.AddUint64(&mmWarn.beforeWarnCounter, 1)
	defer mm_atomic.AddUint64(&mmWarn.afterWarnCounter, 1)

	if mmWarn.inspectFuncWarn != nil {
		mmWarn.inspectFuncWarn(p1...)
	}

	params := &LoggerMockWarnParams{p1}

	// Record call args
	mmWarn.WarnMock.mutex.Lock()
	mmWarn.WarnMock.callArgs = append(mmWarn.WarnMock.callArgs, params)
	mmWarn.WarnMock.mutex.Unlock()

	for _, e := range mmWarn.WarnMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmWarn.WarnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWarn.WarnMock.defaultExpectation.Counter, 1)
		want := mmWarn.WarnMock.defaultExpectation.params
		got := LoggerMockWarnParams{p1}
		if want != nil && !minimock.Equal(*want, got) {
			mmWarn.t.Errorf("LoggerMock.Warn got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmWarn.funcWarn != nil {
		mmWarn.funcWarn(p1...)
		return
	}
	mmWarn.t.Fatalf("Unexpected call to LoggerMock.Warn. %v", p1)

}

// WarnAfterCounter returns a count of finished LoggerMock.Warn invocations
func (mmWarn *LoggerMock) WarnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarn.afterWarnCounter)
}

// WarnBeforeCounter returns a count of LoggerMock.Warn invocations
func (mmWarn *LoggerMock) WarnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarn.beforeWarnCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Warn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWarn *mLoggerMockWarn) Calls() []*LoggerMockWarnParams {
	mmWarn.mutex.RLock()

	argCopy := make([]*LoggerMockWarnParams, len(mmWarn.callArgs))
	copy(argCopy, mmWarn.callArgs)

	mmWarn.mutex.RUnlock()

	return argCopy
}

// MinimockWarnDone returns true if the count of the Warn invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockWarnDone() bool {
	for _, e := range m.WarnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WarnMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWarnCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWarn != nil && mm_atomic.LoadUint64(&m.afterWarnCounter) < 1 {
		return false
	}
	return true
}

// MinimockWarnInspect logs each unmet expectation
func (m *LoggerMock) MinimockWarnInspect() {
	for _, e := range m.WarnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Warn with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WarnMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWarnCounter) < 1 {
		if m.WarnMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Warn")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Warn with params: %#v", *m.WarnMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWarn != nil && mm_atomic.LoadUint64(&m.afterWarnCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Warn")
	}
}

type mLoggerMockWarnf struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockWarnfExpectation
	expectations       []*LoggerMockWarnfExpectation

	callArgs []*LoggerMockWarnfParams
	mutex    sync.RWMutex
}

// LoggerMockWarnfExpectation specifies expectation struct of the Logger.Warnf
type LoggerMockWarnfExpectation struct {
	mock   *LoggerMock
	params *LoggerMockWarnfParams

	Counter uint64
}

// LoggerMockWarnfParams contains parameters of the Logger.Warnf
type LoggerMockWarnfParams struct {
	s1 string
	p1 []interface{}
}

// Expect sets up expected params for Logger.Warnf
func (mmWarnf *mLoggerMockWarnf) Expect(s1 string, p1 ...interface{}) *mLoggerMockWarnf {
	if mmWarnf.mock.funcWarnf != nil {
		mmWarnf.mock.t.Fatalf("LoggerMock.Warnf mock is already set by Set")
	}

	if mmWarnf.defaultExpectation == nil {
		mmWarnf.defaultExpectation = &LoggerMockWarnfExpectation{}
	}

	mmWarnf.defaultExpectation.params = &LoggerMockWarnfParams{s1, p1}
	for _, e := range mmWarnf.expectations {
		if minimock.Equal(e.params, mmWarnf.defaultExpectation.params) {
			mmWarnf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWarnf.defaultExpectation.params)
		}
	}

	return mmWarnf
}

// Inspect accepts an inspector function that has same arguments as the Logger.Warnf
func (mmWarnf *mLoggerMockWarnf) Inspect(f func(s1 string, p1 ...interface{})) *mLoggerMockWarnf {
	if mmWarnf.mock.inspectFuncWarnf != nil {
		mmWarnf.mock.t.Fatalf("Inspect function is already set for LoggerMock.Warnf")
	}

	mmWarnf.mock.inspectFuncWarnf = f

	return mmWarnf
}

// Return sets up results that will be returned by Logger.Warnf
func (mmWarnf *mLoggerMockWarnf) Return() *LoggerMock {
	if mmWarnf.mock.funcWarnf != nil {
		mmWarnf.mock.t.Fatalf("LoggerMock.Warnf mock is already set by Set")
	}

	if mmWarnf.defaultExpectation == nil {
		mmWarnf.defaultExpectation = &LoggerMockWarnfExpectation{mock: mmWarnf.mock}
	}

	return mmWarnf.mock
}

//Set uses given function f to mock the Logger.Warnf method
func (mmWarnf *mLoggerMockWarnf) Set(f func(s1 string, p1 ...interface{})) *LoggerMock {
	if mmWarnf.defaultExpectation != nil {
		mmWarnf.mock.t.Fatalf("Default expectation is already set for the Logger.Warnf method")
	}

	if len(mmWarnf.expectations) > 0 {
		mmWarnf.mock.t.Fatalf("Some expectations are already set for the Logger.Warnf method")
	}

	mmWarnf.mock.funcWarnf = f
	return mmWarnf.mock
}

// Warnf implements Logger
func (mmWarnf *LoggerMock) Warnf(s1 string, p1 ...interface{}) {
	mm_atomic.AddUint64(&mmWarnf.beforeWarnfCounter, 1)
	defer mm_atomic.AddUint64(&mmWarnf.afterWarnfCounter, 1)

	if mmWarnf.inspectFuncWarnf != nil {
		mmWarnf.inspectFuncWarnf(s1, p1...)
	}

	params := &LoggerMockWarnfParams{s1, p1}

	// Record call args
	mmWarnf.WarnfMock.mutex.Lock()
	mmWarnf.WarnfMock.callArgs = append(mmWarnf.WarnfMock.callArgs, params)
	mmWarnf.WarnfMock.mutex.Unlock()

	for _, e := range mmWarnf.WarnfMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmWarnf.WarnfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWarnf.WarnfMock.defaultExpectation.Counter, 1)
		want := mmWarnf.WarnfMock.defaultExpectation.params
		got := LoggerMockWarnfParams{s1, p1}
		if want != nil && !minimock.Equal(*want, got) {
			mmWarnf.t.Errorf("LoggerMock.Warnf got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmWarnf.funcWarnf != nil {
		mmWarnf.funcWarnf(s1, p1...)
		return
	}
	mmWarnf.t.Fatalf("Unexpected call to LoggerMock.Warnf. %v %v", s1, p1)

}

// WarnfAfterCounter returns a count of finished LoggerMock.Warnf invocations
func (mmWarnf *LoggerMock) WarnfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarnf.afterWarnfCounter)
}

// WarnfBeforeCounter returns a count of LoggerMock.Warnf invocations
func (mmWarnf *LoggerMock) WarnfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarnf.beforeWarnfCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Warnf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWarnf *mLoggerMockWarnf) Calls() []*LoggerMockWarnfParams {
	mmWarnf.mutex.RLock()

	argCopy := make([]*LoggerMockWarnfParams, len(mmWarnf.callArgs))
	copy(argCopy, mmWarnf.callArgs)

	mmWarnf.mutex.RUnlock()

	return argCopy
}

// MinimockWarnfDone returns true if the count of the Warnf invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockWarnfDone() bool {
	for _, e := range m.WarnfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WarnfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWarnfCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWarnf != nil && mm_atomic.LoadUint64(&m.afterWarnfCounter) < 1 {
		return false
	}
	return true
}

// MinimockWarnfInspect logs each unmet expectation
func (m *LoggerMock) MinimockWarnfInspect() {
	for _, e := range m.WarnfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Warnf with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WarnfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWarnfCounter) < 1 {
		if m.WarnfMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.Warnf")
		} else {
			m.t.Errorf("Expected call to LoggerMock.Warnf with params: %#v", *m.WarnfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWarnf != nil && mm_atomic.LoadUint64(&m.afterWarnfCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.Warnf")
	}
}

type mLoggerMockWithCaller struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockWithCallerExpectation
	expectations       []*LoggerMockWithCallerExpectation

	callArgs []*LoggerMockWithCallerParams
	mutex    sync.RWMutex
}

// LoggerMockWithCallerExpectation specifies expectation struct of the Logger.WithCaller
type LoggerMockWithCallerExpectation struct {
	mock    *LoggerMock
	params  *LoggerMockWithCallerParams
	results *LoggerMockWithCallerResults
	Counter uint64
}

// LoggerMockWithCallerParams contains parameters of the Logger.WithCaller
type LoggerMockWithCallerParams struct {
	flag bool
}

// LoggerMockWithCallerResults contains results of the Logger.WithCaller
type LoggerMockWithCallerResults struct {
	l1 Logger
}

// Expect sets up expected params for Logger.WithCaller
func (mmWithCaller *mLoggerMockWithCaller) Expect(flag bool) *mLoggerMockWithCaller {
	if mmWithCaller.mock.funcWithCaller != nil {
		mmWithCaller.mock.t.Fatalf("LoggerMock.WithCaller mock is already set by Set")
	}

	if mmWithCaller.defaultExpectation == nil {
		mmWithCaller.defaultExpectation = &LoggerMockWithCallerExpectation{}
	}

	mmWithCaller.defaultExpectation.params = &LoggerMockWithCallerParams{flag}
	for _, e := range mmWithCaller.expectations {
		if minimock.Equal(e.params, mmWithCaller.defaultExpectation.params) {
			mmWithCaller.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWithCaller.defaultExpectation.params)
		}
	}

	return mmWithCaller
}

// Inspect accepts an inspector function that has same arguments as the Logger.WithCaller
func (mmWithCaller *mLoggerMockWithCaller) Inspect(f func(flag bool)) *mLoggerMockWithCaller {
	if mmWithCaller.mock.inspectFuncWithCaller != nil {
		mmWithCaller.mock.t.Fatalf("Inspect function is already set for LoggerMock.WithCaller")
	}

	mmWithCaller.mock.inspectFuncWithCaller = f

	return mmWithCaller
}

// Return sets up results that will be returned by Logger.WithCaller
func (mmWithCaller *mLoggerMockWithCaller) Return(l1 Logger) *LoggerMock {
	if mmWithCaller.mock.funcWithCaller != nil {
		mmWithCaller.mock.t.Fatalf("LoggerMock.WithCaller mock is already set by Set")
	}

	if mmWithCaller.defaultExpectation == nil {
		mmWithCaller.defaultExpectation = &LoggerMockWithCallerExpectation{mock: mmWithCaller.mock}
	}
	mmWithCaller.defaultExpectation.results = &LoggerMockWithCallerResults{l1}
	return mmWithCaller.mock
}

//Set uses given function f to mock the Logger.WithCaller method
func (mmWithCaller *mLoggerMockWithCaller) Set(f func(flag bool) (l1 Logger)) *LoggerMock {
	if mmWithCaller.defaultExpectation != nil {
		mmWithCaller.mock.t.Fatalf("Default expectation is already set for the Logger.WithCaller method")
	}

	if len(mmWithCaller.expectations) > 0 {
		mmWithCaller.mock.t.Fatalf("Some expectations are already set for the Logger.WithCaller method")
	}

	mmWithCaller.mock.funcWithCaller = f
	return mmWithCaller.mock
}

// When sets expectation for the Logger.WithCaller which will trigger the result defined by the following
// Then helper
func (mmWithCaller *mLoggerMockWithCaller) When(flag bool) *LoggerMockWithCallerExpectation {
	if mmWithCaller.mock.funcWithCaller != nil {
		mmWithCaller.mock.t.Fatalf("LoggerMock.WithCaller mock is already set by Set")
	}

	expectation := &LoggerMockWithCallerExpectation{
		mock:   mmWithCaller.mock,
		params: &LoggerMockWithCallerParams{flag},
	}
	mmWithCaller.expectations = append(mmWithCaller.expectations, expectation)
	return expectation
}

// Then sets up Logger.WithCaller return parameters for the expectation previously defined by the When method
func (e *LoggerMockWithCallerExpectation) Then(l1 Logger) *LoggerMock {
	e.results = &LoggerMockWithCallerResults{l1}
	return e.mock
}

// WithCaller implements Logger
func (mmWithCaller *LoggerMock) WithCaller(flag bool) (l1 Logger) {
	mm_atomic.AddUint64(&mmWithCaller.beforeWithCallerCounter, 1)
	defer mm_atomic.AddUint64(&mmWithCaller.afterWithCallerCounter, 1)

	if mmWithCaller.inspectFuncWithCaller != nil {
		mmWithCaller.inspectFuncWithCaller(flag)
	}

	params := &LoggerMockWithCallerParams{flag}

	// Record call args
	mmWithCaller.WithCallerMock.mutex.Lock()
	mmWithCaller.WithCallerMock.callArgs = append(mmWithCaller.WithCallerMock.callArgs, params)
	mmWithCaller.WithCallerMock.mutex.Unlock()

	for _, e := range mmWithCaller.WithCallerMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.l1
		}
	}

	if mmWithCaller.WithCallerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWithCaller.WithCallerMock.defaultExpectation.Counter, 1)
		want := mmWithCaller.WithCallerMock.defaultExpectation.params
		got := LoggerMockWithCallerParams{flag}
		if want != nil && !minimock.Equal(*want, got) {
			mmWithCaller.t.Errorf("LoggerMock.WithCaller got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmWithCaller.WithCallerMock.defaultExpectation.results
		if results == nil {
			mmWithCaller.t.Fatal("No results are set for the LoggerMock.WithCaller")
		}
		return (*results).l1
	}
	if mmWithCaller.funcWithCaller != nil {
		return mmWithCaller.funcWithCaller(flag)
	}
	mmWithCaller.t.Fatalf("Unexpected call to LoggerMock.WithCaller. %v", flag)
	return
}

// WithCallerAfterCounter returns a count of finished LoggerMock.WithCaller invocations
func (mmWithCaller *LoggerMock) WithCallerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithCaller.afterWithCallerCounter)
}

// WithCallerBeforeCounter returns a count of LoggerMock.WithCaller invocations
func (mmWithCaller *LoggerMock) WithCallerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithCaller.beforeWithCallerCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.WithCaller.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWithCaller *mLoggerMockWithCaller) Calls() []*LoggerMockWithCallerParams {
	mmWithCaller.mutex.RLock()

	argCopy := make([]*LoggerMockWithCallerParams, len(mmWithCaller.callArgs))
	copy(argCopy, mmWithCaller.callArgs)

	mmWithCaller.mutex.RUnlock()

	return argCopy
}

// MinimockWithCallerDone returns true if the count of the WithCaller invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockWithCallerDone() bool {
	for _, e := range m.WithCallerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithCallerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithCallerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithCaller != nil && mm_atomic.LoadUint64(&m.afterWithCallerCounter) < 1 {
		return false
	}
	return true
}

// MinimockWithCallerInspect logs each unmet expectation
func (m *LoggerMock) MinimockWithCallerInspect() {
	for _, e := range m.WithCallerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.WithCaller with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithCallerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithCallerCounter) < 1 {
		if m.WithCallerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.WithCaller")
		} else {
			m.t.Errorf("Expected call to LoggerMock.WithCaller with params: %#v", *m.WithCallerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithCaller != nil && mm_atomic.LoadUint64(&m.afterWithCallerCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.WithCaller")
	}
}

type mLoggerMockWithField struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockWithFieldExpectation
	expectations       []*LoggerMockWithFieldExpectation

	callArgs []*LoggerMockWithFieldParams
	mutex    sync.RWMutex
}

// LoggerMockWithFieldExpectation specifies expectation struct of the Logger.WithField
type LoggerMockWithFieldExpectation struct {
	mock    *LoggerMock
	params  *LoggerMockWithFieldParams
	results *LoggerMockWithFieldResults
	Counter uint64
}

// LoggerMockWithFieldParams contains parameters of the Logger.WithField
type LoggerMockWithFieldParams struct {
	s1 string
	p1 interface{}
}

// LoggerMockWithFieldResults contains results of the Logger.WithField
type LoggerMockWithFieldResults struct {
	l1 Logger
}

// Expect sets up expected params for Logger.WithField
func (mmWithField *mLoggerMockWithField) Expect(s1 string, p1 interface{}) *mLoggerMockWithField {
	if mmWithField.mock.funcWithField != nil {
		mmWithField.mock.t.Fatalf("LoggerMock.WithField mock is already set by Set")
	}

	if mmWithField.defaultExpectation == nil {
		mmWithField.defaultExpectation = &LoggerMockWithFieldExpectation{}
	}

	mmWithField.defaultExpectation.params = &LoggerMockWithFieldParams{s1, p1}
	for _, e := range mmWithField.expectations {
		if minimock.Equal(e.params, mmWithField.defaultExpectation.params) {
			mmWithField.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWithField.defaultExpectation.params)
		}
	}

	return mmWithField
}

// Inspect accepts an inspector function that has same arguments as the Logger.WithField
func (mmWithField *mLoggerMockWithField) Inspect(f func(s1 string, p1 interface{})) *mLoggerMockWithField {
	if mmWithField.mock.inspectFuncWithField != nil {
		mmWithField.mock.t.Fatalf("Inspect function is already set for LoggerMock.WithField")
	}

	mmWithField.mock.inspectFuncWithField = f

	return mmWithField
}

// Return sets up results that will be returned by Logger.WithField
func (mmWithField *mLoggerMockWithField) Return(l1 Logger) *LoggerMock {
	if mmWithField.mock.funcWithField != nil {
		mmWithField.mock.t.Fatalf("LoggerMock.WithField mock is already set by Set")
	}

	if mmWithField.defaultExpectation == nil {
		mmWithField.defaultExpectation = &LoggerMockWithFieldExpectation{mock: mmWithField.mock}
	}
	mmWithField.defaultExpectation.results = &LoggerMockWithFieldResults{l1}
	return mmWithField.mock
}

//Set uses given function f to mock the Logger.WithField method
func (mmWithField *mLoggerMockWithField) Set(f func(s1 string, p1 interface{}) (l1 Logger)) *LoggerMock {
	if mmWithField.defaultExpectation != nil {
		mmWithField.mock.t.Fatalf("Default expectation is already set for the Logger.WithField method")
	}

	if len(mmWithField.expectations) > 0 {
		mmWithField.mock.t.Fatalf("Some expectations are already set for the Logger.WithField method")
	}

	mmWithField.mock.funcWithField = f
	return mmWithField.mock
}

// When sets expectation for the Logger.WithField which will trigger the result defined by the following
// Then helper
func (mmWithField *mLoggerMockWithField) When(s1 string, p1 interface{}) *LoggerMockWithFieldExpectation {
	if mmWithField.mock.funcWithField != nil {
		mmWithField.mock.t.Fatalf("LoggerMock.WithField mock is already set by Set")
	}

	expectation := &LoggerMockWithFieldExpectation{
		mock:   mmWithField.mock,
		params: &LoggerMockWithFieldParams{s1, p1},
	}
	mmWithField.expectations = append(mmWithField.expectations, expectation)
	return expectation
}

// Then sets up Logger.WithField return parameters for the expectation previously defined by the When method
func (e *LoggerMockWithFieldExpectation) Then(l1 Logger) *LoggerMock {
	e.results = &LoggerMockWithFieldResults{l1}
	return e.mock
}

// WithField implements Logger
func (mmWithField *LoggerMock) WithField(s1 string, p1 interface{}) (l1 Logger) {
	mm_atomic.AddUint64(&mmWithField.beforeWithFieldCounter, 1)
	defer mm_atomic.AddUint64(&mmWithField.afterWithFieldCounter, 1)

	if mmWithField.inspectFuncWithField != nil {
		mmWithField.inspectFuncWithField(s1, p1)
	}

	params := &LoggerMockWithFieldParams{s1, p1}

	// Record call args
	mmWithField.WithFieldMock.mutex.Lock()
	mmWithField.WithFieldMock.callArgs = append(mmWithField.WithFieldMock.callArgs, params)
	mmWithField.WithFieldMock.mutex.Unlock()

	for _, e := range mmWithField.WithFieldMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.l1
		}
	}

	if mmWithField.WithFieldMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWithField.WithFieldMock.defaultExpectation.Counter, 1)
		want := mmWithField.WithFieldMock.defaultExpectation.params
		got := LoggerMockWithFieldParams{s1, p1}
		if want != nil && !minimock.Equal(*want, got) {
			mmWithField.t.Errorf("LoggerMock.WithField got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmWithField.WithFieldMock.defaultExpectation.results
		if results == nil {
			mmWithField.t.Fatal("No results are set for the LoggerMock.WithField")
		}
		return (*results).l1
	}
	if mmWithField.funcWithField != nil {
		return mmWithField.funcWithField(s1, p1)
	}
	mmWithField.t.Fatalf("Unexpected call to LoggerMock.WithField. %v %v", s1, p1)
	return
}

// WithFieldAfterCounter returns a count of finished LoggerMock.WithField invocations
func (mmWithField *LoggerMock) WithFieldAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithField.afterWithFieldCounter)
}

// WithFieldBeforeCounter returns a count of LoggerMock.WithField invocations
func (mmWithField *LoggerMock) WithFieldBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithField.beforeWithFieldCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.WithField.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWithField *mLoggerMockWithField) Calls() []*LoggerMockWithFieldParams {
	mmWithField.mutex.RLock()

	argCopy := make([]*LoggerMockWithFieldParams, len(mmWithField.callArgs))
	copy(argCopy, mmWithField.callArgs)

	mmWithField.mutex.RUnlock()

	return argCopy
}

// MinimockWithFieldDone returns true if the count of the WithField invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockWithFieldDone() bool {
	for _, e := range m.WithFieldMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithFieldMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithFieldCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithField != nil && mm_atomic.LoadUint64(&m.afterWithFieldCounter) < 1 {
		return false
	}
	return true
}

// MinimockWithFieldInspect logs each unmet expectation
func (m *LoggerMock) MinimockWithFieldInspect() {
	for _, e := range m.WithFieldMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.WithField with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithFieldMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithFieldCounter) < 1 {
		if m.WithFieldMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.WithField")
		} else {
			m.t.Errorf("Expected call to LoggerMock.WithField with params: %#v", *m.WithFieldMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithField != nil && mm_atomic.LoadUint64(&m.afterWithFieldCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.WithField")
	}
}

type mLoggerMockWithFields struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockWithFieldsExpectation
	expectations       []*LoggerMockWithFieldsExpectation

	callArgs []*LoggerMockWithFieldsParams
	mutex    sync.RWMutex
}

// LoggerMockWithFieldsExpectation specifies expectation struct of the Logger.WithFields
type LoggerMockWithFieldsExpectation struct {
	mock    *LoggerMock
	params  *LoggerMockWithFieldsParams
	results *LoggerMockWithFieldsResults
	Counter uint64
}

// LoggerMockWithFieldsParams contains parameters of the Logger.WithFields
type LoggerMockWithFieldsParams struct {
	m1 map[string]interface{}
}

// LoggerMockWithFieldsResults contains results of the Logger.WithFields
type LoggerMockWithFieldsResults struct {
	l1 Logger
}

// Expect sets up expected params for Logger.WithFields
func (mmWithFields *mLoggerMockWithFields) Expect(m1 map[string]interface{}) *mLoggerMockWithFields {
	if mmWithFields.mock.funcWithFields != nil {
		mmWithFields.mock.t.Fatalf("LoggerMock.WithFields mock is already set by Set")
	}

	if mmWithFields.defaultExpectation == nil {
		mmWithFields.defaultExpectation = &LoggerMockWithFieldsExpectation{}
	}

	mmWithFields.defaultExpectation.params = &LoggerMockWithFieldsParams{m1}
	for _, e := range mmWithFields.expectations {
		if minimock.Equal(e.params, mmWithFields.defaultExpectation.params) {
			mmWithFields.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWithFields.defaultExpectation.params)
		}
	}

	return mmWithFields
}

// Inspect accepts an inspector function that has same arguments as the Logger.WithFields
func (mmWithFields *mLoggerMockWithFields) Inspect(f func(m1 map[string]interface{})) *mLoggerMockWithFields {
	if mmWithFields.mock.inspectFuncWithFields != nil {
		mmWithFields.mock.t.Fatalf("Inspect function is already set for LoggerMock.WithFields")
	}

	mmWithFields.mock.inspectFuncWithFields = f

	return mmWithFields
}

// Return sets up results that will be returned by Logger.WithFields
func (mmWithFields *mLoggerMockWithFields) Return(l1 Logger) *LoggerMock {
	if mmWithFields.mock.funcWithFields != nil {
		mmWithFields.mock.t.Fatalf("LoggerMock.WithFields mock is already set by Set")
	}

	if mmWithFields.defaultExpectation == nil {
		mmWithFields.defaultExpectation = &LoggerMockWithFieldsExpectation{mock: mmWithFields.mock}
	}
	mmWithFields.defaultExpectation.results = &LoggerMockWithFieldsResults{l1}
	return mmWithFields.mock
}

//Set uses given function f to mock the Logger.WithFields method
func (mmWithFields *mLoggerMockWithFields) Set(f func(m1 map[string]interface{}) (l1 Logger)) *LoggerMock {
	if mmWithFields.defaultExpectation != nil {
		mmWithFields.mock.t.Fatalf("Default expectation is already set for the Logger.WithFields method")
	}

	if len(mmWithFields.expectations) > 0 {
		mmWithFields.mock.t.Fatalf("Some expectations are already set for the Logger.WithFields method")
	}

	mmWithFields.mock.funcWithFields = f
	return mmWithFields.mock
}

// When sets expectation for the Logger.WithFields which will trigger the result defined by the following
// Then helper
func (mmWithFields *mLoggerMockWithFields) When(m1 map[string]interface{}) *LoggerMockWithFieldsExpectation {
	if mmWithFields.mock.funcWithFields != nil {
		mmWithFields.mock.t.Fatalf("LoggerMock.WithFields mock is already set by Set")
	}

	expectation := &LoggerMockWithFieldsExpectation{
		mock:   mmWithFields.mock,
		params: &LoggerMockWithFieldsParams{m1},
	}
	mmWithFields.expectations = append(mmWithFields.expectations, expectation)
	return expectation
}

// Then sets up Logger.WithFields return parameters for the expectation previously defined by the When method
func (e *LoggerMockWithFieldsExpectation) Then(l1 Logger) *LoggerMock {
	e.results = &LoggerMockWithFieldsResults{l1}
	return e.mock
}

// WithFields implements Logger
func (mmWithFields *LoggerMock) WithFields(m1 map[string]interface{}) (l1 Logger) {
	mm_atomic.AddUint64(&mmWithFields.beforeWithFieldsCounter, 1)
	defer mm_atomic.AddUint64(&mmWithFields.afterWithFieldsCounter, 1)

	if mmWithFields.inspectFuncWithFields != nil {
		mmWithFields.inspectFuncWithFields(m1)
	}

	params := &LoggerMockWithFieldsParams{m1}

	// Record call args
	mmWithFields.WithFieldsMock.mutex.Lock()
	mmWithFields.WithFieldsMock.callArgs = append(mmWithFields.WithFieldsMock.callArgs, params)
	mmWithFields.WithFieldsMock.mutex.Unlock()

	for _, e := range mmWithFields.WithFieldsMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.l1
		}
	}

	if mmWithFields.WithFieldsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWithFields.WithFieldsMock.defaultExpectation.Counter, 1)
		want := mmWithFields.WithFieldsMock.defaultExpectation.params
		got := LoggerMockWithFieldsParams{m1}
		if want != nil && !minimock.Equal(*want, got) {
			mmWithFields.t.Errorf("LoggerMock.WithFields got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmWithFields.WithFieldsMock.defaultExpectation.results
		if results == nil {
			mmWithFields.t.Fatal("No results are set for the LoggerMock.WithFields")
		}
		return (*results).l1
	}
	if mmWithFields.funcWithFields != nil {
		return mmWithFields.funcWithFields(m1)
	}
	mmWithFields.t.Fatalf("Unexpected call to LoggerMock.WithFields. %v", m1)
	return
}

// WithFieldsAfterCounter returns a count of finished LoggerMock.WithFields invocations
func (mmWithFields *LoggerMock) WithFieldsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithFields.afterWithFieldsCounter)
}

// WithFieldsBeforeCounter returns a count of LoggerMock.WithFields invocations
func (mmWithFields *LoggerMock) WithFieldsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithFields.beforeWithFieldsCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.WithFields.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWithFields *mLoggerMockWithFields) Calls() []*LoggerMockWithFieldsParams {
	mmWithFields.mutex.RLock()

	argCopy := make([]*LoggerMockWithFieldsParams, len(mmWithFields.callArgs))
	copy(argCopy, mmWithFields.callArgs)

	mmWithFields.mutex.RUnlock()

	return argCopy
}

// MinimockWithFieldsDone returns true if the count of the WithFields invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockWithFieldsDone() bool {
	for _, e := range m.WithFieldsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithFieldsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithFieldsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithFields != nil && mm_atomic.LoadUint64(&m.afterWithFieldsCounter) < 1 {
		return false
	}
	return true
}

// MinimockWithFieldsInspect logs each unmet expectation
func (m *LoggerMock) MinimockWithFieldsInspect() {
	for _, e := range m.WithFieldsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.WithFields with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithFieldsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithFieldsCounter) < 1 {
		if m.WithFieldsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.WithFields")
		} else {
			m.t.Errorf("Expected call to LoggerMock.WithFields with params: %#v", *m.WithFieldsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithFields != nil && mm_atomic.LoadUint64(&m.afterWithFieldsCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.WithFields")
	}
}

type mLoggerMockWithFormat struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockWithFormatExpectation
	expectations       []*LoggerMockWithFormatExpectation

	callArgs []*LoggerMockWithFormatParams
	mutex    sync.RWMutex
}

// LoggerMockWithFormatExpectation specifies expectation struct of the Logger.WithFormat
type LoggerMockWithFormatExpectation struct {
	mock    *LoggerMock
	params  *LoggerMockWithFormatParams
	results *LoggerMockWithFormatResults
	Counter uint64
}

// LoggerMockWithFormatParams contains parameters of the Logger.WithFormat
type LoggerMockWithFormatParams struct {
	format LogFormat
}

// LoggerMockWithFormatResults contains results of the Logger.WithFormat
type LoggerMockWithFormatResults struct {
	l1  Logger
	err error
}

// Expect sets up expected params for Logger.WithFormat
func (mmWithFormat *mLoggerMockWithFormat) Expect(format LogFormat) *mLoggerMockWithFormat {
	if mmWithFormat.mock.funcWithFormat != nil {
		mmWithFormat.mock.t.Fatalf("LoggerMock.WithFormat mock is already set by Set")
	}

	if mmWithFormat.defaultExpectation == nil {
		mmWithFormat.defaultExpectation = &LoggerMockWithFormatExpectation{}
	}

	mmWithFormat.defaultExpectation.params = &LoggerMockWithFormatParams{format}
	for _, e := range mmWithFormat.expectations {
		if minimock.Equal(e.params, mmWithFormat.defaultExpectation.params) {
			mmWithFormat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWithFormat.defaultExpectation.params)
		}
	}

	return mmWithFormat
}

// Inspect accepts an inspector function that has same arguments as the Logger.WithFormat
func (mmWithFormat *mLoggerMockWithFormat) Inspect(f func(format LogFormat)) *mLoggerMockWithFormat {
	if mmWithFormat.mock.inspectFuncWithFormat != nil {
		mmWithFormat.mock.t.Fatalf("Inspect function is already set for LoggerMock.WithFormat")
	}

	mmWithFormat.mock.inspectFuncWithFormat = f

	return mmWithFormat
}

// Return sets up results that will be returned by Logger.WithFormat
func (mmWithFormat *mLoggerMockWithFormat) Return(l1 Logger, err error) *LoggerMock {
	if mmWithFormat.mock.funcWithFormat != nil {
		mmWithFormat.mock.t.Fatalf("LoggerMock.WithFormat mock is already set by Set")
	}

	if mmWithFormat.defaultExpectation == nil {
		mmWithFormat.defaultExpectation = &LoggerMockWithFormatExpectation{mock: mmWithFormat.mock}
	}
	mmWithFormat.defaultExpectation.results = &LoggerMockWithFormatResults{l1, err}
	return mmWithFormat.mock
}

//Set uses given function f to mock the Logger.WithFormat method
func (mmWithFormat *mLoggerMockWithFormat) Set(f func(format LogFormat) (l1 Logger, err error)) *LoggerMock {
	if mmWithFormat.defaultExpectation != nil {
		mmWithFormat.mock.t.Fatalf("Default expectation is already set for the Logger.WithFormat method")
	}

	if len(mmWithFormat.expectations) > 0 {
		mmWithFormat.mock.t.Fatalf("Some expectations are already set for the Logger.WithFormat method")
	}

	mmWithFormat.mock.funcWithFormat = f
	return mmWithFormat.mock
}

// When sets expectation for the Logger.WithFormat which will trigger the result defined by the following
// Then helper
func (mmWithFormat *mLoggerMockWithFormat) When(format LogFormat) *LoggerMockWithFormatExpectation {
	if mmWithFormat.mock.funcWithFormat != nil {
		mmWithFormat.mock.t.Fatalf("LoggerMock.WithFormat mock is already set by Set")
	}

	expectation := &LoggerMockWithFormatExpectation{
		mock:   mmWithFormat.mock,
		params: &LoggerMockWithFormatParams{format},
	}
	mmWithFormat.expectations = append(mmWithFormat.expectations, expectation)
	return expectation
}

// Then sets up Logger.WithFormat return parameters for the expectation previously defined by the When method
func (e *LoggerMockWithFormatExpectation) Then(l1 Logger, err error) *LoggerMock {
	e.results = &LoggerMockWithFormatResults{l1, err}
	return e.mock
}

// WithFormat implements Logger
func (mmWithFormat *LoggerMock) WithFormat(format LogFormat) (l1 Logger, err error) {
	mm_atomic.AddUint64(&mmWithFormat.beforeWithFormatCounter, 1)
	defer mm_atomic.AddUint64(&mmWithFormat.afterWithFormatCounter, 1)

	if mmWithFormat.inspectFuncWithFormat != nil {
		mmWithFormat.inspectFuncWithFormat(format)
	}

	params := &LoggerMockWithFormatParams{format}

	// Record call args
	mmWithFormat.WithFormatMock.mutex.Lock()
	mmWithFormat.WithFormatMock.callArgs = append(mmWithFormat.WithFormatMock.callArgs, params)
	mmWithFormat.WithFormatMock.mutex.Unlock()

	for _, e := range mmWithFormat.WithFormatMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.l1, e.results.err
		}
	}

	if mmWithFormat.WithFormatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWithFormat.WithFormatMock.defaultExpectation.Counter, 1)
		want := mmWithFormat.WithFormatMock.defaultExpectation.params
		got := LoggerMockWithFormatParams{format}
		if want != nil && !minimock.Equal(*want, got) {
			mmWithFormat.t.Errorf("LoggerMock.WithFormat got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmWithFormat.WithFormatMock.defaultExpectation.results
		if results == nil {
			mmWithFormat.t.Fatal("No results are set for the LoggerMock.WithFormat")
		}
		return (*results).l1, (*results).err
	}
	if mmWithFormat.funcWithFormat != nil {
		return mmWithFormat.funcWithFormat(format)
	}
	mmWithFormat.t.Fatalf("Unexpected call to LoggerMock.WithFormat. %v", format)
	return
}

// WithFormatAfterCounter returns a count of finished LoggerMock.WithFormat invocations
func (mmWithFormat *LoggerMock) WithFormatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithFormat.afterWithFormatCounter)
}

// WithFormatBeforeCounter returns a count of LoggerMock.WithFormat invocations
func (mmWithFormat *LoggerMock) WithFormatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithFormat.beforeWithFormatCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.WithFormat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWithFormat *mLoggerMockWithFormat) Calls() []*LoggerMockWithFormatParams {
	mmWithFormat.mutex.RLock()

	argCopy := make([]*LoggerMockWithFormatParams, len(mmWithFormat.callArgs))
	copy(argCopy, mmWithFormat.callArgs)

	mmWithFormat.mutex.RUnlock()

	return argCopy
}

// MinimockWithFormatDone returns true if the count of the WithFormat invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockWithFormatDone() bool {
	for _, e := range m.WithFormatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithFormatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithFormatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithFormat != nil && mm_atomic.LoadUint64(&m.afterWithFormatCounter) < 1 {
		return false
	}
	return true
}

// MinimockWithFormatInspect logs each unmet expectation
func (m *LoggerMock) MinimockWithFormatInspect() {
	for _, e := range m.WithFormatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.WithFormat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithFormatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithFormatCounter) < 1 {
		if m.WithFormatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.WithFormat")
		} else {
			m.t.Errorf("Expected call to LoggerMock.WithFormat with params: %#v", *m.WithFormatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithFormat != nil && mm_atomic.LoadUint64(&m.afterWithFormatCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.WithFormat")
	}
}

type mLoggerMockWithFuncName struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockWithFuncNameExpectation
	expectations       []*LoggerMockWithFuncNameExpectation

	callArgs []*LoggerMockWithFuncNameParams
	mutex    sync.RWMutex
}

// LoggerMockWithFuncNameExpectation specifies expectation struct of the Logger.WithFuncName
type LoggerMockWithFuncNameExpectation struct {
	mock    *LoggerMock
	params  *LoggerMockWithFuncNameParams
	results *LoggerMockWithFuncNameResults
	Counter uint64
}

// LoggerMockWithFuncNameParams contains parameters of the Logger.WithFuncName
type LoggerMockWithFuncNameParams struct {
	flag bool
}

// LoggerMockWithFuncNameResults contains results of the Logger.WithFuncName
type LoggerMockWithFuncNameResults struct {
	l1 Logger
}

// Expect sets up expected params for Logger.WithFuncName
func (mmWithFuncName *mLoggerMockWithFuncName) Expect(flag bool) *mLoggerMockWithFuncName {
	if mmWithFuncName.mock.funcWithFuncName != nil {
		mmWithFuncName.mock.t.Fatalf("LoggerMock.WithFuncName mock is already set by Set")
	}

	if mmWithFuncName.defaultExpectation == nil {
		mmWithFuncName.defaultExpectation = &LoggerMockWithFuncNameExpectation{}
	}

	mmWithFuncName.defaultExpectation.params = &LoggerMockWithFuncNameParams{flag}
	for _, e := range mmWithFuncName.expectations {
		if minimock.Equal(e.params, mmWithFuncName.defaultExpectation.params) {
			mmWithFuncName.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWithFuncName.defaultExpectation.params)
		}
	}

	return mmWithFuncName
}

// Inspect accepts an inspector function that has same arguments as the Logger.WithFuncName
func (mmWithFuncName *mLoggerMockWithFuncName) Inspect(f func(flag bool)) *mLoggerMockWithFuncName {
	if mmWithFuncName.mock.inspectFuncWithFuncName != nil {
		mmWithFuncName.mock.t.Fatalf("Inspect function is already set for LoggerMock.WithFuncName")
	}

	mmWithFuncName.mock.inspectFuncWithFuncName = f

	return mmWithFuncName
}

// Return sets up results that will be returned by Logger.WithFuncName
func (mmWithFuncName *mLoggerMockWithFuncName) Return(l1 Logger) *LoggerMock {
	if mmWithFuncName.mock.funcWithFuncName != nil {
		mmWithFuncName.mock.t.Fatalf("LoggerMock.WithFuncName mock is already set by Set")
	}

	if mmWithFuncName.defaultExpectation == nil {
		mmWithFuncName.defaultExpectation = &LoggerMockWithFuncNameExpectation{mock: mmWithFuncName.mock}
	}
	mmWithFuncName.defaultExpectation.results = &LoggerMockWithFuncNameResults{l1}
	return mmWithFuncName.mock
}

//Set uses given function f to mock the Logger.WithFuncName method
func (mmWithFuncName *mLoggerMockWithFuncName) Set(f func(flag bool) (l1 Logger)) *LoggerMock {
	if mmWithFuncName.defaultExpectation != nil {
		mmWithFuncName.mock.t.Fatalf("Default expectation is already set for the Logger.WithFuncName method")
	}

	if len(mmWithFuncName.expectations) > 0 {
		mmWithFuncName.mock.t.Fatalf("Some expectations are already set for the Logger.WithFuncName method")
	}

	mmWithFuncName.mock.funcWithFuncName = f
	return mmWithFuncName.mock
}

// When sets expectation for the Logger.WithFuncName which will trigger the result defined by the following
// Then helper
func (mmWithFuncName *mLoggerMockWithFuncName) When(flag bool) *LoggerMockWithFuncNameExpectation {
	if mmWithFuncName.mock.funcWithFuncName != nil {
		mmWithFuncName.mock.t.Fatalf("LoggerMock.WithFuncName mock is already set by Set")
	}

	expectation := &LoggerMockWithFuncNameExpectation{
		mock:   mmWithFuncName.mock,
		params: &LoggerMockWithFuncNameParams{flag},
	}
	mmWithFuncName.expectations = append(mmWithFuncName.expectations, expectation)
	return expectation
}

// Then sets up Logger.WithFuncName return parameters for the expectation previously defined by the When method
func (e *LoggerMockWithFuncNameExpectation) Then(l1 Logger) *LoggerMock {
	e.results = &LoggerMockWithFuncNameResults{l1}
	return e.mock
}

// WithFuncName implements Logger
func (mmWithFuncName *LoggerMock) WithFuncName(flag bool) (l1 Logger) {
	mm_atomic.AddUint64(&mmWithFuncName.beforeWithFuncNameCounter, 1)
	defer mm_atomic.AddUint64(&mmWithFuncName.afterWithFuncNameCounter, 1)

	if mmWithFuncName.inspectFuncWithFuncName != nil {
		mmWithFuncName.inspectFuncWithFuncName(flag)
	}

	params := &LoggerMockWithFuncNameParams{flag}

	// Record call args
	mmWithFuncName.WithFuncNameMock.mutex.Lock()
	mmWithFuncName.WithFuncNameMock.callArgs = append(mmWithFuncName.WithFuncNameMock.callArgs, params)
	mmWithFuncName.WithFuncNameMock.mutex.Unlock()

	for _, e := range mmWithFuncName.WithFuncNameMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.l1
		}
	}

	if mmWithFuncName.WithFuncNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWithFuncName.WithFuncNameMock.defaultExpectation.Counter, 1)
		want := mmWithFuncName.WithFuncNameMock.defaultExpectation.params
		got := LoggerMockWithFuncNameParams{flag}
		if want != nil && !minimock.Equal(*want, got) {
			mmWithFuncName.t.Errorf("LoggerMock.WithFuncName got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmWithFuncName.WithFuncNameMock.defaultExpectation.results
		if results == nil {
			mmWithFuncName.t.Fatal("No results are set for the LoggerMock.WithFuncName")
		}
		return (*results).l1
	}
	if mmWithFuncName.funcWithFuncName != nil {
		return mmWithFuncName.funcWithFuncName(flag)
	}
	mmWithFuncName.t.Fatalf("Unexpected call to LoggerMock.WithFuncName. %v", flag)
	return
}

// WithFuncNameAfterCounter returns a count of finished LoggerMock.WithFuncName invocations
func (mmWithFuncName *LoggerMock) WithFuncNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithFuncName.afterWithFuncNameCounter)
}

// WithFuncNameBeforeCounter returns a count of LoggerMock.WithFuncName invocations
func (mmWithFuncName *LoggerMock) WithFuncNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithFuncName.beforeWithFuncNameCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.WithFuncName.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWithFuncName *mLoggerMockWithFuncName) Calls() []*LoggerMockWithFuncNameParams {
	mmWithFuncName.mutex.RLock()

	argCopy := make([]*LoggerMockWithFuncNameParams, len(mmWithFuncName.callArgs))
	copy(argCopy, mmWithFuncName.callArgs)

	mmWithFuncName.mutex.RUnlock()

	return argCopy
}

// MinimockWithFuncNameDone returns true if the count of the WithFuncName invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockWithFuncNameDone() bool {
	for _, e := range m.WithFuncNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithFuncNameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithFuncNameCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithFuncName != nil && mm_atomic.LoadUint64(&m.afterWithFuncNameCounter) < 1 {
		return false
	}
	return true
}

// MinimockWithFuncNameInspect logs each unmet expectation
func (m *LoggerMock) MinimockWithFuncNameInspect() {
	for _, e := range m.WithFuncNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.WithFuncName with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithFuncNameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithFuncNameCounter) < 1 {
		if m.WithFuncNameMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.WithFuncName")
		} else {
			m.t.Errorf("Expected call to LoggerMock.WithFuncName with params: %#v", *m.WithFuncNameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithFuncName != nil && mm_atomic.LoadUint64(&m.afterWithFuncNameCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.WithFuncName")
	}
}

type mLoggerMockWithLevel struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockWithLevelExpectation
	expectations       []*LoggerMockWithLevelExpectation

	callArgs []*LoggerMockWithLevelParams
	mutex    sync.RWMutex
}

// LoggerMockWithLevelExpectation specifies expectation struct of the Logger.WithLevel
type LoggerMockWithLevelExpectation struct {
	mock    *LoggerMock
	params  *LoggerMockWithLevelParams
	results *LoggerMockWithLevelResults
	Counter uint64
}

// LoggerMockWithLevelParams contains parameters of the Logger.WithLevel
type LoggerMockWithLevelParams struct {
	s1 string
}

// LoggerMockWithLevelResults contains results of the Logger.WithLevel
type LoggerMockWithLevelResults struct {
	l1  Logger
	err error
}

// Expect sets up expected params for Logger.WithLevel
func (mmWithLevel *mLoggerMockWithLevel) Expect(s1 string) *mLoggerMockWithLevel {
	if mmWithLevel.mock.funcWithLevel != nil {
		mmWithLevel.mock.t.Fatalf("LoggerMock.WithLevel mock is already set by Set")
	}

	if mmWithLevel.defaultExpectation == nil {
		mmWithLevel.defaultExpectation = &LoggerMockWithLevelExpectation{}
	}

	mmWithLevel.defaultExpectation.params = &LoggerMockWithLevelParams{s1}
	for _, e := range mmWithLevel.expectations {
		if minimock.Equal(e.params, mmWithLevel.defaultExpectation.params) {
			mmWithLevel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWithLevel.defaultExpectation.params)
		}
	}

	return mmWithLevel
}

// Inspect accepts an inspector function that has same arguments as the Logger.WithLevel
func (mmWithLevel *mLoggerMockWithLevel) Inspect(f func(s1 string)) *mLoggerMockWithLevel {
	if mmWithLevel.mock.inspectFuncWithLevel != nil {
		mmWithLevel.mock.t.Fatalf("Inspect function is already set for LoggerMock.WithLevel")
	}

	mmWithLevel.mock.inspectFuncWithLevel = f

	return mmWithLevel
}

// Return sets up results that will be returned by Logger.WithLevel
func (mmWithLevel *mLoggerMockWithLevel) Return(l1 Logger, err error) *LoggerMock {
	if mmWithLevel.mock.funcWithLevel != nil {
		mmWithLevel.mock.t.Fatalf("LoggerMock.WithLevel mock is already set by Set")
	}

	if mmWithLevel.defaultExpectation == nil {
		mmWithLevel.defaultExpectation = &LoggerMockWithLevelExpectation{mock: mmWithLevel.mock}
	}
	mmWithLevel.defaultExpectation.results = &LoggerMockWithLevelResults{l1, err}
	return mmWithLevel.mock
}

//Set uses given function f to mock the Logger.WithLevel method
func (mmWithLevel *mLoggerMockWithLevel) Set(f func(s1 string) (l1 Logger, err error)) *LoggerMock {
	if mmWithLevel.defaultExpectation != nil {
		mmWithLevel.mock.t.Fatalf("Default expectation is already set for the Logger.WithLevel method")
	}

	if len(mmWithLevel.expectations) > 0 {
		mmWithLevel.mock.t.Fatalf("Some expectations are already set for the Logger.WithLevel method")
	}

	mmWithLevel.mock.funcWithLevel = f
	return mmWithLevel.mock
}

// When sets expectation for the Logger.WithLevel which will trigger the result defined by the following
// Then helper
func (mmWithLevel *mLoggerMockWithLevel) When(s1 string) *LoggerMockWithLevelExpectation {
	if mmWithLevel.mock.funcWithLevel != nil {
		mmWithLevel.mock.t.Fatalf("LoggerMock.WithLevel mock is already set by Set")
	}

	expectation := &LoggerMockWithLevelExpectation{
		mock:   mmWithLevel.mock,
		params: &LoggerMockWithLevelParams{s1},
	}
	mmWithLevel.expectations = append(mmWithLevel.expectations, expectation)
	return expectation
}

// Then sets up Logger.WithLevel return parameters for the expectation previously defined by the When method
func (e *LoggerMockWithLevelExpectation) Then(l1 Logger, err error) *LoggerMock {
	e.results = &LoggerMockWithLevelResults{l1, err}
	return e.mock
}

// WithLevel implements Logger
func (mmWithLevel *LoggerMock) WithLevel(s1 string) (l1 Logger, err error) {
	mm_atomic.AddUint64(&mmWithLevel.beforeWithLevelCounter, 1)
	defer mm_atomic.AddUint64(&mmWithLevel.afterWithLevelCounter, 1)

	if mmWithLevel.inspectFuncWithLevel != nil {
		mmWithLevel.inspectFuncWithLevel(s1)
	}

	params := &LoggerMockWithLevelParams{s1}

	// Record call args
	mmWithLevel.WithLevelMock.mutex.Lock()
	mmWithLevel.WithLevelMock.callArgs = append(mmWithLevel.WithLevelMock.callArgs, params)
	mmWithLevel.WithLevelMock.mutex.Unlock()

	for _, e := range mmWithLevel.WithLevelMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.l1, e.results.err
		}
	}

	if mmWithLevel.WithLevelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWithLevel.WithLevelMock.defaultExpectation.Counter, 1)
		want := mmWithLevel.WithLevelMock.defaultExpectation.params
		got := LoggerMockWithLevelParams{s1}
		if want != nil && !minimock.Equal(*want, got) {
			mmWithLevel.t.Errorf("LoggerMock.WithLevel got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmWithLevel.WithLevelMock.defaultExpectation.results
		if results == nil {
			mmWithLevel.t.Fatal("No results are set for the LoggerMock.WithLevel")
		}
		return (*results).l1, (*results).err
	}
	if mmWithLevel.funcWithLevel != nil {
		return mmWithLevel.funcWithLevel(s1)
	}
	mmWithLevel.t.Fatalf("Unexpected call to LoggerMock.WithLevel. %v", s1)
	return
}

// WithLevelAfterCounter returns a count of finished LoggerMock.WithLevel invocations
func (mmWithLevel *LoggerMock) WithLevelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithLevel.afterWithLevelCounter)
}

// WithLevelBeforeCounter returns a count of LoggerMock.WithLevel invocations
func (mmWithLevel *LoggerMock) WithLevelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithLevel.beforeWithLevelCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.WithLevel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWithLevel *mLoggerMockWithLevel) Calls() []*LoggerMockWithLevelParams {
	mmWithLevel.mutex.RLock()

	argCopy := make([]*LoggerMockWithLevelParams, len(mmWithLevel.callArgs))
	copy(argCopy, mmWithLevel.callArgs)

	mmWithLevel.mutex.RUnlock()

	return argCopy
}

// MinimockWithLevelDone returns true if the count of the WithLevel invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockWithLevelDone() bool {
	for _, e := range m.WithLevelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithLevelMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithLevelCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithLevel != nil && mm_atomic.LoadUint64(&m.afterWithLevelCounter) < 1 {
		return false
	}
	return true
}

// MinimockWithLevelInspect logs each unmet expectation
func (m *LoggerMock) MinimockWithLevelInspect() {
	for _, e := range m.WithLevelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.WithLevel with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithLevelMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithLevelCounter) < 1 {
		if m.WithLevelMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.WithLevel")
		} else {
			m.t.Errorf("Expected call to LoggerMock.WithLevel with params: %#v", *m.WithLevelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithLevel != nil && mm_atomic.LoadUint64(&m.afterWithLevelCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.WithLevel")
	}
}

type mLoggerMockWithLevelNumber struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockWithLevelNumberExpectation
	expectations       []*LoggerMockWithLevelNumberExpectation

	callArgs []*LoggerMockWithLevelNumberParams
	mutex    sync.RWMutex
}

// LoggerMockWithLevelNumberExpectation specifies expectation struct of the Logger.WithLevelNumber
type LoggerMockWithLevelNumberExpectation struct {
	mock    *LoggerMock
	params  *LoggerMockWithLevelNumberParams
	results *LoggerMockWithLevelNumberResults
	Counter uint64
}

// LoggerMockWithLevelNumberParams contains parameters of the Logger.WithLevelNumber
type LoggerMockWithLevelNumberParams struct {
	level LogLevel
}

// LoggerMockWithLevelNumberResults contains results of the Logger.WithLevelNumber
type LoggerMockWithLevelNumberResults struct {
	l1  Logger
	err error
}

// Expect sets up expected params for Logger.WithLevelNumber
func (mmWithLevelNumber *mLoggerMockWithLevelNumber) Expect(level LogLevel) *mLoggerMockWithLevelNumber {
	if mmWithLevelNumber.mock.funcWithLevelNumber != nil {
		mmWithLevelNumber.mock.t.Fatalf("LoggerMock.WithLevelNumber mock is already set by Set")
	}

	if mmWithLevelNumber.defaultExpectation == nil {
		mmWithLevelNumber.defaultExpectation = &LoggerMockWithLevelNumberExpectation{}
	}

	mmWithLevelNumber.defaultExpectation.params = &LoggerMockWithLevelNumberParams{level}
	for _, e := range mmWithLevelNumber.expectations {
		if minimock.Equal(e.params, mmWithLevelNumber.defaultExpectation.params) {
			mmWithLevelNumber.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWithLevelNumber.defaultExpectation.params)
		}
	}

	return mmWithLevelNumber
}

// Inspect accepts an inspector function that has same arguments as the Logger.WithLevelNumber
func (mmWithLevelNumber *mLoggerMockWithLevelNumber) Inspect(f func(level LogLevel)) *mLoggerMockWithLevelNumber {
	if mmWithLevelNumber.mock.inspectFuncWithLevelNumber != nil {
		mmWithLevelNumber.mock.t.Fatalf("Inspect function is already set for LoggerMock.WithLevelNumber")
	}

	mmWithLevelNumber.mock.inspectFuncWithLevelNumber = f

	return mmWithLevelNumber
}

// Return sets up results that will be returned by Logger.WithLevelNumber
func (mmWithLevelNumber *mLoggerMockWithLevelNumber) Return(l1 Logger, err error) *LoggerMock {
	if mmWithLevelNumber.mock.funcWithLevelNumber != nil {
		mmWithLevelNumber.mock.t.Fatalf("LoggerMock.WithLevelNumber mock is already set by Set")
	}

	if mmWithLevelNumber.defaultExpectation == nil {
		mmWithLevelNumber.defaultExpectation = &LoggerMockWithLevelNumberExpectation{mock: mmWithLevelNumber.mock}
	}
	mmWithLevelNumber.defaultExpectation.results = &LoggerMockWithLevelNumberResults{l1, err}
	return mmWithLevelNumber.mock
}

//Set uses given function f to mock the Logger.WithLevelNumber method
func (mmWithLevelNumber *mLoggerMockWithLevelNumber) Set(f func(level LogLevel) (l1 Logger, err error)) *LoggerMock {
	if mmWithLevelNumber.defaultExpectation != nil {
		mmWithLevelNumber.mock.t.Fatalf("Default expectation is already set for the Logger.WithLevelNumber method")
	}

	if len(mmWithLevelNumber.expectations) > 0 {
		mmWithLevelNumber.mock.t.Fatalf("Some expectations are already set for the Logger.WithLevelNumber method")
	}

	mmWithLevelNumber.mock.funcWithLevelNumber = f
	return mmWithLevelNumber.mock
}

// When sets expectation for the Logger.WithLevelNumber which will trigger the result defined by the following
// Then helper
func (mmWithLevelNumber *mLoggerMockWithLevelNumber) When(level LogLevel) *LoggerMockWithLevelNumberExpectation {
	if mmWithLevelNumber.mock.funcWithLevelNumber != nil {
		mmWithLevelNumber.mock.t.Fatalf("LoggerMock.WithLevelNumber mock is already set by Set")
	}

	expectation := &LoggerMockWithLevelNumberExpectation{
		mock:   mmWithLevelNumber.mock,
		params: &LoggerMockWithLevelNumberParams{level},
	}
	mmWithLevelNumber.expectations = append(mmWithLevelNumber.expectations, expectation)
	return expectation
}

// Then sets up Logger.WithLevelNumber return parameters for the expectation previously defined by the When method
func (e *LoggerMockWithLevelNumberExpectation) Then(l1 Logger, err error) *LoggerMock {
	e.results = &LoggerMockWithLevelNumberResults{l1, err}
	return e.mock
}

// WithLevelNumber implements Logger
func (mmWithLevelNumber *LoggerMock) WithLevelNumber(level LogLevel) (l1 Logger, err error) {
	mm_atomic.AddUint64(&mmWithLevelNumber.beforeWithLevelNumberCounter, 1)
	defer mm_atomic.AddUint64(&mmWithLevelNumber.afterWithLevelNumberCounter, 1)

	if mmWithLevelNumber.inspectFuncWithLevelNumber != nil {
		mmWithLevelNumber.inspectFuncWithLevelNumber(level)
	}

	params := &LoggerMockWithLevelNumberParams{level}

	// Record call args
	mmWithLevelNumber.WithLevelNumberMock.mutex.Lock()
	mmWithLevelNumber.WithLevelNumberMock.callArgs = append(mmWithLevelNumber.WithLevelNumberMock.callArgs, params)
	mmWithLevelNumber.WithLevelNumberMock.mutex.Unlock()

	for _, e := range mmWithLevelNumber.WithLevelNumberMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.l1, e.results.err
		}
	}

	if mmWithLevelNumber.WithLevelNumberMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWithLevelNumber.WithLevelNumberMock.defaultExpectation.Counter, 1)
		want := mmWithLevelNumber.WithLevelNumberMock.defaultExpectation.params
		got := LoggerMockWithLevelNumberParams{level}
		if want != nil && !minimock.Equal(*want, got) {
			mmWithLevelNumber.t.Errorf("LoggerMock.WithLevelNumber got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmWithLevelNumber.WithLevelNumberMock.defaultExpectation.results
		if results == nil {
			mmWithLevelNumber.t.Fatal("No results are set for the LoggerMock.WithLevelNumber")
		}
		return (*results).l1, (*results).err
	}
	if mmWithLevelNumber.funcWithLevelNumber != nil {
		return mmWithLevelNumber.funcWithLevelNumber(level)
	}
	mmWithLevelNumber.t.Fatalf("Unexpected call to LoggerMock.WithLevelNumber. %v", level)
	return
}

// WithLevelNumberAfterCounter returns a count of finished LoggerMock.WithLevelNumber invocations
func (mmWithLevelNumber *LoggerMock) WithLevelNumberAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithLevelNumber.afterWithLevelNumberCounter)
}

// WithLevelNumberBeforeCounter returns a count of LoggerMock.WithLevelNumber invocations
func (mmWithLevelNumber *LoggerMock) WithLevelNumberBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithLevelNumber.beforeWithLevelNumberCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.WithLevelNumber.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWithLevelNumber *mLoggerMockWithLevelNumber) Calls() []*LoggerMockWithLevelNumberParams {
	mmWithLevelNumber.mutex.RLock()

	argCopy := make([]*LoggerMockWithLevelNumberParams, len(mmWithLevelNumber.callArgs))
	copy(argCopy, mmWithLevelNumber.callArgs)

	mmWithLevelNumber.mutex.RUnlock()

	return argCopy
}

// MinimockWithLevelNumberDone returns true if the count of the WithLevelNumber invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockWithLevelNumberDone() bool {
	for _, e := range m.WithLevelNumberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithLevelNumberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithLevelNumberCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithLevelNumber != nil && mm_atomic.LoadUint64(&m.afterWithLevelNumberCounter) < 1 {
		return false
	}
	return true
}

// MinimockWithLevelNumberInspect logs each unmet expectation
func (m *LoggerMock) MinimockWithLevelNumberInspect() {
	for _, e := range m.WithLevelNumberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.WithLevelNumber with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithLevelNumberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithLevelNumberCounter) < 1 {
		if m.WithLevelNumberMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.WithLevelNumber")
		} else {
			m.t.Errorf("Expected call to LoggerMock.WithLevelNumber with params: %#v", *m.WithLevelNumberMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithLevelNumber != nil && mm_atomic.LoadUint64(&m.afterWithLevelNumberCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.WithLevelNumber")
	}
}

type mLoggerMockWithOutput struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockWithOutputExpectation
	expectations       []*LoggerMockWithOutputExpectation

	callArgs []*LoggerMockWithOutputParams
	mutex    sync.RWMutex
}

// LoggerMockWithOutputExpectation specifies expectation struct of the Logger.WithOutput
type LoggerMockWithOutputExpectation struct {
	mock    *LoggerMock
	params  *LoggerMockWithOutputParams
	results *LoggerMockWithOutputResults
	Counter uint64
}

// LoggerMockWithOutputParams contains parameters of the Logger.WithOutput
type LoggerMockWithOutputParams struct {
	w io.Writer
}

// LoggerMockWithOutputResults contains results of the Logger.WithOutput
type LoggerMockWithOutputResults struct {
	l1 Logger
}

// Expect sets up expected params for Logger.WithOutput
func (mmWithOutput *mLoggerMockWithOutput) Expect(w io.Writer) *mLoggerMockWithOutput {
	if mmWithOutput.mock.funcWithOutput != nil {
		mmWithOutput.mock.t.Fatalf("LoggerMock.WithOutput mock is already set by Set")
	}

	if mmWithOutput.defaultExpectation == nil {
		mmWithOutput.defaultExpectation = &LoggerMockWithOutputExpectation{}
	}

	mmWithOutput.defaultExpectation.params = &LoggerMockWithOutputParams{w}
	for _, e := range mmWithOutput.expectations {
		if minimock.Equal(e.params, mmWithOutput.defaultExpectation.params) {
			mmWithOutput.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWithOutput.defaultExpectation.params)
		}
	}

	return mmWithOutput
}

// Inspect accepts an inspector function that has same arguments as the Logger.WithOutput
func (mmWithOutput *mLoggerMockWithOutput) Inspect(f func(w io.Writer)) *mLoggerMockWithOutput {
	if mmWithOutput.mock.inspectFuncWithOutput != nil {
		mmWithOutput.mock.t.Fatalf("Inspect function is already set for LoggerMock.WithOutput")
	}

	mmWithOutput.mock.inspectFuncWithOutput = f

	return mmWithOutput
}

// Return sets up results that will be returned by Logger.WithOutput
func (mmWithOutput *mLoggerMockWithOutput) Return(l1 Logger) *LoggerMock {
	if mmWithOutput.mock.funcWithOutput != nil {
		mmWithOutput.mock.t.Fatalf("LoggerMock.WithOutput mock is already set by Set")
	}

	if mmWithOutput.defaultExpectation == nil {
		mmWithOutput.defaultExpectation = &LoggerMockWithOutputExpectation{mock: mmWithOutput.mock}
	}
	mmWithOutput.defaultExpectation.results = &LoggerMockWithOutputResults{l1}
	return mmWithOutput.mock
}

//Set uses given function f to mock the Logger.WithOutput method
func (mmWithOutput *mLoggerMockWithOutput) Set(f func(w io.Writer) (l1 Logger)) *LoggerMock {
	if mmWithOutput.defaultExpectation != nil {
		mmWithOutput.mock.t.Fatalf("Default expectation is already set for the Logger.WithOutput method")
	}

	if len(mmWithOutput.expectations) > 0 {
		mmWithOutput.mock.t.Fatalf("Some expectations are already set for the Logger.WithOutput method")
	}

	mmWithOutput.mock.funcWithOutput = f
	return mmWithOutput.mock
}

// When sets expectation for the Logger.WithOutput which will trigger the result defined by the following
// Then helper
func (mmWithOutput *mLoggerMockWithOutput) When(w io.Writer) *LoggerMockWithOutputExpectation {
	if mmWithOutput.mock.funcWithOutput != nil {
		mmWithOutput.mock.t.Fatalf("LoggerMock.WithOutput mock is already set by Set")
	}

	expectation := &LoggerMockWithOutputExpectation{
		mock:   mmWithOutput.mock,
		params: &LoggerMockWithOutputParams{w},
	}
	mmWithOutput.expectations = append(mmWithOutput.expectations, expectation)
	return expectation
}

// Then sets up Logger.WithOutput return parameters for the expectation previously defined by the When method
func (e *LoggerMockWithOutputExpectation) Then(l1 Logger) *LoggerMock {
	e.results = &LoggerMockWithOutputResults{l1}
	return e.mock
}

// WithOutput implements Logger
func (mmWithOutput *LoggerMock) WithOutput(w io.Writer) (l1 Logger) {
	mm_atomic.AddUint64(&mmWithOutput.beforeWithOutputCounter, 1)
	defer mm_atomic.AddUint64(&mmWithOutput.afterWithOutputCounter, 1)

	if mmWithOutput.inspectFuncWithOutput != nil {
		mmWithOutput.inspectFuncWithOutput(w)
	}

	params := &LoggerMockWithOutputParams{w}

	// Record call args
	mmWithOutput.WithOutputMock.mutex.Lock()
	mmWithOutput.WithOutputMock.callArgs = append(mmWithOutput.WithOutputMock.callArgs, params)
	mmWithOutput.WithOutputMock.mutex.Unlock()

	for _, e := range mmWithOutput.WithOutputMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.l1
		}
	}

	if mmWithOutput.WithOutputMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWithOutput.WithOutputMock.defaultExpectation.Counter, 1)
		want := mmWithOutput.WithOutputMock.defaultExpectation.params
		got := LoggerMockWithOutputParams{w}
		if want != nil && !minimock.Equal(*want, got) {
			mmWithOutput.t.Errorf("LoggerMock.WithOutput got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmWithOutput.WithOutputMock.defaultExpectation.results
		if results == nil {
			mmWithOutput.t.Fatal("No results are set for the LoggerMock.WithOutput")
		}
		return (*results).l1
	}
	if mmWithOutput.funcWithOutput != nil {
		return mmWithOutput.funcWithOutput(w)
	}
	mmWithOutput.t.Fatalf("Unexpected call to LoggerMock.WithOutput. %v", w)
	return
}

// WithOutputAfterCounter returns a count of finished LoggerMock.WithOutput invocations
func (mmWithOutput *LoggerMock) WithOutputAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithOutput.afterWithOutputCounter)
}

// WithOutputBeforeCounter returns a count of LoggerMock.WithOutput invocations
func (mmWithOutput *LoggerMock) WithOutputBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithOutput.beforeWithOutputCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.WithOutput.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWithOutput *mLoggerMockWithOutput) Calls() []*LoggerMockWithOutputParams {
	mmWithOutput.mutex.RLock()

	argCopy := make([]*LoggerMockWithOutputParams, len(mmWithOutput.callArgs))
	copy(argCopy, mmWithOutput.callArgs)

	mmWithOutput.mutex.RUnlock()

	return argCopy
}

// MinimockWithOutputDone returns true if the count of the WithOutput invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockWithOutputDone() bool {
	for _, e := range m.WithOutputMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithOutputMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithOutputCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithOutput != nil && mm_atomic.LoadUint64(&m.afterWithOutputCounter) < 1 {
		return false
	}
	return true
}

// MinimockWithOutputInspect logs each unmet expectation
func (m *LoggerMock) MinimockWithOutputInspect() {
	for _, e := range m.WithOutputMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.WithOutput with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithOutputMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithOutputCounter) < 1 {
		if m.WithOutputMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.WithOutput")
		} else {
			m.t.Errorf("Expected call to LoggerMock.WithOutput with params: %#v", *m.WithOutputMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithOutput != nil && mm_atomic.LoadUint64(&m.afterWithOutputCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.WithOutput")
	}
}

type mLoggerMockWithSkipFrameCount struct {
	mock               *LoggerMock
	defaultExpectation *LoggerMockWithSkipFrameCountExpectation
	expectations       []*LoggerMockWithSkipFrameCountExpectation

	callArgs []*LoggerMockWithSkipFrameCountParams
	mutex    sync.RWMutex
}

// LoggerMockWithSkipFrameCountExpectation specifies expectation struct of the Logger.WithSkipFrameCount
type LoggerMockWithSkipFrameCountExpectation struct {
	mock    *LoggerMock
	params  *LoggerMockWithSkipFrameCountParams
	results *LoggerMockWithSkipFrameCountResults
	Counter uint64
}

// LoggerMockWithSkipFrameCountParams contains parameters of the Logger.WithSkipFrameCount
type LoggerMockWithSkipFrameCountParams struct {
	delta int
}

// LoggerMockWithSkipFrameCountResults contains results of the Logger.WithSkipFrameCount
type LoggerMockWithSkipFrameCountResults struct {
	l1 Logger
}

// Expect sets up expected params for Logger.WithSkipFrameCount
func (mmWithSkipFrameCount *mLoggerMockWithSkipFrameCount) Expect(delta int) *mLoggerMockWithSkipFrameCount {
	if mmWithSkipFrameCount.mock.funcWithSkipFrameCount != nil {
		mmWithSkipFrameCount.mock.t.Fatalf("LoggerMock.WithSkipFrameCount mock is already set by Set")
	}

	if mmWithSkipFrameCount.defaultExpectation == nil {
		mmWithSkipFrameCount.defaultExpectation = &LoggerMockWithSkipFrameCountExpectation{}
	}

	mmWithSkipFrameCount.defaultExpectation.params = &LoggerMockWithSkipFrameCountParams{delta}
	for _, e := range mmWithSkipFrameCount.expectations {
		if minimock.Equal(e.params, mmWithSkipFrameCount.defaultExpectation.params) {
			mmWithSkipFrameCount.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWithSkipFrameCount.defaultExpectation.params)
		}
	}

	return mmWithSkipFrameCount
}

// Inspect accepts an inspector function that has same arguments as the Logger.WithSkipFrameCount
func (mmWithSkipFrameCount *mLoggerMockWithSkipFrameCount) Inspect(f func(delta int)) *mLoggerMockWithSkipFrameCount {
	if mmWithSkipFrameCount.mock.inspectFuncWithSkipFrameCount != nil {
		mmWithSkipFrameCount.mock.t.Fatalf("Inspect function is already set for LoggerMock.WithSkipFrameCount")
	}

	mmWithSkipFrameCount.mock.inspectFuncWithSkipFrameCount = f

	return mmWithSkipFrameCount
}

// Return sets up results that will be returned by Logger.WithSkipFrameCount
func (mmWithSkipFrameCount *mLoggerMockWithSkipFrameCount) Return(l1 Logger) *LoggerMock {
	if mmWithSkipFrameCount.mock.funcWithSkipFrameCount != nil {
		mmWithSkipFrameCount.mock.t.Fatalf("LoggerMock.WithSkipFrameCount mock is already set by Set")
	}

	if mmWithSkipFrameCount.defaultExpectation == nil {
		mmWithSkipFrameCount.defaultExpectation = &LoggerMockWithSkipFrameCountExpectation{mock: mmWithSkipFrameCount.mock}
	}
	mmWithSkipFrameCount.defaultExpectation.results = &LoggerMockWithSkipFrameCountResults{l1}
	return mmWithSkipFrameCount.mock
}

//Set uses given function f to mock the Logger.WithSkipFrameCount method
func (mmWithSkipFrameCount *mLoggerMockWithSkipFrameCount) Set(f func(delta int) (l1 Logger)) *LoggerMock {
	if mmWithSkipFrameCount.defaultExpectation != nil {
		mmWithSkipFrameCount.mock.t.Fatalf("Default expectation is already set for the Logger.WithSkipFrameCount method")
	}

	if len(mmWithSkipFrameCount.expectations) > 0 {
		mmWithSkipFrameCount.mock.t.Fatalf("Some expectations are already set for the Logger.WithSkipFrameCount method")
	}

	mmWithSkipFrameCount.mock.funcWithSkipFrameCount = f
	return mmWithSkipFrameCount.mock
}

// When sets expectation for the Logger.WithSkipFrameCount which will trigger the result defined by the following
// Then helper
func (mmWithSkipFrameCount *mLoggerMockWithSkipFrameCount) When(delta int) *LoggerMockWithSkipFrameCountExpectation {
	if mmWithSkipFrameCount.mock.funcWithSkipFrameCount != nil {
		mmWithSkipFrameCount.mock.t.Fatalf("LoggerMock.WithSkipFrameCount mock is already set by Set")
	}

	expectation := &LoggerMockWithSkipFrameCountExpectation{
		mock:   mmWithSkipFrameCount.mock,
		params: &LoggerMockWithSkipFrameCountParams{delta},
	}
	mmWithSkipFrameCount.expectations = append(mmWithSkipFrameCount.expectations, expectation)
	return expectation
}

// Then sets up Logger.WithSkipFrameCount return parameters for the expectation previously defined by the When method
func (e *LoggerMockWithSkipFrameCountExpectation) Then(l1 Logger) *LoggerMock {
	e.results = &LoggerMockWithSkipFrameCountResults{l1}
	return e.mock
}

// WithSkipFrameCount implements Logger
func (mmWithSkipFrameCount *LoggerMock) WithSkipFrameCount(delta int) (l1 Logger) {
	mm_atomic.AddUint64(&mmWithSkipFrameCount.beforeWithSkipFrameCountCounter, 1)
	defer mm_atomic.AddUint64(&mmWithSkipFrameCount.afterWithSkipFrameCountCounter, 1)

	if mmWithSkipFrameCount.inspectFuncWithSkipFrameCount != nil {
		mmWithSkipFrameCount.inspectFuncWithSkipFrameCount(delta)
	}

	params := &LoggerMockWithSkipFrameCountParams{delta}

	// Record call args
	mmWithSkipFrameCount.WithSkipFrameCountMock.mutex.Lock()
	mmWithSkipFrameCount.WithSkipFrameCountMock.callArgs = append(mmWithSkipFrameCount.WithSkipFrameCountMock.callArgs, params)
	mmWithSkipFrameCount.WithSkipFrameCountMock.mutex.Unlock()

	for _, e := range mmWithSkipFrameCount.WithSkipFrameCountMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.l1
		}
	}

	if mmWithSkipFrameCount.WithSkipFrameCountMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWithSkipFrameCount.WithSkipFrameCountMock.defaultExpectation.Counter, 1)
		want := mmWithSkipFrameCount.WithSkipFrameCountMock.defaultExpectation.params
		got := LoggerMockWithSkipFrameCountParams{delta}
		if want != nil && !minimock.Equal(*want, got) {
			mmWithSkipFrameCount.t.Errorf("LoggerMock.WithSkipFrameCount got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmWithSkipFrameCount.WithSkipFrameCountMock.defaultExpectation.results
		if results == nil {
			mmWithSkipFrameCount.t.Fatal("No results are set for the LoggerMock.WithSkipFrameCount")
		}
		return (*results).l1
	}
	if mmWithSkipFrameCount.funcWithSkipFrameCount != nil {
		return mmWithSkipFrameCount.funcWithSkipFrameCount(delta)
	}
	mmWithSkipFrameCount.t.Fatalf("Unexpected call to LoggerMock.WithSkipFrameCount. %v", delta)
	return
}

// WithSkipFrameCountAfterCounter returns a count of finished LoggerMock.WithSkipFrameCount invocations
func (mmWithSkipFrameCount *LoggerMock) WithSkipFrameCountAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithSkipFrameCount.afterWithSkipFrameCountCounter)
}

// WithSkipFrameCountBeforeCounter returns a count of LoggerMock.WithSkipFrameCount invocations
func (mmWithSkipFrameCount *LoggerMock) WithSkipFrameCountBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithSkipFrameCount.beforeWithSkipFrameCountCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.WithSkipFrameCount.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWithSkipFrameCount *mLoggerMockWithSkipFrameCount) Calls() []*LoggerMockWithSkipFrameCountParams {
	mmWithSkipFrameCount.mutex.RLock()

	argCopy := make([]*LoggerMockWithSkipFrameCountParams, len(mmWithSkipFrameCount.callArgs))
	copy(argCopy, mmWithSkipFrameCount.callArgs)

	mmWithSkipFrameCount.mutex.RUnlock()

	return argCopy
}

// MinimockWithSkipFrameCountDone returns true if the count of the WithSkipFrameCount invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockWithSkipFrameCountDone() bool {
	for _, e := range m.WithSkipFrameCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithSkipFrameCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithSkipFrameCountCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithSkipFrameCount != nil && mm_atomic.LoadUint64(&m.afterWithSkipFrameCountCounter) < 1 {
		return false
	}
	return true
}

// MinimockWithSkipFrameCountInspect logs each unmet expectation
func (m *LoggerMock) MinimockWithSkipFrameCountInspect() {
	for _, e := range m.WithSkipFrameCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.WithSkipFrameCount with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithSkipFrameCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithSkipFrameCountCounter) < 1 {
		if m.WithSkipFrameCountMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoggerMock.WithSkipFrameCount")
		} else {
			m.t.Errorf("Expected call to LoggerMock.WithSkipFrameCount with params: %#v", *m.WithSkipFrameCountMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithSkipFrameCount != nil && mm_atomic.LoadUint64(&m.afterWithSkipFrameCountCounter) < 1 {
		m.t.Error("Expected call to LoggerMock.WithSkipFrameCount")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LoggerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockDebugInspect()

		m.MinimockDebugfInspect()

		m.MinimockErrorInspect()

		m.MinimockErrorfInspect()

		m.MinimockFatalInspect()

		m.MinimockFatalfInspect()

		m.MinimockInfoInspect()

		m.MinimockInfofInspect()

		m.MinimockIsInspect()

		m.MinimockPanicInspect()

		m.MinimockPanicfInspect()

		m.MinimockWarnInspect()

		m.MinimockWarnfInspect()

		m.MinimockWithCallerInspect()

		m.MinimockWithFieldInspect()

		m.MinimockWithFieldsInspect()

		m.MinimockWithFormatInspect()

		m.MinimockWithFuncNameInspect()

		m.MinimockWithLevelInspect()

		m.MinimockWithLevelNumberInspect()

		m.MinimockWithOutputInspect()

		m.MinimockWithSkipFrameCountInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LoggerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LoggerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDebugDone() &&
		m.MinimockDebugfDone() &&
		m.MinimockErrorDone() &&
		m.MinimockErrorfDone() &&
		m.MinimockFatalDone() &&
		m.MinimockFatalfDone() &&
		m.MinimockInfoDone() &&
		m.MinimockInfofDone() &&
		m.MinimockIsDone() &&
		m.MinimockPanicDone() &&
		m.MinimockPanicfDone() &&
		m.MinimockWarnDone() &&
		m.MinimockWarnfDone() &&
		m.MinimockWithCallerDone() &&
		m.MinimockWithFieldDone() &&
		m.MinimockWithFieldsDone() &&
		m.MinimockWithFormatDone() &&
		m.MinimockWithFuncNameDone() &&
		m.MinimockWithLevelDone() &&
		m.MinimockWithLevelNumberDone() &&
		m.MinimockWithOutputDone() &&
		m.MinimockWithSkipFrameCountDone()
}
