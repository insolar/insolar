package jet

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/insolar/insolar"
)

// CoordinatorMock implements Coordinator
type CoordinatorMock struct {
	t minimock.Tester

	funcHeavy          func(ctx context.Context) (rp1 *insolar.Reference, err error)
	inspectFuncHeavy   func(ctx context.Context)
	afterHeavyCounter  uint64
	beforeHeavyCounter uint64
	HeavyMock          mCoordinatorMockHeavy

	funcIsAuthorized          func(ctx context.Context, role insolar.DynamicRole, obj insolar.ID, pulse insolar.PulseNumber, node insolar.Reference) (b1 bool, err error)
	inspectFuncIsAuthorized   func(ctx context.Context, role insolar.DynamicRole, obj insolar.ID, pulse insolar.PulseNumber, node insolar.Reference)
	afterIsAuthorizedCounter  uint64
	beforeIsAuthorizedCounter uint64
	IsAuthorizedMock          mCoordinatorMockIsAuthorized

	funcIsBeyondLimit          func(ctx context.Context, targetPN insolar.PulseNumber) (b1 bool, err error)
	inspectFuncIsBeyondLimit   func(ctx context.Context, targetPN insolar.PulseNumber)
	afterIsBeyondLimitCounter  uint64
	beforeIsBeyondLimitCounter uint64
	IsBeyondLimitMock          mCoordinatorMockIsBeyondLimit

	funcIsMeAuthorizedNow          func(ctx context.Context, role insolar.DynamicRole, obj insolar.ID) (b1 bool, err error)
	inspectFuncIsMeAuthorizedNow   func(ctx context.Context, role insolar.DynamicRole, obj insolar.ID)
	afterIsMeAuthorizedNowCounter  uint64
	beforeIsMeAuthorizedNowCounter uint64
	IsMeAuthorizedNowMock          mCoordinatorMockIsMeAuthorizedNow

	funcLightExecutorForJet          func(ctx context.Context, jetID insolar.ID, pulse insolar.PulseNumber) (rp1 *insolar.Reference, err error)
	inspectFuncLightExecutorForJet   func(ctx context.Context, jetID insolar.ID, pulse insolar.PulseNumber)
	afterLightExecutorForJetCounter  uint64
	beforeLightExecutorForJetCounter uint64
	LightExecutorForJetMock          mCoordinatorMockLightExecutorForJet

	funcLightExecutorForObject          func(ctx context.Context, objID insolar.ID, pulse insolar.PulseNumber) (rp1 *insolar.Reference, err error)
	inspectFuncLightExecutorForObject   func(ctx context.Context, objID insolar.ID, pulse insolar.PulseNumber)
	afterLightExecutorForObjectCounter  uint64
	beforeLightExecutorForObjectCounter uint64
	LightExecutorForObjectMock          mCoordinatorMockLightExecutorForObject

	funcLightValidatorsForJet          func(ctx context.Context, jetID insolar.ID, pulse insolar.PulseNumber) (ra1 []insolar.Reference, err error)
	inspectFuncLightValidatorsForJet   func(ctx context.Context, jetID insolar.ID, pulse insolar.PulseNumber)
	afterLightValidatorsForJetCounter  uint64
	beforeLightValidatorsForJetCounter uint64
	LightValidatorsForJetMock          mCoordinatorMockLightValidatorsForJet

	funcLightValidatorsForObject          func(ctx context.Context, objID insolar.ID, pulse insolar.PulseNumber) (ra1 []insolar.Reference, err error)
	inspectFuncLightValidatorsForObject   func(ctx context.Context, objID insolar.ID, pulse insolar.PulseNumber)
	afterLightValidatorsForObjectCounter  uint64
	beforeLightValidatorsForObjectCounter uint64
	LightValidatorsForObjectMock          mCoordinatorMockLightValidatorsForObject

	funcMe          func() (r1 insolar.Reference)
	inspectFuncMe   func()
	afterMeCounter  uint64
	beforeMeCounter uint64
	MeMock          mCoordinatorMockMe

	funcNodeForJet          func(ctx context.Context, jetID insolar.ID, targetPN insolar.PulseNumber) (rp1 *insolar.Reference, err error)
	inspectFuncNodeForJet   func(ctx context.Context, jetID insolar.ID, targetPN insolar.PulseNumber)
	afterNodeForJetCounter  uint64
	beforeNodeForJetCounter uint64
	NodeForJetMock          mCoordinatorMockNodeForJet

	funcNodeForObject          func(ctx context.Context, objectID insolar.ID, targetPN insolar.PulseNumber) (rp1 *insolar.Reference, err error)
	inspectFuncNodeForObject   func(ctx context.Context, objectID insolar.ID, targetPN insolar.PulseNumber)
	afterNodeForObjectCounter  uint64
	beforeNodeForObjectCounter uint64
	NodeForObjectMock          mCoordinatorMockNodeForObject

	funcQueryRole          func(ctx context.Context, role insolar.DynamicRole, obj insolar.ID, pulse insolar.PulseNumber) (ra1 []insolar.Reference, err error)
	inspectFuncQueryRole   func(ctx context.Context, role insolar.DynamicRole, obj insolar.ID, pulse insolar.PulseNumber)
	afterQueryRoleCounter  uint64
	beforeQueryRoleCounter uint64
	QueryRoleMock          mCoordinatorMockQueryRole

	funcVirtualExecutorForObject          func(ctx context.Context, objID insolar.ID, pulse insolar.PulseNumber) (rp1 *insolar.Reference, err error)
	inspectFuncVirtualExecutorForObject   func(ctx context.Context, objID insolar.ID, pulse insolar.PulseNumber)
	afterVirtualExecutorForObjectCounter  uint64
	beforeVirtualExecutorForObjectCounter uint64
	VirtualExecutorForObjectMock          mCoordinatorMockVirtualExecutorForObject

	funcVirtualValidatorsForObject          func(ctx context.Context, objID insolar.ID, pulse insolar.PulseNumber) (ra1 []insolar.Reference, err error)
	inspectFuncVirtualValidatorsForObject   func(ctx context.Context, objID insolar.ID, pulse insolar.PulseNumber)
	afterVirtualValidatorsForObjectCounter  uint64
	beforeVirtualValidatorsForObjectCounter uint64
	VirtualValidatorsForObjectMock          mCoordinatorMockVirtualValidatorsForObject
}

// NewCoordinatorMock returns a mock for Coordinator
func NewCoordinatorMock(t minimock.Tester) *CoordinatorMock {
	m := &CoordinatorMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.HeavyMock = mCoordinatorMockHeavy{mock: m}
	m.HeavyMock.callArgs = []*CoordinatorMockHeavyParams{}

	m.IsAuthorizedMock = mCoordinatorMockIsAuthorized{mock: m}
	m.IsAuthorizedMock.callArgs = []*CoordinatorMockIsAuthorizedParams{}

	m.IsBeyondLimitMock = mCoordinatorMockIsBeyondLimit{mock: m}
	m.IsBeyondLimitMock.callArgs = []*CoordinatorMockIsBeyondLimitParams{}

	m.IsMeAuthorizedNowMock = mCoordinatorMockIsMeAuthorizedNow{mock: m}
	m.IsMeAuthorizedNowMock.callArgs = []*CoordinatorMockIsMeAuthorizedNowParams{}

	m.LightExecutorForJetMock = mCoordinatorMockLightExecutorForJet{mock: m}
	m.LightExecutorForJetMock.callArgs = []*CoordinatorMockLightExecutorForJetParams{}

	m.LightExecutorForObjectMock = mCoordinatorMockLightExecutorForObject{mock: m}
	m.LightExecutorForObjectMock.callArgs = []*CoordinatorMockLightExecutorForObjectParams{}

	m.LightValidatorsForJetMock = mCoordinatorMockLightValidatorsForJet{mock: m}
	m.LightValidatorsForJetMock.callArgs = []*CoordinatorMockLightValidatorsForJetParams{}

	m.LightValidatorsForObjectMock = mCoordinatorMockLightValidatorsForObject{mock: m}
	m.LightValidatorsForObjectMock.callArgs = []*CoordinatorMockLightValidatorsForObjectParams{}

	m.MeMock = mCoordinatorMockMe{mock: m}

	m.NodeForJetMock = mCoordinatorMockNodeForJet{mock: m}
	m.NodeForJetMock.callArgs = []*CoordinatorMockNodeForJetParams{}

	m.NodeForObjectMock = mCoordinatorMockNodeForObject{mock: m}
	m.NodeForObjectMock.callArgs = []*CoordinatorMockNodeForObjectParams{}

	m.QueryRoleMock = mCoordinatorMockQueryRole{mock: m}
	m.QueryRoleMock.callArgs = []*CoordinatorMockQueryRoleParams{}

	m.VirtualExecutorForObjectMock = mCoordinatorMockVirtualExecutorForObject{mock: m}
	m.VirtualExecutorForObjectMock.callArgs = []*CoordinatorMockVirtualExecutorForObjectParams{}

	m.VirtualValidatorsForObjectMock = mCoordinatorMockVirtualValidatorsForObject{mock: m}
	m.VirtualValidatorsForObjectMock.callArgs = []*CoordinatorMockVirtualValidatorsForObjectParams{}

	return m
}

type mCoordinatorMockHeavy struct {
	mock               *CoordinatorMock
	defaultExpectation *CoordinatorMockHeavyExpectation
	expectations       []*CoordinatorMockHeavyExpectation

	callArgs []*CoordinatorMockHeavyParams
	mutex    sync.RWMutex
}

// CoordinatorMockHeavyExpectation specifies expectation struct of the Coordinator.Heavy
type CoordinatorMockHeavyExpectation struct {
	mock    *CoordinatorMock
	params  *CoordinatorMockHeavyParams
	results *CoordinatorMockHeavyResults
	Counter uint64
}

// CoordinatorMockHeavyParams contains parameters of the Coordinator.Heavy
type CoordinatorMockHeavyParams struct {
	ctx context.Context
}

// CoordinatorMockHeavyResults contains results of the Coordinator.Heavy
type CoordinatorMockHeavyResults struct {
	rp1 *insolar.Reference
	err error
}

// Expect sets up expected params for Coordinator.Heavy
func (mmHeavy *mCoordinatorMockHeavy) Expect(ctx context.Context) *mCoordinatorMockHeavy {
	if mmHeavy.mock.funcHeavy != nil {
		mmHeavy.mock.t.Fatalf("CoordinatorMock.Heavy mock is already set by Set")
	}

	if mmHeavy.defaultExpectation == nil {
		mmHeavy.defaultExpectation = &CoordinatorMockHeavyExpectation{}
	}

	mmHeavy.defaultExpectation.params = &CoordinatorMockHeavyParams{ctx}
	for _, e := range mmHeavy.expectations {
		if minimock.Equal(e.params, mmHeavy.defaultExpectation.params) {
			mmHeavy.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHeavy.defaultExpectation.params)
		}
	}

	return mmHeavy
}

// Inspect accepts an inspector function that has same arguments as the Coordinator.Heavy
func (mmHeavy *mCoordinatorMockHeavy) Inspect(f func(ctx context.Context)) *mCoordinatorMockHeavy {
	if mmHeavy.mock.inspectFuncHeavy != nil {
		mmHeavy.mock.t.Fatalf("Inspect function is already set for CoordinatorMock.Heavy")
	}

	mmHeavy.mock.inspectFuncHeavy = f

	return mmHeavy
}

// Return sets up results that will be returned by Coordinator.Heavy
func (mmHeavy *mCoordinatorMockHeavy) Return(rp1 *insolar.Reference, err error) *CoordinatorMock {
	if mmHeavy.mock.funcHeavy != nil {
		mmHeavy.mock.t.Fatalf("CoordinatorMock.Heavy mock is already set by Set")
	}

	if mmHeavy.defaultExpectation == nil {
		mmHeavy.defaultExpectation = &CoordinatorMockHeavyExpectation{mock: mmHeavy.mock}
	}
	mmHeavy.defaultExpectation.results = &CoordinatorMockHeavyResults{rp1, err}
	return mmHeavy.mock
}

//Set uses given function f to mock the Coordinator.Heavy method
func (mmHeavy *mCoordinatorMockHeavy) Set(f func(ctx context.Context) (rp1 *insolar.Reference, err error)) *CoordinatorMock {
	if mmHeavy.defaultExpectation != nil {
		mmHeavy.mock.t.Fatalf("Default expectation is already set for the Coordinator.Heavy method")
	}

	if len(mmHeavy.expectations) > 0 {
		mmHeavy.mock.t.Fatalf("Some expectations are already set for the Coordinator.Heavy method")
	}

	mmHeavy.mock.funcHeavy = f
	return mmHeavy.mock
}

// When sets expectation for the Coordinator.Heavy which will trigger the result defined by the following
// Then helper
func (mmHeavy *mCoordinatorMockHeavy) When(ctx context.Context) *CoordinatorMockHeavyExpectation {
	if mmHeavy.mock.funcHeavy != nil {
		mmHeavy.mock.t.Fatalf("CoordinatorMock.Heavy mock is already set by Set")
	}

	expectation := &CoordinatorMockHeavyExpectation{
		mock:   mmHeavy.mock,
		params: &CoordinatorMockHeavyParams{ctx},
	}
	mmHeavy.expectations = append(mmHeavy.expectations, expectation)
	return expectation
}

// Then sets up Coordinator.Heavy return parameters for the expectation previously defined by the When method
func (e *CoordinatorMockHeavyExpectation) Then(rp1 *insolar.Reference, err error) *CoordinatorMock {
	e.results = &CoordinatorMockHeavyResults{rp1, err}
	return e.mock
}

// Heavy implements Coordinator
func (mmHeavy *CoordinatorMock) Heavy(ctx context.Context) (rp1 *insolar.Reference, err error) {
	mm_atomic.AddUint64(&mmHeavy.beforeHeavyCounter, 1)
	defer mm_atomic.AddUint64(&mmHeavy.afterHeavyCounter, 1)

	if mmHeavy.inspectFuncHeavy != nil {
		mmHeavy.inspectFuncHeavy(ctx)
	}

	mm_params := &CoordinatorMockHeavyParams{ctx}

	// Record call args
	mmHeavy.HeavyMock.mutex.Lock()
	mmHeavy.HeavyMock.callArgs = append(mmHeavy.HeavyMock.callArgs, mm_params)
	mmHeavy.HeavyMock.mutex.Unlock()

	for _, e := range mmHeavy.HeavyMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmHeavy.HeavyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHeavy.HeavyMock.defaultExpectation.Counter, 1)
		mm_want := mmHeavy.HeavyMock.defaultExpectation.params
		mm_got := CoordinatorMockHeavyParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHeavy.t.Errorf("CoordinatorMock.Heavy got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHeavy.HeavyMock.defaultExpectation.results
		if mm_results == nil {
			mmHeavy.t.Fatal("No results are set for the CoordinatorMock.Heavy")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmHeavy.funcHeavy != nil {
		return mmHeavy.funcHeavy(ctx)
	}
	mmHeavy.t.Fatalf("Unexpected call to CoordinatorMock.Heavy. %v", ctx)
	return
}

// HeavyAfterCounter returns a count of finished CoordinatorMock.Heavy invocations
func (mmHeavy *CoordinatorMock) HeavyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHeavy.afterHeavyCounter)
}

// HeavyBeforeCounter returns a count of CoordinatorMock.Heavy invocations
func (mmHeavy *CoordinatorMock) HeavyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHeavy.beforeHeavyCounter)
}

// Calls returns a list of arguments used in each call to CoordinatorMock.Heavy.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHeavy *mCoordinatorMockHeavy) Calls() []*CoordinatorMockHeavyParams {
	mmHeavy.mutex.RLock()

	argCopy := make([]*CoordinatorMockHeavyParams, len(mmHeavy.callArgs))
	copy(argCopy, mmHeavy.callArgs)

	mmHeavy.mutex.RUnlock()

	return argCopy
}

// MinimockHeavyDone returns true if the count of the Heavy invocations corresponds
// the number of defined expectations
func (m *CoordinatorMock) MinimockHeavyDone() bool {
	for _, e := range m.HeavyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HeavyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHeavyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHeavy != nil && mm_atomic.LoadUint64(&m.afterHeavyCounter) < 1 {
		return false
	}
	return true
}

// MinimockHeavyInspect logs each unmet expectation
func (m *CoordinatorMock) MinimockHeavyInspect() {
	for _, e := range m.HeavyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoordinatorMock.Heavy with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HeavyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHeavyCounter) < 1 {
		if m.HeavyMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CoordinatorMock.Heavy")
		} else {
			m.t.Errorf("Expected call to CoordinatorMock.Heavy with params: %#v", *m.HeavyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHeavy != nil && mm_atomic.LoadUint64(&m.afterHeavyCounter) < 1 {
		m.t.Error("Expected call to CoordinatorMock.Heavy")
	}
}

type mCoordinatorMockIsAuthorized struct {
	mock               *CoordinatorMock
	defaultExpectation *CoordinatorMockIsAuthorizedExpectation
	expectations       []*CoordinatorMockIsAuthorizedExpectation

	callArgs []*CoordinatorMockIsAuthorizedParams
	mutex    sync.RWMutex
}

// CoordinatorMockIsAuthorizedExpectation specifies expectation struct of the Coordinator.IsAuthorized
type CoordinatorMockIsAuthorizedExpectation struct {
	mock    *CoordinatorMock
	params  *CoordinatorMockIsAuthorizedParams
	results *CoordinatorMockIsAuthorizedResults
	Counter uint64
}

// CoordinatorMockIsAuthorizedParams contains parameters of the Coordinator.IsAuthorized
type CoordinatorMockIsAuthorizedParams struct {
	ctx   context.Context
	role  insolar.DynamicRole
	obj   insolar.ID
	pulse insolar.PulseNumber
	node  insolar.Reference
}

// CoordinatorMockIsAuthorizedResults contains results of the Coordinator.IsAuthorized
type CoordinatorMockIsAuthorizedResults struct {
	b1  bool
	err error
}

// Expect sets up expected params for Coordinator.IsAuthorized
func (mmIsAuthorized *mCoordinatorMockIsAuthorized) Expect(ctx context.Context, role insolar.DynamicRole, obj insolar.ID, pulse insolar.PulseNumber, node insolar.Reference) *mCoordinatorMockIsAuthorized {
	if mmIsAuthorized.mock.funcIsAuthorized != nil {
		mmIsAuthorized.mock.t.Fatalf("CoordinatorMock.IsAuthorized mock is already set by Set")
	}

	if mmIsAuthorized.defaultExpectation == nil {
		mmIsAuthorized.defaultExpectation = &CoordinatorMockIsAuthorizedExpectation{}
	}

	mmIsAuthorized.defaultExpectation.params = &CoordinatorMockIsAuthorizedParams{ctx, role, obj, pulse, node}
	for _, e := range mmIsAuthorized.expectations {
		if minimock.Equal(e.params, mmIsAuthorized.defaultExpectation.params) {
			mmIsAuthorized.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsAuthorized.defaultExpectation.params)
		}
	}

	return mmIsAuthorized
}

// Inspect accepts an inspector function that has same arguments as the Coordinator.IsAuthorized
func (mmIsAuthorized *mCoordinatorMockIsAuthorized) Inspect(f func(ctx context.Context, role insolar.DynamicRole, obj insolar.ID, pulse insolar.PulseNumber, node insolar.Reference)) *mCoordinatorMockIsAuthorized {
	if mmIsAuthorized.mock.inspectFuncIsAuthorized != nil {
		mmIsAuthorized.mock.t.Fatalf("Inspect function is already set for CoordinatorMock.IsAuthorized")
	}

	mmIsAuthorized.mock.inspectFuncIsAuthorized = f

	return mmIsAuthorized
}

// Return sets up results that will be returned by Coordinator.IsAuthorized
func (mmIsAuthorized *mCoordinatorMockIsAuthorized) Return(b1 bool, err error) *CoordinatorMock {
	if mmIsAuthorized.mock.funcIsAuthorized != nil {
		mmIsAuthorized.mock.t.Fatalf("CoordinatorMock.IsAuthorized mock is already set by Set")
	}

	if mmIsAuthorized.defaultExpectation == nil {
		mmIsAuthorized.defaultExpectation = &CoordinatorMockIsAuthorizedExpectation{mock: mmIsAuthorized.mock}
	}
	mmIsAuthorized.defaultExpectation.results = &CoordinatorMockIsAuthorizedResults{b1, err}
	return mmIsAuthorized.mock
}

//Set uses given function f to mock the Coordinator.IsAuthorized method
func (mmIsAuthorized *mCoordinatorMockIsAuthorized) Set(f func(ctx context.Context, role insolar.DynamicRole, obj insolar.ID, pulse insolar.PulseNumber, node insolar.Reference) (b1 bool, err error)) *CoordinatorMock {
	if mmIsAuthorized.defaultExpectation != nil {
		mmIsAuthorized.mock.t.Fatalf("Default expectation is already set for the Coordinator.IsAuthorized method")
	}

	if len(mmIsAuthorized.expectations) > 0 {
		mmIsAuthorized.mock.t.Fatalf("Some expectations are already set for the Coordinator.IsAuthorized method")
	}

	mmIsAuthorized.mock.funcIsAuthorized = f
	return mmIsAuthorized.mock
}

// When sets expectation for the Coordinator.IsAuthorized which will trigger the result defined by the following
// Then helper
func (mmIsAuthorized *mCoordinatorMockIsAuthorized) When(ctx context.Context, role insolar.DynamicRole, obj insolar.ID, pulse insolar.PulseNumber, node insolar.Reference) *CoordinatorMockIsAuthorizedExpectation {
	if mmIsAuthorized.mock.funcIsAuthorized != nil {
		mmIsAuthorized.mock.t.Fatalf("CoordinatorMock.IsAuthorized mock is already set by Set")
	}

	expectation := &CoordinatorMockIsAuthorizedExpectation{
		mock:   mmIsAuthorized.mock,
		params: &CoordinatorMockIsAuthorizedParams{ctx, role, obj, pulse, node},
	}
	mmIsAuthorized.expectations = append(mmIsAuthorized.expectations, expectation)
	return expectation
}

// Then sets up Coordinator.IsAuthorized return parameters for the expectation previously defined by the When method
func (e *CoordinatorMockIsAuthorizedExpectation) Then(b1 bool, err error) *CoordinatorMock {
	e.results = &CoordinatorMockIsAuthorizedResults{b1, err}
	return e.mock
}

// IsAuthorized implements Coordinator
func (mmIsAuthorized *CoordinatorMock) IsAuthorized(ctx context.Context, role insolar.DynamicRole, obj insolar.ID, pulse insolar.PulseNumber, node insolar.Reference) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmIsAuthorized.beforeIsAuthorizedCounter, 1)
	defer mm_atomic.AddUint64(&mmIsAuthorized.afterIsAuthorizedCounter, 1)

	if mmIsAuthorized.inspectFuncIsAuthorized != nil {
		mmIsAuthorized.inspectFuncIsAuthorized(ctx, role, obj, pulse, node)
	}

	mm_params := &CoordinatorMockIsAuthorizedParams{ctx, role, obj, pulse, node}

	// Record call args
	mmIsAuthorized.IsAuthorizedMock.mutex.Lock()
	mmIsAuthorized.IsAuthorizedMock.callArgs = append(mmIsAuthorized.IsAuthorizedMock.callArgs, mm_params)
	mmIsAuthorized.IsAuthorizedMock.mutex.Unlock()

	for _, e := range mmIsAuthorized.IsAuthorizedMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmIsAuthorized.IsAuthorizedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsAuthorized.IsAuthorizedMock.defaultExpectation.Counter, 1)
		mm_want := mmIsAuthorized.IsAuthorizedMock.defaultExpectation.params
		mm_got := CoordinatorMockIsAuthorizedParams{ctx, role, obj, pulse, node}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsAuthorized.t.Errorf("CoordinatorMock.IsAuthorized got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsAuthorized.IsAuthorizedMock.defaultExpectation.results
		if mm_results == nil {
			mmIsAuthorized.t.Fatal("No results are set for the CoordinatorMock.IsAuthorized")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmIsAuthorized.funcIsAuthorized != nil {
		return mmIsAuthorized.funcIsAuthorized(ctx, role, obj, pulse, node)
	}
	mmIsAuthorized.t.Fatalf("Unexpected call to CoordinatorMock.IsAuthorized. %v %v %v %v %v", ctx, role, obj, pulse, node)
	return
}

// IsAuthorizedAfterCounter returns a count of finished CoordinatorMock.IsAuthorized invocations
func (mmIsAuthorized *CoordinatorMock) IsAuthorizedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsAuthorized.afterIsAuthorizedCounter)
}

// IsAuthorizedBeforeCounter returns a count of CoordinatorMock.IsAuthorized invocations
func (mmIsAuthorized *CoordinatorMock) IsAuthorizedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsAuthorized.beforeIsAuthorizedCounter)
}

// Calls returns a list of arguments used in each call to CoordinatorMock.IsAuthorized.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsAuthorized *mCoordinatorMockIsAuthorized) Calls() []*CoordinatorMockIsAuthorizedParams {
	mmIsAuthorized.mutex.RLock()

	argCopy := make([]*CoordinatorMockIsAuthorizedParams, len(mmIsAuthorized.callArgs))
	copy(argCopy, mmIsAuthorized.callArgs)

	mmIsAuthorized.mutex.RUnlock()

	return argCopy
}

// MinimockIsAuthorizedDone returns true if the count of the IsAuthorized invocations corresponds
// the number of defined expectations
func (m *CoordinatorMock) MinimockIsAuthorizedDone() bool {
	for _, e := range m.IsAuthorizedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsAuthorizedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsAuthorizedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsAuthorized != nil && mm_atomic.LoadUint64(&m.afterIsAuthorizedCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsAuthorizedInspect logs each unmet expectation
func (m *CoordinatorMock) MinimockIsAuthorizedInspect() {
	for _, e := range m.IsAuthorizedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoordinatorMock.IsAuthorized with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsAuthorizedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsAuthorizedCounter) < 1 {
		if m.IsAuthorizedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CoordinatorMock.IsAuthorized")
		} else {
			m.t.Errorf("Expected call to CoordinatorMock.IsAuthorized with params: %#v", *m.IsAuthorizedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsAuthorized != nil && mm_atomic.LoadUint64(&m.afterIsAuthorizedCounter) < 1 {
		m.t.Error("Expected call to CoordinatorMock.IsAuthorized")
	}
}

type mCoordinatorMockIsBeyondLimit struct {
	mock               *CoordinatorMock
	defaultExpectation *CoordinatorMockIsBeyondLimitExpectation
	expectations       []*CoordinatorMockIsBeyondLimitExpectation

	callArgs []*CoordinatorMockIsBeyondLimitParams
	mutex    sync.RWMutex
}

// CoordinatorMockIsBeyondLimitExpectation specifies expectation struct of the Coordinator.IsBeyondLimit
type CoordinatorMockIsBeyondLimitExpectation struct {
	mock    *CoordinatorMock
	params  *CoordinatorMockIsBeyondLimitParams
	results *CoordinatorMockIsBeyondLimitResults
	Counter uint64
}

// CoordinatorMockIsBeyondLimitParams contains parameters of the Coordinator.IsBeyondLimit
type CoordinatorMockIsBeyondLimitParams struct {
	ctx      context.Context
	targetPN insolar.PulseNumber
}

// CoordinatorMockIsBeyondLimitResults contains results of the Coordinator.IsBeyondLimit
type CoordinatorMockIsBeyondLimitResults struct {
	b1  bool
	err error
}

// Expect sets up expected params for Coordinator.IsBeyondLimit
func (mmIsBeyondLimit *mCoordinatorMockIsBeyondLimit) Expect(ctx context.Context, targetPN insolar.PulseNumber) *mCoordinatorMockIsBeyondLimit {
	if mmIsBeyondLimit.mock.funcIsBeyondLimit != nil {
		mmIsBeyondLimit.mock.t.Fatalf("CoordinatorMock.IsBeyondLimit mock is already set by Set")
	}

	if mmIsBeyondLimit.defaultExpectation == nil {
		mmIsBeyondLimit.defaultExpectation = &CoordinatorMockIsBeyondLimitExpectation{}
	}

	mmIsBeyondLimit.defaultExpectation.params = &CoordinatorMockIsBeyondLimitParams{ctx, targetPN}
	for _, e := range mmIsBeyondLimit.expectations {
		if minimock.Equal(e.params, mmIsBeyondLimit.defaultExpectation.params) {
			mmIsBeyondLimit.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsBeyondLimit.defaultExpectation.params)
		}
	}

	return mmIsBeyondLimit
}

// Inspect accepts an inspector function that has same arguments as the Coordinator.IsBeyondLimit
func (mmIsBeyondLimit *mCoordinatorMockIsBeyondLimit) Inspect(f func(ctx context.Context, targetPN insolar.PulseNumber)) *mCoordinatorMockIsBeyondLimit {
	if mmIsBeyondLimit.mock.inspectFuncIsBeyondLimit != nil {
		mmIsBeyondLimit.mock.t.Fatalf("Inspect function is already set for CoordinatorMock.IsBeyondLimit")
	}

	mmIsBeyondLimit.mock.inspectFuncIsBeyondLimit = f

	return mmIsBeyondLimit
}

// Return sets up results that will be returned by Coordinator.IsBeyondLimit
func (mmIsBeyondLimit *mCoordinatorMockIsBeyondLimit) Return(b1 bool, err error) *CoordinatorMock {
	if mmIsBeyondLimit.mock.funcIsBeyondLimit != nil {
		mmIsBeyondLimit.mock.t.Fatalf("CoordinatorMock.IsBeyondLimit mock is already set by Set")
	}

	if mmIsBeyondLimit.defaultExpectation == nil {
		mmIsBeyondLimit.defaultExpectation = &CoordinatorMockIsBeyondLimitExpectation{mock: mmIsBeyondLimit.mock}
	}
	mmIsBeyondLimit.defaultExpectation.results = &CoordinatorMockIsBeyondLimitResults{b1, err}
	return mmIsBeyondLimit.mock
}

//Set uses given function f to mock the Coordinator.IsBeyondLimit method
func (mmIsBeyondLimit *mCoordinatorMockIsBeyondLimit) Set(f func(ctx context.Context, targetPN insolar.PulseNumber) (b1 bool, err error)) *CoordinatorMock {
	if mmIsBeyondLimit.defaultExpectation != nil {
		mmIsBeyondLimit.mock.t.Fatalf("Default expectation is already set for the Coordinator.IsBeyondLimit method")
	}

	if len(mmIsBeyondLimit.expectations) > 0 {
		mmIsBeyondLimit.mock.t.Fatalf("Some expectations are already set for the Coordinator.IsBeyondLimit method")
	}

	mmIsBeyondLimit.mock.funcIsBeyondLimit = f
	return mmIsBeyondLimit.mock
}

// When sets expectation for the Coordinator.IsBeyondLimit which will trigger the result defined by the following
// Then helper
func (mmIsBeyondLimit *mCoordinatorMockIsBeyondLimit) When(ctx context.Context, targetPN insolar.PulseNumber) *CoordinatorMockIsBeyondLimitExpectation {
	if mmIsBeyondLimit.mock.funcIsBeyondLimit != nil {
		mmIsBeyondLimit.mock.t.Fatalf("CoordinatorMock.IsBeyondLimit mock is already set by Set")
	}

	expectation := &CoordinatorMockIsBeyondLimitExpectation{
		mock:   mmIsBeyondLimit.mock,
		params: &CoordinatorMockIsBeyondLimitParams{ctx, targetPN},
	}
	mmIsBeyondLimit.expectations = append(mmIsBeyondLimit.expectations, expectation)
	return expectation
}

// Then sets up Coordinator.IsBeyondLimit return parameters for the expectation previously defined by the When method
func (e *CoordinatorMockIsBeyondLimitExpectation) Then(b1 bool, err error) *CoordinatorMock {
	e.results = &CoordinatorMockIsBeyondLimitResults{b1, err}
	return e.mock
}

// IsBeyondLimit implements Coordinator
func (mmIsBeyondLimit *CoordinatorMock) IsBeyondLimit(ctx context.Context, targetPN insolar.PulseNumber) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmIsBeyondLimit.beforeIsBeyondLimitCounter, 1)
	defer mm_atomic.AddUint64(&mmIsBeyondLimit.afterIsBeyondLimitCounter, 1)

	if mmIsBeyondLimit.inspectFuncIsBeyondLimit != nil {
		mmIsBeyondLimit.inspectFuncIsBeyondLimit(ctx, targetPN)
	}

	mm_params := &CoordinatorMockIsBeyondLimitParams{ctx, targetPN}

	// Record call args
	mmIsBeyondLimit.IsBeyondLimitMock.mutex.Lock()
	mmIsBeyondLimit.IsBeyondLimitMock.callArgs = append(mmIsBeyondLimit.IsBeyondLimitMock.callArgs, mm_params)
	mmIsBeyondLimit.IsBeyondLimitMock.mutex.Unlock()

	for _, e := range mmIsBeyondLimit.IsBeyondLimitMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmIsBeyondLimit.IsBeyondLimitMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsBeyondLimit.IsBeyondLimitMock.defaultExpectation.Counter, 1)
		mm_want := mmIsBeyondLimit.IsBeyondLimitMock.defaultExpectation.params
		mm_got := CoordinatorMockIsBeyondLimitParams{ctx, targetPN}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsBeyondLimit.t.Errorf("CoordinatorMock.IsBeyondLimit got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsBeyondLimit.IsBeyondLimitMock.defaultExpectation.results
		if mm_results == nil {
			mmIsBeyondLimit.t.Fatal("No results are set for the CoordinatorMock.IsBeyondLimit")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmIsBeyondLimit.funcIsBeyondLimit != nil {
		return mmIsBeyondLimit.funcIsBeyondLimit(ctx, targetPN)
	}
	mmIsBeyondLimit.t.Fatalf("Unexpected call to CoordinatorMock.IsBeyondLimit. %v %v", ctx, targetPN)
	return
}

// IsBeyondLimitAfterCounter returns a count of finished CoordinatorMock.IsBeyondLimit invocations
func (mmIsBeyondLimit *CoordinatorMock) IsBeyondLimitAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsBeyondLimit.afterIsBeyondLimitCounter)
}

// IsBeyondLimitBeforeCounter returns a count of CoordinatorMock.IsBeyondLimit invocations
func (mmIsBeyondLimit *CoordinatorMock) IsBeyondLimitBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsBeyondLimit.beforeIsBeyondLimitCounter)
}

// Calls returns a list of arguments used in each call to CoordinatorMock.IsBeyondLimit.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsBeyondLimit *mCoordinatorMockIsBeyondLimit) Calls() []*CoordinatorMockIsBeyondLimitParams {
	mmIsBeyondLimit.mutex.RLock()

	argCopy := make([]*CoordinatorMockIsBeyondLimitParams, len(mmIsBeyondLimit.callArgs))
	copy(argCopy, mmIsBeyondLimit.callArgs)

	mmIsBeyondLimit.mutex.RUnlock()

	return argCopy
}

// MinimockIsBeyondLimitDone returns true if the count of the IsBeyondLimit invocations corresponds
// the number of defined expectations
func (m *CoordinatorMock) MinimockIsBeyondLimitDone() bool {
	for _, e := range m.IsBeyondLimitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsBeyondLimitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsBeyondLimitCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsBeyondLimit != nil && mm_atomic.LoadUint64(&m.afterIsBeyondLimitCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsBeyondLimitInspect logs each unmet expectation
func (m *CoordinatorMock) MinimockIsBeyondLimitInspect() {
	for _, e := range m.IsBeyondLimitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoordinatorMock.IsBeyondLimit with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsBeyondLimitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsBeyondLimitCounter) < 1 {
		if m.IsBeyondLimitMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CoordinatorMock.IsBeyondLimit")
		} else {
			m.t.Errorf("Expected call to CoordinatorMock.IsBeyondLimit with params: %#v", *m.IsBeyondLimitMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsBeyondLimit != nil && mm_atomic.LoadUint64(&m.afterIsBeyondLimitCounter) < 1 {
		m.t.Error("Expected call to CoordinatorMock.IsBeyondLimit")
	}
}

type mCoordinatorMockIsMeAuthorizedNow struct {
	mock               *CoordinatorMock
	defaultExpectation *CoordinatorMockIsMeAuthorizedNowExpectation
	expectations       []*CoordinatorMockIsMeAuthorizedNowExpectation

	callArgs []*CoordinatorMockIsMeAuthorizedNowParams
	mutex    sync.RWMutex
}

// CoordinatorMockIsMeAuthorizedNowExpectation specifies expectation struct of the Coordinator.IsMeAuthorizedNow
type CoordinatorMockIsMeAuthorizedNowExpectation struct {
	mock    *CoordinatorMock
	params  *CoordinatorMockIsMeAuthorizedNowParams
	results *CoordinatorMockIsMeAuthorizedNowResults
	Counter uint64
}

// CoordinatorMockIsMeAuthorizedNowParams contains parameters of the Coordinator.IsMeAuthorizedNow
type CoordinatorMockIsMeAuthorizedNowParams struct {
	ctx  context.Context
	role insolar.DynamicRole
	obj  insolar.ID
}

// CoordinatorMockIsMeAuthorizedNowResults contains results of the Coordinator.IsMeAuthorizedNow
type CoordinatorMockIsMeAuthorizedNowResults struct {
	b1  bool
	err error
}

// Expect sets up expected params for Coordinator.IsMeAuthorizedNow
func (mmIsMeAuthorizedNow *mCoordinatorMockIsMeAuthorizedNow) Expect(ctx context.Context, role insolar.DynamicRole, obj insolar.ID) *mCoordinatorMockIsMeAuthorizedNow {
	if mmIsMeAuthorizedNow.mock.funcIsMeAuthorizedNow != nil {
		mmIsMeAuthorizedNow.mock.t.Fatalf("CoordinatorMock.IsMeAuthorizedNow mock is already set by Set")
	}

	if mmIsMeAuthorizedNow.defaultExpectation == nil {
		mmIsMeAuthorizedNow.defaultExpectation = &CoordinatorMockIsMeAuthorizedNowExpectation{}
	}

	mmIsMeAuthorizedNow.defaultExpectation.params = &CoordinatorMockIsMeAuthorizedNowParams{ctx, role, obj}
	for _, e := range mmIsMeAuthorizedNow.expectations {
		if minimock.Equal(e.params, mmIsMeAuthorizedNow.defaultExpectation.params) {
			mmIsMeAuthorizedNow.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsMeAuthorizedNow.defaultExpectation.params)
		}
	}

	return mmIsMeAuthorizedNow
}

// Inspect accepts an inspector function that has same arguments as the Coordinator.IsMeAuthorizedNow
func (mmIsMeAuthorizedNow *mCoordinatorMockIsMeAuthorizedNow) Inspect(f func(ctx context.Context, role insolar.DynamicRole, obj insolar.ID)) *mCoordinatorMockIsMeAuthorizedNow {
	if mmIsMeAuthorizedNow.mock.inspectFuncIsMeAuthorizedNow != nil {
		mmIsMeAuthorizedNow.mock.t.Fatalf("Inspect function is already set for CoordinatorMock.IsMeAuthorizedNow")
	}

	mmIsMeAuthorizedNow.mock.inspectFuncIsMeAuthorizedNow = f

	return mmIsMeAuthorizedNow
}

// Return sets up results that will be returned by Coordinator.IsMeAuthorizedNow
func (mmIsMeAuthorizedNow *mCoordinatorMockIsMeAuthorizedNow) Return(b1 bool, err error) *CoordinatorMock {
	if mmIsMeAuthorizedNow.mock.funcIsMeAuthorizedNow != nil {
		mmIsMeAuthorizedNow.mock.t.Fatalf("CoordinatorMock.IsMeAuthorizedNow mock is already set by Set")
	}

	if mmIsMeAuthorizedNow.defaultExpectation == nil {
		mmIsMeAuthorizedNow.defaultExpectation = &CoordinatorMockIsMeAuthorizedNowExpectation{mock: mmIsMeAuthorizedNow.mock}
	}
	mmIsMeAuthorizedNow.defaultExpectation.results = &CoordinatorMockIsMeAuthorizedNowResults{b1, err}
	return mmIsMeAuthorizedNow.mock
}

//Set uses given function f to mock the Coordinator.IsMeAuthorizedNow method
func (mmIsMeAuthorizedNow *mCoordinatorMockIsMeAuthorizedNow) Set(f func(ctx context.Context, role insolar.DynamicRole, obj insolar.ID) (b1 bool, err error)) *CoordinatorMock {
	if mmIsMeAuthorizedNow.defaultExpectation != nil {
		mmIsMeAuthorizedNow.mock.t.Fatalf("Default expectation is already set for the Coordinator.IsMeAuthorizedNow method")
	}

	if len(mmIsMeAuthorizedNow.expectations) > 0 {
		mmIsMeAuthorizedNow.mock.t.Fatalf("Some expectations are already set for the Coordinator.IsMeAuthorizedNow method")
	}

	mmIsMeAuthorizedNow.mock.funcIsMeAuthorizedNow = f
	return mmIsMeAuthorizedNow.mock
}

// When sets expectation for the Coordinator.IsMeAuthorizedNow which will trigger the result defined by the following
// Then helper
func (mmIsMeAuthorizedNow *mCoordinatorMockIsMeAuthorizedNow) When(ctx context.Context, role insolar.DynamicRole, obj insolar.ID) *CoordinatorMockIsMeAuthorizedNowExpectation {
	if mmIsMeAuthorizedNow.mock.funcIsMeAuthorizedNow != nil {
		mmIsMeAuthorizedNow.mock.t.Fatalf("CoordinatorMock.IsMeAuthorizedNow mock is already set by Set")
	}

	expectation := &CoordinatorMockIsMeAuthorizedNowExpectation{
		mock:   mmIsMeAuthorizedNow.mock,
		params: &CoordinatorMockIsMeAuthorizedNowParams{ctx, role, obj},
	}
	mmIsMeAuthorizedNow.expectations = append(mmIsMeAuthorizedNow.expectations, expectation)
	return expectation
}

// Then sets up Coordinator.IsMeAuthorizedNow return parameters for the expectation previously defined by the When method
func (e *CoordinatorMockIsMeAuthorizedNowExpectation) Then(b1 bool, err error) *CoordinatorMock {
	e.results = &CoordinatorMockIsMeAuthorizedNowResults{b1, err}
	return e.mock
}

// IsMeAuthorizedNow implements Coordinator
func (mmIsMeAuthorizedNow *CoordinatorMock) IsMeAuthorizedNow(ctx context.Context, role insolar.DynamicRole, obj insolar.ID) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmIsMeAuthorizedNow.beforeIsMeAuthorizedNowCounter, 1)
	defer mm_atomic.AddUint64(&mmIsMeAuthorizedNow.afterIsMeAuthorizedNowCounter, 1)

	if mmIsMeAuthorizedNow.inspectFuncIsMeAuthorizedNow != nil {
		mmIsMeAuthorizedNow.inspectFuncIsMeAuthorizedNow(ctx, role, obj)
	}

	mm_params := &CoordinatorMockIsMeAuthorizedNowParams{ctx, role, obj}

	// Record call args
	mmIsMeAuthorizedNow.IsMeAuthorizedNowMock.mutex.Lock()
	mmIsMeAuthorizedNow.IsMeAuthorizedNowMock.callArgs = append(mmIsMeAuthorizedNow.IsMeAuthorizedNowMock.callArgs, mm_params)
	mmIsMeAuthorizedNow.IsMeAuthorizedNowMock.mutex.Unlock()

	for _, e := range mmIsMeAuthorizedNow.IsMeAuthorizedNowMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmIsMeAuthorizedNow.IsMeAuthorizedNowMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsMeAuthorizedNow.IsMeAuthorizedNowMock.defaultExpectation.Counter, 1)
		mm_want := mmIsMeAuthorizedNow.IsMeAuthorizedNowMock.defaultExpectation.params
		mm_got := CoordinatorMockIsMeAuthorizedNowParams{ctx, role, obj}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsMeAuthorizedNow.t.Errorf("CoordinatorMock.IsMeAuthorizedNow got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsMeAuthorizedNow.IsMeAuthorizedNowMock.defaultExpectation.results
		if mm_results == nil {
			mmIsMeAuthorizedNow.t.Fatal("No results are set for the CoordinatorMock.IsMeAuthorizedNow")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmIsMeAuthorizedNow.funcIsMeAuthorizedNow != nil {
		return mmIsMeAuthorizedNow.funcIsMeAuthorizedNow(ctx, role, obj)
	}
	mmIsMeAuthorizedNow.t.Fatalf("Unexpected call to CoordinatorMock.IsMeAuthorizedNow. %v %v %v", ctx, role, obj)
	return
}

// IsMeAuthorizedNowAfterCounter returns a count of finished CoordinatorMock.IsMeAuthorizedNow invocations
func (mmIsMeAuthorizedNow *CoordinatorMock) IsMeAuthorizedNowAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsMeAuthorizedNow.afterIsMeAuthorizedNowCounter)
}

// IsMeAuthorizedNowBeforeCounter returns a count of CoordinatorMock.IsMeAuthorizedNow invocations
func (mmIsMeAuthorizedNow *CoordinatorMock) IsMeAuthorizedNowBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsMeAuthorizedNow.beforeIsMeAuthorizedNowCounter)
}

// Calls returns a list of arguments used in each call to CoordinatorMock.IsMeAuthorizedNow.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsMeAuthorizedNow *mCoordinatorMockIsMeAuthorizedNow) Calls() []*CoordinatorMockIsMeAuthorizedNowParams {
	mmIsMeAuthorizedNow.mutex.RLock()

	argCopy := make([]*CoordinatorMockIsMeAuthorizedNowParams, len(mmIsMeAuthorizedNow.callArgs))
	copy(argCopy, mmIsMeAuthorizedNow.callArgs)

	mmIsMeAuthorizedNow.mutex.RUnlock()

	return argCopy
}

// MinimockIsMeAuthorizedNowDone returns true if the count of the IsMeAuthorizedNow invocations corresponds
// the number of defined expectations
func (m *CoordinatorMock) MinimockIsMeAuthorizedNowDone() bool {
	for _, e := range m.IsMeAuthorizedNowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsMeAuthorizedNowMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsMeAuthorizedNowCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsMeAuthorizedNow != nil && mm_atomic.LoadUint64(&m.afterIsMeAuthorizedNowCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsMeAuthorizedNowInspect logs each unmet expectation
func (m *CoordinatorMock) MinimockIsMeAuthorizedNowInspect() {
	for _, e := range m.IsMeAuthorizedNowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoordinatorMock.IsMeAuthorizedNow with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsMeAuthorizedNowMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsMeAuthorizedNowCounter) < 1 {
		if m.IsMeAuthorizedNowMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CoordinatorMock.IsMeAuthorizedNow")
		} else {
			m.t.Errorf("Expected call to CoordinatorMock.IsMeAuthorizedNow with params: %#v", *m.IsMeAuthorizedNowMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsMeAuthorizedNow != nil && mm_atomic.LoadUint64(&m.afterIsMeAuthorizedNowCounter) < 1 {
		m.t.Error("Expected call to CoordinatorMock.IsMeAuthorizedNow")
	}
}

type mCoordinatorMockLightExecutorForJet struct {
	mock               *CoordinatorMock
	defaultExpectation *CoordinatorMockLightExecutorForJetExpectation
	expectations       []*CoordinatorMockLightExecutorForJetExpectation

	callArgs []*CoordinatorMockLightExecutorForJetParams
	mutex    sync.RWMutex
}

// CoordinatorMockLightExecutorForJetExpectation specifies expectation struct of the Coordinator.LightExecutorForJet
type CoordinatorMockLightExecutorForJetExpectation struct {
	mock    *CoordinatorMock
	params  *CoordinatorMockLightExecutorForJetParams
	results *CoordinatorMockLightExecutorForJetResults
	Counter uint64
}

// CoordinatorMockLightExecutorForJetParams contains parameters of the Coordinator.LightExecutorForJet
type CoordinatorMockLightExecutorForJetParams struct {
	ctx   context.Context
	jetID insolar.ID
	pulse insolar.PulseNumber
}

// CoordinatorMockLightExecutorForJetResults contains results of the Coordinator.LightExecutorForJet
type CoordinatorMockLightExecutorForJetResults struct {
	rp1 *insolar.Reference
	err error
}

// Expect sets up expected params for Coordinator.LightExecutorForJet
func (mmLightExecutorForJet *mCoordinatorMockLightExecutorForJet) Expect(ctx context.Context, jetID insolar.ID, pulse insolar.PulseNumber) *mCoordinatorMockLightExecutorForJet {
	if mmLightExecutorForJet.mock.funcLightExecutorForJet != nil {
		mmLightExecutorForJet.mock.t.Fatalf("CoordinatorMock.LightExecutorForJet mock is already set by Set")
	}

	if mmLightExecutorForJet.defaultExpectation == nil {
		mmLightExecutorForJet.defaultExpectation = &CoordinatorMockLightExecutorForJetExpectation{}
	}

	mmLightExecutorForJet.defaultExpectation.params = &CoordinatorMockLightExecutorForJetParams{ctx, jetID, pulse}
	for _, e := range mmLightExecutorForJet.expectations {
		if minimock.Equal(e.params, mmLightExecutorForJet.defaultExpectation.params) {
			mmLightExecutorForJet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLightExecutorForJet.defaultExpectation.params)
		}
	}

	return mmLightExecutorForJet
}

// Inspect accepts an inspector function that has same arguments as the Coordinator.LightExecutorForJet
func (mmLightExecutorForJet *mCoordinatorMockLightExecutorForJet) Inspect(f func(ctx context.Context, jetID insolar.ID, pulse insolar.PulseNumber)) *mCoordinatorMockLightExecutorForJet {
	if mmLightExecutorForJet.mock.inspectFuncLightExecutorForJet != nil {
		mmLightExecutorForJet.mock.t.Fatalf("Inspect function is already set for CoordinatorMock.LightExecutorForJet")
	}

	mmLightExecutorForJet.mock.inspectFuncLightExecutorForJet = f

	return mmLightExecutorForJet
}

// Return sets up results that will be returned by Coordinator.LightExecutorForJet
func (mmLightExecutorForJet *mCoordinatorMockLightExecutorForJet) Return(rp1 *insolar.Reference, err error) *CoordinatorMock {
	if mmLightExecutorForJet.mock.funcLightExecutorForJet != nil {
		mmLightExecutorForJet.mock.t.Fatalf("CoordinatorMock.LightExecutorForJet mock is already set by Set")
	}

	if mmLightExecutorForJet.defaultExpectation == nil {
		mmLightExecutorForJet.defaultExpectation = &CoordinatorMockLightExecutorForJetExpectation{mock: mmLightExecutorForJet.mock}
	}
	mmLightExecutorForJet.defaultExpectation.results = &CoordinatorMockLightExecutorForJetResults{rp1, err}
	return mmLightExecutorForJet.mock
}

//Set uses given function f to mock the Coordinator.LightExecutorForJet method
func (mmLightExecutorForJet *mCoordinatorMockLightExecutorForJet) Set(f func(ctx context.Context, jetID insolar.ID, pulse insolar.PulseNumber) (rp1 *insolar.Reference, err error)) *CoordinatorMock {
	if mmLightExecutorForJet.defaultExpectation != nil {
		mmLightExecutorForJet.mock.t.Fatalf("Default expectation is already set for the Coordinator.LightExecutorForJet method")
	}

	if len(mmLightExecutorForJet.expectations) > 0 {
		mmLightExecutorForJet.mock.t.Fatalf("Some expectations are already set for the Coordinator.LightExecutorForJet method")
	}

	mmLightExecutorForJet.mock.funcLightExecutorForJet = f
	return mmLightExecutorForJet.mock
}

// When sets expectation for the Coordinator.LightExecutorForJet which will trigger the result defined by the following
// Then helper
func (mmLightExecutorForJet *mCoordinatorMockLightExecutorForJet) When(ctx context.Context, jetID insolar.ID, pulse insolar.PulseNumber) *CoordinatorMockLightExecutorForJetExpectation {
	if mmLightExecutorForJet.mock.funcLightExecutorForJet != nil {
		mmLightExecutorForJet.mock.t.Fatalf("CoordinatorMock.LightExecutorForJet mock is already set by Set")
	}

	expectation := &CoordinatorMockLightExecutorForJetExpectation{
		mock:   mmLightExecutorForJet.mock,
		params: &CoordinatorMockLightExecutorForJetParams{ctx, jetID, pulse},
	}
	mmLightExecutorForJet.expectations = append(mmLightExecutorForJet.expectations, expectation)
	return expectation
}

// Then sets up Coordinator.LightExecutorForJet return parameters for the expectation previously defined by the When method
func (e *CoordinatorMockLightExecutorForJetExpectation) Then(rp1 *insolar.Reference, err error) *CoordinatorMock {
	e.results = &CoordinatorMockLightExecutorForJetResults{rp1, err}
	return e.mock
}

// LightExecutorForJet implements Coordinator
func (mmLightExecutorForJet *CoordinatorMock) LightExecutorForJet(ctx context.Context, jetID insolar.ID, pulse insolar.PulseNumber) (rp1 *insolar.Reference, err error) {
	mm_atomic.AddUint64(&mmLightExecutorForJet.beforeLightExecutorForJetCounter, 1)
	defer mm_atomic.AddUint64(&mmLightExecutorForJet.afterLightExecutorForJetCounter, 1)

	if mmLightExecutorForJet.inspectFuncLightExecutorForJet != nil {
		mmLightExecutorForJet.inspectFuncLightExecutorForJet(ctx, jetID, pulse)
	}

	mm_params := &CoordinatorMockLightExecutorForJetParams{ctx, jetID, pulse}

	// Record call args
	mmLightExecutorForJet.LightExecutorForJetMock.mutex.Lock()
	mmLightExecutorForJet.LightExecutorForJetMock.callArgs = append(mmLightExecutorForJet.LightExecutorForJetMock.callArgs, mm_params)
	mmLightExecutorForJet.LightExecutorForJetMock.mutex.Unlock()

	for _, e := range mmLightExecutorForJet.LightExecutorForJetMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmLightExecutorForJet.LightExecutorForJetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLightExecutorForJet.LightExecutorForJetMock.defaultExpectation.Counter, 1)
		mm_want := mmLightExecutorForJet.LightExecutorForJetMock.defaultExpectation.params
		mm_got := CoordinatorMockLightExecutorForJetParams{ctx, jetID, pulse}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLightExecutorForJet.t.Errorf("CoordinatorMock.LightExecutorForJet got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLightExecutorForJet.LightExecutorForJetMock.defaultExpectation.results
		if mm_results == nil {
			mmLightExecutorForJet.t.Fatal("No results are set for the CoordinatorMock.LightExecutorForJet")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmLightExecutorForJet.funcLightExecutorForJet != nil {
		return mmLightExecutorForJet.funcLightExecutorForJet(ctx, jetID, pulse)
	}
	mmLightExecutorForJet.t.Fatalf("Unexpected call to CoordinatorMock.LightExecutorForJet. %v %v %v", ctx, jetID, pulse)
	return
}

// LightExecutorForJetAfterCounter returns a count of finished CoordinatorMock.LightExecutorForJet invocations
func (mmLightExecutorForJet *CoordinatorMock) LightExecutorForJetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLightExecutorForJet.afterLightExecutorForJetCounter)
}

// LightExecutorForJetBeforeCounter returns a count of CoordinatorMock.LightExecutorForJet invocations
func (mmLightExecutorForJet *CoordinatorMock) LightExecutorForJetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLightExecutorForJet.beforeLightExecutorForJetCounter)
}

// Calls returns a list of arguments used in each call to CoordinatorMock.LightExecutorForJet.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLightExecutorForJet *mCoordinatorMockLightExecutorForJet) Calls() []*CoordinatorMockLightExecutorForJetParams {
	mmLightExecutorForJet.mutex.RLock()

	argCopy := make([]*CoordinatorMockLightExecutorForJetParams, len(mmLightExecutorForJet.callArgs))
	copy(argCopy, mmLightExecutorForJet.callArgs)

	mmLightExecutorForJet.mutex.RUnlock()

	return argCopy
}

// MinimockLightExecutorForJetDone returns true if the count of the LightExecutorForJet invocations corresponds
// the number of defined expectations
func (m *CoordinatorMock) MinimockLightExecutorForJetDone() bool {
	for _, e := range m.LightExecutorForJetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LightExecutorForJetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLightExecutorForJetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLightExecutorForJet != nil && mm_atomic.LoadUint64(&m.afterLightExecutorForJetCounter) < 1 {
		return false
	}
	return true
}

// MinimockLightExecutorForJetInspect logs each unmet expectation
func (m *CoordinatorMock) MinimockLightExecutorForJetInspect() {
	for _, e := range m.LightExecutorForJetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoordinatorMock.LightExecutorForJet with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LightExecutorForJetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLightExecutorForJetCounter) < 1 {
		if m.LightExecutorForJetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CoordinatorMock.LightExecutorForJet")
		} else {
			m.t.Errorf("Expected call to CoordinatorMock.LightExecutorForJet with params: %#v", *m.LightExecutorForJetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLightExecutorForJet != nil && mm_atomic.LoadUint64(&m.afterLightExecutorForJetCounter) < 1 {
		m.t.Error("Expected call to CoordinatorMock.LightExecutorForJet")
	}
}

type mCoordinatorMockLightExecutorForObject struct {
	mock               *CoordinatorMock
	defaultExpectation *CoordinatorMockLightExecutorForObjectExpectation
	expectations       []*CoordinatorMockLightExecutorForObjectExpectation

	callArgs []*CoordinatorMockLightExecutorForObjectParams
	mutex    sync.RWMutex
}

// CoordinatorMockLightExecutorForObjectExpectation specifies expectation struct of the Coordinator.LightExecutorForObject
type CoordinatorMockLightExecutorForObjectExpectation struct {
	mock    *CoordinatorMock
	params  *CoordinatorMockLightExecutorForObjectParams
	results *CoordinatorMockLightExecutorForObjectResults
	Counter uint64
}

// CoordinatorMockLightExecutorForObjectParams contains parameters of the Coordinator.LightExecutorForObject
type CoordinatorMockLightExecutorForObjectParams struct {
	ctx   context.Context
	objID insolar.ID
	pulse insolar.PulseNumber
}

// CoordinatorMockLightExecutorForObjectResults contains results of the Coordinator.LightExecutorForObject
type CoordinatorMockLightExecutorForObjectResults struct {
	rp1 *insolar.Reference
	err error
}

// Expect sets up expected params for Coordinator.LightExecutorForObject
func (mmLightExecutorForObject *mCoordinatorMockLightExecutorForObject) Expect(ctx context.Context, objID insolar.ID, pulse insolar.PulseNumber) *mCoordinatorMockLightExecutorForObject {
	if mmLightExecutorForObject.mock.funcLightExecutorForObject != nil {
		mmLightExecutorForObject.mock.t.Fatalf("CoordinatorMock.LightExecutorForObject mock is already set by Set")
	}

	if mmLightExecutorForObject.defaultExpectation == nil {
		mmLightExecutorForObject.defaultExpectation = &CoordinatorMockLightExecutorForObjectExpectation{}
	}

	mmLightExecutorForObject.defaultExpectation.params = &CoordinatorMockLightExecutorForObjectParams{ctx, objID, pulse}
	for _, e := range mmLightExecutorForObject.expectations {
		if minimock.Equal(e.params, mmLightExecutorForObject.defaultExpectation.params) {
			mmLightExecutorForObject.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLightExecutorForObject.defaultExpectation.params)
		}
	}

	return mmLightExecutorForObject
}

// Inspect accepts an inspector function that has same arguments as the Coordinator.LightExecutorForObject
func (mmLightExecutorForObject *mCoordinatorMockLightExecutorForObject) Inspect(f func(ctx context.Context, objID insolar.ID, pulse insolar.PulseNumber)) *mCoordinatorMockLightExecutorForObject {
	if mmLightExecutorForObject.mock.inspectFuncLightExecutorForObject != nil {
		mmLightExecutorForObject.mock.t.Fatalf("Inspect function is already set for CoordinatorMock.LightExecutorForObject")
	}

	mmLightExecutorForObject.mock.inspectFuncLightExecutorForObject = f

	return mmLightExecutorForObject
}

// Return sets up results that will be returned by Coordinator.LightExecutorForObject
func (mmLightExecutorForObject *mCoordinatorMockLightExecutorForObject) Return(rp1 *insolar.Reference, err error) *CoordinatorMock {
	if mmLightExecutorForObject.mock.funcLightExecutorForObject != nil {
		mmLightExecutorForObject.mock.t.Fatalf("CoordinatorMock.LightExecutorForObject mock is already set by Set")
	}

	if mmLightExecutorForObject.defaultExpectation == nil {
		mmLightExecutorForObject.defaultExpectation = &CoordinatorMockLightExecutorForObjectExpectation{mock: mmLightExecutorForObject.mock}
	}
	mmLightExecutorForObject.defaultExpectation.results = &CoordinatorMockLightExecutorForObjectResults{rp1, err}
	return mmLightExecutorForObject.mock
}

//Set uses given function f to mock the Coordinator.LightExecutorForObject method
func (mmLightExecutorForObject *mCoordinatorMockLightExecutorForObject) Set(f func(ctx context.Context, objID insolar.ID, pulse insolar.PulseNumber) (rp1 *insolar.Reference, err error)) *CoordinatorMock {
	if mmLightExecutorForObject.defaultExpectation != nil {
		mmLightExecutorForObject.mock.t.Fatalf("Default expectation is already set for the Coordinator.LightExecutorForObject method")
	}

	if len(mmLightExecutorForObject.expectations) > 0 {
		mmLightExecutorForObject.mock.t.Fatalf("Some expectations are already set for the Coordinator.LightExecutorForObject method")
	}

	mmLightExecutorForObject.mock.funcLightExecutorForObject = f
	return mmLightExecutorForObject.mock
}

// When sets expectation for the Coordinator.LightExecutorForObject which will trigger the result defined by the following
// Then helper
func (mmLightExecutorForObject *mCoordinatorMockLightExecutorForObject) When(ctx context.Context, objID insolar.ID, pulse insolar.PulseNumber) *CoordinatorMockLightExecutorForObjectExpectation {
	if mmLightExecutorForObject.mock.funcLightExecutorForObject != nil {
		mmLightExecutorForObject.mock.t.Fatalf("CoordinatorMock.LightExecutorForObject mock is already set by Set")
	}

	expectation := &CoordinatorMockLightExecutorForObjectExpectation{
		mock:   mmLightExecutorForObject.mock,
		params: &CoordinatorMockLightExecutorForObjectParams{ctx, objID, pulse},
	}
	mmLightExecutorForObject.expectations = append(mmLightExecutorForObject.expectations, expectation)
	return expectation
}

// Then sets up Coordinator.LightExecutorForObject return parameters for the expectation previously defined by the When method
func (e *CoordinatorMockLightExecutorForObjectExpectation) Then(rp1 *insolar.Reference, err error) *CoordinatorMock {
	e.results = &CoordinatorMockLightExecutorForObjectResults{rp1, err}
	return e.mock
}

// LightExecutorForObject implements Coordinator
func (mmLightExecutorForObject *CoordinatorMock) LightExecutorForObject(ctx context.Context, objID insolar.ID, pulse insolar.PulseNumber) (rp1 *insolar.Reference, err error) {
	mm_atomic.AddUint64(&mmLightExecutorForObject.beforeLightExecutorForObjectCounter, 1)
	defer mm_atomic.AddUint64(&mmLightExecutorForObject.afterLightExecutorForObjectCounter, 1)

	if mmLightExecutorForObject.inspectFuncLightExecutorForObject != nil {
		mmLightExecutorForObject.inspectFuncLightExecutorForObject(ctx, objID, pulse)
	}

	mm_params := &CoordinatorMockLightExecutorForObjectParams{ctx, objID, pulse}

	// Record call args
	mmLightExecutorForObject.LightExecutorForObjectMock.mutex.Lock()
	mmLightExecutorForObject.LightExecutorForObjectMock.callArgs = append(mmLightExecutorForObject.LightExecutorForObjectMock.callArgs, mm_params)
	mmLightExecutorForObject.LightExecutorForObjectMock.mutex.Unlock()

	for _, e := range mmLightExecutorForObject.LightExecutorForObjectMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmLightExecutorForObject.LightExecutorForObjectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLightExecutorForObject.LightExecutorForObjectMock.defaultExpectation.Counter, 1)
		mm_want := mmLightExecutorForObject.LightExecutorForObjectMock.defaultExpectation.params
		mm_got := CoordinatorMockLightExecutorForObjectParams{ctx, objID, pulse}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLightExecutorForObject.t.Errorf("CoordinatorMock.LightExecutorForObject got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLightExecutorForObject.LightExecutorForObjectMock.defaultExpectation.results
		if mm_results == nil {
			mmLightExecutorForObject.t.Fatal("No results are set for the CoordinatorMock.LightExecutorForObject")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmLightExecutorForObject.funcLightExecutorForObject != nil {
		return mmLightExecutorForObject.funcLightExecutorForObject(ctx, objID, pulse)
	}
	mmLightExecutorForObject.t.Fatalf("Unexpected call to CoordinatorMock.LightExecutorForObject. %v %v %v", ctx, objID, pulse)
	return
}

// LightExecutorForObjectAfterCounter returns a count of finished CoordinatorMock.LightExecutorForObject invocations
func (mmLightExecutorForObject *CoordinatorMock) LightExecutorForObjectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLightExecutorForObject.afterLightExecutorForObjectCounter)
}

// LightExecutorForObjectBeforeCounter returns a count of CoordinatorMock.LightExecutorForObject invocations
func (mmLightExecutorForObject *CoordinatorMock) LightExecutorForObjectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLightExecutorForObject.beforeLightExecutorForObjectCounter)
}

// Calls returns a list of arguments used in each call to CoordinatorMock.LightExecutorForObject.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLightExecutorForObject *mCoordinatorMockLightExecutorForObject) Calls() []*CoordinatorMockLightExecutorForObjectParams {
	mmLightExecutorForObject.mutex.RLock()

	argCopy := make([]*CoordinatorMockLightExecutorForObjectParams, len(mmLightExecutorForObject.callArgs))
	copy(argCopy, mmLightExecutorForObject.callArgs)

	mmLightExecutorForObject.mutex.RUnlock()

	return argCopy
}

// MinimockLightExecutorForObjectDone returns true if the count of the LightExecutorForObject invocations corresponds
// the number of defined expectations
func (m *CoordinatorMock) MinimockLightExecutorForObjectDone() bool {
	for _, e := range m.LightExecutorForObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LightExecutorForObjectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLightExecutorForObjectCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLightExecutorForObject != nil && mm_atomic.LoadUint64(&m.afterLightExecutorForObjectCounter) < 1 {
		return false
	}
	return true
}

// MinimockLightExecutorForObjectInspect logs each unmet expectation
func (m *CoordinatorMock) MinimockLightExecutorForObjectInspect() {
	for _, e := range m.LightExecutorForObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoordinatorMock.LightExecutorForObject with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LightExecutorForObjectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLightExecutorForObjectCounter) < 1 {
		if m.LightExecutorForObjectMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CoordinatorMock.LightExecutorForObject")
		} else {
			m.t.Errorf("Expected call to CoordinatorMock.LightExecutorForObject with params: %#v", *m.LightExecutorForObjectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLightExecutorForObject != nil && mm_atomic.LoadUint64(&m.afterLightExecutorForObjectCounter) < 1 {
		m.t.Error("Expected call to CoordinatorMock.LightExecutorForObject")
	}
}

type mCoordinatorMockLightValidatorsForJet struct {
	mock               *CoordinatorMock
	defaultExpectation *CoordinatorMockLightValidatorsForJetExpectation
	expectations       []*CoordinatorMockLightValidatorsForJetExpectation

	callArgs []*CoordinatorMockLightValidatorsForJetParams
	mutex    sync.RWMutex
}

// CoordinatorMockLightValidatorsForJetExpectation specifies expectation struct of the Coordinator.LightValidatorsForJet
type CoordinatorMockLightValidatorsForJetExpectation struct {
	mock    *CoordinatorMock
	params  *CoordinatorMockLightValidatorsForJetParams
	results *CoordinatorMockLightValidatorsForJetResults
	Counter uint64
}

// CoordinatorMockLightValidatorsForJetParams contains parameters of the Coordinator.LightValidatorsForJet
type CoordinatorMockLightValidatorsForJetParams struct {
	ctx   context.Context
	jetID insolar.ID
	pulse insolar.PulseNumber
}

// CoordinatorMockLightValidatorsForJetResults contains results of the Coordinator.LightValidatorsForJet
type CoordinatorMockLightValidatorsForJetResults struct {
	ra1 []insolar.Reference
	err error
}

// Expect sets up expected params for Coordinator.LightValidatorsForJet
func (mmLightValidatorsForJet *mCoordinatorMockLightValidatorsForJet) Expect(ctx context.Context, jetID insolar.ID, pulse insolar.PulseNumber) *mCoordinatorMockLightValidatorsForJet {
	if mmLightValidatorsForJet.mock.funcLightValidatorsForJet != nil {
		mmLightValidatorsForJet.mock.t.Fatalf("CoordinatorMock.LightValidatorsForJet mock is already set by Set")
	}

	if mmLightValidatorsForJet.defaultExpectation == nil {
		mmLightValidatorsForJet.defaultExpectation = &CoordinatorMockLightValidatorsForJetExpectation{}
	}

	mmLightValidatorsForJet.defaultExpectation.params = &CoordinatorMockLightValidatorsForJetParams{ctx, jetID, pulse}
	for _, e := range mmLightValidatorsForJet.expectations {
		if minimock.Equal(e.params, mmLightValidatorsForJet.defaultExpectation.params) {
			mmLightValidatorsForJet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLightValidatorsForJet.defaultExpectation.params)
		}
	}

	return mmLightValidatorsForJet
}

// Inspect accepts an inspector function that has same arguments as the Coordinator.LightValidatorsForJet
func (mmLightValidatorsForJet *mCoordinatorMockLightValidatorsForJet) Inspect(f func(ctx context.Context, jetID insolar.ID, pulse insolar.PulseNumber)) *mCoordinatorMockLightValidatorsForJet {
	if mmLightValidatorsForJet.mock.inspectFuncLightValidatorsForJet != nil {
		mmLightValidatorsForJet.mock.t.Fatalf("Inspect function is already set for CoordinatorMock.LightValidatorsForJet")
	}

	mmLightValidatorsForJet.mock.inspectFuncLightValidatorsForJet = f

	return mmLightValidatorsForJet
}

// Return sets up results that will be returned by Coordinator.LightValidatorsForJet
func (mmLightValidatorsForJet *mCoordinatorMockLightValidatorsForJet) Return(ra1 []insolar.Reference, err error) *CoordinatorMock {
	if mmLightValidatorsForJet.mock.funcLightValidatorsForJet != nil {
		mmLightValidatorsForJet.mock.t.Fatalf("CoordinatorMock.LightValidatorsForJet mock is already set by Set")
	}

	if mmLightValidatorsForJet.defaultExpectation == nil {
		mmLightValidatorsForJet.defaultExpectation = &CoordinatorMockLightValidatorsForJetExpectation{mock: mmLightValidatorsForJet.mock}
	}
	mmLightValidatorsForJet.defaultExpectation.results = &CoordinatorMockLightValidatorsForJetResults{ra1, err}
	return mmLightValidatorsForJet.mock
}

//Set uses given function f to mock the Coordinator.LightValidatorsForJet method
func (mmLightValidatorsForJet *mCoordinatorMockLightValidatorsForJet) Set(f func(ctx context.Context, jetID insolar.ID, pulse insolar.PulseNumber) (ra1 []insolar.Reference, err error)) *CoordinatorMock {
	if mmLightValidatorsForJet.defaultExpectation != nil {
		mmLightValidatorsForJet.mock.t.Fatalf("Default expectation is already set for the Coordinator.LightValidatorsForJet method")
	}

	if len(mmLightValidatorsForJet.expectations) > 0 {
		mmLightValidatorsForJet.mock.t.Fatalf("Some expectations are already set for the Coordinator.LightValidatorsForJet method")
	}

	mmLightValidatorsForJet.mock.funcLightValidatorsForJet = f
	return mmLightValidatorsForJet.mock
}

// When sets expectation for the Coordinator.LightValidatorsForJet which will trigger the result defined by the following
// Then helper
func (mmLightValidatorsForJet *mCoordinatorMockLightValidatorsForJet) When(ctx context.Context, jetID insolar.ID, pulse insolar.PulseNumber) *CoordinatorMockLightValidatorsForJetExpectation {
	if mmLightValidatorsForJet.mock.funcLightValidatorsForJet != nil {
		mmLightValidatorsForJet.mock.t.Fatalf("CoordinatorMock.LightValidatorsForJet mock is already set by Set")
	}

	expectation := &CoordinatorMockLightValidatorsForJetExpectation{
		mock:   mmLightValidatorsForJet.mock,
		params: &CoordinatorMockLightValidatorsForJetParams{ctx, jetID, pulse},
	}
	mmLightValidatorsForJet.expectations = append(mmLightValidatorsForJet.expectations, expectation)
	return expectation
}

// Then sets up Coordinator.LightValidatorsForJet return parameters for the expectation previously defined by the When method
func (e *CoordinatorMockLightValidatorsForJetExpectation) Then(ra1 []insolar.Reference, err error) *CoordinatorMock {
	e.results = &CoordinatorMockLightValidatorsForJetResults{ra1, err}
	return e.mock
}

// LightValidatorsForJet implements Coordinator
func (mmLightValidatorsForJet *CoordinatorMock) LightValidatorsForJet(ctx context.Context, jetID insolar.ID, pulse insolar.PulseNumber) (ra1 []insolar.Reference, err error) {
	mm_atomic.AddUint64(&mmLightValidatorsForJet.beforeLightValidatorsForJetCounter, 1)
	defer mm_atomic.AddUint64(&mmLightValidatorsForJet.afterLightValidatorsForJetCounter, 1)

	if mmLightValidatorsForJet.inspectFuncLightValidatorsForJet != nil {
		mmLightValidatorsForJet.inspectFuncLightValidatorsForJet(ctx, jetID, pulse)
	}

	mm_params := &CoordinatorMockLightValidatorsForJetParams{ctx, jetID, pulse}

	// Record call args
	mmLightValidatorsForJet.LightValidatorsForJetMock.mutex.Lock()
	mmLightValidatorsForJet.LightValidatorsForJetMock.callArgs = append(mmLightValidatorsForJet.LightValidatorsForJetMock.callArgs, mm_params)
	mmLightValidatorsForJet.LightValidatorsForJetMock.mutex.Unlock()

	for _, e := range mmLightValidatorsForJet.LightValidatorsForJetMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ra1, e.results.err
		}
	}

	if mmLightValidatorsForJet.LightValidatorsForJetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLightValidatorsForJet.LightValidatorsForJetMock.defaultExpectation.Counter, 1)
		mm_want := mmLightValidatorsForJet.LightValidatorsForJetMock.defaultExpectation.params
		mm_got := CoordinatorMockLightValidatorsForJetParams{ctx, jetID, pulse}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLightValidatorsForJet.t.Errorf("CoordinatorMock.LightValidatorsForJet got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLightValidatorsForJet.LightValidatorsForJetMock.defaultExpectation.results
		if mm_results == nil {
			mmLightValidatorsForJet.t.Fatal("No results are set for the CoordinatorMock.LightValidatorsForJet")
		}
		return (*mm_results).ra1, (*mm_results).err
	}
	if mmLightValidatorsForJet.funcLightValidatorsForJet != nil {
		return mmLightValidatorsForJet.funcLightValidatorsForJet(ctx, jetID, pulse)
	}
	mmLightValidatorsForJet.t.Fatalf("Unexpected call to CoordinatorMock.LightValidatorsForJet. %v %v %v", ctx, jetID, pulse)
	return
}

// LightValidatorsForJetAfterCounter returns a count of finished CoordinatorMock.LightValidatorsForJet invocations
func (mmLightValidatorsForJet *CoordinatorMock) LightValidatorsForJetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLightValidatorsForJet.afterLightValidatorsForJetCounter)
}

// LightValidatorsForJetBeforeCounter returns a count of CoordinatorMock.LightValidatorsForJet invocations
func (mmLightValidatorsForJet *CoordinatorMock) LightValidatorsForJetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLightValidatorsForJet.beforeLightValidatorsForJetCounter)
}

// Calls returns a list of arguments used in each call to CoordinatorMock.LightValidatorsForJet.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLightValidatorsForJet *mCoordinatorMockLightValidatorsForJet) Calls() []*CoordinatorMockLightValidatorsForJetParams {
	mmLightValidatorsForJet.mutex.RLock()

	argCopy := make([]*CoordinatorMockLightValidatorsForJetParams, len(mmLightValidatorsForJet.callArgs))
	copy(argCopy, mmLightValidatorsForJet.callArgs)

	mmLightValidatorsForJet.mutex.RUnlock()

	return argCopy
}

// MinimockLightValidatorsForJetDone returns true if the count of the LightValidatorsForJet invocations corresponds
// the number of defined expectations
func (m *CoordinatorMock) MinimockLightValidatorsForJetDone() bool {
	for _, e := range m.LightValidatorsForJetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LightValidatorsForJetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLightValidatorsForJetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLightValidatorsForJet != nil && mm_atomic.LoadUint64(&m.afterLightValidatorsForJetCounter) < 1 {
		return false
	}
	return true
}

// MinimockLightValidatorsForJetInspect logs each unmet expectation
func (m *CoordinatorMock) MinimockLightValidatorsForJetInspect() {
	for _, e := range m.LightValidatorsForJetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoordinatorMock.LightValidatorsForJet with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LightValidatorsForJetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLightValidatorsForJetCounter) < 1 {
		if m.LightValidatorsForJetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CoordinatorMock.LightValidatorsForJet")
		} else {
			m.t.Errorf("Expected call to CoordinatorMock.LightValidatorsForJet with params: %#v", *m.LightValidatorsForJetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLightValidatorsForJet != nil && mm_atomic.LoadUint64(&m.afterLightValidatorsForJetCounter) < 1 {
		m.t.Error("Expected call to CoordinatorMock.LightValidatorsForJet")
	}
}

type mCoordinatorMockLightValidatorsForObject struct {
	mock               *CoordinatorMock
	defaultExpectation *CoordinatorMockLightValidatorsForObjectExpectation
	expectations       []*CoordinatorMockLightValidatorsForObjectExpectation

	callArgs []*CoordinatorMockLightValidatorsForObjectParams
	mutex    sync.RWMutex
}

// CoordinatorMockLightValidatorsForObjectExpectation specifies expectation struct of the Coordinator.LightValidatorsForObject
type CoordinatorMockLightValidatorsForObjectExpectation struct {
	mock    *CoordinatorMock
	params  *CoordinatorMockLightValidatorsForObjectParams
	results *CoordinatorMockLightValidatorsForObjectResults
	Counter uint64
}

// CoordinatorMockLightValidatorsForObjectParams contains parameters of the Coordinator.LightValidatorsForObject
type CoordinatorMockLightValidatorsForObjectParams struct {
	ctx   context.Context
	objID insolar.ID
	pulse insolar.PulseNumber
}

// CoordinatorMockLightValidatorsForObjectResults contains results of the Coordinator.LightValidatorsForObject
type CoordinatorMockLightValidatorsForObjectResults struct {
	ra1 []insolar.Reference
	err error
}

// Expect sets up expected params for Coordinator.LightValidatorsForObject
func (mmLightValidatorsForObject *mCoordinatorMockLightValidatorsForObject) Expect(ctx context.Context, objID insolar.ID, pulse insolar.PulseNumber) *mCoordinatorMockLightValidatorsForObject {
	if mmLightValidatorsForObject.mock.funcLightValidatorsForObject != nil {
		mmLightValidatorsForObject.mock.t.Fatalf("CoordinatorMock.LightValidatorsForObject mock is already set by Set")
	}

	if mmLightValidatorsForObject.defaultExpectation == nil {
		mmLightValidatorsForObject.defaultExpectation = &CoordinatorMockLightValidatorsForObjectExpectation{}
	}

	mmLightValidatorsForObject.defaultExpectation.params = &CoordinatorMockLightValidatorsForObjectParams{ctx, objID, pulse}
	for _, e := range mmLightValidatorsForObject.expectations {
		if minimock.Equal(e.params, mmLightValidatorsForObject.defaultExpectation.params) {
			mmLightValidatorsForObject.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLightValidatorsForObject.defaultExpectation.params)
		}
	}

	return mmLightValidatorsForObject
}

// Inspect accepts an inspector function that has same arguments as the Coordinator.LightValidatorsForObject
func (mmLightValidatorsForObject *mCoordinatorMockLightValidatorsForObject) Inspect(f func(ctx context.Context, objID insolar.ID, pulse insolar.PulseNumber)) *mCoordinatorMockLightValidatorsForObject {
	if mmLightValidatorsForObject.mock.inspectFuncLightValidatorsForObject != nil {
		mmLightValidatorsForObject.mock.t.Fatalf("Inspect function is already set for CoordinatorMock.LightValidatorsForObject")
	}

	mmLightValidatorsForObject.mock.inspectFuncLightValidatorsForObject = f

	return mmLightValidatorsForObject
}

// Return sets up results that will be returned by Coordinator.LightValidatorsForObject
func (mmLightValidatorsForObject *mCoordinatorMockLightValidatorsForObject) Return(ra1 []insolar.Reference, err error) *CoordinatorMock {
	if mmLightValidatorsForObject.mock.funcLightValidatorsForObject != nil {
		mmLightValidatorsForObject.mock.t.Fatalf("CoordinatorMock.LightValidatorsForObject mock is already set by Set")
	}

	if mmLightValidatorsForObject.defaultExpectation == nil {
		mmLightValidatorsForObject.defaultExpectation = &CoordinatorMockLightValidatorsForObjectExpectation{mock: mmLightValidatorsForObject.mock}
	}
	mmLightValidatorsForObject.defaultExpectation.results = &CoordinatorMockLightValidatorsForObjectResults{ra1, err}
	return mmLightValidatorsForObject.mock
}

//Set uses given function f to mock the Coordinator.LightValidatorsForObject method
func (mmLightValidatorsForObject *mCoordinatorMockLightValidatorsForObject) Set(f func(ctx context.Context, objID insolar.ID, pulse insolar.PulseNumber) (ra1 []insolar.Reference, err error)) *CoordinatorMock {
	if mmLightValidatorsForObject.defaultExpectation != nil {
		mmLightValidatorsForObject.mock.t.Fatalf("Default expectation is already set for the Coordinator.LightValidatorsForObject method")
	}

	if len(mmLightValidatorsForObject.expectations) > 0 {
		mmLightValidatorsForObject.mock.t.Fatalf("Some expectations are already set for the Coordinator.LightValidatorsForObject method")
	}

	mmLightValidatorsForObject.mock.funcLightValidatorsForObject = f
	return mmLightValidatorsForObject.mock
}

// When sets expectation for the Coordinator.LightValidatorsForObject which will trigger the result defined by the following
// Then helper
func (mmLightValidatorsForObject *mCoordinatorMockLightValidatorsForObject) When(ctx context.Context, objID insolar.ID, pulse insolar.PulseNumber) *CoordinatorMockLightValidatorsForObjectExpectation {
	if mmLightValidatorsForObject.mock.funcLightValidatorsForObject != nil {
		mmLightValidatorsForObject.mock.t.Fatalf("CoordinatorMock.LightValidatorsForObject mock is already set by Set")
	}

	expectation := &CoordinatorMockLightValidatorsForObjectExpectation{
		mock:   mmLightValidatorsForObject.mock,
		params: &CoordinatorMockLightValidatorsForObjectParams{ctx, objID, pulse},
	}
	mmLightValidatorsForObject.expectations = append(mmLightValidatorsForObject.expectations, expectation)
	return expectation
}

// Then sets up Coordinator.LightValidatorsForObject return parameters for the expectation previously defined by the When method
func (e *CoordinatorMockLightValidatorsForObjectExpectation) Then(ra1 []insolar.Reference, err error) *CoordinatorMock {
	e.results = &CoordinatorMockLightValidatorsForObjectResults{ra1, err}
	return e.mock
}

// LightValidatorsForObject implements Coordinator
func (mmLightValidatorsForObject *CoordinatorMock) LightValidatorsForObject(ctx context.Context, objID insolar.ID, pulse insolar.PulseNumber) (ra1 []insolar.Reference, err error) {
	mm_atomic.AddUint64(&mmLightValidatorsForObject.beforeLightValidatorsForObjectCounter, 1)
	defer mm_atomic.AddUint64(&mmLightValidatorsForObject.afterLightValidatorsForObjectCounter, 1)

	if mmLightValidatorsForObject.inspectFuncLightValidatorsForObject != nil {
		mmLightValidatorsForObject.inspectFuncLightValidatorsForObject(ctx, objID, pulse)
	}

	mm_params := &CoordinatorMockLightValidatorsForObjectParams{ctx, objID, pulse}

	// Record call args
	mmLightValidatorsForObject.LightValidatorsForObjectMock.mutex.Lock()
	mmLightValidatorsForObject.LightValidatorsForObjectMock.callArgs = append(mmLightValidatorsForObject.LightValidatorsForObjectMock.callArgs, mm_params)
	mmLightValidatorsForObject.LightValidatorsForObjectMock.mutex.Unlock()

	for _, e := range mmLightValidatorsForObject.LightValidatorsForObjectMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ra1, e.results.err
		}
	}

	if mmLightValidatorsForObject.LightValidatorsForObjectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLightValidatorsForObject.LightValidatorsForObjectMock.defaultExpectation.Counter, 1)
		mm_want := mmLightValidatorsForObject.LightValidatorsForObjectMock.defaultExpectation.params
		mm_got := CoordinatorMockLightValidatorsForObjectParams{ctx, objID, pulse}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLightValidatorsForObject.t.Errorf("CoordinatorMock.LightValidatorsForObject got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLightValidatorsForObject.LightValidatorsForObjectMock.defaultExpectation.results
		if mm_results == nil {
			mmLightValidatorsForObject.t.Fatal("No results are set for the CoordinatorMock.LightValidatorsForObject")
		}
		return (*mm_results).ra1, (*mm_results).err
	}
	if mmLightValidatorsForObject.funcLightValidatorsForObject != nil {
		return mmLightValidatorsForObject.funcLightValidatorsForObject(ctx, objID, pulse)
	}
	mmLightValidatorsForObject.t.Fatalf("Unexpected call to CoordinatorMock.LightValidatorsForObject. %v %v %v", ctx, objID, pulse)
	return
}

// LightValidatorsForObjectAfterCounter returns a count of finished CoordinatorMock.LightValidatorsForObject invocations
func (mmLightValidatorsForObject *CoordinatorMock) LightValidatorsForObjectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLightValidatorsForObject.afterLightValidatorsForObjectCounter)
}

// LightValidatorsForObjectBeforeCounter returns a count of CoordinatorMock.LightValidatorsForObject invocations
func (mmLightValidatorsForObject *CoordinatorMock) LightValidatorsForObjectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLightValidatorsForObject.beforeLightValidatorsForObjectCounter)
}

// Calls returns a list of arguments used in each call to CoordinatorMock.LightValidatorsForObject.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLightValidatorsForObject *mCoordinatorMockLightValidatorsForObject) Calls() []*CoordinatorMockLightValidatorsForObjectParams {
	mmLightValidatorsForObject.mutex.RLock()

	argCopy := make([]*CoordinatorMockLightValidatorsForObjectParams, len(mmLightValidatorsForObject.callArgs))
	copy(argCopy, mmLightValidatorsForObject.callArgs)

	mmLightValidatorsForObject.mutex.RUnlock()

	return argCopy
}

// MinimockLightValidatorsForObjectDone returns true if the count of the LightValidatorsForObject invocations corresponds
// the number of defined expectations
func (m *CoordinatorMock) MinimockLightValidatorsForObjectDone() bool {
	for _, e := range m.LightValidatorsForObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LightValidatorsForObjectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLightValidatorsForObjectCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLightValidatorsForObject != nil && mm_atomic.LoadUint64(&m.afterLightValidatorsForObjectCounter) < 1 {
		return false
	}
	return true
}

// MinimockLightValidatorsForObjectInspect logs each unmet expectation
func (m *CoordinatorMock) MinimockLightValidatorsForObjectInspect() {
	for _, e := range m.LightValidatorsForObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoordinatorMock.LightValidatorsForObject with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LightValidatorsForObjectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLightValidatorsForObjectCounter) < 1 {
		if m.LightValidatorsForObjectMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CoordinatorMock.LightValidatorsForObject")
		} else {
			m.t.Errorf("Expected call to CoordinatorMock.LightValidatorsForObject with params: %#v", *m.LightValidatorsForObjectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLightValidatorsForObject != nil && mm_atomic.LoadUint64(&m.afterLightValidatorsForObjectCounter) < 1 {
		m.t.Error("Expected call to CoordinatorMock.LightValidatorsForObject")
	}
}

type mCoordinatorMockMe struct {
	mock               *CoordinatorMock
	defaultExpectation *CoordinatorMockMeExpectation
	expectations       []*CoordinatorMockMeExpectation
}

// CoordinatorMockMeExpectation specifies expectation struct of the Coordinator.Me
type CoordinatorMockMeExpectation struct {
	mock *CoordinatorMock

	results *CoordinatorMockMeResults
	Counter uint64
}

// CoordinatorMockMeResults contains results of the Coordinator.Me
type CoordinatorMockMeResults struct {
	r1 insolar.Reference
}

// Expect sets up expected params for Coordinator.Me
func (mmMe *mCoordinatorMockMe) Expect() *mCoordinatorMockMe {
	if mmMe.mock.funcMe != nil {
		mmMe.mock.t.Fatalf("CoordinatorMock.Me mock is already set by Set")
	}

	if mmMe.defaultExpectation == nil {
		mmMe.defaultExpectation = &CoordinatorMockMeExpectation{}
	}

	return mmMe
}

// Inspect accepts an inspector function that has same arguments as the Coordinator.Me
func (mmMe *mCoordinatorMockMe) Inspect(f func()) *mCoordinatorMockMe {
	if mmMe.mock.inspectFuncMe != nil {
		mmMe.mock.t.Fatalf("Inspect function is already set for CoordinatorMock.Me")
	}

	mmMe.mock.inspectFuncMe = f

	return mmMe
}

// Return sets up results that will be returned by Coordinator.Me
func (mmMe *mCoordinatorMockMe) Return(r1 insolar.Reference) *CoordinatorMock {
	if mmMe.mock.funcMe != nil {
		mmMe.mock.t.Fatalf("CoordinatorMock.Me mock is already set by Set")
	}

	if mmMe.defaultExpectation == nil {
		mmMe.defaultExpectation = &CoordinatorMockMeExpectation{mock: mmMe.mock}
	}
	mmMe.defaultExpectation.results = &CoordinatorMockMeResults{r1}
	return mmMe.mock
}

//Set uses given function f to mock the Coordinator.Me method
func (mmMe *mCoordinatorMockMe) Set(f func() (r1 insolar.Reference)) *CoordinatorMock {
	if mmMe.defaultExpectation != nil {
		mmMe.mock.t.Fatalf("Default expectation is already set for the Coordinator.Me method")
	}

	if len(mmMe.expectations) > 0 {
		mmMe.mock.t.Fatalf("Some expectations are already set for the Coordinator.Me method")
	}

	mmMe.mock.funcMe = f
	return mmMe.mock
}

// Me implements Coordinator
func (mmMe *CoordinatorMock) Me() (r1 insolar.Reference) {
	mm_atomic.AddUint64(&mmMe.beforeMeCounter, 1)
	defer mm_atomic.AddUint64(&mmMe.afterMeCounter, 1)

	if mmMe.inspectFuncMe != nil {
		mmMe.inspectFuncMe()
	}

	if mmMe.MeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMe.MeMock.defaultExpectation.Counter, 1)

		mm_results := mmMe.MeMock.defaultExpectation.results
		if mm_results == nil {
			mmMe.t.Fatal("No results are set for the CoordinatorMock.Me")
		}
		return (*mm_results).r1
	}
	if mmMe.funcMe != nil {
		return mmMe.funcMe()
	}
	mmMe.t.Fatalf("Unexpected call to CoordinatorMock.Me.")
	return
}

// MeAfterCounter returns a count of finished CoordinatorMock.Me invocations
func (mmMe *CoordinatorMock) MeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMe.afterMeCounter)
}

// MeBeforeCounter returns a count of CoordinatorMock.Me invocations
func (mmMe *CoordinatorMock) MeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMe.beforeMeCounter)
}

// MinimockMeDone returns true if the count of the Me invocations corresponds
// the number of defined expectations
func (m *CoordinatorMock) MinimockMeDone() bool {
	for _, e := range m.MeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMe != nil && mm_atomic.LoadUint64(&m.afterMeCounter) < 1 {
		return false
	}
	return true
}

// MinimockMeInspect logs each unmet expectation
func (m *CoordinatorMock) MinimockMeInspect() {
	for _, e := range m.MeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to CoordinatorMock.Me")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMeCounter) < 1 {
		m.t.Error("Expected call to CoordinatorMock.Me")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMe != nil && mm_atomic.LoadUint64(&m.afterMeCounter) < 1 {
		m.t.Error("Expected call to CoordinatorMock.Me")
	}
}

type mCoordinatorMockNodeForJet struct {
	mock               *CoordinatorMock
	defaultExpectation *CoordinatorMockNodeForJetExpectation
	expectations       []*CoordinatorMockNodeForJetExpectation

	callArgs []*CoordinatorMockNodeForJetParams
	mutex    sync.RWMutex
}

// CoordinatorMockNodeForJetExpectation specifies expectation struct of the Coordinator.NodeForJet
type CoordinatorMockNodeForJetExpectation struct {
	mock    *CoordinatorMock
	params  *CoordinatorMockNodeForJetParams
	results *CoordinatorMockNodeForJetResults
	Counter uint64
}

// CoordinatorMockNodeForJetParams contains parameters of the Coordinator.NodeForJet
type CoordinatorMockNodeForJetParams struct {
	ctx      context.Context
	jetID    insolar.ID
	targetPN insolar.PulseNumber
}

// CoordinatorMockNodeForJetResults contains results of the Coordinator.NodeForJet
type CoordinatorMockNodeForJetResults struct {
	rp1 *insolar.Reference
	err error
}

// Expect sets up expected params for Coordinator.NodeForJet
func (mmNodeForJet *mCoordinatorMockNodeForJet) Expect(ctx context.Context, jetID insolar.ID, targetPN insolar.PulseNumber) *mCoordinatorMockNodeForJet {
	if mmNodeForJet.mock.funcNodeForJet != nil {
		mmNodeForJet.mock.t.Fatalf("CoordinatorMock.NodeForJet mock is already set by Set")
	}

	if mmNodeForJet.defaultExpectation == nil {
		mmNodeForJet.defaultExpectation = &CoordinatorMockNodeForJetExpectation{}
	}

	mmNodeForJet.defaultExpectation.params = &CoordinatorMockNodeForJetParams{ctx, jetID, targetPN}
	for _, e := range mmNodeForJet.expectations {
		if minimock.Equal(e.params, mmNodeForJet.defaultExpectation.params) {
			mmNodeForJet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmNodeForJet.defaultExpectation.params)
		}
	}

	return mmNodeForJet
}

// Inspect accepts an inspector function that has same arguments as the Coordinator.NodeForJet
func (mmNodeForJet *mCoordinatorMockNodeForJet) Inspect(f func(ctx context.Context, jetID insolar.ID, targetPN insolar.PulseNumber)) *mCoordinatorMockNodeForJet {
	if mmNodeForJet.mock.inspectFuncNodeForJet != nil {
		mmNodeForJet.mock.t.Fatalf("Inspect function is already set for CoordinatorMock.NodeForJet")
	}

	mmNodeForJet.mock.inspectFuncNodeForJet = f

	return mmNodeForJet
}

// Return sets up results that will be returned by Coordinator.NodeForJet
func (mmNodeForJet *mCoordinatorMockNodeForJet) Return(rp1 *insolar.Reference, err error) *CoordinatorMock {
	if mmNodeForJet.mock.funcNodeForJet != nil {
		mmNodeForJet.mock.t.Fatalf("CoordinatorMock.NodeForJet mock is already set by Set")
	}

	if mmNodeForJet.defaultExpectation == nil {
		mmNodeForJet.defaultExpectation = &CoordinatorMockNodeForJetExpectation{mock: mmNodeForJet.mock}
	}
	mmNodeForJet.defaultExpectation.results = &CoordinatorMockNodeForJetResults{rp1, err}
	return mmNodeForJet.mock
}

//Set uses given function f to mock the Coordinator.NodeForJet method
func (mmNodeForJet *mCoordinatorMockNodeForJet) Set(f func(ctx context.Context, jetID insolar.ID, targetPN insolar.PulseNumber) (rp1 *insolar.Reference, err error)) *CoordinatorMock {
	if mmNodeForJet.defaultExpectation != nil {
		mmNodeForJet.mock.t.Fatalf("Default expectation is already set for the Coordinator.NodeForJet method")
	}

	if len(mmNodeForJet.expectations) > 0 {
		mmNodeForJet.mock.t.Fatalf("Some expectations are already set for the Coordinator.NodeForJet method")
	}

	mmNodeForJet.mock.funcNodeForJet = f
	return mmNodeForJet.mock
}

// When sets expectation for the Coordinator.NodeForJet which will trigger the result defined by the following
// Then helper
func (mmNodeForJet *mCoordinatorMockNodeForJet) When(ctx context.Context, jetID insolar.ID, targetPN insolar.PulseNumber) *CoordinatorMockNodeForJetExpectation {
	if mmNodeForJet.mock.funcNodeForJet != nil {
		mmNodeForJet.mock.t.Fatalf("CoordinatorMock.NodeForJet mock is already set by Set")
	}

	expectation := &CoordinatorMockNodeForJetExpectation{
		mock:   mmNodeForJet.mock,
		params: &CoordinatorMockNodeForJetParams{ctx, jetID, targetPN},
	}
	mmNodeForJet.expectations = append(mmNodeForJet.expectations, expectation)
	return expectation
}

// Then sets up Coordinator.NodeForJet return parameters for the expectation previously defined by the When method
func (e *CoordinatorMockNodeForJetExpectation) Then(rp1 *insolar.Reference, err error) *CoordinatorMock {
	e.results = &CoordinatorMockNodeForJetResults{rp1, err}
	return e.mock
}

// NodeForJet implements Coordinator
func (mmNodeForJet *CoordinatorMock) NodeForJet(ctx context.Context, jetID insolar.ID, targetPN insolar.PulseNumber) (rp1 *insolar.Reference, err error) {
	mm_atomic.AddUint64(&mmNodeForJet.beforeNodeForJetCounter, 1)
	defer mm_atomic.AddUint64(&mmNodeForJet.afterNodeForJetCounter, 1)

	if mmNodeForJet.inspectFuncNodeForJet != nil {
		mmNodeForJet.inspectFuncNodeForJet(ctx, jetID, targetPN)
	}

	mm_params := &CoordinatorMockNodeForJetParams{ctx, jetID, targetPN}

	// Record call args
	mmNodeForJet.NodeForJetMock.mutex.Lock()
	mmNodeForJet.NodeForJetMock.callArgs = append(mmNodeForJet.NodeForJetMock.callArgs, mm_params)
	mmNodeForJet.NodeForJetMock.mutex.Unlock()

	for _, e := range mmNodeForJet.NodeForJetMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmNodeForJet.NodeForJetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNodeForJet.NodeForJetMock.defaultExpectation.Counter, 1)
		mm_want := mmNodeForJet.NodeForJetMock.defaultExpectation.params
		mm_got := CoordinatorMockNodeForJetParams{ctx, jetID, targetPN}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmNodeForJet.t.Errorf("CoordinatorMock.NodeForJet got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmNodeForJet.NodeForJetMock.defaultExpectation.results
		if mm_results == nil {
			mmNodeForJet.t.Fatal("No results are set for the CoordinatorMock.NodeForJet")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmNodeForJet.funcNodeForJet != nil {
		return mmNodeForJet.funcNodeForJet(ctx, jetID, targetPN)
	}
	mmNodeForJet.t.Fatalf("Unexpected call to CoordinatorMock.NodeForJet. %v %v %v", ctx, jetID, targetPN)
	return
}

// NodeForJetAfterCounter returns a count of finished CoordinatorMock.NodeForJet invocations
func (mmNodeForJet *CoordinatorMock) NodeForJetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNodeForJet.afterNodeForJetCounter)
}

// NodeForJetBeforeCounter returns a count of CoordinatorMock.NodeForJet invocations
func (mmNodeForJet *CoordinatorMock) NodeForJetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNodeForJet.beforeNodeForJetCounter)
}

// Calls returns a list of arguments used in each call to CoordinatorMock.NodeForJet.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmNodeForJet *mCoordinatorMockNodeForJet) Calls() []*CoordinatorMockNodeForJetParams {
	mmNodeForJet.mutex.RLock()

	argCopy := make([]*CoordinatorMockNodeForJetParams, len(mmNodeForJet.callArgs))
	copy(argCopy, mmNodeForJet.callArgs)

	mmNodeForJet.mutex.RUnlock()

	return argCopy
}

// MinimockNodeForJetDone returns true if the count of the NodeForJet invocations corresponds
// the number of defined expectations
func (m *CoordinatorMock) MinimockNodeForJetDone() bool {
	for _, e := range m.NodeForJetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NodeForJetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNodeForJetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNodeForJet != nil && mm_atomic.LoadUint64(&m.afterNodeForJetCounter) < 1 {
		return false
	}
	return true
}

// MinimockNodeForJetInspect logs each unmet expectation
func (m *CoordinatorMock) MinimockNodeForJetInspect() {
	for _, e := range m.NodeForJetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoordinatorMock.NodeForJet with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NodeForJetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNodeForJetCounter) < 1 {
		if m.NodeForJetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CoordinatorMock.NodeForJet")
		} else {
			m.t.Errorf("Expected call to CoordinatorMock.NodeForJet with params: %#v", *m.NodeForJetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNodeForJet != nil && mm_atomic.LoadUint64(&m.afterNodeForJetCounter) < 1 {
		m.t.Error("Expected call to CoordinatorMock.NodeForJet")
	}
}

type mCoordinatorMockNodeForObject struct {
	mock               *CoordinatorMock
	defaultExpectation *CoordinatorMockNodeForObjectExpectation
	expectations       []*CoordinatorMockNodeForObjectExpectation

	callArgs []*CoordinatorMockNodeForObjectParams
	mutex    sync.RWMutex
}

// CoordinatorMockNodeForObjectExpectation specifies expectation struct of the Coordinator.NodeForObject
type CoordinatorMockNodeForObjectExpectation struct {
	mock    *CoordinatorMock
	params  *CoordinatorMockNodeForObjectParams
	results *CoordinatorMockNodeForObjectResults
	Counter uint64
}

// CoordinatorMockNodeForObjectParams contains parameters of the Coordinator.NodeForObject
type CoordinatorMockNodeForObjectParams struct {
	ctx      context.Context
	objectID insolar.ID
	targetPN insolar.PulseNumber
}

// CoordinatorMockNodeForObjectResults contains results of the Coordinator.NodeForObject
type CoordinatorMockNodeForObjectResults struct {
	rp1 *insolar.Reference
	err error
}

// Expect sets up expected params for Coordinator.NodeForObject
func (mmNodeForObject *mCoordinatorMockNodeForObject) Expect(ctx context.Context, objectID insolar.ID, targetPN insolar.PulseNumber) *mCoordinatorMockNodeForObject {
	if mmNodeForObject.mock.funcNodeForObject != nil {
		mmNodeForObject.mock.t.Fatalf("CoordinatorMock.NodeForObject mock is already set by Set")
	}

	if mmNodeForObject.defaultExpectation == nil {
		mmNodeForObject.defaultExpectation = &CoordinatorMockNodeForObjectExpectation{}
	}

	mmNodeForObject.defaultExpectation.params = &CoordinatorMockNodeForObjectParams{ctx, objectID, targetPN}
	for _, e := range mmNodeForObject.expectations {
		if minimock.Equal(e.params, mmNodeForObject.defaultExpectation.params) {
			mmNodeForObject.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmNodeForObject.defaultExpectation.params)
		}
	}

	return mmNodeForObject
}

// Inspect accepts an inspector function that has same arguments as the Coordinator.NodeForObject
func (mmNodeForObject *mCoordinatorMockNodeForObject) Inspect(f func(ctx context.Context, objectID insolar.ID, targetPN insolar.PulseNumber)) *mCoordinatorMockNodeForObject {
	if mmNodeForObject.mock.inspectFuncNodeForObject != nil {
		mmNodeForObject.mock.t.Fatalf("Inspect function is already set for CoordinatorMock.NodeForObject")
	}

	mmNodeForObject.mock.inspectFuncNodeForObject = f

	return mmNodeForObject
}

// Return sets up results that will be returned by Coordinator.NodeForObject
func (mmNodeForObject *mCoordinatorMockNodeForObject) Return(rp1 *insolar.Reference, err error) *CoordinatorMock {
	if mmNodeForObject.mock.funcNodeForObject != nil {
		mmNodeForObject.mock.t.Fatalf("CoordinatorMock.NodeForObject mock is already set by Set")
	}

	if mmNodeForObject.defaultExpectation == nil {
		mmNodeForObject.defaultExpectation = &CoordinatorMockNodeForObjectExpectation{mock: mmNodeForObject.mock}
	}
	mmNodeForObject.defaultExpectation.results = &CoordinatorMockNodeForObjectResults{rp1, err}
	return mmNodeForObject.mock
}

//Set uses given function f to mock the Coordinator.NodeForObject method
func (mmNodeForObject *mCoordinatorMockNodeForObject) Set(f func(ctx context.Context, objectID insolar.ID, targetPN insolar.PulseNumber) (rp1 *insolar.Reference, err error)) *CoordinatorMock {
	if mmNodeForObject.defaultExpectation != nil {
		mmNodeForObject.mock.t.Fatalf("Default expectation is already set for the Coordinator.NodeForObject method")
	}

	if len(mmNodeForObject.expectations) > 0 {
		mmNodeForObject.mock.t.Fatalf("Some expectations are already set for the Coordinator.NodeForObject method")
	}

	mmNodeForObject.mock.funcNodeForObject = f
	return mmNodeForObject.mock
}

// When sets expectation for the Coordinator.NodeForObject which will trigger the result defined by the following
// Then helper
func (mmNodeForObject *mCoordinatorMockNodeForObject) When(ctx context.Context, objectID insolar.ID, targetPN insolar.PulseNumber) *CoordinatorMockNodeForObjectExpectation {
	if mmNodeForObject.mock.funcNodeForObject != nil {
		mmNodeForObject.mock.t.Fatalf("CoordinatorMock.NodeForObject mock is already set by Set")
	}

	expectation := &CoordinatorMockNodeForObjectExpectation{
		mock:   mmNodeForObject.mock,
		params: &CoordinatorMockNodeForObjectParams{ctx, objectID, targetPN},
	}
	mmNodeForObject.expectations = append(mmNodeForObject.expectations, expectation)
	return expectation
}

// Then sets up Coordinator.NodeForObject return parameters for the expectation previously defined by the When method
func (e *CoordinatorMockNodeForObjectExpectation) Then(rp1 *insolar.Reference, err error) *CoordinatorMock {
	e.results = &CoordinatorMockNodeForObjectResults{rp1, err}
	return e.mock
}

// NodeForObject implements Coordinator
func (mmNodeForObject *CoordinatorMock) NodeForObject(ctx context.Context, objectID insolar.ID, targetPN insolar.PulseNumber) (rp1 *insolar.Reference, err error) {
	mm_atomic.AddUint64(&mmNodeForObject.beforeNodeForObjectCounter, 1)
	defer mm_atomic.AddUint64(&mmNodeForObject.afterNodeForObjectCounter, 1)

	if mmNodeForObject.inspectFuncNodeForObject != nil {
		mmNodeForObject.inspectFuncNodeForObject(ctx, objectID, targetPN)
	}

	mm_params := &CoordinatorMockNodeForObjectParams{ctx, objectID, targetPN}

	// Record call args
	mmNodeForObject.NodeForObjectMock.mutex.Lock()
	mmNodeForObject.NodeForObjectMock.callArgs = append(mmNodeForObject.NodeForObjectMock.callArgs, mm_params)
	mmNodeForObject.NodeForObjectMock.mutex.Unlock()

	for _, e := range mmNodeForObject.NodeForObjectMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmNodeForObject.NodeForObjectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNodeForObject.NodeForObjectMock.defaultExpectation.Counter, 1)
		mm_want := mmNodeForObject.NodeForObjectMock.defaultExpectation.params
		mm_got := CoordinatorMockNodeForObjectParams{ctx, objectID, targetPN}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmNodeForObject.t.Errorf("CoordinatorMock.NodeForObject got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmNodeForObject.NodeForObjectMock.defaultExpectation.results
		if mm_results == nil {
			mmNodeForObject.t.Fatal("No results are set for the CoordinatorMock.NodeForObject")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmNodeForObject.funcNodeForObject != nil {
		return mmNodeForObject.funcNodeForObject(ctx, objectID, targetPN)
	}
	mmNodeForObject.t.Fatalf("Unexpected call to CoordinatorMock.NodeForObject. %v %v %v", ctx, objectID, targetPN)
	return
}

// NodeForObjectAfterCounter returns a count of finished CoordinatorMock.NodeForObject invocations
func (mmNodeForObject *CoordinatorMock) NodeForObjectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNodeForObject.afterNodeForObjectCounter)
}

// NodeForObjectBeforeCounter returns a count of CoordinatorMock.NodeForObject invocations
func (mmNodeForObject *CoordinatorMock) NodeForObjectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNodeForObject.beforeNodeForObjectCounter)
}

// Calls returns a list of arguments used in each call to CoordinatorMock.NodeForObject.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmNodeForObject *mCoordinatorMockNodeForObject) Calls() []*CoordinatorMockNodeForObjectParams {
	mmNodeForObject.mutex.RLock()

	argCopy := make([]*CoordinatorMockNodeForObjectParams, len(mmNodeForObject.callArgs))
	copy(argCopy, mmNodeForObject.callArgs)

	mmNodeForObject.mutex.RUnlock()

	return argCopy
}

// MinimockNodeForObjectDone returns true if the count of the NodeForObject invocations corresponds
// the number of defined expectations
func (m *CoordinatorMock) MinimockNodeForObjectDone() bool {
	for _, e := range m.NodeForObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NodeForObjectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNodeForObjectCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNodeForObject != nil && mm_atomic.LoadUint64(&m.afterNodeForObjectCounter) < 1 {
		return false
	}
	return true
}

// MinimockNodeForObjectInspect logs each unmet expectation
func (m *CoordinatorMock) MinimockNodeForObjectInspect() {
	for _, e := range m.NodeForObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoordinatorMock.NodeForObject with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NodeForObjectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNodeForObjectCounter) < 1 {
		if m.NodeForObjectMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CoordinatorMock.NodeForObject")
		} else {
			m.t.Errorf("Expected call to CoordinatorMock.NodeForObject with params: %#v", *m.NodeForObjectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNodeForObject != nil && mm_atomic.LoadUint64(&m.afterNodeForObjectCounter) < 1 {
		m.t.Error("Expected call to CoordinatorMock.NodeForObject")
	}
}

type mCoordinatorMockQueryRole struct {
	mock               *CoordinatorMock
	defaultExpectation *CoordinatorMockQueryRoleExpectation
	expectations       []*CoordinatorMockQueryRoleExpectation

	callArgs []*CoordinatorMockQueryRoleParams
	mutex    sync.RWMutex
}

// CoordinatorMockQueryRoleExpectation specifies expectation struct of the Coordinator.QueryRole
type CoordinatorMockQueryRoleExpectation struct {
	mock    *CoordinatorMock
	params  *CoordinatorMockQueryRoleParams
	results *CoordinatorMockQueryRoleResults
	Counter uint64
}

// CoordinatorMockQueryRoleParams contains parameters of the Coordinator.QueryRole
type CoordinatorMockQueryRoleParams struct {
	ctx   context.Context
	role  insolar.DynamicRole
	obj   insolar.ID
	pulse insolar.PulseNumber
}

// CoordinatorMockQueryRoleResults contains results of the Coordinator.QueryRole
type CoordinatorMockQueryRoleResults struct {
	ra1 []insolar.Reference
	err error
}

// Expect sets up expected params for Coordinator.QueryRole
func (mmQueryRole *mCoordinatorMockQueryRole) Expect(ctx context.Context, role insolar.DynamicRole, obj insolar.ID, pulse insolar.PulseNumber) *mCoordinatorMockQueryRole {
	if mmQueryRole.mock.funcQueryRole != nil {
		mmQueryRole.mock.t.Fatalf("CoordinatorMock.QueryRole mock is already set by Set")
	}

	if mmQueryRole.defaultExpectation == nil {
		mmQueryRole.defaultExpectation = &CoordinatorMockQueryRoleExpectation{}
	}

	mmQueryRole.defaultExpectation.params = &CoordinatorMockQueryRoleParams{ctx, role, obj, pulse}
	for _, e := range mmQueryRole.expectations {
		if minimock.Equal(e.params, mmQueryRole.defaultExpectation.params) {
			mmQueryRole.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQueryRole.defaultExpectation.params)
		}
	}

	return mmQueryRole
}

// Inspect accepts an inspector function that has same arguments as the Coordinator.QueryRole
func (mmQueryRole *mCoordinatorMockQueryRole) Inspect(f func(ctx context.Context, role insolar.DynamicRole, obj insolar.ID, pulse insolar.PulseNumber)) *mCoordinatorMockQueryRole {
	if mmQueryRole.mock.inspectFuncQueryRole != nil {
		mmQueryRole.mock.t.Fatalf("Inspect function is already set for CoordinatorMock.QueryRole")
	}

	mmQueryRole.mock.inspectFuncQueryRole = f

	return mmQueryRole
}

// Return sets up results that will be returned by Coordinator.QueryRole
func (mmQueryRole *mCoordinatorMockQueryRole) Return(ra1 []insolar.Reference, err error) *CoordinatorMock {
	if mmQueryRole.mock.funcQueryRole != nil {
		mmQueryRole.mock.t.Fatalf("CoordinatorMock.QueryRole mock is already set by Set")
	}

	if mmQueryRole.defaultExpectation == nil {
		mmQueryRole.defaultExpectation = &CoordinatorMockQueryRoleExpectation{mock: mmQueryRole.mock}
	}
	mmQueryRole.defaultExpectation.results = &CoordinatorMockQueryRoleResults{ra1, err}
	return mmQueryRole.mock
}

//Set uses given function f to mock the Coordinator.QueryRole method
func (mmQueryRole *mCoordinatorMockQueryRole) Set(f func(ctx context.Context, role insolar.DynamicRole, obj insolar.ID, pulse insolar.PulseNumber) (ra1 []insolar.Reference, err error)) *CoordinatorMock {
	if mmQueryRole.defaultExpectation != nil {
		mmQueryRole.mock.t.Fatalf("Default expectation is already set for the Coordinator.QueryRole method")
	}

	if len(mmQueryRole.expectations) > 0 {
		mmQueryRole.mock.t.Fatalf("Some expectations are already set for the Coordinator.QueryRole method")
	}

	mmQueryRole.mock.funcQueryRole = f
	return mmQueryRole.mock
}

// When sets expectation for the Coordinator.QueryRole which will trigger the result defined by the following
// Then helper
func (mmQueryRole *mCoordinatorMockQueryRole) When(ctx context.Context, role insolar.DynamicRole, obj insolar.ID, pulse insolar.PulseNumber) *CoordinatorMockQueryRoleExpectation {
	if mmQueryRole.mock.funcQueryRole != nil {
		mmQueryRole.mock.t.Fatalf("CoordinatorMock.QueryRole mock is already set by Set")
	}

	expectation := &CoordinatorMockQueryRoleExpectation{
		mock:   mmQueryRole.mock,
		params: &CoordinatorMockQueryRoleParams{ctx, role, obj, pulse},
	}
	mmQueryRole.expectations = append(mmQueryRole.expectations, expectation)
	return expectation
}

// Then sets up Coordinator.QueryRole return parameters for the expectation previously defined by the When method
func (e *CoordinatorMockQueryRoleExpectation) Then(ra1 []insolar.Reference, err error) *CoordinatorMock {
	e.results = &CoordinatorMockQueryRoleResults{ra1, err}
	return e.mock
}

// QueryRole implements Coordinator
func (mmQueryRole *CoordinatorMock) QueryRole(ctx context.Context, role insolar.DynamicRole, obj insolar.ID, pulse insolar.PulseNumber) (ra1 []insolar.Reference, err error) {
	mm_atomic.AddUint64(&mmQueryRole.beforeQueryRoleCounter, 1)
	defer mm_atomic.AddUint64(&mmQueryRole.afterQueryRoleCounter, 1)

	if mmQueryRole.inspectFuncQueryRole != nil {
		mmQueryRole.inspectFuncQueryRole(ctx, role, obj, pulse)
	}

	mm_params := &CoordinatorMockQueryRoleParams{ctx, role, obj, pulse}

	// Record call args
	mmQueryRole.QueryRoleMock.mutex.Lock()
	mmQueryRole.QueryRoleMock.callArgs = append(mmQueryRole.QueryRoleMock.callArgs, mm_params)
	mmQueryRole.QueryRoleMock.mutex.Unlock()

	for _, e := range mmQueryRole.QueryRoleMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ra1, e.results.err
		}
	}

	if mmQueryRole.QueryRoleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQueryRole.QueryRoleMock.defaultExpectation.Counter, 1)
		mm_want := mmQueryRole.QueryRoleMock.defaultExpectation.params
		mm_got := CoordinatorMockQueryRoleParams{ctx, role, obj, pulse}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQueryRole.t.Errorf("CoordinatorMock.QueryRole got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQueryRole.QueryRoleMock.defaultExpectation.results
		if mm_results == nil {
			mmQueryRole.t.Fatal("No results are set for the CoordinatorMock.QueryRole")
		}
		return (*mm_results).ra1, (*mm_results).err
	}
	if mmQueryRole.funcQueryRole != nil {
		return mmQueryRole.funcQueryRole(ctx, role, obj, pulse)
	}
	mmQueryRole.t.Fatalf("Unexpected call to CoordinatorMock.QueryRole. %v %v %v %v", ctx, role, obj, pulse)
	return
}

// QueryRoleAfterCounter returns a count of finished CoordinatorMock.QueryRole invocations
func (mmQueryRole *CoordinatorMock) QueryRoleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryRole.afterQueryRoleCounter)
}

// QueryRoleBeforeCounter returns a count of CoordinatorMock.QueryRole invocations
func (mmQueryRole *CoordinatorMock) QueryRoleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryRole.beforeQueryRoleCounter)
}

// Calls returns a list of arguments used in each call to CoordinatorMock.QueryRole.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQueryRole *mCoordinatorMockQueryRole) Calls() []*CoordinatorMockQueryRoleParams {
	mmQueryRole.mutex.RLock()

	argCopy := make([]*CoordinatorMockQueryRoleParams, len(mmQueryRole.callArgs))
	copy(argCopy, mmQueryRole.callArgs)

	mmQueryRole.mutex.RUnlock()

	return argCopy
}

// MinimockQueryRoleDone returns true if the count of the QueryRole invocations corresponds
// the number of defined expectations
func (m *CoordinatorMock) MinimockQueryRoleDone() bool {
	for _, e := range m.QueryRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryRoleMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryRoleCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQueryRole != nil && mm_atomic.LoadUint64(&m.afterQueryRoleCounter) < 1 {
		return false
	}
	return true
}

// MinimockQueryRoleInspect logs each unmet expectation
func (m *CoordinatorMock) MinimockQueryRoleInspect() {
	for _, e := range m.QueryRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoordinatorMock.QueryRole with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryRoleMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryRoleCounter) < 1 {
		if m.QueryRoleMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CoordinatorMock.QueryRole")
		} else {
			m.t.Errorf("Expected call to CoordinatorMock.QueryRole with params: %#v", *m.QueryRoleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQueryRole != nil && mm_atomic.LoadUint64(&m.afterQueryRoleCounter) < 1 {
		m.t.Error("Expected call to CoordinatorMock.QueryRole")
	}
}

type mCoordinatorMockVirtualExecutorForObject struct {
	mock               *CoordinatorMock
	defaultExpectation *CoordinatorMockVirtualExecutorForObjectExpectation
	expectations       []*CoordinatorMockVirtualExecutorForObjectExpectation

	callArgs []*CoordinatorMockVirtualExecutorForObjectParams
	mutex    sync.RWMutex
}

// CoordinatorMockVirtualExecutorForObjectExpectation specifies expectation struct of the Coordinator.VirtualExecutorForObject
type CoordinatorMockVirtualExecutorForObjectExpectation struct {
	mock    *CoordinatorMock
	params  *CoordinatorMockVirtualExecutorForObjectParams
	results *CoordinatorMockVirtualExecutorForObjectResults
	Counter uint64
}

// CoordinatorMockVirtualExecutorForObjectParams contains parameters of the Coordinator.VirtualExecutorForObject
type CoordinatorMockVirtualExecutorForObjectParams struct {
	ctx   context.Context
	objID insolar.ID
	pulse insolar.PulseNumber
}

// CoordinatorMockVirtualExecutorForObjectResults contains results of the Coordinator.VirtualExecutorForObject
type CoordinatorMockVirtualExecutorForObjectResults struct {
	rp1 *insolar.Reference
	err error
}

// Expect sets up expected params for Coordinator.VirtualExecutorForObject
func (mmVirtualExecutorForObject *mCoordinatorMockVirtualExecutorForObject) Expect(ctx context.Context, objID insolar.ID, pulse insolar.PulseNumber) *mCoordinatorMockVirtualExecutorForObject {
	if mmVirtualExecutorForObject.mock.funcVirtualExecutorForObject != nil {
		mmVirtualExecutorForObject.mock.t.Fatalf("CoordinatorMock.VirtualExecutorForObject mock is already set by Set")
	}

	if mmVirtualExecutorForObject.defaultExpectation == nil {
		mmVirtualExecutorForObject.defaultExpectation = &CoordinatorMockVirtualExecutorForObjectExpectation{}
	}

	mmVirtualExecutorForObject.defaultExpectation.params = &CoordinatorMockVirtualExecutorForObjectParams{ctx, objID, pulse}
	for _, e := range mmVirtualExecutorForObject.expectations {
		if minimock.Equal(e.params, mmVirtualExecutorForObject.defaultExpectation.params) {
			mmVirtualExecutorForObject.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmVirtualExecutorForObject.defaultExpectation.params)
		}
	}

	return mmVirtualExecutorForObject
}

// Inspect accepts an inspector function that has same arguments as the Coordinator.VirtualExecutorForObject
func (mmVirtualExecutorForObject *mCoordinatorMockVirtualExecutorForObject) Inspect(f func(ctx context.Context, objID insolar.ID, pulse insolar.PulseNumber)) *mCoordinatorMockVirtualExecutorForObject {
	if mmVirtualExecutorForObject.mock.inspectFuncVirtualExecutorForObject != nil {
		mmVirtualExecutorForObject.mock.t.Fatalf("Inspect function is already set for CoordinatorMock.VirtualExecutorForObject")
	}

	mmVirtualExecutorForObject.mock.inspectFuncVirtualExecutorForObject = f

	return mmVirtualExecutorForObject
}

// Return sets up results that will be returned by Coordinator.VirtualExecutorForObject
func (mmVirtualExecutorForObject *mCoordinatorMockVirtualExecutorForObject) Return(rp1 *insolar.Reference, err error) *CoordinatorMock {
	if mmVirtualExecutorForObject.mock.funcVirtualExecutorForObject != nil {
		mmVirtualExecutorForObject.mock.t.Fatalf("CoordinatorMock.VirtualExecutorForObject mock is already set by Set")
	}

	if mmVirtualExecutorForObject.defaultExpectation == nil {
		mmVirtualExecutorForObject.defaultExpectation = &CoordinatorMockVirtualExecutorForObjectExpectation{mock: mmVirtualExecutorForObject.mock}
	}
	mmVirtualExecutorForObject.defaultExpectation.results = &CoordinatorMockVirtualExecutorForObjectResults{rp1, err}
	return mmVirtualExecutorForObject.mock
}

//Set uses given function f to mock the Coordinator.VirtualExecutorForObject method
func (mmVirtualExecutorForObject *mCoordinatorMockVirtualExecutorForObject) Set(f func(ctx context.Context, objID insolar.ID, pulse insolar.PulseNumber) (rp1 *insolar.Reference, err error)) *CoordinatorMock {
	if mmVirtualExecutorForObject.defaultExpectation != nil {
		mmVirtualExecutorForObject.mock.t.Fatalf("Default expectation is already set for the Coordinator.VirtualExecutorForObject method")
	}

	if len(mmVirtualExecutorForObject.expectations) > 0 {
		mmVirtualExecutorForObject.mock.t.Fatalf("Some expectations are already set for the Coordinator.VirtualExecutorForObject method")
	}

	mmVirtualExecutorForObject.mock.funcVirtualExecutorForObject = f
	return mmVirtualExecutorForObject.mock
}

// When sets expectation for the Coordinator.VirtualExecutorForObject which will trigger the result defined by the following
// Then helper
func (mmVirtualExecutorForObject *mCoordinatorMockVirtualExecutorForObject) When(ctx context.Context, objID insolar.ID, pulse insolar.PulseNumber) *CoordinatorMockVirtualExecutorForObjectExpectation {
	if mmVirtualExecutorForObject.mock.funcVirtualExecutorForObject != nil {
		mmVirtualExecutorForObject.mock.t.Fatalf("CoordinatorMock.VirtualExecutorForObject mock is already set by Set")
	}

	expectation := &CoordinatorMockVirtualExecutorForObjectExpectation{
		mock:   mmVirtualExecutorForObject.mock,
		params: &CoordinatorMockVirtualExecutorForObjectParams{ctx, objID, pulse},
	}
	mmVirtualExecutorForObject.expectations = append(mmVirtualExecutorForObject.expectations, expectation)
	return expectation
}

// Then sets up Coordinator.VirtualExecutorForObject return parameters for the expectation previously defined by the When method
func (e *CoordinatorMockVirtualExecutorForObjectExpectation) Then(rp1 *insolar.Reference, err error) *CoordinatorMock {
	e.results = &CoordinatorMockVirtualExecutorForObjectResults{rp1, err}
	return e.mock
}

// VirtualExecutorForObject implements Coordinator
func (mmVirtualExecutorForObject *CoordinatorMock) VirtualExecutorForObject(ctx context.Context, objID insolar.ID, pulse insolar.PulseNumber) (rp1 *insolar.Reference, err error) {
	mm_atomic.AddUint64(&mmVirtualExecutorForObject.beforeVirtualExecutorForObjectCounter, 1)
	defer mm_atomic.AddUint64(&mmVirtualExecutorForObject.afterVirtualExecutorForObjectCounter, 1)

	if mmVirtualExecutorForObject.inspectFuncVirtualExecutorForObject != nil {
		mmVirtualExecutorForObject.inspectFuncVirtualExecutorForObject(ctx, objID, pulse)
	}

	mm_params := &CoordinatorMockVirtualExecutorForObjectParams{ctx, objID, pulse}

	// Record call args
	mmVirtualExecutorForObject.VirtualExecutorForObjectMock.mutex.Lock()
	mmVirtualExecutorForObject.VirtualExecutorForObjectMock.callArgs = append(mmVirtualExecutorForObject.VirtualExecutorForObjectMock.callArgs, mm_params)
	mmVirtualExecutorForObject.VirtualExecutorForObjectMock.mutex.Unlock()

	for _, e := range mmVirtualExecutorForObject.VirtualExecutorForObjectMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmVirtualExecutorForObject.VirtualExecutorForObjectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmVirtualExecutorForObject.VirtualExecutorForObjectMock.defaultExpectation.Counter, 1)
		mm_want := mmVirtualExecutorForObject.VirtualExecutorForObjectMock.defaultExpectation.params
		mm_got := CoordinatorMockVirtualExecutorForObjectParams{ctx, objID, pulse}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmVirtualExecutorForObject.t.Errorf("CoordinatorMock.VirtualExecutorForObject got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmVirtualExecutorForObject.VirtualExecutorForObjectMock.defaultExpectation.results
		if mm_results == nil {
			mmVirtualExecutorForObject.t.Fatal("No results are set for the CoordinatorMock.VirtualExecutorForObject")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmVirtualExecutorForObject.funcVirtualExecutorForObject != nil {
		return mmVirtualExecutorForObject.funcVirtualExecutorForObject(ctx, objID, pulse)
	}
	mmVirtualExecutorForObject.t.Fatalf("Unexpected call to CoordinatorMock.VirtualExecutorForObject. %v %v %v", ctx, objID, pulse)
	return
}

// VirtualExecutorForObjectAfterCounter returns a count of finished CoordinatorMock.VirtualExecutorForObject invocations
func (mmVirtualExecutorForObject *CoordinatorMock) VirtualExecutorForObjectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmVirtualExecutorForObject.afterVirtualExecutorForObjectCounter)
}

// VirtualExecutorForObjectBeforeCounter returns a count of CoordinatorMock.VirtualExecutorForObject invocations
func (mmVirtualExecutorForObject *CoordinatorMock) VirtualExecutorForObjectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmVirtualExecutorForObject.beforeVirtualExecutorForObjectCounter)
}

// Calls returns a list of arguments used in each call to CoordinatorMock.VirtualExecutorForObject.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmVirtualExecutorForObject *mCoordinatorMockVirtualExecutorForObject) Calls() []*CoordinatorMockVirtualExecutorForObjectParams {
	mmVirtualExecutorForObject.mutex.RLock()

	argCopy := make([]*CoordinatorMockVirtualExecutorForObjectParams, len(mmVirtualExecutorForObject.callArgs))
	copy(argCopy, mmVirtualExecutorForObject.callArgs)

	mmVirtualExecutorForObject.mutex.RUnlock()

	return argCopy
}

// MinimockVirtualExecutorForObjectDone returns true if the count of the VirtualExecutorForObject invocations corresponds
// the number of defined expectations
func (m *CoordinatorMock) MinimockVirtualExecutorForObjectDone() bool {
	for _, e := range m.VirtualExecutorForObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.VirtualExecutorForObjectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterVirtualExecutorForObjectCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcVirtualExecutorForObject != nil && mm_atomic.LoadUint64(&m.afterVirtualExecutorForObjectCounter) < 1 {
		return false
	}
	return true
}

// MinimockVirtualExecutorForObjectInspect logs each unmet expectation
func (m *CoordinatorMock) MinimockVirtualExecutorForObjectInspect() {
	for _, e := range m.VirtualExecutorForObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoordinatorMock.VirtualExecutorForObject with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.VirtualExecutorForObjectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterVirtualExecutorForObjectCounter) < 1 {
		if m.VirtualExecutorForObjectMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CoordinatorMock.VirtualExecutorForObject")
		} else {
			m.t.Errorf("Expected call to CoordinatorMock.VirtualExecutorForObject with params: %#v", *m.VirtualExecutorForObjectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcVirtualExecutorForObject != nil && mm_atomic.LoadUint64(&m.afterVirtualExecutorForObjectCounter) < 1 {
		m.t.Error("Expected call to CoordinatorMock.VirtualExecutorForObject")
	}
}

type mCoordinatorMockVirtualValidatorsForObject struct {
	mock               *CoordinatorMock
	defaultExpectation *CoordinatorMockVirtualValidatorsForObjectExpectation
	expectations       []*CoordinatorMockVirtualValidatorsForObjectExpectation

	callArgs []*CoordinatorMockVirtualValidatorsForObjectParams
	mutex    sync.RWMutex
}

// CoordinatorMockVirtualValidatorsForObjectExpectation specifies expectation struct of the Coordinator.VirtualValidatorsForObject
type CoordinatorMockVirtualValidatorsForObjectExpectation struct {
	mock    *CoordinatorMock
	params  *CoordinatorMockVirtualValidatorsForObjectParams
	results *CoordinatorMockVirtualValidatorsForObjectResults
	Counter uint64
}

// CoordinatorMockVirtualValidatorsForObjectParams contains parameters of the Coordinator.VirtualValidatorsForObject
type CoordinatorMockVirtualValidatorsForObjectParams struct {
	ctx   context.Context
	objID insolar.ID
	pulse insolar.PulseNumber
}

// CoordinatorMockVirtualValidatorsForObjectResults contains results of the Coordinator.VirtualValidatorsForObject
type CoordinatorMockVirtualValidatorsForObjectResults struct {
	ra1 []insolar.Reference
	err error
}

// Expect sets up expected params for Coordinator.VirtualValidatorsForObject
func (mmVirtualValidatorsForObject *mCoordinatorMockVirtualValidatorsForObject) Expect(ctx context.Context, objID insolar.ID, pulse insolar.PulseNumber) *mCoordinatorMockVirtualValidatorsForObject {
	if mmVirtualValidatorsForObject.mock.funcVirtualValidatorsForObject != nil {
		mmVirtualValidatorsForObject.mock.t.Fatalf("CoordinatorMock.VirtualValidatorsForObject mock is already set by Set")
	}

	if mmVirtualValidatorsForObject.defaultExpectation == nil {
		mmVirtualValidatorsForObject.defaultExpectation = &CoordinatorMockVirtualValidatorsForObjectExpectation{}
	}

	mmVirtualValidatorsForObject.defaultExpectation.params = &CoordinatorMockVirtualValidatorsForObjectParams{ctx, objID, pulse}
	for _, e := range mmVirtualValidatorsForObject.expectations {
		if minimock.Equal(e.params, mmVirtualValidatorsForObject.defaultExpectation.params) {
			mmVirtualValidatorsForObject.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmVirtualValidatorsForObject.defaultExpectation.params)
		}
	}

	return mmVirtualValidatorsForObject
}

// Inspect accepts an inspector function that has same arguments as the Coordinator.VirtualValidatorsForObject
func (mmVirtualValidatorsForObject *mCoordinatorMockVirtualValidatorsForObject) Inspect(f func(ctx context.Context, objID insolar.ID, pulse insolar.PulseNumber)) *mCoordinatorMockVirtualValidatorsForObject {
	if mmVirtualValidatorsForObject.mock.inspectFuncVirtualValidatorsForObject != nil {
		mmVirtualValidatorsForObject.mock.t.Fatalf("Inspect function is already set for CoordinatorMock.VirtualValidatorsForObject")
	}

	mmVirtualValidatorsForObject.mock.inspectFuncVirtualValidatorsForObject = f

	return mmVirtualValidatorsForObject
}

// Return sets up results that will be returned by Coordinator.VirtualValidatorsForObject
func (mmVirtualValidatorsForObject *mCoordinatorMockVirtualValidatorsForObject) Return(ra1 []insolar.Reference, err error) *CoordinatorMock {
	if mmVirtualValidatorsForObject.mock.funcVirtualValidatorsForObject != nil {
		mmVirtualValidatorsForObject.mock.t.Fatalf("CoordinatorMock.VirtualValidatorsForObject mock is already set by Set")
	}

	if mmVirtualValidatorsForObject.defaultExpectation == nil {
		mmVirtualValidatorsForObject.defaultExpectation = &CoordinatorMockVirtualValidatorsForObjectExpectation{mock: mmVirtualValidatorsForObject.mock}
	}
	mmVirtualValidatorsForObject.defaultExpectation.results = &CoordinatorMockVirtualValidatorsForObjectResults{ra1, err}
	return mmVirtualValidatorsForObject.mock
}

//Set uses given function f to mock the Coordinator.VirtualValidatorsForObject method
func (mmVirtualValidatorsForObject *mCoordinatorMockVirtualValidatorsForObject) Set(f func(ctx context.Context, objID insolar.ID, pulse insolar.PulseNumber) (ra1 []insolar.Reference, err error)) *CoordinatorMock {
	if mmVirtualValidatorsForObject.defaultExpectation != nil {
		mmVirtualValidatorsForObject.mock.t.Fatalf("Default expectation is already set for the Coordinator.VirtualValidatorsForObject method")
	}

	if len(mmVirtualValidatorsForObject.expectations) > 0 {
		mmVirtualValidatorsForObject.mock.t.Fatalf("Some expectations are already set for the Coordinator.VirtualValidatorsForObject method")
	}

	mmVirtualValidatorsForObject.mock.funcVirtualValidatorsForObject = f
	return mmVirtualValidatorsForObject.mock
}

// When sets expectation for the Coordinator.VirtualValidatorsForObject which will trigger the result defined by the following
// Then helper
func (mmVirtualValidatorsForObject *mCoordinatorMockVirtualValidatorsForObject) When(ctx context.Context, objID insolar.ID, pulse insolar.PulseNumber) *CoordinatorMockVirtualValidatorsForObjectExpectation {
	if mmVirtualValidatorsForObject.mock.funcVirtualValidatorsForObject != nil {
		mmVirtualValidatorsForObject.mock.t.Fatalf("CoordinatorMock.VirtualValidatorsForObject mock is already set by Set")
	}

	expectation := &CoordinatorMockVirtualValidatorsForObjectExpectation{
		mock:   mmVirtualValidatorsForObject.mock,
		params: &CoordinatorMockVirtualValidatorsForObjectParams{ctx, objID, pulse},
	}
	mmVirtualValidatorsForObject.expectations = append(mmVirtualValidatorsForObject.expectations, expectation)
	return expectation
}

// Then sets up Coordinator.VirtualValidatorsForObject return parameters for the expectation previously defined by the When method
func (e *CoordinatorMockVirtualValidatorsForObjectExpectation) Then(ra1 []insolar.Reference, err error) *CoordinatorMock {
	e.results = &CoordinatorMockVirtualValidatorsForObjectResults{ra1, err}
	return e.mock
}

// VirtualValidatorsForObject implements Coordinator
func (mmVirtualValidatorsForObject *CoordinatorMock) VirtualValidatorsForObject(ctx context.Context, objID insolar.ID, pulse insolar.PulseNumber) (ra1 []insolar.Reference, err error) {
	mm_atomic.AddUint64(&mmVirtualValidatorsForObject.beforeVirtualValidatorsForObjectCounter, 1)
	defer mm_atomic.AddUint64(&mmVirtualValidatorsForObject.afterVirtualValidatorsForObjectCounter, 1)

	if mmVirtualValidatorsForObject.inspectFuncVirtualValidatorsForObject != nil {
		mmVirtualValidatorsForObject.inspectFuncVirtualValidatorsForObject(ctx, objID, pulse)
	}

	mm_params := &CoordinatorMockVirtualValidatorsForObjectParams{ctx, objID, pulse}

	// Record call args
	mmVirtualValidatorsForObject.VirtualValidatorsForObjectMock.mutex.Lock()
	mmVirtualValidatorsForObject.VirtualValidatorsForObjectMock.callArgs = append(mmVirtualValidatorsForObject.VirtualValidatorsForObjectMock.callArgs, mm_params)
	mmVirtualValidatorsForObject.VirtualValidatorsForObjectMock.mutex.Unlock()

	for _, e := range mmVirtualValidatorsForObject.VirtualValidatorsForObjectMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ra1, e.results.err
		}
	}

	if mmVirtualValidatorsForObject.VirtualValidatorsForObjectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmVirtualValidatorsForObject.VirtualValidatorsForObjectMock.defaultExpectation.Counter, 1)
		mm_want := mmVirtualValidatorsForObject.VirtualValidatorsForObjectMock.defaultExpectation.params
		mm_got := CoordinatorMockVirtualValidatorsForObjectParams{ctx, objID, pulse}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmVirtualValidatorsForObject.t.Errorf("CoordinatorMock.VirtualValidatorsForObject got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmVirtualValidatorsForObject.VirtualValidatorsForObjectMock.defaultExpectation.results
		if mm_results == nil {
			mmVirtualValidatorsForObject.t.Fatal("No results are set for the CoordinatorMock.VirtualValidatorsForObject")
		}
		return (*mm_results).ra1, (*mm_results).err
	}
	if mmVirtualValidatorsForObject.funcVirtualValidatorsForObject != nil {
		return mmVirtualValidatorsForObject.funcVirtualValidatorsForObject(ctx, objID, pulse)
	}
	mmVirtualValidatorsForObject.t.Fatalf("Unexpected call to CoordinatorMock.VirtualValidatorsForObject. %v %v %v", ctx, objID, pulse)
	return
}

// VirtualValidatorsForObjectAfterCounter returns a count of finished CoordinatorMock.VirtualValidatorsForObject invocations
func (mmVirtualValidatorsForObject *CoordinatorMock) VirtualValidatorsForObjectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmVirtualValidatorsForObject.afterVirtualValidatorsForObjectCounter)
}

// VirtualValidatorsForObjectBeforeCounter returns a count of CoordinatorMock.VirtualValidatorsForObject invocations
func (mmVirtualValidatorsForObject *CoordinatorMock) VirtualValidatorsForObjectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmVirtualValidatorsForObject.beforeVirtualValidatorsForObjectCounter)
}

// Calls returns a list of arguments used in each call to CoordinatorMock.VirtualValidatorsForObject.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmVirtualValidatorsForObject *mCoordinatorMockVirtualValidatorsForObject) Calls() []*CoordinatorMockVirtualValidatorsForObjectParams {
	mmVirtualValidatorsForObject.mutex.RLock()

	argCopy := make([]*CoordinatorMockVirtualValidatorsForObjectParams, len(mmVirtualValidatorsForObject.callArgs))
	copy(argCopy, mmVirtualValidatorsForObject.callArgs)

	mmVirtualValidatorsForObject.mutex.RUnlock()

	return argCopy
}

// MinimockVirtualValidatorsForObjectDone returns true if the count of the VirtualValidatorsForObject invocations corresponds
// the number of defined expectations
func (m *CoordinatorMock) MinimockVirtualValidatorsForObjectDone() bool {
	for _, e := range m.VirtualValidatorsForObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.VirtualValidatorsForObjectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterVirtualValidatorsForObjectCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcVirtualValidatorsForObject != nil && mm_atomic.LoadUint64(&m.afterVirtualValidatorsForObjectCounter) < 1 {
		return false
	}
	return true
}

// MinimockVirtualValidatorsForObjectInspect logs each unmet expectation
func (m *CoordinatorMock) MinimockVirtualValidatorsForObjectInspect() {
	for _, e := range m.VirtualValidatorsForObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CoordinatorMock.VirtualValidatorsForObject with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.VirtualValidatorsForObjectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterVirtualValidatorsForObjectCounter) < 1 {
		if m.VirtualValidatorsForObjectMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CoordinatorMock.VirtualValidatorsForObject")
		} else {
			m.t.Errorf("Expected call to CoordinatorMock.VirtualValidatorsForObject with params: %#v", *m.VirtualValidatorsForObjectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcVirtualValidatorsForObject != nil && mm_atomic.LoadUint64(&m.afterVirtualValidatorsForObjectCounter) < 1 {
		m.t.Error("Expected call to CoordinatorMock.VirtualValidatorsForObject")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CoordinatorMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockHeavyInspect()

		m.MinimockIsAuthorizedInspect()

		m.MinimockIsBeyondLimitInspect()

		m.MinimockIsMeAuthorizedNowInspect()

		m.MinimockLightExecutorForJetInspect()

		m.MinimockLightExecutorForObjectInspect()

		m.MinimockLightValidatorsForJetInspect()

		m.MinimockLightValidatorsForObjectInspect()

		m.MinimockMeInspect()

		m.MinimockNodeForJetInspect()

		m.MinimockNodeForObjectInspect()

		m.MinimockQueryRoleInspect()

		m.MinimockVirtualExecutorForObjectInspect()

		m.MinimockVirtualValidatorsForObjectInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CoordinatorMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CoordinatorMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockHeavyDone() &&
		m.MinimockIsAuthorizedDone() &&
		m.MinimockIsBeyondLimitDone() &&
		m.MinimockIsMeAuthorizedNowDone() &&
		m.MinimockLightExecutorForJetDone() &&
		m.MinimockLightExecutorForObjectDone() &&
		m.MinimockLightValidatorsForJetDone() &&
		m.MinimockLightValidatorsForObjectDone() &&
		m.MinimockMeDone() &&
		m.MinimockNodeForJetDone() &&
		m.MinimockNodeForObjectDone() &&
		m.MinimockQueryRoleDone() &&
		m.MinimockVirtualExecutorForObjectDone() &&
		m.MinimockVirtualValidatorsForObjectDone()
}
