package jet

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/insolar/insolar"
)

// StorageMock implements Storage
type StorageMock struct {
	t minimock.Tester

	funcAll          func(ctx context.Context, pulse insolar.PulseNumber) (ja1 []insolar.JetID)
	inspectFuncAll   func(ctx context.Context, pulse insolar.PulseNumber)
	afterAllCounter  uint64
	beforeAllCounter uint64
	AllMock          mStorageMockAll

	funcClone          func(ctx context.Context, from insolar.PulseNumber, to insolar.PulseNumber, keepActual bool) (err error)
	inspectFuncClone   func(ctx context.Context, from insolar.PulseNumber, to insolar.PulseNumber, keepActual bool)
	afterCloneCounter  uint64
	beforeCloneCounter uint64
	CloneMock          mStorageMockClone

	funcForID          func(ctx context.Context, pulse insolar.PulseNumber, recordID insolar.ID) (j1 insolar.JetID, b1 bool)
	inspectFuncForID   func(ctx context.Context, pulse insolar.PulseNumber, recordID insolar.ID)
	afterForIDCounter  uint64
	beforeForIDCounter uint64
	ForIDMock          mStorageMockForID

	funcSplit          func(ctx context.Context, pulse insolar.PulseNumber, id insolar.JetID) (j1 insolar.JetID, j2 insolar.JetID, err error)
	inspectFuncSplit   func(ctx context.Context, pulse insolar.PulseNumber, id insolar.JetID)
	afterSplitCounter  uint64
	beforeSplitCounter uint64
	SplitMock          mStorageMockSplit

	funcUpdate          func(ctx context.Context, pulse insolar.PulseNumber, actual bool, ids ...insolar.JetID) (err error)
	inspectFuncUpdate   func(ctx context.Context, pulse insolar.PulseNumber, actual bool, ids ...insolar.JetID)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mStorageMockUpdate
}

// NewStorageMock returns a mock for Storage
func NewStorageMock(t minimock.Tester) *StorageMock {
	m := &StorageMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AllMock = mStorageMockAll{mock: m}
	m.AllMock.callArgs = []*StorageMockAllParams{}

	m.CloneMock = mStorageMockClone{mock: m}
	m.CloneMock.callArgs = []*StorageMockCloneParams{}

	m.ForIDMock = mStorageMockForID{mock: m}
	m.ForIDMock.callArgs = []*StorageMockForIDParams{}

	m.SplitMock = mStorageMockSplit{mock: m}
	m.SplitMock.callArgs = []*StorageMockSplitParams{}

	m.UpdateMock = mStorageMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*StorageMockUpdateParams{}

	return m
}

type mStorageMockAll struct {
	mock               *StorageMock
	defaultExpectation *StorageMockAllExpectation
	expectations       []*StorageMockAllExpectation

	callArgs []*StorageMockAllParams
	mutex    sync.RWMutex
}

// StorageMockAllExpectation specifies expectation struct of the Storage.All
type StorageMockAllExpectation struct {
	mock    *StorageMock
	params  *StorageMockAllParams
	results *StorageMockAllResults
	Counter uint64
}

// StorageMockAllParams contains parameters of the Storage.All
type StorageMockAllParams struct {
	ctx   context.Context
	pulse insolar.PulseNumber
}

// StorageMockAllResults contains results of the Storage.All
type StorageMockAllResults struct {
	ja1 []insolar.JetID
}

// Expect sets up expected params for Storage.All
func (mmAll *mStorageMockAll) Expect(ctx context.Context, pulse insolar.PulseNumber) *mStorageMockAll {
	if mmAll.mock.funcAll != nil {
		mmAll.mock.t.Fatalf("StorageMock.All mock is already set by Set")
	}

	if mmAll.defaultExpectation == nil {
		mmAll.defaultExpectation = &StorageMockAllExpectation{}
	}

	mmAll.defaultExpectation.params = &StorageMockAllParams{ctx, pulse}
	for _, e := range mmAll.expectations {
		if minimock.Equal(e.params, mmAll.defaultExpectation.params) {
			mmAll.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAll.defaultExpectation.params)
		}
	}

	return mmAll
}

// Inspect accepts an inspector function that has same arguments as the Storage.All
func (mmAll *mStorageMockAll) Inspect(f func(ctx context.Context, pulse insolar.PulseNumber)) *mStorageMockAll {
	if mmAll.mock.inspectFuncAll != nil {
		mmAll.mock.t.Fatalf("Inspect function is already set for StorageMock.All")
	}

	mmAll.mock.inspectFuncAll = f

	return mmAll
}

// Return sets up results that will be returned by Storage.All
func (mmAll *mStorageMockAll) Return(ja1 []insolar.JetID) *StorageMock {
	if mmAll.mock.funcAll != nil {
		mmAll.mock.t.Fatalf("StorageMock.All mock is already set by Set")
	}

	if mmAll.defaultExpectation == nil {
		mmAll.defaultExpectation = &StorageMockAllExpectation{mock: mmAll.mock}
	}
	mmAll.defaultExpectation.results = &StorageMockAllResults{ja1}
	return mmAll.mock
}

//Set uses given function f to mock the Storage.All method
func (mmAll *mStorageMockAll) Set(f func(ctx context.Context, pulse insolar.PulseNumber) (ja1 []insolar.JetID)) *StorageMock {
	if mmAll.defaultExpectation != nil {
		mmAll.mock.t.Fatalf("Default expectation is already set for the Storage.All method")
	}

	if len(mmAll.expectations) > 0 {
		mmAll.mock.t.Fatalf("Some expectations are already set for the Storage.All method")
	}

	mmAll.mock.funcAll = f
	return mmAll.mock
}

// When sets expectation for the Storage.All which will trigger the result defined by the following
// Then helper
func (mmAll *mStorageMockAll) When(ctx context.Context, pulse insolar.PulseNumber) *StorageMockAllExpectation {
	if mmAll.mock.funcAll != nil {
		mmAll.mock.t.Fatalf("StorageMock.All mock is already set by Set")
	}

	expectation := &StorageMockAllExpectation{
		mock:   mmAll.mock,
		params: &StorageMockAllParams{ctx, pulse},
	}
	mmAll.expectations = append(mmAll.expectations, expectation)
	return expectation
}

// Then sets up Storage.All return parameters for the expectation previously defined by the When method
func (e *StorageMockAllExpectation) Then(ja1 []insolar.JetID) *StorageMock {
	e.results = &StorageMockAllResults{ja1}
	return e.mock
}

// All implements Storage
func (mmAll *StorageMock) All(ctx context.Context, pulse insolar.PulseNumber) (ja1 []insolar.JetID) {
	mm_atomic.AddUint64(&mmAll.beforeAllCounter, 1)
	defer mm_atomic.AddUint64(&mmAll.afterAllCounter, 1)

	if mmAll.inspectFuncAll != nil {
		mmAll.inspectFuncAll(ctx, pulse)
	}

	mm_params := &StorageMockAllParams{ctx, pulse}

	// Record call args
	mmAll.AllMock.mutex.Lock()
	mmAll.AllMock.callArgs = append(mmAll.AllMock.callArgs, mm_params)
	mmAll.AllMock.mutex.Unlock()

	for _, e := range mmAll.AllMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ja1
		}
	}

	if mmAll.AllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAll.AllMock.defaultExpectation.Counter, 1)
		mm_want := mmAll.AllMock.defaultExpectation.params
		mm_got := StorageMockAllParams{ctx, pulse}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAll.t.Errorf("StorageMock.All got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAll.AllMock.defaultExpectation.results
		if mm_results == nil {
			mmAll.t.Fatal("No results are set for the StorageMock.All")
		}
		return (*mm_results).ja1
	}
	if mmAll.funcAll != nil {
		return mmAll.funcAll(ctx, pulse)
	}
	mmAll.t.Fatalf("Unexpected call to StorageMock.All. %v %v", ctx, pulse)
	return
}

// AllAfterCounter returns a count of finished StorageMock.All invocations
func (mmAll *StorageMock) AllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAll.afterAllCounter)
}

// AllBeforeCounter returns a count of StorageMock.All invocations
func (mmAll *StorageMock) AllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAll.beforeAllCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.All.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAll *mStorageMockAll) Calls() []*StorageMockAllParams {
	mmAll.mutex.RLock()

	argCopy := make([]*StorageMockAllParams, len(mmAll.callArgs))
	copy(argCopy, mmAll.callArgs)

	mmAll.mutex.RUnlock()

	return argCopy
}

// MinimockAllDone returns true if the count of the All invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockAllDone() bool {
	for _, e := range m.AllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAllCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAll != nil && mm_atomic.LoadUint64(&m.afterAllCounter) < 1 {
		return false
	}
	return true
}

// MinimockAllInspect logs each unmet expectation
func (m *StorageMock) MinimockAllInspect() {
	for _, e := range m.AllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.All with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAllCounter) < 1 {
		if m.AllMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.All")
		} else {
			m.t.Errorf("Expected call to StorageMock.All with params: %#v", *m.AllMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAll != nil && mm_atomic.LoadUint64(&m.afterAllCounter) < 1 {
		m.t.Error("Expected call to StorageMock.All")
	}
}

type mStorageMockClone struct {
	mock               *StorageMock
	defaultExpectation *StorageMockCloneExpectation
	expectations       []*StorageMockCloneExpectation

	callArgs []*StorageMockCloneParams
	mutex    sync.RWMutex
}

// StorageMockCloneExpectation specifies expectation struct of the Storage.Clone
type StorageMockCloneExpectation struct {
	mock    *StorageMock
	params  *StorageMockCloneParams
	results *StorageMockCloneResults
	Counter uint64
}

// StorageMockCloneParams contains parameters of the Storage.Clone
type StorageMockCloneParams struct {
	ctx        context.Context
	from       insolar.PulseNumber
	to         insolar.PulseNumber
	keepActual bool
}

// StorageMockCloneResults contains results of the Storage.Clone
type StorageMockCloneResults struct {
	err error
}

// Expect sets up expected params for Storage.Clone
func (mmClone *mStorageMockClone) Expect(ctx context.Context, from insolar.PulseNumber, to insolar.PulseNumber, keepActual bool) *mStorageMockClone {
	if mmClone.mock.funcClone != nil {
		mmClone.mock.t.Fatalf("StorageMock.Clone mock is already set by Set")
	}

	if mmClone.defaultExpectation == nil {
		mmClone.defaultExpectation = &StorageMockCloneExpectation{}
	}

	mmClone.defaultExpectation.params = &StorageMockCloneParams{ctx, from, to, keepActual}
	for _, e := range mmClone.expectations {
		if minimock.Equal(e.params, mmClone.defaultExpectation.params) {
			mmClone.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmClone.defaultExpectation.params)
		}
	}

	return mmClone
}

// Inspect accepts an inspector function that has same arguments as the Storage.Clone
func (mmClone *mStorageMockClone) Inspect(f func(ctx context.Context, from insolar.PulseNumber, to insolar.PulseNumber, keepActual bool)) *mStorageMockClone {
	if mmClone.mock.inspectFuncClone != nil {
		mmClone.mock.t.Fatalf("Inspect function is already set for StorageMock.Clone")
	}

	mmClone.mock.inspectFuncClone = f

	return mmClone
}

// Return sets up results that will be returned by Storage.Clone
func (mmClone *mStorageMockClone) Return(err error) *StorageMock {
	if mmClone.mock.funcClone != nil {
		mmClone.mock.t.Fatalf("StorageMock.Clone mock is already set by Set")
	}

	if mmClone.defaultExpectation == nil {
		mmClone.defaultExpectation = &StorageMockCloneExpectation{mock: mmClone.mock}
	}
	mmClone.defaultExpectation.results = &StorageMockCloneResults{err}
	return mmClone.mock
}

//Set uses given function f to mock the Storage.Clone method
func (mmClone *mStorageMockClone) Set(f func(ctx context.Context, from insolar.PulseNumber, to insolar.PulseNumber, keepActual bool) (err error)) *StorageMock {
	if mmClone.defaultExpectation != nil {
		mmClone.mock.t.Fatalf("Default expectation is already set for the Storage.Clone method")
	}

	if len(mmClone.expectations) > 0 {
		mmClone.mock.t.Fatalf("Some expectations are already set for the Storage.Clone method")
	}

	mmClone.mock.funcClone = f
	return mmClone.mock
}

// When sets expectation for the Storage.Clone which will trigger the result defined by the following
// Then helper
func (mmClone *mStorageMockClone) When(ctx context.Context, from insolar.PulseNumber, to insolar.PulseNumber, keepActual bool) *StorageMockCloneExpectation {
	if mmClone.mock.funcClone != nil {
		mmClone.mock.t.Fatalf("StorageMock.Clone mock is already set by Set")
	}

	expectation := &StorageMockCloneExpectation{
		mock:   mmClone.mock,
		params: &StorageMockCloneParams{ctx, from, to, keepActual},
	}
	mmClone.expectations = append(mmClone.expectations, expectation)
	return expectation
}

// Then sets up Storage.Clone return parameters for the expectation previously defined by the When method
func (e *StorageMockCloneExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockCloneResults{err}
	return e.mock
}

// Clone implements Storage
func (mmClone *StorageMock) Clone(ctx context.Context, from insolar.PulseNumber, to insolar.PulseNumber, keepActual bool) (err error) {
	mm_atomic.AddUint64(&mmClone.beforeCloneCounter, 1)
	defer mm_atomic.AddUint64(&mmClone.afterCloneCounter, 1)

	if mmClone.inspectFuncClone != nil {
		mmClone.inspectFuncClone(ctx, from, to, keepActual)
	}

	mm_params := &StorageMockCloneParams{ctx, from, to, keepActual}

	// Record call args
	mmClone.CloneMock.mutex.Lock()
	mmClone.CloneMock.callArgs = append(mmClone.CloneMock.callArgs, mm_params)
	mmClone.CloneMock.mutex.Unlock()

	for _, e := range mmClone.CloneMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmClone.CloneMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClone.CloneMock.defaultExpectation.Counter, 1)
		mm_want := mmClone.CloneMock.defaultExpectation.params
		mm_got := StorageMockCloneParams{ctx, from, to, keepActual}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmClone.t.Errorf("StorageMock.Clone got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmClone.CloneMock.defaultExpectation.results
		if mm_results == nil {
			mmClone.t.Fatal("No results are set for the StorageMock.Clone")
		}
		return (*mm_results).err
	}
	if mmClone.funcClone != nil {
		return mmClone.funcClone(ctx, from, to, keepActual)
	}
	mmClone.t.Fatalf("Unexpected call to StorageMock.Clone. %v %v %v %v", ctx, from, to, keepActual)
	return
}

// CloneAfterCounter returns a count of finished StorageMock.Clone invocations
func (mmClone *StorageMock) CloneAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClone.afterCloneCounter)
}

// CloneBeforeCounter returns a count of StorageMock.Clone invocations
func (mmClone *StorageMock) CloneBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClone.beforeCloneCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.Clone.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmClone *mStorageMockClone) Calls() []*StorageMockCloneParams {
	mmClone.mutex.RLock()

	argCopy := make([]*StorageMockCloneParams, len(mmClone.callArgs))
	copy(argCopy, mmClone.callArgs)

	mmClone.mutex.RUnlock()

	return argCopy
}

// MinimockCloneDone returns true if the count of the Clone invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockCloneDone() bool {
	for _, e := range m.CloneMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloneMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloneCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClone != nil && mm_atomic.LoadUint64(&m.afterCloneCounter) < 1 {
		return false
	}
	return true
}

// MinimockCloneInspect logs each unmet expectation
func (m *StorageMock) MinimockCloneInspect() {
	for _, e := range m.CloneMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.Clone with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloneMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloneCounter) < 1 {
		if m.CloneMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.Clone")
		} else {
			m.t.Errorf("Expected call to StorageMock.Clone with params: %#v", *m.CloneMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClone != nil && mm_atomic.LoadUint64(&m.afterCloneCounter) < 1 {
		m.t.Error("Expected call to StorageMock.Clone")
	}
}

type mStorageMockForID struct {
	mock               *StorageMock
	defaultExpectation *StorageMockForIDExpectation
	expectations       []*StorageMockForIDExpectation

	callArgs []*StorageMockForIDParams
	mutex    sync.RWMutex
}

// StorageMockForIDExpectation specifies expectation struct of the Storage.ForID
type StorageMockForIDExpectation struct {
	mock    *StorageMock
	params  *StorageMockForIDParams
	results *StorageMockForIDResults
	Counter uint64
}

// StorageMockForIDParams contains parameters of the Storage.ForID
type StorageMockForIDParams struct {
	ctx      context.Context
	pulse    insolar.PulseNumber
	recordID insolar.ID
}

// StorageMockForIDResults contains results of the Storage.ForID
type StorageMockForIDResults struct {
	j1 insolar.JetID
	b1 bool
}

// Expect sets up expected params for Storage.ForID
func (mmForID *mStorageMockForID) Expect(ctx context.Context, pulse insolar.PulseNumber, recordID insolar.ID) *mStorageMockForID {
	if mmForID.mock.funcForID != nil {
		mmForID.mock.t.Fatalf("StorageMock.ForID mock is already set by Set")
	}

	if mmForID.defaultExpectation == nil {
		mmForID.defaultExpectation = &StorageMockForIDExpectation{}
	}

	mmForID.defaultExpectation.params = &StorageMockForIDParams{ctx, pulse, recordID}
	for _, e := range mmForID.expectations {
		if minimock.Equal(e.params, mmForID.defaultExpectation.params) {
			mmForID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmForID.defaultExpectation.params)
		}
	}

	return mmForID
}

// Inspect accepts an inspector function that has same arguments as the Storage.ForID
func (mmForID *mStorageMockForID) Inspect(f func(ctx context.Context, pulse insolar.PulseNumber, recordID insolar.ID)) *mStorageMockForID {
	if mmForID.mock.inspectFuncForID != nil {
		mmForID.mock.t.Fatalf("Inspect function is already set for StorageMock.ForID")
	}

	mmForID.mock.inspectFuncForID = f

	return mmForID
}

// Return sets up results that will be returned by Storage.ForID
func (mmForID *mStorageMockForID) Return(j1 insolar.JetID, b1 bool) *StorageMock {
	if mmForID.mock.funcForID != nil {
		mmForID.mock.t.Fatalf("StorageMock.ForID mock is already set by Set")
	}

	if mmForID.defaultExpectation == nil {
		mmForID.defaultExpectation = &StorageMockForIDExpectation{mock: mmForID.mock}
	}
	mmForID.defaultExpectation.results = &StorageMockForIDResults{j1, b1}
	return mmForID.mock
}

//Set uses given function f to mock the Storage.ForID method
func (mmForID *mStorageMockForID) Set(f func(ctx context.Context, pulse insolar.PulseNumber, recordID insolar.ID) (j1 insolar.JetID, b1 bool)) *StorageMock {
	if mmForID.defaultExpectation != nil {
		mmForID.mock.t.Fatalf("Default expectation is already set for the Storage.ForID method")
	}

	if len(mmForID.expectations) > 0 {
		mmForID.mock.t.Fatalf("Some expectations are already set for the Storage.ForID method")
	}

	mmForID.mock.funcForID = f
	return mmForID.mock
}

// When sets expectation for the Storage.ForID which will trigger the result defined by the following
// Then helper
func (mmForID *mStorageMockForID) When(ctx context.Context, pulse insolar.PulseNumber, recordID insolar.ID) *StorageMockForIDExpectation {
	if mmForID.mock.funcForID != nil {
		mmForID.mock.t.Fatalf("StorageMock.ForID mock is already set by Set")
	}

	expectation := &StorageMockForIDExpectation{
		mock:   mmForID.mock,
		params: &StorageMockForIDParams{ctx, pulse, recordID},
	}
	mmForID.expectations = append(mmForID.expectations, expectation)
	return expectation
}

// Then sets up Storage.ForID return parameters for the expectation previously defined by the When method
func (e *StorageMockForIDExpectation) Then(j1 insolar.JetID, b1 bool) *StorageMock {
	e.results = &StorageMockForIDResults{j1, b1}
	return e.mock
}

// ForID implements Storage
func (mmForID *StorageMock) ForID(ctx context.Context, pulse insolar.PulseNumber, recordID insolar.ID) (j1 insolar.JetID, b1 bool) {
	mm_atomic.AddUint64(&mmForID.beforeForIDCounter, 1)
	defer mm_atomic.AddUint64(&mmForID.afterForIDCounter, 1)

	if mmForID.inspectFuncForID != nil {
		mmForID.inspectFuncForID(ctx, pulse, recordID)
	}

	mm_params := &StorageMockForIDParams{ctx, pulse, recordID}

	// Record call args
	mmForID.ForIDMock.mutex.Lock()
	mmForID.ForIDMock.callArgs = append(mmForID.ForIDMock.callArgs, mm_params)
	mmForID.ForIDMock.mutex.Unlock()

	for _, e := range mmForID.ForIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.j1, e.results.b1
		}
	}

	if mmForID.ForIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmForID.ForIDMock.defaultExpectation.Counter, 1)
		mm_want := mmForID.ForIDMock.defaultExpectation.params
		mm_got := StorageMockForIDParams{ctx, pulse, recordID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmForID.t.Errorf("StorageMock.ForID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmForID.ForIDMock.defaultExpectation.results
		if mm_results == nil {
			mmForID.t.Fatal("No results are set for the StorageMock.ForID")
		}
		return (*mm_results).j1, (*mm_results).b1
	}
	if mmForID.funcForID != nil {
		return mmForID.funcForID(ctx, pulse, recordID)
	}
	mmForID.t.Fatalf("Unexpected call to StorageMock.ForID. %v %v %v", ctx, pulse, recordID)
	return
}

// ForIDAfterCounter returns a count of finished StorageMock.ForID invocations
func (mmForID *StorageMock) ForIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmForID.afterForIDCounter)
}

// ForIDBeforeCounter returns a count of StorageMock.ForID invocations
func (mmForID *StorageMock) ForIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmForID.beforeForIDCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.ForID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmForID *mStorageMockForID) Calls() []*StorageMockForIDParams {
	mmForID.mutex.RLock()

	argCopy := make([]*StorageMockForIDParams, len(mmForID.callArgs))
	copy(argCopy, mmForID.callArgs)

	mmForID.mutex.RUnlock()

	return argCopy
}

// MinimockForIDDone returns true if the count of the ForID invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockForIDDone() bool {
	for _, e := range m.ForIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ForIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterForIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcForID != nil && mm_atomic.LoadUint64(&m.afterForIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockForIDInspect logs each unmet expectation
func (m *StorageMock) MinimockForIDInspect() {
	for _, e := range m.ForIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.ForID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ForIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterForIDCounter) < 1 {
		if m.ForIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.ForID")
		} else {
			m.t.Errorf("Expected call to StorageMock.ForID with params: %#v", *m.ForIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcForID != nil && mm_atomic.LoadUint64(&m.afterForIDCounter) < 1 {
		m.t.Error("Expected call to StorageMock.ForID")
	}
}

type mStorageMockSplit struct {
	mock               *StorageMock
	defaultExpectation *StorageMockSplitExpectation
	expectations       []*StorageMockSplitExpectation

	callArgs []*StorageMockSplitParams
	mutex    sync.RWMutex
}

// StorageMockSplitExpectation specifies expectation struct of the Storage.Split
type StorageMockSplitExpectation struct {
	mock    *StorageMock
	params  *StorageMockSplitParams
	results *StorageMockSplitResults
	Counter uint64
}

// StorageMockSplitParams contains parameters of the Storage.Split
type StorageMockSplitParams struct {
	ctx   context.Context
	pulse insolar.PulseNumber
	id    insolar.JetID
}

// StorageMockSplitResults contains results of the Storage.Split
type StorageMockSplitResults struct {
	j1  insolar.JetID
	j2  insolar.JetID
	err error
}

// Expect sets up expected params for Storage.Split
func (mmSplit *mStorageMockSplit) Expect(ctx context.Context, pulse insolar.PulseNumber, id insolar.JetID) *mStorageMockSplit {
	if mmSplit.mock.funcSplit != nil {
		mmSplit.mock.t.Fatalf("StorageMock.Split mock is already set by Set")
	}

	if mmSplit.defaultExpectation == nil {
		mmSplit.defaultExpectation = &StorageMockSplitExpectation{}
	}

	mmSplit.defaultExpectation.params = &StorageMockSplitParams{ctx, pulse, id}
	for _, e := range mmSplit.expectations {
		if minimock.Equal(e.params, mmSplit.defaultExpectation.params) {
			mmSplit.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSplit.defaultExpectation.params)
		}
	}

	return mmSplit
}

// Inspect accepts an inspector function that has same arguments as the Storage.Split
func (mmSplit *mStorageMockSplit) Inspect(f func(ctx context.Context, pulse insolar.PulseNumber, id insolar.JetID)) *mStorageMockSplit {
	if mmSplit.mock.inspectFuncSplit != nil {
		mmSplit.mock.t.Fatalf("Inspect function is already set for StorageMock.Split")
	}

	mmSplit.mock.inspectFuncSplit = f

	return mmSplit
}

// Return sets up results that will be returned by Storage.Split
func (mmSplit *mStorageMockSplit) Return(j1 insolar.JetID, j2 insolar.JetID, err error) *StorageMock {
	if mmSplit.mock.funcSplit != nil {
		mmSplit.mock.t.Fatalf("StorageMock.Split mock is already set by Set")
	}

	if mmSplit.defaultExpectation == nil {
		mmSplit.defaultExpectation = &StorageMockSplitExpectation{mock: mmSplit.mock}
	}
	mmSplit.defaultExpectation.results = &StorageMockSplitResults{j1, j2, err}
	return mmSplit.mock
}

//Set uses given function f to mock the Storage.Split method
func (mmSplit *mStorageMockSplit) Set(f func(ctx context.Context, pulse insolar.PulseNumber, id insolar.JetID) (j1 insolar.JetID, j2 insolar.JetID, err error)) *StorageMock {
	if mmSplit.defaultExpectation != nil {
		mmSplit.mock.t.Fatalf("Default expectation is already set for the Storage.Split method")
	}

	if len(mmSplit.expectations) > 0 {
		mmSplit.mock.t.Fatalf("Some expectations are already set for the Storage.Split method")
	}

	mmSplit.mock.funcSplit = f
	return mmSplit.mock
}

// When sets expectation for the Storage.Split which will trigger the result defined by the following
// Then helper
func (mmSplit *mStorageMockSplit) When(ctx context.Context, pulse insolar.PulseNumber, id insolar.JetID) *StorageMockSplitExpectation {
	if mmSplit.mock.funcSplit != nil {
		mmSplit.mock.t.Fatalf("StorageMock.Split mock is already set by Set")
	}

	expectation := &StorageMockSplitExpectation{
		mock:   mmSplit.mock,
		params: &StorageMockSplitParams{ctx, pulse, id},
	}
	mmSplit.expectations = append(mmSplit.expectations, expectation)
	return expectation
}

// Then sets up Storage.Split return parameters for the expectation previously defined by the When method
func (e *StorageMockSplitExpectation) Then(j1 insolar.JetID, j2 insolar.JetID, err error) *StorageMock {
	e.results = &StorageMockSplitResults{j1, j2, err}
	return e.mock
}

// Split implements Storage
func (mmSplit *StorageMock) Split(ctx context.Context, pulse insolar.PulseNumber, id insolar.JetID) (j1 insolar.JetID, j2 insolar.JetID, err error) {
	mm_atomic.AddUint64(&mmSplit.beforeSplitCounter, 1)
	defer mm_atomic.AddUint64(&mmSplit.afterSplitCounter, 1)

	if mmSplit.inspectFuncSplit != nil {
		mmSplit.inspectFuncSplit(ctx, pulse, id)
	}

	mm_params := &StorageMockSplitParams{ctx, pulse, id}

	// Record call args
	mmSplit.SplitMock.mutex.Lock()
	mmSplit.SplitMock.callArgs = append(mmSplit.SplitMock.callArgs, mm_params)
	mmSplit.SplitMock.mutex.Unlock()

	for _, e := range mmSplit.SplitMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.j1, e.results.j2, e.results.err
		}
	}

	if mmSplit.SplitMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSplit.SplitMock.defaultExpectation.Counter, 1)
		mm_want := mmSplit.SplitMock.defaultExpectation.params
		mm_got := StorageMockSplitParams{ctx, pulse, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSplit.t.Errorf("StorageMock.Split got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSplit.SplitMock.defaultExpectation.results
		if mm_results == nil {
			mmSplit.t.Fatal("No results are set for the StorageMock.Split")
		}
		return (*mm_results).j1, (*mm_results).j2, (*mm_results).err
	}
	if mmSplit.funcSplit != nil {
		return mmSplit.funcSplit(ctx, pulse, id)
	}
	mmSplit.t.Fatalf("Unexpected call to StorageMock.Split. %v %v %v", ctx, pulse, id)
	return
}

// SplitAfterCounter returns a count of finished StorageMock.Split invocations
func (mmSplit *StorageMock) SplitAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSplit.afterSplitCounter)
}

// SplitBeforeCounter returns a count of StorageMock.Split invocations
func (mmSplit *StorageMock) SplitBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSplit.beforeSplitCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.Split.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSplit *mStorageMockSplit) Calls() []*StorageMockSplitParams {
	mmSplit.mutex.RLock()

	argCopy := make([]*StorageMockSplitParams, len(mmSplit.callArgs))
	copy(argCopy, mmSplit.callArgs)

	mmSplit.mutex.RUnlock()

	return argCopy
}

// MinimockSplitDone returns true if the count of the Split invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockSplitDone() bool {
	for _, e := range m.SplitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SplitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSplitCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSplit != nil && mm_atomic.LoadUint64(&m.afterSplitCounter) < 1 {
		return false
	}
	return true
}

// MinimockSplitInspect logs each unmet expectation
func (m *StorageMock) MinimockSplitInspect() {
	for _, e := range m.SplitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.Split with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SplitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSplitCounter) < 1 {
		if m.SplitMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.Split")
		} else {
			m.t.Errorf("Expected call to StorageMock.Split with params: %#v", *m.SplitMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSplit != nil && mm_atomic.LoadUint64(&m.afterSplitCounter) < 1 {
		m.t.Error("Expected call to StorageMock.Split")
	}
}

type mStorageMockUpdate struct {
	mock               *StorageMock
	defaultExpectation *StorageMockUpdateExpectation
	expectations       []*StorageMockUpdateExpectation

	callArgs []*StorageMockUpdateParams
	mutex    sync.RWMutex
}

// StorageMockUpdateExpectation specifies expectation struct of the Storage.Update
type StorageMockUpdateExpectation struct {
	mock    *StorageMock
	params  *StorageMockUpdateParams
	results *StorageMockUpdateResults
	Counter uint64
}

// StorageMockUpdateParams contains parameters of the Storage.Update
type StorageMockUpdateParams struct {
	ctx    context.Context
	pulse  insolar.PulseNumber
	actual bool
	ids    []insolar.JetID
}

// StorageMockUpdateResults contains results of the Storage.Update
type StorageMockUpdateResults struct {
	err error
}

// Expect sets up expected params for Storage.Update
func (mmUpdate *mStorageMockUpdate) Expect(ctx context.Context, pulse insolar.PulseNumber, actual bool, ids ...insolar.JetID) *mStorageMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("StorageMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &StorageMockUpdateExpectation{}
	}

	mmUpdate.defaultExpectation.params = &StorageMockUpdateParams{ctx, pulse, actual, ids}
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the Storage.Update
func (mmUpdate *mStorageMockUpdate) Inspect(f func(ctx context.Context, pulse insolar.PulseNumber, actual bool, ids ...insolar.JetID)) *mStorageMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for StorageMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by Storage.Update
func (mmUpdate *mStorageMockUpdate) Return(err error) *StorageMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("StorageMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &StorageMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &StorageMockUpdateResults{err}
	return mmUpdate.mock
}

//Set uses given function f to mock the Storage.Update method
func (mmUpdate *mStorageMockUpdate) Set(f func(ctx context.Context, pulse insolar.PulseNumber, actual bool, ids ...insolar.JetID) (err error)) *StorageMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the Storage.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the Storage.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	return mmUpdate.mock
}

// When sets expectation for the Storage.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mStorageMockUpdate) When(ctx context.Context, pulse insolar.PulseNumber, actual bool, ids ...insolar.JetID) *StorageMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("StorageMock.Update mock is already set by Set")
	}

	expectation := &StorageMockUpdateExpectation{
		mock:   mmUpdate.mock,
		params: &StorageMockUpdateParams{ctx, pulse, actual, ids},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up Storage.Update return parameters for the expectation previously defined by the When method
func (e *StorageMockUpdateExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockUpdateResults{err}
	return e.mock
}

// Update implements Storage
func (mmUpdate *StorageMock) Update(ctx context.Context, pulse insolar.PulseNumber, actual bool, ids ...insolar.JetID) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, pulse, actual, ids...)
	}

	mm_params := &StorageMockUpdateParams{ctx, pulse, actual, ids}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_got := StorageMockUpdateParams{ctx, pulse, actual, ids}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("StorageMock.Update got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the StorageMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, pulse, actual, ids...)
	}
	mmUpdate.t.Fatalf("Unexpected call to StorageMock.Update. %v %v %v %v", ctx, pulse, actual, ids)
	return
}

// UpdateAfterCounter returns a count of finished StorageMock.Update invocations
func (mmUpdate *StorageMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of StorageMock.Update invocations
func (mmUpdate *StorageMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mStorageMockUpdate) Calls() []*StorageMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*StorageMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockUpdateDone() bool {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateInspect logs each unmet expectation
func (m *StorageMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.Update with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.Update")
		} else {
			m.t.Errorf("Expected call to StorageMock.Update with params: %#v", *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		m.t.Error("Expected call to StorageMock.Update")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StorageMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAllInspect()

		m.MinimockCloneInspect()

		m.MinimockForIDInspect()

		m.MinimockSplitInspect()

		m.MinimockUpdateInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAllDone() &&
		m.MinimockCloneDone() &&
		m.MinimockForIDDone() &&
		m.MinimockSplitDone() &&
		m.MinimockUpdateDone()
}
