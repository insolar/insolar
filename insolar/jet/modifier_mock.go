package jet

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/insolar/insolar"
)

// ModifierMock implements Modifier
type ModifierMock struct {
	t minimock.Tester

	funcClone          func(ctx context.Context, from insolar.PulseNumber, to insolar.PulseNumber, keepActual bool) (err error)
	inspectFuncClone   func(ctx context.Context, from insolar.PulseNumber, to insolar.PulseNumber, keepActual bool)
	afterCloneCounter  uint64
	beforeCloneCounter uint64
	CloneMock          mModifierMockClone

	funcSplit          func(ctx context.Context, pulse insolar.PulseNumber, id insolar.JetID) (j1 insolar.JetID, j2 insolar.JetID, err error)
	inspectFuncSplit   func(ctx context.Context, pulse insolar.PulseNumber, id insolar.JetID)
	afterSplitCounter  uint64
	beforeSplitCounter uint64
	SplitMock          mModifierMockSplit

	funcUpdate          func(ctx context.Context, pulse insolar.PulseNumber, actual bool, ids ...insolar.JetID) (err error)
	inspectFuncUpdate   func(ctx context.Context, pulse insolar.PulseNumber, actual bool, ids ...insolar.JetID)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mModifierMockUpdate
}

// NewModifierMock returns a mock for Modifier
func NewModifierMock(t minimock.Tester) *ModifierMock {
	m := &ModifierMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CloneMock = mModifierMockClone{mock: m}
	m.CloneMock.callArgs = []*ModifierMockCloneParams{}

	m.SplitMock = mModifierMockSplit{mock: m}
	m.SplitMock.callArgs = []*ModifierMockSplitParams{}

	m.UpdateMock = mModifierMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*ModifierMockUpdateParams{}

	return m
}

type mModifierMockClone struct {
	mock               *ModifierMock
	defaultExpectation *ModifierMockCloneExpectation
	expectations       []*ModifierMockCloneExpectation

	callArgs []*ModifierMockCloneParams
	mutex    sync.RWMutex
}

// ModifierMockCloneExpectation specifies expectation struct of the Modifier.Clone
type ModifierMockCloneExpectation struct {
	mock    *ModifierMock
	params  *ModifierMockCloneParams
	results *ModifierMockCloneResults
	Counter uint64
}

// ModifierMockCloneParams contains parameters of the Modifier.Clone
type ModifierMockCloneParams struct {
	ctx        context.Context
	from       insolar.PulseNumber
	to         insolar.PulseNumber
	keepActual bool
}

// ModifierMockCloneResults contains results of the Modifier.Clone
type ModifierMockCloneResults struct {
	err error
}

// Expect sets up expected params for Modifier.Clone
func (mmClone *mModifierMockClone) Expect(ctx context.Context, from insolar.PulseNumber, to insolar.PulseNumber, keepActual bool) *mModifierMockClone {
	if mmClone.mock.funcClone != nil {
		mmClone.mock.t.Fatalf("ModifierMock.Clone mock is already set by Set")
	}

	if mmClone.defaultExpectation == nil {
		mmClone.defaultExpectation = &ModifierMockCloneExpectation{}
	}

	mmClone.defaultExpectation.params = &ModifierMockCloneParams{ctx, from, to, keepActual}
	for _, e := range mmClone.expectations {
		if minimock.Equal(e.params, mmClone.defaultExpectation.params) {
			mmClone.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmClone.defaultExpectation.params)
		}
	}

	return mmClone
}

// Inspect accepts an inspector function that has same arguments as the Modifier.Clone
func (mmClone *mModifierMockClone) Inspect(f func(ctx context.Context, from insolar.PulseNumber, to insolar.PulseNumber, keepActual bool)) *mModifierMockClone {
	if mmClone.mock.inspectFuncClone != nil {
		mmClone.mock.t.Fatalf("Inspect function is already set for ModifierMock.Clone")
	}

	mmClone.mock.inspectFuncClone = f

	return mmClone
}

// Return sets up results that will be returned by Modifier.Clone
func (mmClone *mModifierMockClone) Return(err error) *ModifierMock {
	if mmClone.mock.funcClone != nil {
		mmClone.mock.t.Fatalf("ModifierMock.Clone mock is already set by Set")
	}

	if mmClone.defaultExpectation == nil {
		mmClone.defaultExpectation = &ModifierMockCloneExpectation{mock: mmClone.mock}
	}
	mmClone.defaultExpectation.results = &ModifierMockCloneResults{err}
	return mmClone.mock
}

//Set uses given function f to mock the Modifier.Clone method
func (mmClone *mModifierMockClone) Set(f func(ctx context.Context, from insolar.PulseNumber, to insolar.PulseNumber, keepActual bool) (err error)) *ModifierMock {
	if mmClone.defaultExpectation != nil {
		mmClone.mock.t.Fatalf("Default expectation is already set for the Modifier.Clone method")
	}

	if len(mmClone.expectations) > 0 {
		mmClone.mock.t.Fatalf("Some expectations are already set for the Modifier.Clone method")
	}

	mmClone.mock.funcClone = f
	return mmClone.mock
}

// When sets expectation for the Modifier.Clone which will trigger the result defined by the following
// Then helper
func (mmClone *mModifierMockClone) When(ctx context.Context, from insolar.PulseNumber, to insolar.PulseNumber, keepActual bool) *ModifierMockCloneExpectation {
	if mmClone.mock.funcClone != nil {
		mmClone.mock.t.Fatalf("ModifierMock.Clone mock is already set by Set")
	}

	expectation := &ModifierMockCloneExpectation{
		mock:   mmClone.mock,
		params: &ModifierMockCloneParams{ctx, from, to, keepActual},
	}
	mmClone.expectations = append(mmClone.expectations, expectation)
	return expectation
}

// Then sets up Modifier.Clone return parameters for the expectation previously defined by the When method
func (e *ModifierMockCloneExpectation) Then(err error) *ModifierMock {
	e.results = &ModifierMockCloneResults{err}
	return e.mock
}

// Clone implements Modifier
func (mmClone *ModifierMock) Clone(ctx context.Context, from insolar.PulseNumber, to insolar.PulseNumber, keepActual bool) (err error) {
	mm_atomic.AddUint64(&mmClone.beforeCloneCounter, 1)
	defer mm_atomic.AddUint64(&mmClone.afterCloneCounter, 1)

	if mmClone.inspectFuncClone != nil {
		mmClone.inspectFuncClone(ctx, from, to, keepActual)
	}

	mm_params := &ModifierMockCloneParams{ctx, from, to, keepActual}

	// Record call args
	mmClone.CloneMock.mutex.Lock()
	mmClone.CloneMock.callArgs = append(mmClone.CloneMock.callArgs, mm_params)
	mmClone.CloneMock.mutex.Unlock()

	for _, e := range mmClone.CloneMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmClone.CloneMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClone.CloneMock.defaultExpectation.Counter, 1)
		mm_want := mmClone.CloneMock.defaultExpectation.params
		mm_got := ModifierMockCloneParams{ctx, from, to, keepActual}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmClone.t.Errorf("ModifierMock.Clone got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmClone.CloneMock.defaultExpectation.results
		if mm_results == nil {
			mmClone.t.Fatal("No results are set for the ModifierMock.Clone")
		}
		return (*mm_results).err
	}
	if mmClone.funcClone != nil {
		return mmClone.funcClone(ctx, from, to, keepActual)
	}
	mmClone.t.Fatalf("Unexpected call to ModifierMock.Clone. %v %v %v %v", ctx, from, to, keepActual)
	return
}

// CloneAfterCounter returns a count of finished ModifierMock.Clone invocations
func (mmClone *ModifierMock) CloneAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClone.afterCloneCounter)
}

// CloneBeforeCounter returns a count of ModifierMock.Clone invocations
func (mmClone *ModifierMock) CloneBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClone.beforeCloneCounter)
}

// Calls returns a list of arguments used in each call to ModifierMock.Clone.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmClone *mModifierMockClone) Calls() []*ModifierMockCloneParams {
	mmClone.mutex.RLock()

	argCopy := make([]*ModifierMockCloneParams, len(mmClone.callArgs))
	copy(argCopy, mmClone.callArgs)

	mmClone.mutex.RUnlock()

	return argCopy
}

// MinimockCloneDone returns true if the count of the Clone invocations corresponds
// the number of defined expectations
func (m *ModifierMock) MinimockCloneDone() bool {
	for _, e := range m.CloneMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloneMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloneCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClone != nil && mm_atomic.LoadUint64(&m.afterCloneCounter) < 1 {
		return false
	}
	return true
}

// MinimockCloneInspect logs each unmet expectation
func (m *ModifierMock) MinimockCloneInspect() {
	for _, e := range m.CloneMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModifierMock.Clone with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloneMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloneCounter) < 1 {
		if m.CloneMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ModifierMock.Clone")
		} else {
			m.t.Errorf("Expected call to ModifierMock.Clone with params: %#v", *m.CloneMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClone != nil && mm_atomic.LoadUint64(&m.afterCloneCounter) < 1 {
		m.t.Error("Expected call to ModifierMock.Clone")
	}
}

type mModifierMockSplit struct {
	mock               *ModifierMock
	defaultExpectation *ModifierMockSplitExpectation
	expectations       []*ModifierMockSplitExpectation

	callArgs []*ModifierMockSplitParams
	mutex    sync.RWMutex
}

// ModifierMockSplitExpectation specifies expectation struct of the Modifier.Split
type ModifierMockSplitExpectation struct {
	mock    *ModifierMock
	params  *ModifierMockSplitParams
	results *ModifierMockSplitResults
	Counter uint64
}

// ModifierMockSplitParams contains parameters of the Modifier.Split
type ModifierMockSplitParams struct {
	ctx   context.Context
	pulse insolar.PulseNumber
	id    insolar.JetID
}

// ModifierMockSplitResults contains results of the Modifier.Split
type ModifierMockSplitResults struct {
	j1  insolar.JetID
	j2  insolar.JetID
	err error
}

// Expect sets up expected params for Modifier.Split
func (mmSplit *mModifierMockSplit) Expect(ctx context.Context, pulse insolar.PulseNumber, id insolar.JetID) *mModifierMockSplit {
	if mmSplit.mock.funcSplit != nil {
		mmSplit.mock.t.Fatalf("ModifierMock.Split mock is already set by Set")
	}

	if mmSplit.defaultExpectation == nil {
		mmSplit.defaultExpectation = &ModifierMockSplitExpectation{}
	}

	mmSplit.defaultExpectation.params = &ModifierMockSplitParams{ctx, pulse, id}
	for _, e := range mmSplit.expectations {
		if minimock.Equal(e.params, mmSplit.defaultExpectation.params) {
			mmSplit.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSplit.defaultExpectation.params)
		}
	}

	return mmSplit
}

// Inspect accepts an inspector function that has same arguments as the Modifier.Split
func (mmSplit *mModifierMockSplit) Inspect(f func(ctx context.Context, pulse insolar.PulseNumber, id insolar.JetID)) *mModifierMockSplit {
	if mmSplit.mock.inspectFuncSplit != nil {
		mmSplit.mock.t.Fatalf("Inspect function is already set for ModifierMock.Split")
	}

	mmSplit.mock.inspectFuncSplit = f

	return mmSplit
}

// Return sets up results that will be returned by Modifier.Split
func (mmSplit *mModifierMockSplit) Return(j1 insolar.JetID, j2 insolar.JetID, err error) *ModifierMock {
	if mmSplit.mock.funcSplit != nil {
		mmSplit.mock.t.Fatalf("ModifierMock.Split mock is already set by Set")
	}

	if mmSplit.defaultExpectation == nil {
		mmSplit.defaultExpectation = &ModifierMockSplitExpectation{mock: mmSplit.mock}
	}
	mmSplit.defaultExpectation.results = &ModifierMockSplitResults{j1, j2, err}
	return mmSplit.mock
}

//Set uses given function f to mock the Modifier.Split method
func (mmSplit *mModifierMockSplit) Set(f func(ctx context.Context, pulse insolar.PulseNumber, id insolar.JetID) (j1 insolar.JetID, j2 insolar.JetID, err error)) *ModifierMock {
	if mmSplit.defaultExpectation != nil {
		mmSplit.mock.t.Fatalf("Default expectation is already set for the Modifier.Split method")
	}

	if len(mmSplit.expectations) > 0 {
		mmSplit.mock.t.Fatalf("Some expectations are already set for the Modifier.Split method")
	}

	mmSplit.mock.funcSplit = f
	return mmSplit.mock
}

// When sets expectation for the Modifier.Split which will trigger the result defined by the following
// Then helper
func (mmSplit *mModifierMockSplit) When(ctx context.Context, pulse insolar.PulseNumber, id insolar.JetID) *ModifierMockSplitExpectation {
	if mmSplit.mock.funcSplit != nil {
		mmSplit.mock.t.Fatalf("ModifierMock.Split mock is already set by Set")
	}

	expectation := &ModifierMockSplitExpectation{
		mock:   mmSplit.mock,
		params: &ModifierMockSplitParams{ctx, pulse, id},
	}
	mmSplit.expectations = append(mmSplit.expectations, expectation)
	return expectation
}

// Then sets up Modifier.Split return parameters for the expectation previously defined by the When method
func (e *ModifierMockSplitExpectation) Then(j1 insolar.JetID, j2 insolar.JetID, err error) *ModifierMock {
	e.results = &ModifierMockSplitResults{j1, j2, err}
	return e.mock
}

// Split implements Modifier
func (mmSplit *ModifierMock) Split(ctx context.Context, pulse insolar.PulseNumber, id insolar.JetID) (j1 insolar.JetID, j2 insolar.JetID, err error) {
	mm_atomic.AddUint64(&mmSplit.beforeSplitCounter, 1)
	defer mm_atomic.AddUint64(&mmSplit.afterSplitCounter, 1)

	if mmSplit.inspectFuncSplit != nil {
		mmSplit.inspectFuncSplit(ctx, pulse, id)
	}

	mm_params := &ModifierMockSplitParams{ctx, pulse, id}

	// Record call args
	mmSplit.SplitMock.mutex.Lock()
	mmSplit.SplitMock.callArgs = append(mmSplit.SplitMock.callArgs, mm_params)
	mmSplit.SplitMock.mutex.Unlock()

	for _, e := range mmSplit.SplitMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.j1, e.results.j2, e.results.err
		}
	}

	if mmSplit.SplitMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSplit.SplitMock.defaultExpectation.Counter, 1)
		mm_want := mmSplit.SplitMock.defaultExpectation.params
		mm_got := ModifierMockSplitParams{ctx, pulse, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSplit.t.Errorf("ModifierMock.Split got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSplit.SplitMock.defaultExpectation.results
		if mm_results == nil {
			mmSplit.t.Fatal("No results are set for the ModifierMock.Split")
		}
		return (*mm_results).j1, (*mm_results).j2, (*mm_results).err
	}
	if mmSplit.funcSplit != nil {
		return mmSplit.funcSplit(ctx, pulse, id)
	}
	mmSplit.t.Fatalf("Unexpected call to ModifierMock.Split. %v %v %v", ctx, pulse, id)
	return
}

// SplitAfterCounter returns a count of finished ModifierMock.Split invocations
func (mmSplit *ModifierMock) SplitAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSplit.afterSplitCounter)
}

// SplitBeforeCounter returns a count of ModifierMock.Split invocations
func (mmSplit *ModifierMock) SplitBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSplit.beforeSplitCounter)
}

// Calls returns a list of arguments used in each call to ModifierMock.Split.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSplit *mModifierMockSplit) Calls() []*ModifierMockSplitParams {
	mmSplit.mutex.RLock()

	argCopy := make([]*ModifierMockSplitParams, len(mmSplit.callArgs))
	copy(argCopy, mmSplit.callArgs)

	mmSplit.mutex.RUnlock()

	return argCopy
}

// MinimockSplitDone returns true if the count of the Split invocations corresponds
// the number of defined expectations
func (m *ModifierMock) MinimockSplitDone() bool {
	for _, e := range m.SplitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SplitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSplitCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSplit != nil && mm_atomic.LoadUint64(&m.afterSplitCounter) < 1 {
		return false
	}
	return true
}

// MinimockSplitInspect logs each unmet expectation
func (m *ModifierMock) MinimockSplitInspect() {
	for _, e := range m.SplitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModifierMock.Split with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SplitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSplitCounter) < 1 {
		if m.SplitMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ModifierMock.Split")
		} else {
			m.t.Errorf("Expected call to ModifierMock.Split with params: %#v", *m.SplitMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSplit != nil && mm_atomic.LoadUint64(&m.afterSplitCounter) < 1 {
		m.t.Error("Expected call to ModifierMock.Split")
	}
}

type mModifierMockUpdate struct {
	mock               *ModifierMock
	defaultExpectation *ModifierMockUpdateExpectation
	expectations       []*ModifierMockUpdateExpectation

	callArgs []*ModifierMockUpdateParams
	mutex    sync.RWMutex
}

// ModifierMockUpdateExpectation specifies expectation struct of the Modifier.Update
type ModifierMockUpdateExpectation struct {
	mock    *ModifierMock
	params  *ModifierMockUpdateParams
	results *ModifierMockUpdateResults
	Counter uint64
}

// ModifierMockUpdateParams contains parameters of the Modifier.Update
type ModifierMockUpdateParams struct {
	ctx    context.Context
	pulse  insolar.PulseNumber
	actual bool
	ids    []insolar.JetID
}

// ModifierMockUpdateResults contains results of the Modifier.Update
type ModifierMockUpdateResults struct {
	err error
}

// Expect sets up expected params for Modifier.Update
func (mmUpdate *mModifierMockUpdate) Expect(ctx context.Context, pulse insolar.PulseNumber, actual bool, ids ...insolar.JetID) *mModifierMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("ModifierMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &ModifierMockUpdateExpectation{}
	}

	mmUpdate.defaultExpectation.params = &ModifierMockUpdateParams{ctx, pulse, actual, ids}
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the Modifier.Update
func (mmUpdate *mModifierMockUpdate) Inspect(f func(ctx context.Context, pulse insolar.PulseNumber, actual bool, ids ...insolar.JetID)) *mModifierMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for ModifierMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by Modifier.Update
func (mmUpdate *mModifierMockUpdate) Return(err error) *ModifierMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("ModifierMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &ModifierMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &ModifierMockUpdateResults{err}
	return mmUpdate.mock
}

//Set uses given function f to mock the Modifier.Update method
func (mmUpdate *mModifierMockUpdate) Set(f func(ctx context.Context, pulse insolar.PulseNumber, actual bool, ids ...insolar.JetID) (err error)) *ModifierMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the Modifier.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the Modifier.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	return mmUpdate.mock
}

// When sets expectation for the Modifier.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mModifierMockUpdate) When(ctx context.Context, pulse insolar.PulseNumber, actual bool, ids ...insolar.JetID) *ModifierMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("ModifierMock.Update mock is already set by Set")
	}

	expectation := &ModifierMockUpdateExpectation{
		mock:   mmUpdate.mock,
		params: &ModifierMockUpdateParams{ctx, pulse, actual, ids},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up Modifier.Update return parameters for the expectation previously defined by the When method
func (e *ModifierMockUpdateExpectation) Then(err error) *ModifierMock {
	e.results = &ModifierMockUpdateResults{err}
	return e.mock
}

// Update implements Modifier
func (mmUpdate *ModifierMock) Update(ctx context.Context, pulse insolar.PulseNumber, actual bool, ids ...insolar.JetID) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, pulse, actual, ids...)
	}

	mm_params := &ModifierMockUpdateParams{ctx, pulse, actual, ids}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_got := ModifierMockUpdateParams{ctx, pulse, actual, ids}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("ModifierMock.Update got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the ModifierMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, pulse, actual, ids...)
	}
	mmUpdate.t.Fatalf("Unexpected call to ModifierMock.Update. %v %v %v %v", ctx, pulse, actual, ids)
	return
}

// UpdateAfterCounter returns a count of finished ModifierMock.Update invocations
func (mmUpdate *ModifierMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of ModifierMock.Update invocations
func (mmUpdate *ModifierMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to ModifierMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mModifierMockUpdate) Calls() []*ModifierMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*ModifierMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *ModifierMock) MinimockUpdateDone() bool {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateInspect logs each unmet expectation
func (m *ModifierMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModifierMock.Update with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ModifierMock.Update")
		} else {
			m.t.Errorf("Expected call to ModifierMock.Update with params: %#v", *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		m.t.Error("Expected call to ModifierMock.Update")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ModifierMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCloneInspect()

		m.MinimockSplitInspect()

		m.MinimockUpdateInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ModifierMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ModifierMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCloneDone() &&
		m.MinimockSplitDone() &&
		m.MinimockUpdateDone()
}
