package network

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/insolar"
	mm_network "github.com/insolar/insolar/network"
)

// GatewayMock implements network.Gateway
type GatewayMock struct {
	t minimock.Tester

	funcAuther          func() (a1 mm_network.Auther)
	inspectFuncAuther   func()
	afterAutherCounter  uint64
	beforeAutherCounter uint64
	AutherMock          mGatewayMockAuther

	funcBeforeRun          func(ctx context.Context, pulse insolar.Pulse)
	inspectFuncBeforeRun   func(ctx context.Context, pulse insolar.Pulse)
	afterBeforeRunCounter  uint64
	beforeBeforeRunCounter uint64
	BeforeRunMock          mGatewayMockBeforeRun

	funcBootstrapper          func() (b1 mm_network.Bootstrapper)
	inspectFuncBootstrapper   func()
	afterBootstrapperCounter  uint64
	beforeBootstrapperCounter uint64
	BootstrapperMock          mGatewayMockBootstrapper

	funcEphemeralMode          func(nodes []insolar.NetworkNode) (b1 bool)
	inspectFuncEphemeralMode   func(nodes []insolar.NetworkNode)
	afterEphemeralModeCounter  uint64
	beforeEphemeralModeCounter uint64
	EphemeralModeMock          mGatewayMockEphemeralMode

	funcGetState          func() (n1 insolar.NetworkState)
	inspectFuncGetState   func()
	afterGetStateCounter  uint64
	beforeGetStateCounter uint64
	GetStateMock          mGatewayMockGetState

	funcNewGateway          func(ctx context.Context, n1 insolar.NetworkState) (g1 mm_network.Gateway)
	inspectFuncNewGateway   func(ctx context.Context, n1 insolar.NetworkState)
	afterNewGatewayCounter  uint64
	beforeNewGatewayCounter uint64
	NewGatewayMock          mGatewayMockNewGateway

	funcOnConsensusFinished          func(ctx context.Context, report mm_network.Report)
	inspectFuncOnConsensusFinished   func(ctx context.Context, report mm_network.Report)
	afterOnConsensusFinishedCounter  uint64
	beforeOnConsensusFinishedCounter uint64
	OnConsensusFinishedMock          mGatewayMockOnConsensusFinished

	funcOnPulseFromConsensus          func(ctx context.Context, p1 insolar.Pulse)
	inspectFuncOnPulseFromConsensus   func(ctx context.Context, p1 insolar.Pulse)
	afterOnPulseFromConsensusCounter  uint64
	beforeOnPulseFromConsensusCounter uint64
	OnPulseFromConsensusMock          mGatewayMockOnPulseFromConsensus

	funcOnPulseFromPulsar          func(ctx context.Context, p1 insolar.Pulse, r1 mm_network.ReceivedPacket)
	inspectFuncOnPulseFromPulsar   func(ctx context.Context, p1 insolar.Pulse, r1 mm_network.ReceivedPacket)
	afterOnPulseFromPulsarCounter  uint64
	beforeOnPulseFromPulsarCounter uint64
	OnPulseFromPulsarMock          mGatewayMockOnPulseFromPulsar

	funcRun          func(ctx context.Context, pulse insolar.Pulse)
	inspectFuncRun   func(ctx context.Context, pulse insolar.Pulse)
	afterRunCounter  uint64
	beforeRunCounter uint64
	RunMock          mGatewayMockRun

	funcUpdateState          func(ctx context.Context, pulseNumber insolar.PulseNumber, nodes []insolar.NetworkNode, cloudStateHash []byte)
	inspectFuncUpdateState   func(ctx context.Context, pulseNumber insolar.PulseNumber, nodes []insolar.NetworkNode, cloudStateHash []byte)
	afterUpdateStateCounter  uint64
	beforeUpdateStateCounter uint64
	UpdateStateMock          mGatewayMockUpdateState
}

// NewGatewayMock returns a mock for network.Gateway
func NewGatewayMock(t minimock.Tester) *GatewayMock {
	m := &GatewayMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AutherMock = mGatewayMockAuther{mock: m}

	m.BeforeRunMock = mGatewayMockBeforeRun{mock: m}
	m.BeforeRunMock.callArgs = []*GatewayMockBeforeRunParams{}

	m.BootstrapperMock = mGatewayMockBootstrapper{mock: m}

	m.EphemeralModeMock = mGatewayMockEphemeralMode{mock: m}
	m.EphemeralModeMock.callArgs = []*GatewayMockEphemeralModeParams{}

	m.GetStateMock = mGatewayMockGetState{mock: m}

	m.NewGatewayMock = mGatewayMockNewGateway{mock: m}
	m.NewGatewayMock.callArgs = []*GatewayMockNewGatewayParams{}

	m.OnConsensusFinishedMock = mGatewayMockOnConsensusFinished{mock: m}
	m.OnConsensusFinishedMock.callArgs = []*GatewayMockOnConsensusFinishedParams{}

	m.OnPulseFromConsensusMock = mGatewayMockOnPulseFromConsensus{mock: m}
	m.OnPulseFromConsensusMock.callArgs = []*GatewayMockOnPulseFromConsensusParams{}

	m.OnPulseFromPulsarMock = mGatewayMockOnPulseFromPulsar{mock: m}
	m.OnPulseFromPulsarMock.callArgs = []*GatewayMockOnPulseFromPulsarParams{}

	m.RunMock = mGatewayMockRun{mock: m}
	m.RunMock.callArgs = []*GatewayMockRunParams{}

	m.UpdateStateMock = mGatewayMockUpdateState{mock: m}
	m.UpdateStateMock.callArgs = []*GatewayMockUpdateStateParams{}

	return m
}

type mGatewayMockAuther struct {
	mock               *GatewayMock
	defaultExpectation *GatewayMockAutherExpectation
	expectations       []*GatewayMockAutherExpectation
}

// GatewayMockAutherExpectation specifies expectation struct of the Gateway.Auther
type GatewayMockAutherExpectation struct {
	mock *GatewayMock

	results *GatewayMockAutherResults
	Counter uint64
}

// GatewayMockAutherResults contains results of the Gateway.Auther
type GatewayMockAutherResults struct {
	a1 mm_network.Auther
}

// Expect sets up expected params for Gateway.Auther
func (mmAuther *mGatewayMockAuther) Expect() *mGatewayMockAuther {
	if mmAuther.mock.funcAuther != nil {
		mmAuther.mock.t.Fatalf("GatewayMock.Auther mock is already set by Set")
	}

	if mmAuther.defaultExpectation == nil {
		mmAuther.defaultExpectation = &GatewayMockAutherExpectation{}
	}

	return mmAuther
}

// Inspect accepts an inspector function that has same arguments as the Gateway.Auther
func (mmAuther *mGatewayMockAuther) Inspect(f func()) *mGatewayMockAuther {
	if mmAuther.mock.inspectFuncAuther != nil {
		mmAuther.mock.t.Fatalf("Inspect function is already set for GatewayMock.Auther")
	}

	mmAuther.mock.inspectFuncAuther = f

	return mmAuther
}

// Return sets up results that will be returned by Gateway.Auther
func (mmAuther *mGatewayMockAuther) Return(a1 mm_network.Auther) *GatewayMock {
	if mmAuther.mock.funcAuther != nil {
		mmAuther.mock.t.Fatalf("GatewayMock.Auther mock is already set by Set")
	}

	if mmAuther.defaultExpectation == nil {
		mmAuther.defaultExpectation = &GatewayMockAutherExpectation{mock: mmAuther.mock}
	}
	mmAuther.defaultExpectation.results = &GatewayMockAutherResults{a1}
	return mmAuther.mock
}

//Set uses given function f to mock the Gateway.Auther method
func (mmAuther *mGatewayMockAuther) Set(f func() (a1 mm_network.Auther)) *GatewayMock {
	if mmAuther.defaultExpectation != nil {
		mmAuther.mock.t.Fatalf("Default expectation is already set for the Gateway.Auther method")
	}

	if len(mmAuther.expectations) > 0 {
		mmAuther.mock.t.Fatalf("Some expectations are already set for the Gateway.Auther method")
	}

	mmAuther.mock.funcAuther = f
	return mmAuther.mock
}

// Auther implements network.Gateway
func (mmAuther *GatewayMock) Auther() (a1 mm_network.Auther) {
	mm_atomic.AddUint64(&mmAuther.beforeAutherCounter, 1)
	defer mm_atomic.AddUint64(&mmAuther.afterAutherCounter, 1)

	if mmAuther.inspectFuncAuther != nil {
		mmAuther.inspectFuncAuther()
	}

	if mmAuther.AutherMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAuther.AutherMock.defaultExpectation.Counter, 1)

		results := mmAuther.AutherMock.defaultExpectation.results
		if results == nil {
			mmAuther.t.Fatal("No results are set for the GatewayMock.Auther")
		}
		return (*results).a1
	}
	if mmAuther.funcAuther != nil {
		return mmAuther.funcAuther()
	}
	mmAuther.t.Fatalf("Unexpected call to GatewayMock.Auther.")
	return
}

// AutherAfterCounter returns a count of finished GatewayMock.Auther invocations
func (mmAuther *GatewayMock) AutherAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAuther.afterAutherCounter)
}

// AutherBeforeCounter returns a count of GatewayMock.Auther invocations
func (mmAuther *GatewayMock) AutherBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAuther.beforeAutherCounter)
}

// MinimockAutherDone returns true if the count of the Auther invocations corresponds
// the number of defined expectations
func (m *GatewayMock) MinimockAutherDone() bool {
	for _, e := range m.AutherMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AutherMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAutherCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAuther != nil && mm_atomic.LoadUint64(&m.afterAutherCounter) < 1 {
		return false
	}
	return true
}

// MinimockAutherInspect logs each unmet expectation
func (m *GatewayMock) MinimockAutherInspect() {
	for _, e := range m.AutherMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to GatewayMock.Auther")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AutherMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAutherCounter) < 1 {
		m.t.Error("Expected call to GatewayMock.Auther")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAuther != nil && mm_atomic.LoadUint64(&m.afterAutherCounter) < 1 {
		m.t.Error("Expected call to GatewayMock.Auther")
	}
}

type mGatewayMockBeforeRun struct {
	mock               *GatewayMock
	defaultExpectation *GatewayMockBeforeRunExpectation
	expectations       []*GatewayMockBeforeRunExpectation

	callArgs []*GatewayMockBeforeRunParams
	mutex    sync.RWMutex
}

// GatewayMockBeforeRunExpectation specifies expectation struct of the Gateway.BeforeRun
type GatewayMockBeforeRunExpectation struct {
	mock   *GatewayMock
	params *GatewayMockBeforeRunParams

	Counter uint64
}

// GatewayMockBeforeRunParams contains parameters of the Gateway.BeforeRun
type GatewayMockBeforeRunParams struct {
	ctx   context.Context
	pulse insolar.Pulse
}

// Expect sets up expected params for Gateway.BeforeRun
func (mmBeforeRun *mGatewayMockBeforeRun) Expect(ctx context.Context, pulse insolar.Pulse) *mGatewayMockBeforeRun {
	if mmBeforeRun.mock.funcBeforeRun != nil {
		mmBeforeRun.mock.t.Fatalf("GatewayMock.BeforeRun mock is already set by Set")
	}

	if mmBeforeRun.defaultExpectation == nil {
		mmBeforeRun.defaultExpectation = &GatewayMockBeforeRunExpectation{}
	}

	mmBeforeRun.defaultExpectation.params = &GatewayMockBeforeRunParams{ctx, pulse}
	for _, e := range mmBeforeRun.expectations {
		if minimock.Equal(e.params, mmBeforeRun.defaultExpectation.params) {
			mmBeforeRun.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBeforeRun.defaultExpectation.params)
		}
	}

	return mmBeforeRun
}

// Inspect accepts an inspector function that has same arguments as the Gateway.BeforeRun
func (mmBeforeRun *mGatewayMockBeforeRun) Inspect(f func(ctx context.Context, pulse insolar.Pulse)) *mGatewayMockBeforeRun {
	if mmBeforeRun.mock.inspectFuncBeforeRun != nil {
		mmBeforeRun.mock.t.Fatalf("Inspect function is already set for GatewayMock.BeforeRun")
	}

	mmBeforeRun.mock.inspectFuncBeforeRun = f

	return mmBeforeRun
}

// Return sets up results that will be returned by Gateway.BeforeRun
func (mmBeforeRun *mGatewayMockBeforeRun) Return() *GatewayMock {
	if mmBeforeRun.mock.funcBeforeRun != nil {
		mmBeforeRun.mock.t.Fatalf("GatewayMock.BeforeRun mock is already set by Set")
	}

	if mmBeforeRun.defaultExpectation == nil {
		mmBeforeRun.defaultExpectation = &GatewayMockBeforeRunExpectation{mock: mmBeforeRun.mock}
	}

	return mmBeforeRun.mock
}

//Set uses given function f to mock the Gateway.BeforeRun method
func (mmBeforeRun *mGatewayMockBeforeRun) Set(f func(ctx context.Context, pulse insolar.Pulse)) *GatewayMock {
	if mmBeforeRun.defaultExpectation != nil {
		mmBeforeRun.mock.t.Fatalf("Default expectation is already set for the Gateway.BeforeRun method")
	}

	if len(mmBeforeRun.expectations) > 0 {
		mmBeforeRun.mock.t.Fatalf("Some expectations are already set for the Gateway.BeforeRun method")
	}

	mmBeforeRun.mock.funcBeforeRun = f
	return mmBeforeRun.mock
}

// BeforeRun implements network.Gateway
func (mmBeforeRun *GatewayMock) BeforeRun(ctx context.Context, pulse insolar.Pulse) {
	mm_atomic.AddUint64(&mmBeforeRun.beforeBeforeRunCounter, 1)
	defer mm_atomic.AddUint64(&mmBeforeRun.afterBeforeRunCounter, 1)

	if mmBeforeRun.inspectFuncBeforeRun != nil {
		mmBeforeRun.inspectFuncBeforeRun(ctx, pulse)
	}

	params := &GatewayMockBeforeRunParams{ctx, pulse}

	// Record call args
	mmBeforeRun.BeforeRunMock.mutex.Lock()
	mmBeforeRun.BeforeRunMock.callArgs = append(mmBeforeRun.BeforeRunMock.callArgs, params)
	mmBeforeRun.BeforeRunMock.mutex.Unlock()

	for _, e := range mmBeforeRun.BeforeRunMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmBeforeRun.BeforeRunMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBeforeRun.BeforeRunMock.defaultExpectation.Counter, 1)
		want := mmBeforeRun.BeforeRunMock.defaultExpectation.params
		got := GatewayMockBeforeRunParams{ctx, pulse}
		if want != nil && !minimock.Equal(*want, got) {
			mmBeforeRun.t.Errorf("GatewayMock.BeforeRun got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmBeforeRun.funcBeforeRun != nil {
		mmBeforeRun.funcBeforeRun(ctx, pulse)
		return
	}
	mmBeforeRun.t.Fatalf("Unexpected call to GatewayMock.BeforeRun. %v %v", ctx, pulse)

}

// BeforeRunAfterCounter returns a count of finished GatewayMock.BeforeRun invocations
func (mmBeforeRun *GatewayMock) BeforeRunAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBeforeRun.afterBeforeRunCounter)
}

// BeforeRunBeforeCounter returns a count of GatewayMock.BeforeRun invocations
func (mmBeforeRun *GatewayMock) BeforeRunBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBeforeRun.beforeBeforeRunCounter)
}

// Calls returns a list of arguments used in each call to GatewayMock.BeforeRun.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBeforeRun *mGatewayMockBeforeRun) Calls() []*GatewayMockBeforeRunParams {
	mmBeforeRun.mutex.RLock()

	argCopy := make([]*GatewayMockBeforeRunParams, len(mmBeforeRun.callArgs))
	copy(argCopy, mmBeforeRun.callArgs)

	mmBeforeRun.mutex.RUnlock()

	return argCopy
}

// MinimockBeforeRunDone returns true if the count of the BeforeRun invocations corresponds
// the number of defined expectations
func (m *GatewayMock) MinimockBeforeRunDone() bool {
	for _, e := range m.BeforeRunMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BeforeRunMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBeforeRunCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBeforeRun != nil && mm_atomic.LoadUint64(&m.afterBeforeRunCounter) < 1 {
		return false
	}
	return true
}

// MinimockBeforeRunInspect logs each unmet expectation
func (m *GatewayMock) MinimockBeforeRunInspect() {
	for _, e := range m.BeforeRunMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GatewayMock.BeforeRun with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BeforeRunMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBeforeRunCounter) < 1 {
		if m.BeforeRunMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GatewayMock.BeforeRun")
		} else {
			m.t.Errorf("Expected call to GatewayMock.BeforeRun with params: %#v", *m.BeforeRunMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBeforeRun != nil && mm_atomic.LoadUint64(&m.afterBeforeRunCounter) < 1 {
		m.t.Error("Expected call to GatewayMock.BeforeRun")
	}
}

type mGatewayMockBootstrapper struct {
	mock               *GatewayMock
	defaultExpectation *GatewayMockBootstrapperExpectation
	expectations       []*GatewayMockBootstrapperExpectation
}

// GatewayMockBootstrapperExpectation specifies expectation struct of the Gateway.Bootstrapper
type GatewayMockBootstrapperExpectation struct {
	mock *GatewayMock

	results *GatewayMockBootstrapperResults
	Counter uint64
}

// GatewayMockBootstrapperResults contains results of the Gateway.Bootstrapper
type GatewayMockBootstrapperResults struct {
	b1 mm_network.Bootstrapper
}

// Expect sets up expected params for Gateway.Bootstrapper
func (mmBootstrapper *mGatewayMockBootstrapper) Expect() *mGatewayMockBootstrapper {
	if mmBootstrapper.mock.funcBootstrapper != nil {
		mmBootstrapper.mock.t.Fatalf("GatewayMock.Bootstrapper mock is already set by Set")
	}

	if mmBootstrapper.defaultExpectation == nil {
		mmBootstrapper.defaultExpectation = &GatewayMockBootstrapperExpectation{}
	}

	return mmBootstrapper
}

// Inspect accepts an inspector function that has same arguments as the Gateway.Bootstrapper
func (mmBootstrapper *mGatewayMockBootstrapper) Inspect(f func()) *mGatewayMockBootstrapper {
	if mmBootstrapper.mock.inspectFuncBootstrapper != nil {
		mmBootstrapper.mock.t.Fatalf("Inspect function is already set for GatewayMock.Bootstrapper")
	}

	mmBootstrapper.mock.inspectFuncBootstrapper = f

	return mmBootstrapper
}

// Return sets up results that will be returned by Gateway.Bootstrapper
func (mmBootstrapper *mGatewayMockBootstrapper) Return(b1 mm_network.Bootstrapper) *GatewayMock {
	if mmBootstrapper.mock.funcBootstrapper != nil {
		mmBootstrapper.mock.t.Fatalf("GatewayMock.Bootstrapper mock is already set by Set")
	}

	if mmBootstrapper.defaultExpectation == nil {
		mmBootstrapper.defaultExpectation = &GatewayMockBootstrapperExpectation{mock: mmBootstrapper.mock}
	}
	mmBootstrapper.defaultExpectation.results = &GatewayMockBootstrapperResults{b1}
	return mmBootstrapper.mock
}

//Set uses given function f to mock the Gateway.Bootstrapper method
func (mmBootstrapper *mGatewayMockBootstrapper) Set(f func() (b1 mm_network.Bootstrapper)) *GatewayMock {
	if mmBootstrapper.defaultExpectation != nil {
		mmBootstrapper.mock.t.Fatalf("Default expectation is already set for the Gateway.Bootstrapper method")
	}

	if len(mmBootstrapper.expectations) > 0 {
		mmBootstrapper.mock.t.Fatalf("Some expectations are already set for the Gateway.Bootstrapper method")
	}

	mmBootstrapper.mock.funcBootstrapper = f
	return mmBootstrapper.mock
}

// Bootstrapper implements network.Gateway
func (mmBootstrapper *GatewayMock) Bootstrapper() (b1 mm_network.Bootstrapper) {
	mm_atomic.AddUint64(&mmBootstrapper.beforeBootstrapperCounter, 1)
	defer mm_atomic.AddUint64(&mmBootstrapper.afterBootstrapperCounter, 1)

	if mmBootstrapper.inspectFuncBootstrapper != nil {
		mmBootstrapper.inspectFuncBootstrapper()
	}

	if mmBootstrapper.BootstrapperMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBootstrapper.BootstrapperMock.defaultExpectation.Counter, 1)

		results := mmBootstrapper.BootstrapperMock.defaultExpectation.results
		if results == nil {
			mmBootstrapper.t.Fatal("No results are set for the GatewayMock.Bootstrapper")
		}
		return (*results).b1
	}
	if mmBootstrapper.funcBootstrapper != nil {
		return mmBootstrapper.funcBootstrapper()
	}
	mmBootstrapper.t.Fatalf("Unexpected call to GatewayMock.Bootstrapper.")
	return
}

// BootstrapperAfterCounter returns a count of finished GatewayMock.Bootstrapper invocations
func (mmBootstrapper *GatewayMock) BootstrapperAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBootstrapper.afterBootstrapperCounter)
}

// BootstrapperBeforeCounter returns a count of GatewayMock.Bootstrapper invocations
func (mmBootstrapper *GatewayMock) BootstrapperBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBootstrapper.beforeBootstrapperCounter)
}

// MinimockBootstrapperDone returns true if the count of the Bootstrapper invocations corresponds
// the number of defined expectations
func (m *GatewayMock) MinimockBootstrapperDone() bool {
	for _, e := range m.BootstrapperMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BootstrapperMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBootstrapperCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBootstrapper != nil && mm_atomic.LoadUint64(&m.afterBootstrapperCounter) < 1 {
		return false
	}
	return true
}

// MinimockBootstrapperInspect logs each unmet expectation
func (m *GatewayMock) MinimockBootstrapperInspect() {
	for _, e := range m.BootstrapperMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to GatewayMock.Bootstrapper")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BootstrapperMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBootstrapperCounter) < 1 {
		m.t.Error("Expected call to GatewayMock.Bootstrapper")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBootstrapper != nil && mm_atomic.LoadUint64(&m.afterBootstrapperCounter) < 1 {
		m.t.Error("Expected call to GatewayMock.Bootstrapper")
	}
}

type mGatewayMockEphemeralMode struct {
	mock               *GatewayMock
	defaultExpectation *GatewayMockEphemeralModeExpectation
	expectations       []*GatewayMockEphemeralModeExpectation

	callArgs []*GatewayMockEphemeralModeParams
	mutex    sync.RWMutex
}

// GatewayMockEphemeralModeExpectation specifies expectation struct of the Gateway.EphemeralMode
type GatewayMockEphemeralModeExpectation struct {
	mock    *GatewayMock
	params  *GatewayMockEphemeralModeParams
	results *GatewayMockEphemeralModeResults
	Counter uint64
}

// GatewayMockEphemeralModeParams contains parameters of the Gateway.EphemeralMode
type GatewayMockEphemeralModeParams struct {
	nodes []insolar.NetworkNode
}

// GatewayMockEphemeralModeResults contains results of the Gateway.EphemeralMode
type GatewayMockEphemeralModeResults struct {
	b1 bool
}

// Expect sets up expected params for Gateway.EphemeralMode
func (mmEphemeralMode *mGatewayMockEphemeralMode) Expect(nodes []insolar.NetworkNode) *mGatewayMockEphemeralMode {
	if mmEphemeralMode.mock.funcEphemeralMode != nil {
		mmEphemeralMode.mock.t.Fatalf("GatewayMock.EphemeralMode mock is already set by Set")
	}

	if mmEphemeralMode.defaultExpectation == nil {
		mmEphemeralMode.defaultExpectation = &GatewayMockEphemeralModeExpectation{}
	}

	mmEphemeralMode.defaultExpectation.params = &GatewayMockEphemeralModeParams{nodes}
	for _, e := range mmEphemeralMode.expectations {
		if minimock.Equal(e.params, mmEphemeralMode.defaultExpectation.params) {
			mmEphemeralMode.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEphemeralMode.defaultExpectation.params)
		}
	}

	return mmEphemeralMode
}

// Inspect accepts an inspector function that has same arguments as the Gateway.EphemeralMode
func (mmEphemeralMode *mGatewayMockEphemeralMode) Inspect(f func(nodes []insolar.NetworkNode)) *mGatewayMockEphemeralMode {
	if mmEphemeralMode.mock.inspectFuncEphemeralMode != nil {
		mmEphemeralMode.mock.t.Fatalf("Inspect function is already set for GatewayMock.EphemeralMode")
	}

	mmEphemeralMode.mock.inspectFuncEphemeralMode = f

	return mmEphemeralMode
}

// Return sets up results that will be returned by Gateway.EphemeralMode
func (mmEphemeralMode *mGatewayMockEphemeralMode) Return(b1 bool) *GatewayMock {
	if mmEphemeralMode.mock.funcEphemeralMode != nil {
		mmEphemeralMode.mock.t.Fatalf("GatewayMock.EphemeralMode mock is already set by Set")
	}

	if mmEphemeralMode.defaultExpectation == nil {
		mmEphemeralMode.defaultExpectation = &GatewayMockEphemeralModeExpectation{mock: mmEphemeralMode.mock}
	}
	mmEphemeralMode.defaultExpectation.results = &GatewayMockEphemeralModeResults{b1}
	return mmEphemeralMode.mock
}

//Set uses given function f to mock the Gateway.EphemeralMode method
func (mmEphemeralMode *mGatewayMockEphemeralMode) Set(f func(nodes []insolar.NetworkNode) (b1 bool)) *GatewayMock {
	if mmEphemeralMode.defaultExpectation != nil {
		mmEphemeralMode.mock.t.Fatalf("Default expectation is already set for the Gateway.EphemeralMode method")
	}

	if len(mmEphemeralMode.expectations) > 0 {
		mmEphemeralMode.mock.t.Fatalf("Some expectations are already set for the Gateway.EphemeralMode method")
	}

	mmEphemeralMode.mock.funcEphemeralMode = f
	return mmEphemeralMode.mock
}

// When sets expectation for the Gateway.EphemeralMode which will trigger the result defined by the following
// Then helper
func (mmEphemeralMode *mGatewayMockEphemeralMode) When(nodes []insolar.NetworkNode) *GatewayMockEphemeralModeExpectation {
	if mmEphemeralMode.mock.funcEphemeralMode != nil {
		mmEphemeralMode.mock.t.Fatalf("GatewayMock.EphemeralMode mock is already set by Set")
	}

	expectation := &GatewayMockEphemeralModeExpectation{
		mock:   mmEphemeralMode.mock,
		params: &GatewayMockEphemeralModeParams{nodes},
	}
	mmEphemeralMode.expectations = append(mmEphemeralMode.expectations, expectation)
	return expectation
}

// Then sets up Gateway.EphemeralMode return parameters for the expectation previously defined by the When method
func (e *GatewayMockEphemeralModeExpectation) Then(b1 bool) *GatewayMock {
	e.results = &GatewayMockEphemeralModeResults{b1}
	return e.mock
}

// EphemeralMode implements network.Gateway
func (mmEphemeralMode *GatewayMock) EphemeralMode(nodes []insolar.NetworkNode) (b1 bool) {
	mm_atomic.AddUint64(&mmEphemeralMode.beforeEphemeralModeCounter, 1)
	defer mm_atomic.AddUint64(&mmEphemeralMode.afterEphemeralModeCounter, 1)

	if mmEphemeralMode.inspectFuncEphemeralMode != nil {
		mmEphemeralMode.inspectFuncEphemeralMode(nodes)
	}

	params := &GatewayMockEphemeralModeParams{nodes}

	// Record call args
	mmEphemeralMode.EphemeralModeMock.mutex.Lock()
	mmEphemeralMode.EphemeralModeMock.callArgs = append(mmEphemeralMode.EphemeralModeMock.callArgs, params)
	mmEphemeralMode.EphemeralModeMock.mutex.Unlock()

	for _, e := range mmEphemeralMode.EphemeralModeMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmEphemeralMode.EphemeralModeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEphemeralMode.EphemeralModeMock.defaultExpectation.Counter, 1)
		want := mmEphemeralMode.EphemeralModeMock.defaultExpectation.params
		got := GatewayMockEphemeralModeParams{nodes}
		if want != nil && !minimock.Equal(*want, got) {
			mmEphemeralMode.t.Errorf("GatewayMock.EphemeralMode got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmEphemeralMode.EphemeralModeMock.defaultExpectation.results
		if results == nil {
			mmEphemeralMode.t.Fatal("No results are set for the GatewayMock.EphemeralMode")
		}
		return (*results).b1
	}
	if mmEphemeralMode.funcEphemeralMode != nil {
		return mmEphemeralMode.funcEphemeralMode(nodes)
	}
	mmEphemeralMode.t.Fatalf("Unexpected call to GatewayMock.EphemeralMode. %v", nodes)
	return
}

// EphemeralModeAfterCounter returns a count of finished GatewayMock.EphemeralMode invocations
func (mmEphemeralMode *GatewayMock) EphemeralModeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEphemeralMode.afterEphemeralModeCounter)
}

// EphemeralModeBeforeCounter returns a count of GatewayMock.EphemeralMode invocations
func (mmEphemeralMode *GatewayMock) EphemeralModeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEphemeralMode.beforeEphemeralModeCounter)
}

// Calls returns a list of arguments used in each call to GatewayMock.EphemeralMode.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEphemeralMode *mGatewayMockEphemeralMode) Calls() []*GatewayMockEphemeralModeParams {
	mmEphemeralMode.mutex.RLock()

	argCopy := make([]*GatewayMockEphemeralModeParams, len(mmEphemeralMode.callArgs))
	copy(argCopy, mmEphemeralMode.callArgs)

	mmEphemeralMode.mutex.RUnlock()

	return argCopy
}

// MinimockEphemeralModeDone returns true if the count of the EphemeralMode invocations corresponds
// the number of defined expectations
func (m *GatewayMock) MinimockEphemeralModeDone() bool {
	for _, e := range m.EphemeralModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EphemeralModeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEphemeralModeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEphemeralMode != nil && mm_atomic.LoadUint64(&m.afterEphemeralModeCounter) < 1 {
		return false
	}
	return true
}

// MinimockEphemeralModeInspect logs each unmet expectation
func (m *GatewayMock) MinimockEphemeralModeInspect() {
	for _, e := range m.EphemeralModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GatewayMock.EphemeralMode with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EphemeralModeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEphemeralModeCounter) < 1 {
		if m.EphemeralModeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GatewayMock.EphemeralMode")
		} else {
			m.t.Errorf("Expected call to GatewayMock.EphemeralMode with params: %#v", *m.EphemeralModeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEphemeralMode != nil && mm_atomic.LoadUint64(&m.afterEphemeralModeCounter) < 1 {
		m.t.Error("Expected call to GatewayMock.EphemeralMode")
	}
}

type mGatewayMockGetState struct {
	mock               *GatewayMock
	defaultExpectation *GatewayMockGetStateExpectation
	expectations       []*GatewayMockGetStateExpectation
}

// GatewayMockGetStateExpectation specifies expectation struct of the Gateway.GetState
type GatewayMockGetStateExpectation struct {
	mock *GatewayMock

	results *GatewayMockGetStateResults
	Counter uint64
}

// GatewayMockGetStateResults contains results of the Gateway.GetState
type GatewayMockGetStateResults struct {
	n1 insolar.NetworkState
}

// Expect sets up expected params for Gateway.GetState
func (mmGetState *mGatewayMockGetState) Expect() *mGatewayMockGetState {
	if mmGetState.mock.funcGetState != nil {
		mmGetState.mock.t.Fatalf("GatewayMock.GetState mock is already set by Set")
	}

	if mmGetState.defaultExpectation == nil {
		mmGetState.defaultExpectation = &GatewayMockGetStateExpectation{}
	}

	return mmGetState
}

// Inspect accepts an inspector function that has same arguments as the Gateway.GetState
func (mmGetState *mGatewayMockGetState) Inspect(f func()) *mGatewayMockGetState {
	if mmGetState.mock.inspectFuncGetState != nil {
		mmGetState.mock.t.Fatalf("Inspect function is already set for GatewayMock.GetState")
	}

	mmGetState.mock.inspectFuncGetState = f

	return mmGetState
}

// Return sets up results that will be returned by Gateway.GetState
func (mmGetState *mGatewayMockGetState) Return(n1 insolar.NetworkState) *GatewayMock {
	if mmGetState.mock.funcGetState != nil {
		mmGetState.mock.t.Fatalf("GatewayMock.GetState mock is already set by Set")
	}

	if mmGetState.defaultExpectation == nil {
		mmGetState.defaultExpectation = &GatewayMockGetStateExpectation{mock: mmGetState.mock}
	}
	mmGetState.defaultExpectation.results = &GatewayMockGetStateResults{n1}
	return mmGetState.mock
}

//Set uses given function f to mock the Gateway.GetState method
func (mmGetState *mGatewayMockGetState) Set(f func() (n1 insolar.NetworkState)) *GatewayMock {
	if mmGetState.defaultExpectation != nil {
		mmGetState.mock.t.Fatalf("Default expectation is already set for the Gateway.GetState method")
	}

	if len(mmGetState.expectations) > 0 {
		mmGetState.mock.t.Fatalf("Some expectations are already set for the Gateway.GetState method")
	}

	mmGetState.mock.funcGetState = f
	return mmGetState.mock
}

// GetState implements network.Gateway
func (mmGetState *GatewayMock) GetState() (n1 insolar.NetworkState) {
	mm_atomic.AddUint64(&mmGetState.beforeGetStateCounter, 1)
	defer mm_atomic.AddUint64(&mmGetState.afterGetStateCounter, 1)

	if mmGetState.inspectFuncGetState != nil {
		mmGetState.inspectFuncGetState()
	}

	if mmGetState.GetStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetState.GetStateMock.defaultExpectation.Counter, 1)

		results := mmGetState.GetStateMock.defaultExpectation.results
		if results == nil {
			mmGetState.t.Fatal("No results are set for the GatewayMock.GetState")
		}
		return (*results).n1
	}
	if mmGetState.funcGetState != nil {
		return mmGetState.funcGetState()
	}
	mmGetState.t.Fatalf("Unexpected call to GatewayMock.GetState.")
	return
}

// GetStateAfterCounter returns a count of finished GatewayMock.GetState invocations
func (mmGetState *GatewayMock) GetStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetState.afterGetStateCounter)
}

// GetStateBeforeCounter returns a count of GatewayMock.GetState invocations
func (mmGetState *GatewayMock) GetStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetState.beforeGetStateCounter)
}

// MinimockGetStateDone returns true if the count of the GetState invocations corresponds
// the number of defined expectations
func (m *GatewayMock) MinimockGetStateDone() bool {
	for _, e := range m.GetStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetStateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetState != nil && mm_atomic.LoadUint64(&m.afterGetStateCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetStateInspect logs each unmet expectation
func (m *GatewayMock) MinimockGetStateInspect() {
	for _, e := range m.GetStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to GatewayMock.GetState")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetStateCounter) < 1 {
		m.t.Error("Expected call to GatewayMock.GetState")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetState != nil && mm_atomic.LoadUint64(&m.afterGetStateCounter) < 1 {
		m.t.Error("Expected call to GatewayMock.GetState")
	}
}

type mGatewayMockNewGateway struct {
	mock               *GatewayMock
	defaultExpectation *GatewayMockNewGatewayExpectation
	expectations       []*GatewayMockNewGatewayExpectation

	callArgs []*GatewayMockNewGatewayParams
	mutex    sync.RWMutex
}

// GatewayMockNewGatewayExpectation specifies expectation struct of the Gateway.NewGateway
type GatewayMockNewGatewayExpectation struct {
	mock    *GatewayMock
	params  *GatewayMockNewGatewayParams
	results *GatewayMockNewGatewayResults
	Counter uint64
}

// GatewayMockNewGatewayParams contains parameters of the Gateway.NewGateway
type GatewayMockNewGatewayParams struct {
	ctx context.Context
	n1  insolar.NetworkState
}

// GatewayMockNewGatewayResults contains results of the Gateway.NewGateway
type GatewayMockNewGatewayResults struct {
	g1 mm_network.Gateway
}

// Expect sets up expected params for Gateway.NewGateway
func (mmNewGateway *mGatewayMockNewGateway) Expect(ctx context.Context, n1 insolar.NetworkState) *mGatewayMockNewGateway {
	if mmNewGateway.mock.funcNewGateway != nil {
		mmNewGateway.mock.t.Fatalf("GatewayMock.NewGateway mock is already set by Set")
	}

	if mmNewGateway.defaultExpectation == nil {
		mmNewGateway.defaultExpectation = &GatewayMockNewGatewayExpectation{}
	}

	mmNewGateway.defaultExpectation.params = &GatewayMockNewGatewayParams{ctx, n1}
	for _, e := range mmNewGateway.expectations {
		if minimock.Equal(e.params, mmNewGateway.defaultExpectation.params) {
			mmNewGateway.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmNewGateway.defaultExpectation.params)
		}
	}

	return mmNewGateway
}

// Inspect accepts an inspector function that has same arguments as the Gateway.NewGateway
func (mmNewGateway *mGatewayMockNewGateway) Inspect(f func(ctx context.Context, n1 insolar.NetworkState)) *mGatewayMockNewGateway {
	if mmNewGateway.mock.inspectFuncNewGateway != nil {
		mmNewGateway.mock.t.Fatalf("Inspect function is already set for GatewayMock.NewGateway")
	}

	mmNewGateway.mock.inspectFuncNewGateway = f

	return mmNewGateway
}

// Return sets up results that will be returned by Gateway.NewGateway
func (mmNewGateway *mGatewayMockNewGateway) Return(g1 mm_network.Gateway) *GatewayMock {
	if mmNewGateway.mock.funcNewGateway != nil {
		mmNewGateway.mock.t.Fatalf("GatewayMock.NewGateway mock is already set by Set")
	}

	if mmNewGateway.defaultExpectation == nil {
		mmNewGateway.defaultExpectation = &GatewayMockNewGatewayExpectation{mock: mmNewGateway.mock}
	}
	mmNewGateway.defaultExpectation.results = &GatewayMockNewGatewayResults{g1}
	return mmNewGateway.mock
}

//Set uses given function f to mock the Gateway.NewGateway method
func (mmNewGateway *mGatewayMockNewGateway) Set(f func(ctx context.Context, n1 insolar.NetworkState) (g1 mm_network.Gateway)) *GatewayMock {
	if mmNewGateway.defaultExpectation != nil {
		mmNewGateway.mock.t.Fatalf("Default expectation is already set for the Gateway.NewGateway method")
	}

	if len(mmNewGateway.expectations) > 0 {
		mmNewGateway.mock.t.Fatalf("Some expectations are already set for the Gateway.NewGateway method")
	}

	mmNewGateway.mock.funcNewGateway = f
	return mmNewGateway.mock
}

// When sets expectation for the Gateway.NewGateway which will trigger the result defined by the following
// Then helper
func (mmNewGateway *mGatewayMockNewGateway) When(ctx context.Context, n1 insolar.NetworkState) *GatewayMockNewGatewayExpectation {
	if mmNewGateway.mock.funcNewGateway != nil {
		mmNewGateway.mock.t.Fatalf("GatewayMock.NewGateway mock is already set by Set")
	}

	expectation := &GatewayMockNewGatewayExpectation{
		mock:   mmNewGateway.mock,
		params: &GatewayMockNewGatewayParams{ctx, n1},
	}
	mmNewGateway.expectations = append(mmNewGateway.expectations, expectation)
	return expectation
}

// Then sets up Gateway.NewGateway return parameters for the expectation previously defined by the When method
func (e *GatewayMockNewGatewayExpectation) Then(g1 mm_network.Gateway) *GatewayMock {
	e.results = &GatewayMockNewGatewayResults{g1}
	return e.mock
}

// NewGateway implements network.Gateway
func (mmNewGateway *GatewayMock) NewGateway(ctx context.Context, n1 insolar.NetworkState) (g1 mm_network.Gateway) {
	mm_atomic.AddUint64(&mmNewGateway.beforeNewGatewayCounter, 1)
	defer mm_atomic.AddUint64(&mmNewGateway.afterNewGatewayCounter, 1)

	if mmNewGateway.inspectFuncNewGateway != nil {
		mmNewGateway.inspectFuncNewGateway(ctx, n1)
	}

	params := &GatewayMockNewGatewayParams{ctx, n1}

	// Record call args
	mmNewGateway.NewGatewayMock.mutex.Lock()
	mmNewGateway.NewGatewayMock.callArgs = append(mmNewGateway.NewGatewayMock.callArgs, params)
	mmNewGateway.NewGatewayMock.mutex.Unlock()

	for _, e := range mmNewGateway.NewGatewayMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.g1
		}
	}

	if mmNewGateway.NewGatewayMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNewGateway.NewGatewayMock.defaultExpectation.Counter, 1)
		want := mmNewGateway.NewGatewayMock.defaultExpectation.params
		got := GatewayMockNewGatewayParams{ctx, n1}
		if want != nil && !minimock.Equal(*want, got) {
			mmNewGateway.t.Errorf("GatewayMock.NewGateway got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmNewGateway.NewGatewayMock.defaultExpectation.results
		if results == nil {
			mmNewGateway.t.Fatal("No results are set for the GatewayMock.NewGateway")
		}
		return (*results).g1
	}
	if mmNewGateway.funcNewGateway != nil {
		return mmNewGateway.funcNewGateway(ctx, n1)
	}
	mmNewGateway.t.Fatalf("Unexpected call to GatewayMock.NewGateway. %v %v", ctx, n1)
	return
}

// NewGatewayAfterCounter returns a count of finished GatewayMock.NewGateway invocations
func (mmNewGateway *GatewayMock) NewGatewayAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewGateway.afterNewGatewayCounter)
}

// NewGatewayBeforeCounter returns a count of GatewayMock.NewGateway invocations
func (mmNewGateway *GatewayMock) NewGatewayBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewGateway.beforeNewGatewayCounter)
}

// Calls returns a list of arguments used in each call to GatewayMock.NewGateway.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmNewGateway *mGatewayMockNewGateway) Calls() []*GatewayMockNewGatewayParams {
	mmNewGateway.mutex.RLock()

	argCopy := make([]*GatewayMockNewGatewayParams, len(mmNewGateway.callArgs))
	copy(argCopy, mmNewGateway.callArgs)

	mmNewGateway.mutex.RUnlock()

	return argCopy
}

// MinimockNewGatewayDone returns true if the count of the NewGateway invocations corresponds
// the number of defined expectations
func (m *GatewayMock) MinimockNewGatewayDone() bool {
	for _, e := range m.NewGatewayMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NewGatewayMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNewGatewayCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewGateway != nil && mm_atomic.LoadUint64(&m.afterNewGatewayCounter) < 1 {
		return false
	}
	return true
}

// MinimockNewGatewayInspect logs each unmet expectation
func (m *GatewayMock) MinimockNewGatewayInspect() {
	for _, e := range m.NewGatewayMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GatewayMock.NewGateway with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NewGatewayMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNewGatewayCounter) < 1 {
		if m.NewGatewayMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GatewayMock.NewGateway")
		} else {
			m.t.Errorf("Expected call to GatewayMock.NewGateway with params: %#v", *m.NewGatewayMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewGateway != nil && mm_atomic.LoadUint64(&m.afterNewGatewayCounter) < 1 {
		m.t.Error("Expected call to GatewayMock.NewGateway")
	}
}

type mGatewayMockOnConsensusFinished struct {
	mock               *GatewayMock
	defaultExpectation *GatewayMockOnConsensusFinishedExpectation
	expectations       []*GatewayMockOnConsensusFinishedExpectation

	callArgs []*GatewayMockOnConsensusFinishedParams
	mutex    sync.RWMutex
}

// GatewayMockOnConsensusFinishedExpectation specifies expectation struct of the Gateway.OnConsensusFinished
type GatewayMockOnConsensusFinishedExpectation struct {
	mock   *GatewayMock
	params *GatewayMockOnConsensusFinishedParams

	Counter uint64
}

// GatewayMockOnConsensusFinishedParams contains parameters of the Gateway.OnConsensusFinished
type GatewayMockOnConsensusFinishedParams struct {
	ctx    context.Context
	report mm_network.Report
}

// Expect sets up expected params for Gateway.OnConsensusFinished
func (mmOnConsensusFinished *mGatewayMockOnConsensusFinished) Expect(ctx context.Context, report mm_network.Report) *mGatewayMockOnConsensusFinished {
	if mmOnConsensusFinished.mock.funcOnConsensusFinished != nil {
		mmOnConsensusFinished.mock.t.Fatalf("GatewayMock.OnConsensusFinished mock is already set by Set")
	}

	if mmOnConsensusFinished.defaultExpectation == nil {
		mmOnConsensusFinished.defaultExpectation = &GatewayMockOnConsensusFinishedExpectation{}
	}

	mmOnConsensusFinished.defaultExpectation.params = &GatewayMockOnConsensusFinishedParams{ctx, report}
	for _, e := range mmOnConsensusFinished.expectations {
		if minimock.Equal(e.params, mmOnConsensusFinished.defaultExpectation.params) {
			mmOnConsensusFinished.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOnConsensusFinished.defaultExpectation.params)
		}
	}

	return mmOnConsensusFinished
}

// Inspect accepts an inspector function that has same arguments as the Gateway.OnConsensusFinished
func (mmOnConsensusFinished *mGatewayMockOnConsensusFinished) Inspect(f func(ctx context.Context, report mm_network.Report)) *mGatewayMockOnConsensusFinished {
	if mmOnConsensusFinished.mock.inspectFuncOnConsensusFinished != nil {
		mmOnConsensusFinished.mock.t.Fatalf("Inspect function is already set for GatewayMock.OnConsensusFinished")
	}

	mmOnConsensusFinished.mock.inspectFuncOnConsensusFinished = f

	return mmOnConsensusFinished
}

// Return sets up results that will be returned by Gateway.OnConsensusFinished
func (mmOnConsensusFinished *mGatewayMockOnConsensusFinished) Return() *GatewayMock {
	if mmOnConsensusFinished.mock.funcOnConsensusFinished != nil {
		mmOnConsensusFinished.mock.t.Fatalf("GatewayMock.OnConsensusFinished mock is already set by Set")
	}

	if mmOnConsensusFinished.defaultExpectation == nil {
		mmOnConsensusFinished.defaultExpectation = &GatewayMockOnConsensusFinishedExpectation{mock: mmOnConsensusFinished.mock}
	}

	return mmOnConsensusFinished.mock
}

//Set uses given function f to mock the Gateway.OnConsensusFinished method
func (mmOnConsensusFinished *mGatewayMockOnConsensusFinished) Set(f func(ctx context.Context, report mm_network.Report)) *GatewayMock {
	if mmOnConsensusFinished.defaultExpectation != nil {
		mmOnConsensusFinished.mock.t.Fatalf("Default expectation is already set for the Gateway.OnConsensusFinished method")
	}

	if len(mmOnConsensusFinished.expectations) > 0 {
		mmOnConsensusFinished.mock.t.Fatalf("Some expectations are already set for the Gateway.OnConsensusFinished method")
	}

	mmOnConsensusFinished.mock.funcOnConsensusFinished = f
	return mmOnConsensusFinished.mock
}

// OnConsensusFinished implements network.Gateway
func (mmOnConsensusFinished *GatewayMock) OnConsensusFinished(ctx context.Context, report mm_network.Report) {
	mm_atomic.AddUint64(&mmOnConsensusFinished.beforeOnConsensusFinishedCounter, 1)
	defer mm_atomic.AddUint64(&mmOnConsensusFinished.afterOnConsensusFinishedCounter, 1)

	if mmOnConsensusFinished.inspectFuncOnConsensusFinished != nil {
		mmOnConsensusFinished.inspectFuncOnConsensusFinished(ctx, report)
	}

	params := &GatewayMockOnConsensusFinishedParams{ctx, report}

	// Record call args
	mmOnConsensusFinished.OnConsensusFinishedMock.mutex.Lock()
	mmOnConsensusFinished.OnConsensusFinishedMock.callArgs = append(mmOnConsensusFinished.OnConsensusFinishedMock.callArgs, params)
	mmOnConsensusFinished.OnConsensusFinishedMock.mutex.Unlock()

	for _, e := range mmOnConsensusFinished.OnConsensusFinishedMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmOnConsensusFinished.OnConsensusFinishedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOnConsensusFinished.OnConsensusFinishedMock.defaultExpectation.Counter, 1)
		want := mmOnConsensusFinished.OnConsensusFinishedMock.defaultExpectation.params
		got := GatewayMockOnConsensusFinishedParams{ctx, report}
		if want != nil && !minimock.Equal(*want, got) {
			mmOnConsensusFinished.t.Errorf("GatewayMock.OnConsensusFinished got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmOnConsensusFinished.funcOnConsensusFinished != nil {
		mmOnConsensusFinished.funcOnConsensusFinished(ctx, report)
		return
	}
	mmOnConsensusFinished.t.Fatalf("Unexpected call to GatewayMock.OnConsensusFinished. %v %v", ctx, report)

}

// OnConsensusFinishedAfterCounter returns a count of finished GatewayMock.OnConsensusFinished invocations
func (mmOnConsensusFinished *GatewayMock) OnConsensusFinishedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOnConsensusFinished.afterOnConsensusFinishedCounter)
}

// OnConsensusFinishedBeforeCounter returns a count of GatewayMock.OnConsensusFinished invocations
func (mmOnConsensusFinished *GatewayMock) OnConsensusFinishedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOnConsensusFinished.beforeOnConsensusFinishedCounter)
}

// Calls returns a list of arguments used in each call to GatewayMock.OnConsensusFinished.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOnConsensusFinished *mGatewayMockOnConsensusFinished) Calls() []*GatewayMockOnConsensusFinishedParams {
	mmOnConsensusFinished.mutex.RLock()

	argCopy := make([]*GatewayMockOnConsensusFinishedParams, len(mmOnConsensusFinished.callArgs))
	copy(argCopy, mmOnConsensusFinished.callArgs)

	mmOnConsensusFinished.mutex.RUnlock()

	return argCopy
}

// MinimockOnConsensusFinishedDone returns true if the count of the OnConsensusFinished invocations corresponds
// the number of defined expectations
func (m *GatewayMock) MinimockOnConsensusFinishedDone() bool {
	for _, e := range m.OnConsensusFinishedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OnConsensusFinishedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOnConsensusFinishedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOnConsensusFinished != nil && mm_atomic.LoadUint64(&m.afterOnConsensusFinishedCounter) < 1 {
		return false
	}
	return true
}

// MinimockOnConsensusFinishedInspect logs each unmet expectation
func (m *GatewayMock) MinimockOnConsensusFinishedInspect() {
	for _, e := range m.OnConsensusFinishedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GatewayMock.OnConsensusFinished with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OnConsensusFinishedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOnConsensusFinishedCounter) < 1 {
		if m.OnConsensusFinishedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GatewayMock.OnConsensusFinished")
		} else {
			m.t.Errorf("Expected call to GatewayMock.OnConsensusFinished with params: %#v", *m.OnConsensusFinishedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOnConsensusFinished != nil && mm_atomic.LoadUint64(&m.afterOnConsensusFinishedCounter) < 1 {
		m.t.Error("Expected call to GatewayMock.OnConsensusFinished")
	}
}

type mGatewayMockOnPulseFromConsensus struct {
	mock               *GatewayMock
	defaultExpectation *GatewayMockOnPulseFromConsensusExpectation
	expectations       []*GatewayMockOnPulseFromConsensusExpectation

	callArgs []*GatewayMockOnPulseFromConsensusParams
	mutex    sync.RWMutex
}

// GatewayMockOnPulseFromConsensusExpectation specifies expectation struct of the Gateway.OnPulseFromConsensus
type GatewayMockOnPulseFromConsensusExpectation struct {
	mock   *GatewayMock
	params *GatewayMockOnPulseFromConsensusParams

	Counter uint64
}

// GatewayMockOnPulseFromConsensusParams contains parameters of the Gateway.OnPulseFromConsensus
type GatewayMockOnPulseFromConsensusParams struct {
	ctx context.Context
	p1  insolar.Pulse
}

// Expect sets up expected params for Gateway.OnPulseFromConsensus
func (mmOnPulseFromConsensus *mGatewayMockOnPulseFromConsensus) Expect(ctx context.Context, p1 insolar.Pulse) *mGatewayMockOnPulseFromConsensus {
	if mmOnPulseFromConsensus.mock.funcOnPulseFromConsensus != nil {
		mmOnPulseFromConsensus.mock.t.Fatalf("GatewayMock.OnPulseFromConsensus mock is already set by Set")
	}

	if mmOnPulseFromConsensus.defaultExpectation == nil {
		mmOnPulseFromConsensus.defaultExpectation = &GatewayMockOnPulseFromConsensusExpectation{}
	}

	mmOnPulseFromConsensus.defaultExpectation.params = &GatewayMockOnPulseFromConsensusParams{ctx, p1}
	for _, e := range mmOnPulseFromConsensus.expectations {
		if minimock.Equal(e.params, mmOnPulseFromConsensus.defaultExpectation.params) {
			mmOnPulseFromConsensus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOnPulseFromConsensus.defaultExpectation.params)
		}
	}

	return mmOnPulseFromConsensus
}

// Inspect accepts an inspector function that has same arguments as the Gateway.OnPulseFromConsensus
func (mmOnPulseFromConsensus *mGatewayMockOnPulseFromConsensus) Inspect(f func(ctx context.Context, p1 insolar.Pulse)) *mGatewayMockOnPulseFromConsensus {
	if mmOnPulseFromConsensus.mock.inspectFuncOnPulseFromConsensus != nil {
		mmOnPulseFromConsensus.mock.t.Fatalf("Inspect function is already set for GatewayMock.OnPulseFromConsensus")
	}

	mmOnPulseFromConsensus.mock.inspectFuncOnPulseFromConsensus = f

	return mmOnPulseFromConsensus
}

// Return sets up results that will be returned by Gateway.OnPulseFromConsensus
func (mmOnPulseFromConsensus *mGatewayMockOnPulseFromConsensus) Return() *GatewayMock {
	if mmOnPulseFromConsensus.mock.funcOnPulseFromConsensus != nil {
		mmOnPulseFromConsensus.mock.t.Fatalf("GatewayMock.OnPulseFromConsensus mock is already set by Set")
	}

	if mmOnPulseFromConsensus.defaultExpectation == nil {
		mmOnPulseFromConsensus.defaultExpectation = &GatewayMockOnPulseFromConsensusExpectation{mock: mmOnPulseFromConsensus.mock}
	}

	return mmOnPulseFromConsensus.mock
}

//Set uses given function f to mock the Gateway.OnPulseFromConsensus method
func (mmOnPulseFromConsensus *mGatewayMockOnPulseFromConsensus) Set(f func(ctx context.Context, p1 insolar.Pulse)) *GatewayMock {
	if mmOnPulseFromConsensus.defaultExpectation != nil {
		mmOnPulseFromConsensus.mock.t.Fatalf("Default expectation is already set for the Gateway.OnPulseFromConsensus method")
	}

	if len(mmOnPulseFromConsensus.expectations) > 0 {
		mmOnPulseFromConsensus.mock.t.Fatalf("Some expectations are already set for the Gateway.OnPulseFromConsensus method")
	}

	mmOnPulseFromConsensus.mock.funcOnPulseFromConsensus = f
	return mmOnPulseFromConsensus.mock
}

// OnPulseFromConsensus implements network.Gateway
func (mmOnPulseFromConsensus *GatewayMock) OnPulseFromConsensus(ctx context.Context, p1 insolar.Pulse) {
	mm_atomic.AddUint64(&mmOnPulseFromConsensus.beforeOnPulseFromConsensusCounter, 1)
	defer mm_atomic.AddUint64(&mmOnPulseFromConsensus.afterOnPulseFromConsensusCounter, 1)

	if mmOnPulseFromConsensus.inspectFuncOnPulseFromConsensus != nil {
		mmOnPulseFromConsensus.inspectFuncOnPulseFromConsensus(ctx, p1)
	}

	params := &GatewayMockOnPulseFromConsensusParams{ctx, p1}

	// Record call args
	mmOnPulseFromConsensus.OnPulseFromConsensusMock.mutex.Lock()
	mmOnPulseFromConsensus.OnPulseFromConsensusMock.callArgs = append(mmOnPulseFromConsensus.OnPulseFromConsensusMock.callArgs, params)
	mmOnPulseFromConsensus.OnPulseFromConsensusMock.mutex.Unlock()

	for _, e := range mmOnPulseFromConsensus.OnPulseFromConsensusMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmOnPulseFromConsensus.OnPulseFromConsensusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOnPulseFromConsensus.OnPulseFromConsensusMock.defaultExpectation.Counter, 1)
		want := mmOnPulseFromConsensus.OnPulseFromConsensusMock.defaultExpectation.params
		got := GatewayMockOnPulseFromConsensusParams{ctx, p1}
		if want != nil && !minimock.Equal(*want, got) {
			mmOnPulseFromConsensus.t.Errorf("GatewayMock.OnPulseFromConsensus got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmOnPulseFromConsensus.funcOnPulseFromConsensus != nil {
		mmOnPulseFromConsensus.funcOnPulseFromConsensus(ctx, p1)
		return
	}
	mmOnPulseFromConsensus.t.Fatalf("Unexpected call to GatewayMock.OnPulseFromConsensus. %v %v", ctx, p1)

}

// OnPulseFromConsensusAfterCounter returns a count of finished GatewayMock.OnPulseFromConsensus invocations
func (mmOnPulseFromConsensus *GatewayMock) OnPulseFromConsensusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOnPulseFromConsensus.afterOnPulseFromConsensusCounter)
}

// OnPulseFromConsensusBeforeCounter returns a count of GatewayMock.OnPulseFromConsensus invocations
func (mmOnPulseFromConsensus *GatewayMock) OnPulseFromConsensusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOnPulseFromConsensus.beforeOnPulseFromConsensusCounter)
}

// Calls returns a list of arguments used in each call to GatewayMock.OnPulseFromConsensus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOnPulseFromConsensus *mGatewayMockOnPulseFromConsensus) Calls() []*GatewayMockOnPulseFromConsensusParams {
	mmOnPulseFromConsensus.mutex.RLock()

	argCopy := make([]*GatewayMockOnPulseFromConsensusParams, len(mmOnPulseFromConsensus.callArgs))
	copy(argCopy, mmOnPulseFromConsensus.callArgs)

	mmOnPulseFromConsensus.mutex.RUnlock()

	return argCopy
}

// MinimockOnPulseFromConsensusDone returns true if the count of the OnPulseFromConsensus invocations corresponds
// the number of defined expectations
func (m *GatewayMock) MinimockOnPulseFromConsensusDone() bool {
	for _, e := range m.OnPulseFromConsensusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OnPulseFromConsensusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOnPulseFromConsensusCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOnPulseFromConsensus != nil && mm_atomic.LoadUint64(&m.afterOnPulseFromConsensusCounter) < 1 {
		return false
	}
	return true
}

// MinimockOnPulseFromConsensusInspect logs each unmet expectation
func (m *GatewayMock) MinimockOnPulseFromConsensusInspect() {
	for _, e := range m.OnPulseFromConsensusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GatewayMock.OnPulseFromConsensus with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OnPulseFromConsensusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOnPulseFromConsensusCounter) < 1 {
		if m.OnPulseFromConsensusMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GatewayMock.OnPulseFromConsensus")
		} else {
			m.t.Errorf("Expected call to GatewayMock.OnPulseFromConsensus with params: %#v", *m.OnPulseFromConsensusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOnPulseFromConsensus != nil && mm_atomic.LoadUint64(&m.afterOnPulseFromConsensusCounter) < 1 {
		m.t.Error("Expected call to GatewayMock.OnPulseFromConsensus")
	}
}

type mGatewayMockOnPulseFromPulsar struct {
	mock               *GatewayMock
	defaultExpectation *GatewayMockOnPulseFromPulsarExpectation
	expectations       []*GatewayMockOnPulseFromPulsarExpectation

	callArgs []*GatewayMockOnPulseFromPulsarParams
	mutex    sync.RWMutex
}

// GatewayMockOnPulseFromPulsarExpectation specifies expectation struct of the Gateway.OnPulseFromPulsar
type GatewayMockOnPulseFromPulsarExpectation struct {
	mock   *GatewayMock
	params *GatewayMockOnPulseFromPulsarParams

	Counter uint64
}

// GatewayMockOnPulseFromPulsarParams contains parameters of the Gateway.OnPulseFromPulsar
type GatewayMockOnPulseFromPulsarParams struct {
	ctx context.Context
	p1  insolar.Pulse
	r1  mm_network.ReceivedPacket
}

// Expect sets up expected params for Gateway.OnPulseFromPulsar
func (mmOnPulseFromPulsar *mGatewayMockOnPulseFromPulsar) Expect(ctx context.Context, p1 insolar.Pulse, r1 mm_network.ReceivedPacket) *mGatewayMockOnPulseFromPulsar {
	if mmOnPulseFromPulsar.mock.funcOnPulseFromPulsar != nil {
		mmOnPulseFromPulsar.mock.t.Fatalf("GatewayMock.OnPulseFromPulsar mock is already set by Set")
	}

	if mmOnPulseFromPulsar.defaultExpectation == nil {
		mmOnPulseFromPulsar.defaultExpectation = &GatewayMockOnPulseFromPulsarExpectation{}
	}

	mmOnPulseFromPulsar.defaultExpectation.params = &GatewayMockOnPulseFromPulsarParams{ctx, p1, r1}
	for _, e := range mmOnPulseFromPulsar.expectations {
		if minimock.Equal(e.params, mmOnPulseFromPulsar.defaultExpectation.params) {
			mmOnPulseFromPulsar.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOnPulseFromPulsar.defaultExpectation.params)
		}
	}

	return mmOnPulseFromPulsar
}

// Inspect accepts an inspector function that has same arguments as the Gateway.OnPulseFromPulsar
func (mmOnPulseFromPulsar *mGatewayMockOnPulseFromPulsar) Inspect(f func(ctx context.Context, p1 insolar.Pulse, r1 mm_network.ReceivedPacket)) *mGatewayMockOnPulseFromPulsar {
	if mmOnPulseFromPulsar.mock.inspectFuncOnPulseFromPulsar != nil {
		mmOnPulseFromPulsar.mock.t.Fatalf("Inspect function is already set for GatewayMock.OnPulseFromPulsar")
	}

	mmOnPulseFromPulsar.mock.inspectFuncOnPulseFromPulsar = f

	return mmOnPulseFromPulsar
}

// Return sets up results that will be returned by Gateway.OnPulseFromPulsar
func (mmOnPulseFromPulsar *mGatewayMockOnPulseFromPulsar) Return() *GatewayMock {
	if mmOnPulseFromPulsar.mock.funcOnPulseFromPulsar != nil {
		mmOnPulseFromPulsar.mock.t.Fatalf("GatewayMock.OnPulseFromPulsar mock is already set by Set")
	}

	if mmOnPulseFromPulsar.defaultExpectation == nil {
		mmOnPulseFromPulsar.defaultExpectation = &GatewayMockOnPulseFromPulsarExpectation{mock: mmOnPulseFromPulsar.mock}
	}

	return mmOnPulseFromPulsar.mock
}

//Set uses given function f to mock the Gateway.OnPulseFromPulsar method
func (mmOnPulseFromPulsar *mGatewayMockOnPulseFromPulsar) Set(f func(ctx context.Context, p1 insolar.Pulse, r1 mm_network.ReceivedPacket)) *GatewayMock {
	if mmOnPulseFromPulsar.defaultExpectation != nil {
		mmOnPulseFromPulsar.mock.t.Fatalf("Default expectation is already set for the Gateway.OnPulseFromPulsar method")
	}

	if len(mmOnPulseFromPulsar.expectations) > 0 {
		mmOnPulseFromPulsar.mock.t.Fatalf("Some expectations are already set for the Gateway.OnPulseFromPulsar method")
	}

	mmOnPulseFromPulsar.mock.funcOnPulseFromPulsar = f
	return mmOnPulseFromPulsar.mock
}

// OnPulseFromPulsar implements network.Gateway
func (mmOnPulseFromPulsar *GatewayMock) OnPulseFromPulsar(ctx context.Context, p1 insolar.Pulse, r1 mm_network.ReceivedPacket) {
	mm_atomic.AddUint64(&mmOnPulseFromPulsar.beforeOnPulseFromPulsarCounter, 1)
	defer mm_atomic.AddUint64(&mmOnPulseFromPulsar.afterOnPulseFromPulsarCounter, 1)

	if mmOnPulseFromPulsar.inspectFuncOnPulseFromPulsar != nil {
		mmOnPulseFromPulsar.inspectFuncOnPulseFromPulsar(ctx, p1, r1)
	}

	params := &GatewayMockOnPulseFromPulsarParams{ctx, p1, r1}

	// Record call args
	mmOnPulseFromPulsar.OnPulseFromPulsarMock.mutex.Lock()
	mmOnPulseFromPulsar.OnPulseFromPulsarMock.callArgs = append(mmOnPulseFromPulsar.OnPulseFromPulsarMock.callArgs, params)
	mmOnPulseFromPulsar.OnPulseFromPulsarMock.mutex.Unlock()

	for _, e := range mmOnPulseFromPulsar.OnPulseFromPulsarMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmOnPulseFromPulsar.OnPulseFromPulsarMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOnPulseFromPulsar.OnPulseFromPulsarMock.defaultExpectation.Counter, 1)
		want := mmOnPulseFromPulsar.OnPulseFromPulsarMock.defaultExpectation.params
		got := GatewayMockOnPulseFromPulsarParams{ctx, p1, r1}
		if want != nil && !minimock.Equal(*want, got) {
			mmOnPulseFromPulsar.t.Errorf("GatewayMock.OnPulseFromPulsar got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmOnPulseFromPulsar.funcOnPulseFromPulsar != nil {
		mmOnPulseFromPulsar.funcOnPulseFromPulsar(ctx, p1, r1)
		return
	}
	mmOnPulseFromPulsar.t.Fatalf("Unexpected call to GatewayMock.OnPulseFromPulsar. %v %v %v", ctx, p1, r1)

}

// OnPulseFromPulsarAfterCounter returns a count of finished GatewayMock.OnPulseFromPulsar invocations
func (mmOnPulseFromPulsar *GatewayMock) OnPulseFromPulsarAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOnPulseFromPulsar.afterOnPulseFromPulsarCounter)
}

// OnPulseFromPulsarBeforeCounter returns a count of GatewayMock.OnPulseFromPulsar invocations
func (mmOnPulseFromPulsar *GatewayMock) OnPulseFromPulsarBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOnPulseFromPulsar.beforeOnPulseFromPulsarCounter)
}

// Calls returns a list of arguments used in each call to GatewayMock.OnPulseFromPulsar.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOnPulseFromPulsar *mGatewayMockOnPulseFromPulsar) Calls() []*GatewayMockOnPulseFromPulsarParams {
	mmOnPulseFromPulsar.mutex.RLock()

	argCopy := make([]*GatewayMockOnPulseFromPulsarParams, len(mmOnPulseFromPulsar.callArgs))
	copy(argCopy, mmOnPulseFromPulsar.callArgs)

	mmOnPulseFromPulsar.mutex.RUnlock()

	return argCopy
}

// MinimockOnPulseFromPulsarDone returns true if the count of the OnPulseFromPulsar invocations corresponds
// the number of defined expectations
func (m *GatewayMock) MinimockOnPulseFromPulsarDone() bool {
	for _, e := range m.OnPulseFromPulsarMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OnPulseFromPulsarMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOnPulseFromPulsarCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOnPulseFromPulsar != nil && mm_atomic.LoadUint64(&m.afterOnPulseFromPulsarCounter) < 1 {
		return false
	}
	return true
}

// MinimockOnPulseFromPulsarInspect logs each unmet expectation
func (m *GatewayMock) MinimockOnPulseFromPulsarInspect() {
	for _, e := range m.OnPulseFromPulsarMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GatewayMock.OnPulseFromPulsar with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OnPulseFromPulsarMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOnPulseFromPulsarCounter) < 1 {
		if m.OnPulseFromPulsarMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GatewayMock.OnPulseFromPulsar")
		} else {
			m.t.Errorf("Expected call to GatewayMock.OnPulseFromPulsar with params: %#v", *m.OnPulseFromPulsarMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOnPulseFromPulsar != nil && mm_atomic.LoadUint64(&m.afterOnPulseFromPulsarCounter) < 1 {
		m.t.Error("Expected call to GatewayMock.OnPulseFromPulsar")
	}
}

type mGatewayMockRun struct {
	mock               *GatewayMock
	defaultExpectation *GatewayMockRunExpectation
	expectations       []*GatewayMockRunExpectation

	callArgs []*GatewayMockRunParams
	mutex    sync.RWMutex
}

// GatewayMockRunExpectation specifies expectation struct of the Gateway.Run
type GatewayMockRunExpectation struct {
	mock   *GatewayMock
	params *GatewayMockRunParams

	Counter uint64
}

// GatewayMockRunParams contains parameters of the Gateway.Run
type GatewayMockRunParams struct {
	ctx   context.Context
	pulse insolar.Pulse
}

// Expect sets up expected params for Gateway.Run
func (mmRun *mGatewayMockRun) Expect(ctx context.Context, pulse insolar.Pulse) *mGatewayMockRun {
	if mmRun.mock.funcRun != nil {
		mmRun.mock.t.Fatalf("GatewayMock.Run mock is already set by Set")
	}

	if mmRun.defaultExpectation == nil {
		mmRun.defaultExpectation = &GatewayMockRunExpectation{}
	}

	mmRun.defaultExpectation.params = &GatewayMockRunParams{ctx, pulse}
	for _, e := range mmRun.expectations {
		if minimock.Equal(e.params, mmRun.defaultExpectation.params) {
			mmRun.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRun.defaultExpectation.params)
		}
	}

	return mmRun
}

// Inspect accepts an inspector function that has same arguments as the Gateway.Run
func (mmRun *mGatewayMockRun) Inspect(f func(ctx context.Context, pulse insolar.Pulse)) *mGatewayMockRun {
	if mmRun.mock.inspectFuncRun != nil {
		mmRun.mock.t.Fatalf("Inspect function is already set for GatewayMock.Run")
	}

	mmRun.mock.inspectFuncRun = f

	return mmRun
}

// Return sets up results that will be returned by Gateway.Run
func (mmRun *mGatewayMockRun) Return() *GatewayMock {
	if mmRun.mock.funcRun != nil {
		mmRun.mock.t.Fatalf("GatewayMock.Run mock is already set by Set")
	}

	if mmRun.defaultExpectation == nil {
		mmRun.defaultExpectation = &GatewayMockRunExpectation{mock: mmRun.mock}
	}

	return mmRun.mock
}

//Set uses given function f to mock the Gateway.Run method
func (mmRun *mGatewayMockRun) Set(f func(ctx context.Context, pulse insolar.Pulse)) *GatewayMock {
	if mmRun.defaultExpectation != nil {
		mmRun.mock.t.Fatalf("Default expectation is already set for the Gateway.Run method")
	}

	if len(mmRun.expectations) > 0 {
		mmRun.mock.t.Fatalf("Some expectations are already set for the Gateway.Run method")
	}

	mmRun.mock.funcRun = f
	return mmRun.mock
}

// Run implements network.Gateway
func (mmRun *GatewayMock) Run(ctx context.Context, pulse insolar.Pulse) {
	mm_atomic.AddUint64(&mmRun.beforeRunCounter, 1)
	defer mm_atomic.AddUint64(&mmRun.afterRunCounter, 1)

	if mmRun.inspectFuncRun != nil {
		mmRun.inspectFuncRun(ctx, pulse)
	}

	params := &GatewayMockRunParams{ctx, pulse}

	// Record call args
	mmRun.RunMock.mutex.Lock()
	mmRun.RunMock.callArgs = append(mmRun.RunMock.callArgs, params)
	mmRun.RunMock.mutex.Unlock()

	for _, e := range mmRun.RunMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmRun.RunMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRun.RunMock.defaultExpectation.Counter, 1)
		want := mmRun.RunMock.defaultExpectation.params
		got := GatewayMockRunParams{ctx, pulse}
		if want != nil && !minimock.Equal(*want, got) {
			mmRun.t.Errorf("GatewayMock.Run got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmRun.funcRun != nil {
		mmRun.funcRun(ctx, pulse)
		return
	}
	mmRun.t.Fatalf("Unexpected call to GatewayMock.Run. %v %v", ctx, pulse)

}

// RunAfterCounter returns a count of finished GatewayMock.Run invocations
func (mmRun *GatewayMock) RunAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRun.afterRunCounter)
}

// RunBeforeCounter returns a count of GatewayMock.Run invocations
func (mmRun *GatewayMock) RunBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRun.beforeRunCounter)
}

// Calls returns a list of arguments used in each call to GatewayMock.Run.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRun *mGatewayMockRun) Calls() []*GatewayMockRunParams {
	mmRun.mutex.RLock()

	argCopy := make([]*GatewayMockRunParams, len(mmRun.callArgs))
	copy(argCopy, mmRun.callArgs)

	mmRun.mutex.RUnlock()

	return argCopy
}

// MinimockRunDone returns true if the count of the Run invocations corresponds
// the number of defined expectations
func (m *GatewayMock) MinimockRunDone() bool {
	for _, e := range m.RunMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RunMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRunCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRun != nil && mm_atomic.LoadUint64(&m.afterRunCounter) < 1 {
		return false
	}
	return true
}

// MinimockRunInspect logs each unmet expectation
func (m *GatewayMock) MinimockRunInspect() {
	for _, e := range m.RunMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GatewayMock.Run with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RunMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRunCounter) < 1 {
		if m.RunMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GatewayMock.Run")
		} else {
			m.t.Errorf("Expected call to GatewayMock.Run with params: %#v", *m.RunMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRun != nil && mm_atomic.LoadUint64(&m.afterRunCounter) < 1 {
		m.t.Error("Expected call to GatewayMock.Run")
	}
}

type mGatewayMockUpdateState struct {
	mock               *GatewayMock
	defaultExpectation *GatewayMockUpdateStateExpectation
	expectations       []*GatewayMockUpdateStateExpectation

	callArgs []*GatewayMockUpdateStateParams
	mutex    sync.RWMutex
}

// GatewayMockUpdateStateExpectation specifies expectation struct of the Gateway.UpdateState
type GatewayMockUpdateStateExpectation struct {
	mock   *GatewayMock
	params *GatewayMockUpdateStateParams

	Counter uint64
}

// GatewayMockUpdateStateParams contains parameters of the Gateway.UpdateState
type GatewayMockUpdateStateParams struct {
	ctx            context.Context
	pulseNumber    insolar.PulseNumber
	nodes          []insolar.NetworkNode
	cloudStateHash []byte
}

// Expect sets up expected params for Gateway.UpdateState
func (mmUpdateState *mGatewayMockUpdateState) Expect(ctx context.Context, pulseNumber insolar.PulseNumber, nodes []insolar.NetworkNode, cloudStateHash []byte) *mGatewayMockUpdateState {
	if mmUpdateState.mock.funcUpdateState != nil {
		mmUpdateState.mock.t.Fatalf("GatewayMock.UpdateState mock is already set by Set")
	}

	if mmUpdateState.defaultExpectation == nil {
		mmUpdateState.defaultExpectation = &GatewayMockUpdateStateExpectation{}
	}

	mmUpdateState.defaultExpectation.params = &GatewayMockUpdateStateParams{ctx, pulseNumber, nodes, cloudStateHash}
	for _, e := range mmUpdateState.expectations {
		if minimock.Equal(e.params, mmUpdateState.defaultExpectation.params) {
			mmUpdateState.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateState.defaultExpectation.params)
		}
	}

	return mmUpdateState
}

// Inspect accepts an inspector function that has same arguments as the Gateway.UpdateState
func (mmUpdateState *mGatewayMockUpdateState) Inspect(f func(ctx context.Context, pulseNumber insolar.PulseNumber, nodes []insolar.NetworkNode, cloudStateHash []byte)) *mGatewayMockUpdateState {
	if mmUpdateState.mock.inspectFuncUpdateState != nil {
		mmUpdateState.mock.t.Fatalf("Inspect function is already set for GatewayMock.UpdateState")
	}

	mmUpdateState.mock.inspectFuncUpdateState = f

	return mmUpdateState
}

// Return sets up results that will be returned by Gateway.UpdateState
func (mmUpdateState *mGatewayMockUpdateState) Return() *GatewayMock {
	if mmUpdateState.mock.funcUpdateState != nil {
		mmUpdateState.mock.t.Fatalf("GatewayMock.UpdateState mock is already set by Set")
	}

	if mmUpdateState.defaultExpectation == nil {
		mmUpdateState.defaultExpectation = &GatewayMockUpdateStateExpectation{mock: mmUpdateState.mock}
	}

	return mmUpdateState.mock
}

//Set uses given function f to mock the Gateway.UpdateState method
func (mmUpdateState *mGatewayMockUpdateState) Set(f func(ctx context.Context, pulseNumber insolar.PulseNumber, nodes []insolar.NetworkNode, cloudStateHash []byte)) *GatewayMock {
	if mmUpdateState.defaultExpectation != nil {
		mmUpdateState.mock.t.Fatalf("Default expectation is already set for the Gateway.UpdateState method")
	}

	if len(mmUpdateState.expectations) > 0 {
		mmUpdateState.mock.t.Fatalf("Some expectations are already set for the Gateway.UpdateState method")
	}

	mmUpdateState.mock.funcUpdateState = f
	return mmUpdateState.mock
}

// UpdateState implements network.Gateway
func (mmUpdateState *GatewayMock) UpdateState(ctx context.Context, pulseNumber insolar.PulseNumber, nodes []insolar.NetworkNode, cloudStateHash []byte) {
	mm_atomic.AddUint64(&mmUpdateState.beforeUpdateStateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateState.afterUpdateStateCounter, 1)

	if mmUpdateState.inspectFuncUpdateState != nil {
		mmUpdateState.inspectFuncUpdateState(ctx, pulseNumber, nodes, cloudStateHash)
	}

	params := &GatewayMockUpdateStateParams{ctx, pulseNumber, nodes, cloudStateHash}

	// Record call args
	mmUpdateState.UpdateStateMock.mutex.Lock()
	mmUpdateState.UpdateStateMock.callArgs = append(mmUpdateState.UpdateStateMock.callArgs, params)
	mmUpdateState.UpdateStateMock.mutex.Unlock()

	for _, e := range mmUpdateState.UpdateStateMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmUpdateState.UpdateStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateState.UpdateStateMock.defaultExpectation.Counter, 1)
		want := mmUpdateState.UpdateStateMock.defaultExpectation.params
		got := GatewayMockUpdateStateParams{ctx, pulseNumber, nodes, cloudStateHash}
		if want != nil && !minimock.Equal(*want, got) {
			mmUpdateState.t.Errorf("GatewayMock.UpdateState got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmUpdateState.funcUpdateState != nil {
		mmUpdateState.funcUpdateState(ctx, pulseNumber, nodes, cloudStateHash)
		return
	}
	mmUpdateState.t.Fatalf("Unexpected call to GatewayMock.UpdateState. %v %v %v %v", ctx, pulseNumber, nodes, cloudStateHash)

}

// UpdateStateAfterCounter returns a count of finished GatewayMock.UpdateState invocations
func (mmUpdateState *GatewayMock) UpdateStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateState.afterUpdateStateCounter)
}

// UpdateStateBeforeCounter returns a count of GatewayMock.UpdateState invocations
func (mmUpdateState *GatewayMock) UpdateStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateState.beforeUpdateStateCounter)
}

// Calls returns a list of arguments used in each call to GatewayMock.UpdateState.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateState *mGatewayMockUpdateState) Calls() []*GatewayMockUpdateStateParams {
	mmUpdateState.mutex.RLock()

	argCopy := make([]*GatewayMockUpdateStateParams, len(mmUpdateState.callArgs))
	copy(argCopy, mmUpdateState.callArgs)

	mmUpdateState.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateStateDone returns true if the count of the UpdateState invocations corresponds
// the number of defined expectations
func (m *GatewayMock) MinimockUpdateStateDone() bool {
	for _, e := range m.UpdateStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateStateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateState != nil && mm_atomic.LoadUint64(&m.afterUpdateStateCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateStateInspect logs each unmet expectation
func (m *GatewayMock) MinimockUpdateStateInspect() {
	for _, e := range m.UpdateStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GatewayMock.UpdateState with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateStateCounter) < 1 {
		if m.UpdateStateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GatewayMock.UpdateState")
		} else {
			m.t.Errorf("Expected call to GatewayMock.UpdateState with params: %#v", *m.UpdateStateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateState != nil && mm_atomic.LoadUint64(&m.afterUpdateStateCounter) < 1 {
		m.t.Error("Expected call to GatewayMock.UpdateState")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *GatewayMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAutherInspect()

		m.MinimockBeforeRunInspect()

		m.MinimockBootstrapperInspect()

		m.MinimockEphemeralModeInspect()

		m.MinimockGetStateInspect()

		m.MinimockNewGatewayInspect()

		m.MinimockOnConsensusFinishedInspect()

		m.MinimockOnPulseFromConsensusInspect()

		m.MinimockOnPulseFromPulsarInspect()

		m.MinimockRunInspect()

		m.MinimockUpdateStateInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *GatewayMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *GatewayMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAutherDone() &&
		m.MinimockBeforeRunDone() &&
		m.MinimockBootstrapperDone() &&
		m.MinimockEphemeralModeDone() &&
		m.MinimockGetStateDone() &&
		m.MinimockNewGatewayDone() &&
		m.MinimockOnConsensusFinishedDone() &&
		m.MinimockOnPulseFromConsensusDone() &&
		m.MinimockOnPulseFromPulsarDone() &&
		m.MinimockRunDone() &&
		m.MinimockUpdateStateDone()
}
