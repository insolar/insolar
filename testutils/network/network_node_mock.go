package network

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"crypto"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	mm_insolar "github.com/insolar/insolar/insolar"
)

// NetworkNodeMock implements insolar.NetworkNode
type NetworkNodeMock struct {
	t minimock.Tester

	funcAddress          func() (s1 string)
	inspectFuncAddress   func()
	afterAddressCounter  uint64
	beforeAddressCounter uint64
	AddressMock          mNetworkNodeMockAddress

	funcGetGlobuleID          func() (g1 mm_insolar.GlobuleID)
	inspectFuncGetGlobuleID   func()
	afterGetGlobuleIDCounter  uint64
	beforeGetGlobuleIDCounter uint64
	GetGlobuleIDMock          mNetworkNodeMockGetGlobuleID

	funcGetState          func() (n1 mm_insolar.NodeState)
	inspectFuncGetState   func()
	afterGetStateCounter  uint64
	beforeGetStateCounter uint64
	GetStateMock          mNetworkNodeMockGetState

	funcID          func() (r1 mm_insolar.Reference)
	inspectFuncID   func()
	afterIDCounter  uint64
	beforeIDCounter uint64
	IDMock          mNetworkNodeMockID

	funcLeavingETA          func() (p1 mm_insolar.PulseNumber)
	inspectFuncLeavingETA   func()
	afterLeavingETACounter  uint64
	beforeLeavingETACounter uint64
	LeavingETAMock          mNetworkNodeMockLeavingETA

	funcPublicKey          func() (p1 crypto.PublicKey)
	inspectFuncPublicKey   func()
	afterPublicKeyCounter  uint64
	beforePublicKeyCounter uint64
	PublicKeyMock          mNetworkNodeMockPublicKey

	funcRole          func() (s1 mm_insolar.StaticRole)
	inspectFuncRole   func()
	afterRoleCounter  uint64
	beforeRoleCounter uint64
	RoleMock          mNetworkNodeMockRole

	funcShortID          func() (s1 mm_insolar.ShortNodeID)
	inspectFuncShortID   func()
	afterShortIDCounter  uint64
	beforeShortIDCounter uint64
	ShortIDMock          mNetworkNodeMockShortID

	funcVersion          func() (s1 string)
	inspectFuncVersion   func()
	afterVersionCounter  uint64
	beforeVersionCounter uint64
	VersionMock          mNetworkNodeMockVersion
}

// NewNetworkNodeMock returns a mock for insolar.NetworkNode
func NewNetworkNodeMock(t minimock.Tester) *NetworkNodeMock {
	m := &NetworkNodeMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddressMock = mNetworkNodeMockAddress{mock: m}

	m.GetGlobuleIDMock = mNetworkNodeMockGetGlobuleID{mock: m}

	m.GetStateMock = mNetworkNodeMockGetState{mock: m}

	m.IDMock = mNetworkNodeMockID{mock: m}

	m.LeavingETAMock = mNetworkNodeMockLeavingETA{mock: m}

	m.PublicKeyMock = mNetworkNodeMockPublicKey{mock: m}

	m.RoleMock = mNetworkNodeMockRole{mock: m}

	m.ShortIDMock = mNetworkNodeMockShortID{mock: m}

	m.VersionMock = mNetworkNodeMockVersion{mock: m}

	return m
}

type mNetworkNodeMockAddress struct {
	mock               *NetworkNodeMock
	defaultExpectation *NetworkNodeMockAddressExpectation
	expectations       []*NetworkNodeMockAddressExpectation
}

// NetworkNodeMockAddressExpectation specifies expectation struct of the NetworkNode.Address
type NetworkNodeMockAddressExpectation struct {
	mock *NetworkNodeMock

	results *NetworkNodeMockAddressResults
	Counter uint64
}

// NetworkNodeMockAddressResults contains results of the NetworkNode.Address
type NetworkNodeMockAddressResults struct {
	s1 string
}

// Expect sets up expected params for NetworkNode.Address
func (mmAddress *mNetworkNodeMockAddress) Expect() *mNetworkNodeMockAddress {
	if mmAddress.mock.funcAddress != nil {
		mmAddress.mock.t.Fatalf("NetworkNodeMock.Address mock is already set by Set")
	}

	if mmAddress.defaultExpectation == nil {
		mmAddress.defaultExpectation = &NetworkNodeMockAddressExpectation{}
	}

	return mmAddress
}

// Inspect accepts an inspector function that has same arguments as the NetworkNode.Address
func (mmAddress *mNetworkNodeMockAddress) Inspect(f func()) *mNetworkNodeMockAddress {
	if mmAddress.mock.inspectFuncAddress != nil {
		mmAddress.mock.t.Fatalf("Inspect function is already set for NetworkNodeMock.Address")
	}

	mmAddress.mock.inspectFuncAddress = f

	return mmAddress
}

// Return sets up results that will be returned by NetworkNode.Address
func (mmAddress *mNetworkNodeMockAddress) Return(s1 string) *NetworkNodeMock {
	if mmAddress.mock.funcAddress != nil {
		mmAddress.mock.t.Fatalf("NetworkNodeMock.Address mock is already set by Set")
	}

	if mmAddress.defaultExpectation == nil {
		mmAddress.defaultExpectation = &NetworkNodeMockAddressExpectation{mock: mmAddress.mock}
	}
	mmAddress.defaultExpectation.results = &NetworkNodeMockAddressResults{s1}
	return mmAddress.mock
}

//Set uses given function f to mock the NetworkNode.Address method
func (mmAddress *mNetworkNodeMockAddress) Set(f func() (s1 string)) *NetworkNodeMock {
	if mmAddress.defaultExpectation != nil {
		mmAddress.mock.t.Fatalf("Default expectation is already set for the NetworkNode.Address method")
	}

	if len(mmAddress.expectations) > 0 {
		mmAddress.mock.t.Fatalf("Some expectations are already set for the NetworkNode.Address method")
	}

	mmAddress.mock.funcAddress = f
	return mmAddress.mock
}

// Address implements insolar.NetworkNode
func (mmAddress *NetworkNodeMock) Address() (s1 string) {
	mm_atomic.AddUint64(&mmAddress.beforeAddressCounter, 1)
	defer mm_atomic.AddUint64(&mmAddress.afterAddressCounter, 1)

	if mmAddress.inspectFuncAddress != nil {
		mmAddress.inspectFuncAddress()
	}

	if mmAddress.AddressMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddress.AddressMock.defaultExpectation.Counter, 1)

		results := mmAddress.AddressMock.defaultExpectation.results
		if results == nil {
			mmAddress.t.Fatal("No results are set for the NetworkNodeMock.Address")
		}
		return (*results).s1
	}
	if mmAddress.funcAddress != nil {
		return mmAddress.funcAddress()
	}
	mmAddress.t.Fatalf("Unexpected call to NetworkNodeMock.Address.")
	return
}

// AddressAfterCounter returns a count of finished NetworkNodeMock.Address invocations
func (mmAddress *NetworkNodeMock) AddressAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddress.afterAddressCounter)
}

// AddressBeforeCounter returns a count of NetworkNodeMock.Address invocations
func (mmAddress *NetworkNodeMock) AddressBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddress.beforeAddressCounter)
}

// MinimockAddressDone returns true if the count of the Address invocations corresponds
// the number of defined expectations
func (m *NetworkNodeMock) MinimockAddressDone() bool {
	for _, e := range m.AddressMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddressMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddressCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddress != nil && mm_atomic.LoadUint64(&m.afterAddressCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddressInspect logs each unmet expectation
func (m *NetworkNodeMock) MinimockAddressInspect() {
	for _, e := range m.AddressMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NetworkNodeMock.Address")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddressMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddressCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.Address")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddress != nil && mm_atomic.LoadUint64(&m.afterAddressCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.Address")
	}
}

type mNetworkNodeMockGetGlobuleID struct {
	mock               *NetworkNodeMock
	defaultExpectation *NetworkNodeMockGetGlobuleIDExpectation
	expectations       []*NetworkNodeMockGetGlobuleIDExpectation
}

// NetworkNodeMockGetGlobuleIDExpectation specifies expectation struct of the NetworkNode.GetGlobuleID
type NetworkNodeMockGetGlobuleIDExpectation struct {
	mock *NetworkNodeMock

	results *NetworkNodeMockGetGlobuleIDResults
	Counter uint64
}

// NetworkNodeMockGetGlobuleIDResults contains results of the NetworkNode.GetGlobuleID
type NetworkNodeMockGetGlobuleIDResults struct {
	g1 mm_insolar.GlobuleID
}

// Expect sets up expected params for NetworkNode.GetGlobuleID
func (mmGetGlobuleID *mNetworkNodeMockGetGlobuleID) Expect() *mNetworkNodeMockGetGlobuleID {
	if mmGetGlobuleID.mock.funcGetGlobuleID != nil {
		mmGetGlobuleID.mock.t.Fatalf("NetworkNodeMock.GetGlobuleID mock is already set by Set")
	}

	if mmGetGlobuleID.defaultExpectation == nil {
		mmGetGlobuleID.defaultExpectation = &NetworkNodeMockGetGlobuleIDExpectation{}
	}

	return mmGetGlobuleID
}

// Inspect accepts an inspector function that has same arguments as the NetworkNode.GetGlobuleID
func (mmGetGlobuleID *mNetworkNodeMockGetGlobuleID) Inspect(f func()) *mNetworkNodeMockGetGlobuleID {
	if mmGetGlobuleID.mock.inspectFuncGetGlobuleID != nil {
		mmGetGlobuleID.mock.t.Fatalf("Inspect function is already set for NetworkNodeMock.GetGlobuleID")
	}

	mmGetGlobuleID.mock.inspectFuncGetGlobuleID = f

	return mmGetGlobuleID
}

// Return sets up results that will be returned by NetworkNode.GetGlobuleID
func (mmGetGlobuleID *mNetworkNodeMockGetGlobuleID) Return(g1 mm_insolar.GlobuleID) *NetworkNodeMock {
	if mmGetGlobuleID.mock.funcGetGlobuleID != nil {
		mmGetGlobuleID.mock.t.Fatalf("NetworkNodeMock.GetGlobuleID mock is already set by Set")
	}

	if mmGetGlobuleID.defaultExpectation == nil {
		mmGetGlobuleID.defaultExpectation = &NetworkNodeMockGetGlobuleIDExpectation{mock: mmGetGlobuleID.mock}
	}
	mmGetGlobuleID.defaultExpectation.results = &NetworkNodeMockGetGlobuleIDResults{g1}
	return mmGetGlobuleID.mock
}

//Set uses given function f to mock the NetworkNode.GetGlobuleID method
func (mmGetGlobuleID *mNetworkNodeMockGetGlobuleID) Set(f func() (g1 mm_insolar.GlobuleID)) *NetworkNodeMock {
	if mmGetGlobuleID.defaultExpectation != nil {
		mmGetGlobuleID.mock.t.Fatalf("Default expectation is already set for the NetworkNode.GetGlobuleID method")
	}

	if len(mmGetGlobuleID.expectations) > 0 {
		mmGetGlobuleID.mock.t.Fatalf("Some expectations are already set for the NetworkNode.GetGlobuleID method")
	}

	mmGetGlobuleID.mock.funcGetGlobuleID = f
	return mmGetGlobuleID.mock
}

// GetGlobuleID implements insolar.NetworkNode
func (mmGetGlobuleID *NetworkNodeMock) GetGlobuleID() (g1 mm_insolar.GlobuleID) {
	mm_atomic.AddUint64(&mmGetGlobuleID.beforeGetGlobuleIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetGlobuleID.afterGetGlobuleIDCounter, 1)

	if mmGetGlobuleID.inspectFuncGetGlobuleID != nil {
		mmGetGlobuleID.inspectFuncGetGlobuleID()
	}

	if mmGetGlobuleID.GetGlobuleIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetGlobuleID.GetGlobuleIDMock.defaultExpectation.Counter, 1)

		results := mmGetGlobuleID.GetGlobuleIDMock.defaultExpectation.results
		if results == nil {
			mmGetGlobuleID.t.Fatal("No results are set for the NetworkNodeMock.GetGlobuleID")
		}
		return (*results).g1
	}
	if mmGetGlobuleID.funcGetGlobuleID != nil {
		return mmGetGlobuleID.funcGetGlobuleID()
	}
	mmGetGlobuleID.t.Fatalf("Unexpected call to NetworkNodeMock.GetGlobuleID.")
	return
}

// GetGlobuleIDAfterCounter returns a count of finished NetworkNodeMock.GetGlobuleID invocations
func (mmGetGlobuleID *NetworkNodeMock) GetGlobuleIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetGlobuleID.afterGetGlobuleIDCounter)
}

// GetGlobuleIDBeforeCounter returns a count of NetworkNodeMock.GetGlobuleID invocations
func (mmGetGlobuleID *NetworkNodeMock) GetGlobuleIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetGlobuleID.beforeGetGlobuleIDCounter)
}

// MinimockGetGlobuleIDDone returns true if the count of the GetGlobuleID invocations corresponds
// the number of defined expectations
func (m *NetworkNodeMock) MinimockGetGlobuleIDDone() bool {
	for _, e := range m.GetGlobuleIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetGlobuleIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetGlobuleIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetGlobuleID != nil && mm_atomic.LoadUint64(&m.afterGetGlobuleIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetGlobuleIDInspect logs each unmet expectation
func (m *NetworkNodeMock) MinimockGetGlobuleIDInspect() {
	for _, e := range m.GetGlobuleIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NetworkNodeMock.GetGlobuleID")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetGlobuleIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetGlobuleIDCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.GetGlobuleID")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetGlobuleID != nil && mm_atomic.LoadUint64(&m.afterGetGlobuleIDCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.GetGlobuleID")
	}
}

type mNetworkNodeMockGetState struct {
	mock               *NetworkNodeMock
	defaultExpectation *NetworkNodeMockGetStateExpectation
	expectations       []*NetworkNodeMockGetStateExpectation
}

// NetworkNodeMockGetStateExpectation specifies expectation struct of the NetworkNode.GetState
type NetworkNodeMockGetStateExpectation struct {
	mock *NetworkNodeMock

	results *NetworkNodeMockGetStateResults
	Counter uint64
}

// NetworkNodeMockGetStateResults contains results of the NetworkNode.GetState
type NetworkNodeMockGetStateResults struct {
	n1 mm_insolar.NodeState
}

// Expect sets up expected params for NetworkNode.GetState
func (mmGetState *mNetworkNodeMockGetState) Expect() *mNetworkNodeMockGetState {
	if mmGetState.mock.funcGetState != nil {
		mmGetState.mock.t.Fatalf("NetworkNodeMock.GetState mock is already set by Set")
	}

	if mmGetState.defaultExpectation == nil {
		mmGetState.defaultExpectation = &NetworkNodeMockGetStateExpectation{}
	}

	return mmGetState
}

// Inspect accepts an inspector function that has same arguments as the NetworkNode.GetState
func (mmGetState *mNetworkNodeMockGetState) Inspect(f func()) *mNetworkNodeMockGetState {
	if mmGetState.mock.inspectFuncGetState != nil {
		mmGetState.mock.t.Fatalf("Inspect function is already set for NetworkNodeMock.GetState")
	}

	mmGetState.mock.inspectFuncGetState = f

	return mmGetState
}

// Return sets up results that will be returned by NetworkNode.GetState
func (mmGetState *mNetworkNodeMockGetState) Return(n1 mm_insolar.NodeState) *NetworkNodeMock {
	if mmGetState.mock.funcGetState != nil {
		mmGetState.mock.t.Fatalf("NetworkNodeMock.GetState mock is already set by Set")
	}

	if mmGetState.defaultExpectation == nil {
		mmGetState.defaultExpectation = &NetworkNodeMockGetStateExpectation{mock: mmGetState.mock}
	}
	mmGetState.defaultExpectation.results = &NetworkNodeMockGetStateResults{n1}
	return mmGetState.mock
}

//Set uses given function f to mock the NetworkNode.GetState method
func (mmGetState *mNetworkNodeMockGetState) Set(f func() (n1 mm_insolar.NodeState)) *NetworkNodeMock {
	if mmGetState.defaultExpectation != nil {
		mmGetState.mock.t.Fatalf("Default expectation is already set for the NetworkNode.GetState method")
	}

	if len(mmGetState.expectations) > 0 {
		mmGetState.mock.t.Fatalf("Some expectations are already set for the NetworkNode.GetState method")
	}

	mmGetState.mock.funcGetState = f
	return mmGetState.mock
}

// GetState implements insolar.NetworkNode
func (mmGetState *NetworkNodeMock) GetState() (n1 mm_insolar.NodeState) {
	mm_atomic.AddUint64(&mmGetState.beforeGetStateCounter, 1)
	defer mm_atomic.AddUint64(&mmGetState.afterGetStateCounter, 1)

	if mmGetState.inspectFuncGetState != nil {
		mmGetState.inspectFuncGetState()
	}

	if mmGetState.GetStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetState.GetStateMock.defaultExpectation.Counter, 1)

		results := mmGetState.GetStateMock.defaultExpectation.results
		if results == nil {
			mmGetState.t.Fatal("No results are set for the NetworkNodeMock.GetState")
		}
		return (*results).n1
	}
	if mmGetState.funcGetState != nil {
		return mmGetState.funcGetState()
	}
	mmGetState.t.Fatalf("Unexpected call to NetworkNodeMock.GetState.")
	return
}

// GetStateAfterCounter returns a count of finished NetworkNodeMock.GetState invocations
func (mmGetState *NetworkNodeMock) GetStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetState.afterGetStateCounter)
}

// GetStateBeforeCounter returns a count of NetworkNodeMock.GetState invocations
func (mmGetState *NetworkNodeMock) GetStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetState.beforeGetStateCounter)
}

// MinimockGetStateDone returns true if the count of the GetState invocations corresponds
// the number of defined expectations
func (m *NetworkNodeMock) MinimockGetStateDone() bool {
	for _, e := range m.GetStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetStateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetState != nil && mm_atomic.LoadUint64(&m.afterGetStateCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetStateInspect logs each unmet expectation
func (m *NetworkNodeMock) MinimockGetStateInspect() {
	for _, e := range m.GetStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NetworkNodeMock.GetState")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetStateCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.GetState")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetState != nil && mm_atomic.LoadUint64(&m.afterGetStateCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.GetState")
	}
}

type mNetworkNodeMockID struct {
	mock               *NetworkNodeMock
	defaultExpectation *NetworkNodeMockIDExpectation
	expectations       []*NetworkNodeMockIDExpectation
}

// NetworkNodeMockIDExpectation specifies expectation struct of the NetworkNode.ID
type NetworkNodeMockIDExpectation struct {
	mock *NetworkNodeMock

	results *NetworkNodeMockIDResults
	Counter uint64
}

// NetworkNodeMockIDResults contains results of the NetworkNode.ID
type NetworkNodeMockIDResults struct {
	r1 mm_insolar.Reference
}

// Expect sets up expected params for NetworkNode.ID
func (mmID *mNetworkNodeMockID) Expect() *mNetworkNodeMockID {
	if mmID.mock.funcID != nil {
		mmID.mock.t.Fatalf("NetworkNodeMock.ID mock is already set by Set")
	}

	if mmID.defaultExpectation == nil {
		mmID.defaultExpectation = &NetworkNodeMockIDExpectation{}
	}

	return mmID
}

// Inspect accepts an inspector function that has same arguments as the NetworkNode.ID
func (mmID *mNetworkNodeMockID) Inspect(f func()) *mNetworkNodeMockID {
	if mmID.mock.inspectFuncID != nil {
		mmID.mock.t.Fatalf("Inspect function is already set for NetworkNodeMock.ID")
	}

	mmID.mock.inspectFuncID = f

	return mmID
}

// Return sets up results that will be returned by NetworkNode.ID
func (mmID *mNetworkNodeMockID) Return(r1 mm_insolar.Reference) *NetworkNodeMock {
	if mmID.mock.funcID != nil {
		mmID.mock.t.Fatalf("NetworkNodeMock.ID mock is already set by Set")
	}

	if mmID.defaultExpectation == nil {
		mmID.defaultExpectation = &NetworkNodeMockIDExpectation{mock: mmID.mock}
	}
	mmID.defaultExpectation.results = &NetworkNodeMockIDResults{r1}
	return mmID.mock
}

//Set uses given function f to mock the NetworkNode.ID method
func (mmID *mNetworkNodeMockID) Set(f func() (r1 mm_insolar.Reference)) *NetworkNodeMock {
	if mmID.defaultExpectation != nil {
		mmID.mock.t.Fatalf("Default expectation is already set for the NetworkNode.ID method")
	}

	if len(mmID.expectations) > 0 {
		mmID.mock.t.Fatalf("Some expectations are already set for the NetworkNode.ID method")
	}

	mmID.mock.funcID = f
	return mmID.mock
}

// ID implements insolar.NetworkNode
func (mmID *NetworkNodeMock) ID() (r1 mm_insolar.Reference) {
	mm_atomic.AddUint64(&mmID.beforeIDCounter, 1)
	defer mm_atomic.AddUint64(&mmID.afterIDCounter, 1)

	if mmID.inspectFuncID != nil {
		mmID.inspectFuncID()
	}

	if mmID.IDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmID.IDMock.defaultExpectation.Counter, 1)

		results := mmID.IDMock.defaultExpectation.results
		if results == nil {
			mmID.t.Fatal("No results are set for the NetworkNodeMock.ID")
		}
		return (*results).r1
	}
	if mmID.funcID != nil {
		return mmID.funcID()
	}
	mmID.t.Fatalf("Unexpected call to NetworkNodeMock.ID.")
	return
}

// IDAfterCounter returns a count of finished NetworkNodeMock.ID invocations
func (mmID *NetworkNodeMock) IDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmID.afterIDCounter)
}

// IDBeforeCounter returns a count of NetworkNodeMock.ID invocations
func (mmID *NetworkNodeMock) IDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmID.beforeIDCounter)
}

// MinimockIDDone returns true if the count of the ID invocations corresponds
// the number of defined expectations
func (m *NetworkNodeMock) MinimockIDDone() bool {
	for _, e := range m.IDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcID != nil && mm_atomic.LoadUint64(&m.afterIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockIDInspect logs each unmet expectation
func (m *NetworkNodeMock) MinimockIDInspect() {
	for _, e := range m.IDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NetworkNodeMock.ID")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIDCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.ID")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcID != nil && mm_atomic.LoadUint64(&m.afterIDCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.ID")
	}
}

type mNetworkNodeMockLeavingETA struct {
	mock               *NetworkNodeMock
	defaultExpectation *NetworkNodeMockLeavingETAExpectation
	expectations       []*NetworkNodeMockLeavingETAExpectation
}

// NetworkNodeMockLeavingETAExpectation specifies expectation struct of the NetworkNode.LeavingETA
type NetworkNodeMockLeavingETAExpectation struct {
	mock *NetworkNodeMock

	results *NetworkNodeMockLeavingETAResults
	Counter uint64
}

// NetworkNodeMockLeavingETAResults contains results of the NetworkNode.LeavingETA
type NetworkNodeMockLeavingETAResults struct {
	p1 mm_insolar.PulseNumber
}

// Expect sets up expected params for NetworkNode.LeavingETA
func (mmLeavingETA *mNetworkNodeMockLeavingETA) Expect() *mNetworkNodeMockLeavingETA {
	if mmLeavingETA.mock.funcLeavingETA != nil {
		mmLeavingETA.mock.t.Fatalf("NetworkNodeMock.LeavingETA mock is already set by Set")
	}

	if mmLeavingETA.defaultExpectation == nil {
		mmLeavingETA.defaultExpectation = &NetworkNodeMockLeavingETAExpectation{}
	}

	return mmLeavingETA
}

// Inspect accepts an inspector function that has same arguments as the NetworkNode.LeavingETA
func (mmLeavingETA *mNetworkNodeMockLeavingETA) Inspect(f func()) *mNetworkNodeMockLeavingETA {
	if mmLeavingETA.mock.inspectFuncLeavingETA != nil {
		mmLeavingETA.mock.t.Fatalf("Inspect function is already set for NetworkNodeMock.LeavingETA")
	}

	mmLeavingETA.mock.inspectFuncLeavingETA = f

	return mmLeavingETA
}

// Return sets up results that will be returned by NetworkNode.LeavingETA
func (mmLeavingETA *mNetworkNodeMockLeavingETA) Return(p1 mm_insolar.PulseNumber) *NetworkNodeMock {
	if mmLeavingETA.mock.funcLeavingETA != nil {
		mmLeavingETA.mock.t.Fatalf("NetworkNodeMock.LeavingETA mock is already set by Set")
	}

	if mmLeavingETA.defaultExpectation == nil {
		mmLeavingETA.defaultExpectation = &NetworkNodeMockLeavingETAExpectation{mock: mmLeavingETA.mock}
	}
	mmLeavingETA.defaultExpectation.results = &NetworkNodeMockLeavingETAResults{p1}
	return mmLeavingETA.mock
}

//Set uses given function f to mock the NetworkNode.LeavingETA method
func (mmLeavingETA *mNetworkNodeMockLeavingETA) Set(f func() (p1 mm_insolar.PulseNumber)) *NetworkNodeMock {
	if mmLeavingETA.defaultExpectation != nil {
		mmLeavingETA.mock.t.Fatalf("Default expectation is already set for the NetworkNode.LeavingETA method")
	}

	if len(mmLeavingETA.expectations) > 0 {
		mmLeavingETA.mock.t.Fatalf("Some expectations are already set for the NetworkNode.LeavingETA method")
	}

	mmLeavingETA.mock.funcLeavingETA = f
	return mmLeavingETA.mock
}

// LeavingETA implements insolar.NetworkNode
func (mmLeavingETA *NetworkNodeMock) LeavingETA() (p1 mm_insolar.PulseNumber) {
	mm_atomic.AddUint64(&mmLeavingETA.beforeLeavingETACounter, 1)
	defer mm_atomic.AddUint64(&mmLeavingETA.afterLeavingETACounter, 1)

	if mmLeavingETA.inspectFuncLeavingETA != nil {
		mmLeavingETA.inspectFuncLeavingETA()
	}

	if mmLeavingETA.LeavingETAMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLeavingETA.LeavingETAMock.defaultExpectation.Counter, 1)

		results := mmLeavingETA.LeavingETAMock.defaultExpectation.results
		if results == nil {
			mmLeavingETA.t.Fatal("No results are set for the NetworkNodeMock.LeavingETA")
		}
		return (*results).p1
	}
	if mmLeavingETA.funcLeavingETA != nil {
		return mmLeavingETA.funcLeavingETA()
	}
	mmLeavingETA.t.Fatalf("Unexpected call to NetworkNodeMock.LeavingETA.")
	return
}

// LeavingETAAfterCounter returns a count of finished NetworkNodeMock.LeavingETA invocations
func (mmLeavingETA *NetworkNodeMock) LeavingETAAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLeavingETA.afterLeavingETACounter)
}

// LeavingETABeforeCounter returns a count of NetworkNodeMock.LeavingETA invocations
func (mmLeavingETA *NetworkNodeMock) LeavingETABeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLeavingETA.beforeLeavingETACounter)
}

// MinimockLeavingETADone returns true if the count of the LeavingETA invocations corresponds
// the number of defined expectations
func (m *NetworkNodeMock) MinimockLeavingETADone() bool {
	for _, e := range m.LeavingETAMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LeavingETAMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLeavingETACounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLeavingETA != nil && mm_atomic.LoadUint64(&m.afterLeavingETACounter) < 1 {
		return false
	}
	return true
}

// MinimockLeavingETAInspect logs each unmet expectation
func (m *NetworkNodeMock) MinimockLeavingETAInspect() {
	for _, e := range m.LeavingETAMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NetworkNodeMock.LeavingETA")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LeavingETAMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLeavingETACounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.LeavingETA")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLeavingETA != nil && mm_atomic.LoadUint64(&m.afterLeavingETACounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.LeavingETA")
	}
}

type mNetworkNodeMockPublicKey struct {
	mock               *NetworkNodeMock
	defaultExpectation *NetworkNodeMockPublicKeyExpectation
	expectations       []*NetworkNodeMockPublicKeyExpectation
}

// NetworkNodeMockPublicKeyExpectation specifies expectation struct of the NetworkNode.PublicKey
type NetworkNodeMockPublicKeyExpectation struct {
	mock *NetworkNodeMock

	results *NetworkNodeMockPublicKeyResults
	Counter uint64
}

// NetworkNodeMockPublicKeyResults contains results of the NetworkNode.PublicKey
type NetworkNodeMockPublicKeyResults struct {
	p1 crypto.PublicKey
}

// Expect sets up expected params for NetworkNode.PublicKey
func (mmPublicKey *mNetworkNodeMockPublicKey) Expect() *mNetworkNodeMockPublicKey {
	if mmPublicKey.mock.funcPublicKey != nil {
		mmPublicKey.mock.t.Fatalf("NetworkNodeMock.PublicKey mock is already set by Set")
	}

	if mmPublicKey.defaultExpectation == nil {
		mmPublicKey.defaultExpectation = &NetworkNodeMockPublicKeyExpectation{}
	}

	return mmPublicKey
}

// Inspect accepts an inspector function that has same arguments as the NetworkNode.PublicKey
func (mmPublicKey *mNetworkNodeMockPublicKey) Inspect(f func()) *mNetworkNodeMockPublicKey {
	if mmPublicKey.mock.inspectFuncPublicKey != nil {
		mmPublicKey.mock.t.Fatalf("Inspect function is already set for NetworkNodeMock.PublicKey")
	}

	mmPublicKey.mock.inspectFuncPublicKey = f

	return mmPublicKey
}

// Return sets up results that will be returned by NetworkNode.PublicKey
func (mmPublicKey *mNetworkNodeMockPublicKey) Return(p1 crypto.PublicKey) *NetworkNodeMock {
	if mmPublicKey.mock.funcPublicKey != nil {
		mmPublicKey.mock.t.Fatalf("NetworkNodeMock.PublicKey mock is already set by Set")
	}

	if mmPublicKey.defaultExpectation == nil {
		mmPublicKey.defaultExpectation = &NetworkNodeMockPublicKeyExpectation{mock: mmPublicKey.mock}
	}
	mmPublicKey.defaultExpectation.results = &NetworkNodeMockPublicKeyResults{p1}
	return mmPublicKey.mock
}

//Set uses given function f to mock the NetworkNode.PublicKey method
func (mmPublicKey *mNetworkNodeMockPublicKey) Set(f func() (p1 crypto.PublicKey)) *NetworkNodeMock {
	if mmPublicKey.defaultExpectation != nil {
		mmPublicKey.mock.t.Fatalf("Default expectation is already set for the NetworkNode.PublicKey method")
	}

	if len(mmPublicKey.expectations) > 0 {
		mmPublicKey.mock.t.Fatalf("Some expectations are already set for the NetworkNode.PublicKey method")
	}

	mmPublicKey.mock.funcPublicKey = f
	return mmPublicKey.mock
}

// PublicKey implements insolar.NetworkNode
func (mmPublicKey *NetworkNodeMock) PublicKey() (p1 crypto.PublicKey) {
	mm_atomic.AddUint64(&mmPublicKey.beforePublicKeyCounter, 1)
	defer mm_atomic.AddUint64(&mmPublicKey.afterPublicKeyCounter, 1)

	if mmPublicKey.inspectFuncPublicKey != nil {
		mmPublicKey.inspectFuncPublicKey()
	}

	if mmPublicKey.PublicKeyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPublicKey.PublicKeyMock.defaultExpectation.Counter, 1)

		results := mmPublicKey.PublicKeyMock.defaultExpectation.results
		if results == nil {
			mmPublicKey.t.Fatal("No results are set for the NetworkNodeMock.PublicKey")
		}
		return (*results).p1
	}
	if mmPublicKey.funcPublicKey != nil {
		return mmPublicKey.funcPublicKey()
	}
	mmPublicKey.t.Fatalf("Unexpected call to NetworkNodeMock.PublicKey.")
	return
}

// PublicKeyAfterCounter returns a count of finished NetworkNodeMock.PublicKey invocations
func (mmPublicKey *NetworkNodeMock) PublicKeyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublicKey.afterPublicKeyCounter)
}

// PublicKeyBeforeCounter returns a count of NetworkNodeMock.PublicKey invocations
func (mmPublicKey *NetworkNodeMock) PublicKeyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublicKey.beforePublicKeyCounter)
}

// MinimockPublicKeyDone returns true if the count of the PublicKey invocations corresponds
// the number of defined expectations
func (m *NetworkNodeMock) MinimockPublicKeyDone() bool {
	for _, e := range m.PublicKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PublicKeyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPublicKeyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublicKey != nil && mm_atomic.LoadUint64(&m.afterPublicKeyCounter) < 1 {
		return false
	}
	return true
}

// MinimockPublicKeyInspect logs each unmet expectation
func (m *NetworkNodeMock) MinimockPublicKeyInspect() {
	for _, e := range m.PublicKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NetworkNodeMock.PublicKey")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PublicKeyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPublicKeyCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.PublicKey")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublicKey != nil && mm_atomic.LoadUint64(&m.afterPublicKeyCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.PublicKey")
	}
}

type mNetworkNodeMockRole struct {
	mock               *NetworkNodeMock
	defaultExpectation *NetworkNodeMockRoleExpectation
	expectations       []*NetworkNodeMockRoleExpectation
}

// NetworkNodeMockRoleExpectation specifies expectation struct of the NetworkNode.Role
type NetworkNodeMockRoleExpectation struct {
	mock *NetworkNodeMock

	results *NetworkNodeMockRoleResults
	Counter uint64
}

// NetworkNodeMockRoleResults contains results of the NetworkNode.Role
type NetworkNodeMockRoleResults struct {
	s1 mm_insolar.StaticRole
}

// Expect sets up expected params for NetworkNode.Role
func (mmRole *mNetworkNodeMockRole) Expect() *mNetworkNodeMockRole {
	if mmRole.mock.funcRole != nil {
		mmRole.mock.t.Fatalf("NetworkNodeMock.Role mock is already set by Set")
	}

	if mmRole.defaultExpectation == nil {
		mmRole.defaultExpectation = &NetworkNodeMockRoleExpectation{}
	}

	return mmRole
}

// Inspect accepts an inspector function that has same arguments as the NetworkNode.Role
func (mmRole *mNetworkNodeMockRole) Inspect(f func()) *mNetworkNodeMockRole {
	if mmRole.mock.inspectFuncRole != nil {
		mmRole.mock.t.Fatalf("Inspect function is already set for NetworkNodeMock.Role")
	}

	mmRole.mock.inspectFuncRole = f

	return mmRole
}

// Return sets up results that will be returned by NetworkNode.Role
func (mmRole *mNetworkNodeMockRole) Return(s1 mm_insolar.StaticRole) *NetworkNodeMock {
	if mmRole.mock.funcRole != nil {
		mmRole.mock.t.Fatalf("NetworkNodeMock.Role mock is already set by Set")
	}

	if mmRole.defaultExpectation == nil {
		mmRole.defaultExpectation = &NetworkNodeMockRoleExpectation{mock: mmRole.mock}
	}
	mmRole.defaultExpectation.results = &NetworkNodeMockRoleResults{s1}
	return mmRole.mock
}

//Set uses given function f to mock the NetworkNode.Role method
func (mmRole *mNetworkNodeMockRole) Set(f func() (s1 mm_insolar.StaticRole)) *NetworkNodeMock {
	if mmRole.defaultExpectation != nil {
		mmRole.mock.t.Fatalf("Default expectation is already set for the NetworkNode.Role method")
	}

	if len(mmRole.expectations) > 0 {
		mmRole.mock.t.Fatalf("Some expectations are already set for the NetworkNode.Role method")
	}

	mmRole.mock.funcRole = f
	return mmRole.mock
}

// Role implements insolar.NetworkNode
func (mmRole *NetworkNodeMock) Role() (s1 mm_insolar.StaticRole) {
	mm_atomic.AddUint64(&mmRole.beforeRoleCounter, 1)
	defer mm_atomic.AddUint64(&mmRole.afterRoleCounter, 1)

	if mmRole.inspectFuncRole != nil {
		mmRole.inspectFuncRole()
	}

	if mmRole.RoleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRole.RoleMock.defaultExpectation.Counter, 1)

		results := mmRole.RoleMock.defaultExpectation.results
		if results == nil {
			mmRole.t.Fatal("No results are set for the NetworkNodeMock.Role")
		}
		return (*results).s1
	}
	if mmRole.funcRole != nil {
		return mmRole.funcRole()
	}
	mmRole.t.Fatalf("Unexpected call to NetworkNodeMock.Role.")
	return
}

// RoleAfterCounter returns a count of finished NetworkNodeMock.Role invocations
func (mmRole *NetworkNodeMock) RoleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRole.afterRoleCounter)
}

// RoleBeforeCounter returns a count of NetworkNodeMock.Role invocations
func (mmRole *NetworkNodeMock) RoleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRole.beforeRoleCounter)
}

// MinimockRoleDone returns true if the count of the Role invocations corresponds
// the number of defined expectations
func (m *NetworkNodeMock) MinimockRoleDone() bool {
	for _, e := range m.RoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RoleMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRoleCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRole != nil && mm_atomic.LoadUint64(&m.afterRoleCounter) < 1 {
		return false
	}
	return true
}

// MinimockRoleInspect logs each unmet expectation
func (m *NetworkNodeMock) MinimockRoleInspect() {
	for _, e := range m.RoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NetworkNodeMock.Role")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RoleMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRoleCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.Role")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRole != nil && mm_atomic.LoadUint64(&m.afterRoleCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.Role")
	}
}

type mNetworkNodeMockShortID struct {
	mock               *NetworkNodeMock
	defaultExpectation *NetworkNodeMockShortIDExpectation
	expectations       []*NetworkNodeMockShortIDExpectation
}

// NetworkNodeMockShortIDExpectation specifies expectation struct of the NetworkNode.ShortID
type NetworkNodeMockShortIDExpectation struct {
	mock *NetworkNodeMock

	results *NetworkNodeMockShortIDResults
	Counter uint64
}

// NetworkNodeMockShortIDResults contains results of the NetworkNode.ShortID
type NetworkNodeMockShortIDResults struct {
	s1 mm_insolar.ShortNodeID
}

// Expect sets up expected params for NetworkNode.ShortID
func (mmShortID *mNetworkNodeMockShortID) Expect() *mNetworkNodeMockShortID {
	if mmShortID.mock.funcShortID != nil {
		mmShortID.mock.t.Fatalf("NetworkNodeMock.ShortID mock is already set by Set")
	}

	if mmShortID.defaultExpectation == nil {
		mmShortID.defaultExpectation = &NetworkNodeMockShortIDExpectation{}
	}

	return mmShortID
}

// Inspect accepts an inspector function that has same arguments as the NetworkNode.ShortID
func (mmShortID *mNetworkNodeMockShortID) Inspect(f func()) *mNetworkNodeMockShortID {
	if mmShortID.mock.inspectFuncShortID != nil {
		mmShortID.mock.t.Fatalf("Inspect function is already set for NetworkNodeMock.ShortID")
	}

	mmShortID.mock.inspectFuncShortID = f

	return mmShortID
}

// Return sets up results that will be returned by NetworkNode.ShortID
func (mmShortID *mNetworkNodeMockShortID) Return(s1 mm_insolar.ShortNodeID) *NetworkNodeMock {
	if mmShortID.mock.funcShortID != nil {
		mmShortID.mock.t.Fatalf("NetworkNodeMock.ShortID mock is already set by Set")
	}

	if mmShortID.defaultExpectation == nil {
		mmShortID.defaultExpectation = &NetworkNodeMockShortIDExpectation{mock: mmShortID.mock}
	}
	mmShortID.defaultExpectation.results = &NetworkNodeMockShortIDResults{s1}
	return mmShortID.mock
}

//Set uses given function f to mock the NetworkNode.ShortID method
func (mmShortID *mNetworkNodeMockShortID) Set(f func() (s1 mm_insolar.ShortNodeID)) *NetworkNodeMock {
	if mmShortID.defaultExpectation != nil {
		mmShortID.mock.t.Fatalf("Default expectation is already set for the NetworkNode.ShortID method")
	}

	if len(mmShortID.expectations) > 0 {
		mmShortID.mock.t.Fatalf("Some expectations are already set for the NetworkNode.ShortID method")
	}

	mmShortID.mock.funcShortID = f
	return mmShortID.mock
}

// ShortID implements insolar.NetworkNode
func (mmShortID *NetworkNodeMock) ShortID() (s1 mm_insolar.ShortNodeID) {
	mm_atomic.AddUint64(&mmShortID.beforeShortIDCounter, 1)
	defer mm_atomic.AddUint64(&mmShortID.afterShortIDCounter, 1)

	if mmShortID.inspectFuncShortID != nil {
		mmShortID.inspectFuncShortID()
	}

	if mmShortID.ShortIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmShortID.ShortIDMock.defaultExpectation.Counter, 1)

		results := mmShortID.ShortIDMock.defaultExpectation.results
		if results == nil {
			mmShortID.t.Fatal("No results are set for the NetworkNodeMock.ShortID")
		}
		return (*results).s1
	}
	if mmShortID.funcShortID != nil {
		return mmShortID.funcShortID()
	}
	mmShortID.t.Fatalf("Unexpected call to NetworkNodeMock.ShortID.")
	return
}

// ShortIDAfterCounter returns a count of finished NetworkNodeMock.ShortID invocations
func (mmShortID *NetworkNodeMock) ShortIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShortID.afterShortIDCounter)
}

// ShortIDBeforeCounter returns a count of NetworkNodeMock.ShortID invocations
func (mmShortID *NetworkNodeMock) ShortIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShortID.beforeShortIDCounter)
}

// MinimockShortIDDone returns true if the count of the ShortID invocations corresponds
// the number of defined expectations
func (m *NetworkNodeMock) MinimockShortIDDone() bool {
	for _, e := range m.ShortIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ShortIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterShortIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcShortID != nil && mm_atomic.LoadUint64(&m.afterShortIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockShortIDInspect logs each unmet expectation
func (m *NetworkNodeMock) MinimockShortIDInspect() {
	for _, e := range m.ShortIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NetworkNodeMock.ShortID")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ShortIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterShortIDCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.ShortID")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcShortID != nil && mm_atomic.LoadUint64(&m.afterShortIDCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.ShortID")
	}
}

type mNetworkNodeMockVersion struct {
	mock               *NetworkNodeMock
	defaultExpectation *NetworkNodeMockVersionExpectation
	expectations       []*NetworkNodeMockVersionExpectation
}

// NetworkNodeMockVersionExpectation specifies expectation struct of the NetworkNode.Version
type NetworkNodeMockVersionExpectation struct {
	mock *NetworkNodeMock

	results *NetworkNodeMockVersionResults
	Counter uint64
}

// NetworkNodeMockVersionResults contains results of the NetworkNode.Version
type NetworkNodeMockVersionResults struct {
	s1 string
}

// Expect sets up expected params for NetworkNode.Version
func (mmVersion *mNetworkNodeMockVersion) Expect() *mNetworkNodeMockVersion {
	if mmVersion.mock.funcVersion != nil {
		mmVersion.mock.t.Fatalf("NetworkNodeMock.Version mock is already set by Set")
	}

	if mmVersion.defaultExpectation == nil {
		mmVersion.defaultExpectation = &NetworkNodeMockVersionExpectation{}
	}

	return mmVersion
}

// Inspect accepts an inspector function that has same arguments as the NetworkNode.Version
func (mmVersion *mNetworkNodeMockVersion) Inspect(f func()) *mNetworkNodeMockVersion {
	if mmVersion.mock.inspectFuncVersion != nil {
		mmVersion.mock.t.Fatalf("Inspect function is already set for NetworkNodeMock.Version")
	}

	mmVersion.mock.inspectFuncVersion = f

	return mmVersion
}

// Return sets up results that will be returned by NetworkNode.Version
func (mmVersion *mNetworkNodeMockVersion) Return(s1 string) *NetworkNodeMock {
	if mmVersion.mock.funcVersion != nil {
		mmVersion.mock.t.Fatalf("NetworkNodeMock.Version mock is already set by Set")
	}

	if mmVersion.defaultExpectation == nil {
		mmVersion.defaultExpectation = &NetworkNodeMockVersionExpectation{mock: mmVersion.mock}
	}
	mmVersion.defaultExpectation.results = &NetworkNodeMockVersionResults{s1}
	return mmVersion.mock
}

//Set uses given function f to mock the NetworkNode.Version method
func (mmVersion *mNetworkNodeMockVersion) Set(f func() (s1 string)) *NetworkNodeMock {
	if mmVersion.defaultExpectation != nil {
		mmVersion.mock.t.Fatalf("Default expectation is already set for the NetworkNode.Version method")
	}

	if len(mmVersion.expectations) > 0 {
		mmVersion.mock.t.Fatalf("Some expectations are already set for the NetworkNode.Version method")
	}

	mmVersion.mock.funcVersion = f
	return mmVersion.mock
}

// Version implements insolar.NetworkNode
func (mmVersion *NetworkNodeMock) Version() (s1 string) {
	mm_atomic.AddUint64(&mmVersion.beforeVersionCounter, 1)
	defer mm_atomic.AddUint64(&mmVersion.afterVersionCounter, 1)

	if mmVersion.inspectFuncVersion != nil {
		mmVersion.inspectFuncVersion()
	}

	if mmVersion.VersionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmVersion.VersionMock.defaultExpectation.Counter, 1)

		results := mmVersion.VersionMock.defaultExpectation.results
		if results == nil {
			mmVersion.t.Fatal("No results are set for the NetworkNodeMock.Version")
		}
		return (*results).s1
	}
	if mmVersion.funcVersion != nil {
		return mmVersion.funcVersion()
	}
	mmVersion.t.Fatalf("Unexpected call to NetworkNodeMock.Version.")
	return
}

// VersionAfterCounter returns a count of finished NetworkNodeMock.Version invocations
func (mmVersion *NetworkNodeMock) VersionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmVersion.afterVersionCounter)
}

// VersionBeforeCounter returns a count of NetworkNodeMock.Version invocations
func (mmVersion *NetworkNodeMock) VersionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmVersion.beforeVersionCounter)
}

// MinimockVersionDone returns true if the count of the Version invocations corresponds
// the number of defined expectations
func (m *NetworkNodeMock) MinimockVersionDone() bool {
	for _, e := range m.VersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.VersionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterVersionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcVersion != nil && mm_atomic.LoadUint64(&m.afterVersionCounter) < 1 {
		return false
	}
	return true
}

// MinimockVersionInspect logs each unmet expectation
func (m *NetworkNodeMock) MinimockVersionInspect() {
	for _, e := range m.VersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NetworkNodeMock.Version")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.VersionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterVersionCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.Version")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcVersion != nil && mm_atomic.LoadUint64(&m.afterVersionCounter) < 1 {
		m.t.Error("Expected call to NetworkNodeMock.Version")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *NetworkNodeMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddressInspect()

		m.MinimockGetGlobuleIDInspect()

		m.MinimockGetStateInspect()

		m.MinimockIDInspect()

		m.MinimockLeavingETAInspect()

		m.MinimockPublicKeyInspect()

		m.MinimockRoleInspect()

		m.MinimockShortIDInspect()

		m.MinimockVersionInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *NetworkNodeMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *NetworkNodeMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddressDone() &&
		m.MinimockGetGlobuleIDDone() &&
		m.MinimockGetStateDone() &&
		m.MinimockIDDone() &&
		m.MinimockLeavingETADone() &&
		m.MinimockPublicKeyDone() &&
		m.MinimockRoleDone() &&
		m.MinimockShortIDDone() &&
		m.MinimockVersionDone()
}
