package network

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/insolar"
	mm_network "github.com/insolar/insolar/network"
	"github.com/insolar/insolar/network/hostnetwork/host"
	"github.com/insolar/insolar/network/hostnetwork/packet/types"
)

// HostNetworkMock implements network.HostNetwork
type HostNetworkMock struct {
	t minimock.Tester

	funcBuildResponse          func(ctx context.Context, request mm_network.Packet, responseData interface{}) (p1 mm_network.Packet)
	inspectFuncBuildResponse   func(ctx context.Context, request mm_network.Packet, responseData interface{})
	afterBuildResponseCounter  uint64
	beforeBuildResponseCounter uint64
	BuildResponseMock          mHostNetworkMockBuildResponse

	funcPublicAddress          func() (s1 string)
	inspectFuncPublicAddress   func()
	afterPublicAddressCounter  uint64
	beforePublicAddressCounter uint64
	PublicAddressMock          mHostNetworkMockPublicAddress

	funcRegisterRequestHandler          func(t types.PacketType, handler mm_network.RequestHandler)
	inspectFuncRegisterRequestHandler   func(t types.PacketType, handler mm_network.RequestHandler)
	afterRegisterRequestHandlerCounter  uint64
	beforeRegisterRequestHandlerCounter uint64
	RegisterRequestHandlerMock          mHostNetworkMockRegisterRequestHandler

	funcSendRequest          func(ctx context.Context, t types.PacketType, requestData interface{}, receiver insolar.Reference) (f1 mm_network.Future, err error)
	inspectFuncSendRequest   func(ctx context.Context, t types.PacketType, requestData interface{}, receiver insolar.Reference)
	afterSendRequestCounter  uint64
	beforeSendRequestCounter uint64
	SendRequestMock          mHostNetworkMockSendRequest

	funcSendRequestToHost          func(ctx context.Context, t types.PacketType, requestData interface{}, receiver *host.Host) (f1 mm_network.Future, err error)
	inspectFuncSendRequestToHost   func(ctx context.Context, t types.PacketType, requestData interface{}, receiver *host.Host)
	afterSendRequestToHostCounter  uint64
	beforeSendRequestToHostCounter uint64
	SendRequestToHostMock          mHostNetworkMockSendRequestToHost

	funcStart          func(ctx context.Context) (err error)
	inspectFuncStart   func(ctx context.Context)
	afterStartCounter  uint64
	beforeStartCounter uint64
	StartMock          mHostNetworkMockStart

	funcStop          func(ctx context.Context) (err error)
	inspectFuncStop   func(ctx context.Context)
	afterStopCounter  uint64
	beforeStopCounter uint64
	StopMock          mHostNetworkMockStop
}

// NewHostNetworkMock returns a mock for network.HostNetwork
func NewHostNetworkMock(t minimock.Tester) *HostNetworkMock {
	m := &HostNetworkMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BuildResponseMock = mHostNetworkMockBuildResponse{mock: m}
	m.BuildResponseMock.callArgs = []*HostNetworkMockBuildResponseParams{}

	m.PublicAddressMock = mHostNetworkMockPublicAddress{mock: m}

	m.RegisterRequestHandlerMock = mHostNetworkMockRegisterRequestHandler{mock: m}
	m.RegisterRequestHandlerMock.callArgs = []*HostNetworkMockRegisterRequestHandlerParams{}

	m.SendRequestMock = mHostNetworkMockSendRequest{mock: m}
	m.SendRequestMock.callArgs = []*HostNetworkMockSendRequestParams{}

	m.SendRequestToHostMock = mHostNetworkMockSendRequestToHost{mock: m}
	m.SendRequestToHostMock.callArgs = []*HostNetworkMockSendRequestToHostParams{}

	m.StartMock = mHostNetworkMockStart{mock: m}
	m.StartMock.callArgs = []*HostNetworkMockStartParams{}

	m.StopMock = mHostNetworkMockStop{mock: m}
	m.StopMock.callArgs = []*HostNetworkMockStopParams{}

	return m
}

type mHostNetworkMockBuildResponse struct {
	mock               *HostNetworkMock
	defaultExpectation *HostNetworkMockBuildResponseExpectation
	expectations       []*HostNetworkMockBuildResponseExpectation

	callArgs []*HostNetworkMockBuildResponseParams
	mutex    sync.RWMutex
}

// HostNetworkMockBuildResponseExpectation specifies expectation struct of the HostNetwork.BuildResponse
type HostNetworkMockBuildResponseExpectation struct {
	mock    *HostNetworkMock
	params  *HostNetworkMockBuildResponseParams
	results *HostNetworkMockBuildResponseResults
	Counter uint64
}

// HostNetworkMockBuildResponseParams contains parameters of the HostNetwork.BuildResponse
type HostNetworkMockBuildResponseParams struct {
	ctx          context.Context
	request      mm_network.Packet
	responseData interface{}
}

// HostNetworkMockBuildResponseResults contains results of the HostNetwork.BuildResponse
type HostNetworkMockBuildResponseResults struct {
	p1 mm_network.Packet
}

// Expect sets up expected params for HostNetwork.BuildResponse
func (mmBuildResponse *mHostNetworkMockBuildResponse) Expect(ctx context.Context, request mm_network.Packet, responseData interface{}) *mHostNetworkMockBuildResponse {
	if mmBuildResponse.mock.funcBuildResponse != nil {
		mmBuildResponse.mock.t.Fatalf("HostNetworkMock.BuildResponse mock is already set by Set")
	}

	if mmBuildResponse.defaultExpectation == nil {
		mmBuildResponse.defaultExpectation = &HostNetworkMockBuildResponseExpectation{}
	}

	mmBuildResponse.defaultExpectation.params = &HostNetworkMockBuildResponseParams{ctx, request, responseData}
	for _, e := range mmBuildResponse.expectations {
		if minimock.Equal(e.params, mmBuildResponse.defaultExpectation.params) {
			mmBuildResponse.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBuildResponse.defaultExpectation.params)
		}
	}

	return mmBuildResponse
}

// Inspect accepts an inspector function that has same arguments as the HostNetwork.BuildResponse
func (mmBuildResponse *mHostNetworkMockBuildResponse) Inspect(f func(ctx context.Context, request mm_network.Packet, responseData interface{})) *mHostNetworkMockBuildResponse {
	if mmBuildResponse.mock.inspectFuncBuildResponse != nil {
		mmBuildResponse.mock.t.Fatalf("Inspect function is already set for HostNetworkMock.BuildResponse")
	}

	mmBuildResponse.mock.inspectFuncBuildResponse = f

	return mmBuildResponse
}

// Return sets up results that will be returned by HostNetwork.BuildResponse
func (mmBuildResponse *mHostNetworkMockBuildResponse) Return(p1 mm_network.Packet) *HostNetworkMock {
	if mmBuildResponse.mock.funcBuildResponse != nil {
		mmBuildResponse.mock.t.Fatalf("HostNetworkMock.BuildResponse mock is already set by Set")
	}

	if mmBuildResponse.defaultExpectation == nil {
		mmBuildResponse.defaultExpectation = &HostNetworkMockBuildResponseExpectation{mock: mmBuildResponse.mock}
	}
	mmBuildResponse.defaultExpectation.results = &HostNetworkMockBuildResponseResults{p1}
	return mmBuildResponse.mock
}

//Set uses given function f to mock the HostNetwork.BuildResponse method
func (mmBuildResponse *mHostNetworkMockBuildResponse) Set(f func(ctx context.Context, request mm_network.Packet, responseData interface{}) (p1 mm_network.Packet)) *HostNetworkMock {
	if mmBuildResponse.defaultExpectation != nil {
		mmBuildResponse.mock.t.Fatalf("Default expectation is already set for the HostNetwork.BuildResponse method")
	}

	if len(mmBuildResponse.expectations) > 0 {
		mmBuildResponse.mock.t.Fatalf("Some expectations are already set for the HostNetwork.BuildResponse method")
	}

	mmBuildResponse.mock.funcBuildResponse = f
	return mmBuildResponse.mock
}

// When sets expectation for the HostNetwork.BuildResponse which will trigger the result defined by the following
// Then helper
func (mmBuildResponse *mHostNetworkMockBuildResponse) When(ctx context.Context, request mm_network.Packet, responseData interface{}) *HostNetworkMockBuildResponseExpectation {
	if mmBuildResponse.mock.funcBuildResponse != nil {
		mmBuildResponse.mock.t.Fatalf("HostNetworkMock.BuildResponse mock is already set by Set")
	}

	expectation := &HostNetworkMockBuildResponseExpectation{
		mock:   mmBuildResponse.mock,
		params: &HostNetworkMockBuildResponseParams{ctx, request, responseData},
	}
	mmBuildResponse.expectations = append(mmBuildResponse.expectations, expectation)
	return expectation
}

// Then sets up HostNetwork.BuildResponse return parameters for the expectation previously defined by the When method
func (e *HostNetworkMockBuildResponseExpectation) Then(p1 mm_network.Packet) *HostNetworkMock {
	e.results = &HostNetworkMockBuildResponseResults{p1}
	return e.mock
}

// BuildResponse implements network.HostNetwork
func (mmBuildResponse *HostNetworkMock) BuildResponse(ctx context.Context, request mm_network.Packet, responseData interface{}) (p1 mm_network.Packet) {
	mm_atomic.AddUint64(&mmBuildResponse.beforeBuildResponseCounter, 1)
	defer mm_atomic.AddUint64(&mmBuildResponse.afterBuildResponseCounter, 1)

	if mmBuildResponse.inspectFuncBuildResponse != nil {
		mmBuildResponse.inspectFuncBuildResponse(ctx, request, responseData)
	}

	params := &HostNetworkMockBuildResponseParams{ctx, request, responseData}

	// Record call args
	mmBuildResponse.BuildResponseMock.mutex.Lock()
	mmBuildResponse.BuildResponseMock.callArgs = append(mmBuildResponse.BuildResponseMock.callArgs, params)
	mmBuildResponse.BuildResponseMock.mutex.Unlock()

	for _, e := range mmBuildResponse.BuildResponseMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1
		}
	}

	if mmBuildResponse.BuildResponseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBuildResponse.BuildResponseMock.defaultExpectation.Counter, 1)
		want := mmBuildResponse.BuildResponseMock.defaultExpectation.params
		got := HostNetworkMockBuildResponseParams{ctx, request, responseData}
		if want != nil && !minimock.Equal(*want, got) {
			mmBuildResponse.t.Errorf("HostNetworkMock.BuildResponse got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmBuildResponse.BuildResponseMock.defaultExpectation.results
		if results == nil {
			mmBuildResponse.t.Fatal("No results are set for the HostNetworkMock.BuildResponse")
		}
		return (*results).p1
	}
	if mmBuildResponse.funcBuildResponse != nil {
		return mmBuildResponse.funcBuildResponse(ctx, request, responseData)
	}
	mmBuildResponse.t.Fatalf("Unexpected call to HostNetworkMock.BuildResponse. %v %v %v", ctx, request, responseData)
	return
}

// BuildResponseAfterCounter returns a count of finished HostNetworkMock.BuildResponse invocations
func (mmBuildResponse *HostNetworkMock) BuildResponseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBuildResponse.afterBuildResponseCounter)
}

// BuildResponseBeforeCounter returns a count of HostNetworkMock.BuildResponse invocations
func (mmBuildResponse *HostNetworkMock) BuildResponseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBuildResponse.beforeBuildResponseCounter)
}

// Calls returns a list of arguments used in each call to HostNetworkMock.BuildResponse.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBuildResponse *mHostNetworkMockBuildResponse) Calls() []*HostNetworkMockBuildResponseParams {
	mmBuildResponse.mutex.RLock()

	argCopy := make([]*HostNetworkMockBuildResponseParams, len(mmBuildResponse.callArgs))
	copy(argCopy, mmBuildResponse.callArgs)

	mmBuildResponse.mutex.RUnlock()

	return argCopy
}

// MinimockBuildResponseDone returns true if the count of the BuildResponse invocations corresponds
// the number of defined expectations
func (m *HostNetworkMock) MinimockBuildResponseDone() bool {
	for _, e := range m.BuildResponseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BuildResponseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBuildResponseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBuildResponse != nil && mm_atomic.LoadUint64(&m.afterBuildResponseCounter) < 1 {
		return false
	}
	return true
}

// MinimockBuildResponseInspect logs each unmet expectation
func (m *HostNetworkMock) MinimockBuildResponseInspect() {
	for _, e := range m.BuildResponseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to HostNetworkMock.BuildResponse with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BuildResponseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBuildResponseCounter) < 1 {
		if m.BuildResponseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to HostNetworkMock.BuildResponse")
		} else {
			m.t.Errorf("Expected call to HostNetworkMock.BuildResponse with params: %#v", *m.BuildResponseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBuildResponse != nil && mm_atomic.LoadUint64(&m.afterBuildResponseCounter) < 1 {
		m.t.Error("Expected call to HostNetworkMock.BuildResponse")
	}
}

type mHostNetworkMockPublicAddress struct {
	mock               *HostNetworkMock
	defaultExpectation *HostNetworkMockPublicAddressExpectation
	expectations       []*HostNetworkMockPublicAddressExpectation
}

// HostNetworkMockPublicAddressExpectation specifies expectation struct of the HostNetwork.PublicAddress
type HostNetworkMockPublicAddressExpectation struct {
	mock *HostNetworkMock

	results *HostNetworkMockPublicAddressResults
	Counter uint64
}

// HostNetworkMockPublicAddressResults contains results of the HostNetwork.PublicAddress
type HostNetworkMockPublicAddressResults struct {
	s1 string
}

// Expect sets up expected params for HostNetwork.PublicAddress
func (mmPublicAddress *mHostNetworkMockPublicAddress) Expect() *mHostNetworkMockPublicAddress {
	if mmPublicAddress.mock.funcPublicAddress != nil {
		mmPublicAddress.mock.t.Fatalf("HostNetworkMock.PublicAddress mock is already set by Set")
	}

	if mmPublicAddress.defaultExpectation == nil {
		mmPublicAddress.defaultExpectation = &HostNetworkMockPublicAddressExpectation{}
	}

	return mmPublicAddress
}

// Inspect accepts an inspector function that has same arguments as the HostNetwork.PublicAddress
func (mmPublicAddress *mHostNetworkMockPublicAddress) Inspect(f func()) *mHostNetworkMockPublicAddress {
	if mmPublicAddress.mock.inspectFuncPublicAddress != nil {
		mmPublicAddress.mock.t.Fatalf("Inspect function is already set for HostNetworkMock.PublicAddress")
	}

	mmPublicAddress.mock.inspectFuncPublicAddress = f

	return mmPublicAddress
}

// Return sets up results that will be returned by HostNetwork.PublicAddress
func (mmPublicAddress *mHostNetworkMockPublicAddress) Return(s1 string) *HostNetworkMock {
	if mmPublicAddress.mock.funcPublicAddress != nil {
		mmPublicAddress.mock.t.Fatalf("HostNetworkMock.PublicAddress mock is already set by Set")
	}

	if mmPublicAddress.defaultExpectation == nil {
		mmPublicAddress.defaultExpectation = &HostNetworkMockPublicAddressExpectation{mock: mmPublicAddress.mock}
	}
	mmPublicAddress.defaultExpectation.results = &HostNetworkMockPublicAddressResults{s1}
	return mmPublicAddress.mock
}

//Set uses given function f to mock the HostNetwork.PublicAddress method
func (mmPublicAddress *mHostNetworkMockPublicAddress) Set(f func() (s1 string)) *HostNetworkMock {
	if mmPublicAddress.defaultExpectation != nil {
		mmPublicAddress.mock.t.Fatalf("Default expectation is already set for the HostNetwork.PublicAddress method")
	}

	if len(mmPublicAddress.expectations) > 0 {
		mmPublicAddress.mock.t.Fatalf("Some expectations are already set for the HostNetwork.PublicAddress method")
	}

	mmPublicAddress.mock.funcPublicAddress = f
	return mmPublicAddress.mock
}

// PublicAddress implements network.HostNetwork
func (mmPublicAddress *HostNetworkMock) PublicAddress() (s1 string) {
	mm_atomic.AddUint64(&mmPublicAddress.beforePublicAddressCounter, 1)
	defer mm_atomic.AddUint64(&mmPublicAddress.afterPublicAddressCounter, 1)

	if mmPublicAddress.inspectFuncPublicAddress != nil {
		mmPublicAddress.inspectFuncPublicAddress()
	}

	if mmPublicAddress.PublicAddressMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPublicAddress.PublicAddressMock.defaultExpectation.Counter, 1)

		results := mmPublicAddress.PublicAddressMock.defaultExpectation.results
		if results == nil {
			mmPublicAddress.t.Fatal("No results are set for the HostNetworkMock.PublicAddress")
		}
		return (*results).s1
	}
	if mmPublicAddress.funcPublicAddress != nil {
		return mmPublicAddress.funcPublicAddress()
	}
	mmPublicAddress.t.Fatalf("Unexpected call to HostNetworkMock.PublicAddress.")
	return
}

// PublicAddressAfterCounter returns a count of finished HostNetworkMock.PublicAddress invocations
func (mmPublicAddress *HostNetworkMock) PublicAddressAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublicAddress.afterPublicAddressCounter)
}

// PublicAddressBeforeCounter returns a count of HostNetworkMock.PublicAddress invocations
func (mmPublicAddress *HostNetworkMock) PublicAddressBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublicAddress.beforePublicAddressCounter)
}

// MinimockPublicAddressDone returns true if the count of the PublicAddress invocations corresponds
// the number of defined expectations
func (m *HostNetworkMock) MinimockPublicAddressDone() bool {
	for _, e := range m.PublicAddressMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PublicAddressMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPublicAddressCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublicAddress != nil && mm_atomic.LoadUint64(&m.afterPublicAddressCounter) < 1 {
		return false
	}
	return true
}

// MinimockPublicAddressInspect logs each unmet expectation
func (m *HostNetworkMock) MinimockPublicAddressInspect() {
	for _, e := range m.PublicAddressMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to HostNetworkMock.PublicAddress")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PublicAddressMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPublicAddressCounter) < 1 {
		m.t.Error("Expected call to HostNetworkMock.PublicAddress")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublicAddress != nil && mm_atomic.LoadUint64(&m.afterPublicAddressCounter) < 1 {
		m.t.Error("Expected call to HostNetworkMock.PublicAddress")
	}
}

type mHostNetworkMockRegisterRequestHandler struct {
	mock               *HostNetworkMock
	defaultExpectation *HostNetworkMockRegisterRequestHandlerExpectation
	expectations       []*HostNetworkMockRegisterRequestHandlerExpectation

	callArgs []*HostNetworkMockRegisterRequestHandlerParams
	mutex    sync.RWMutex
}

// HostNetworkMockRegisterRequestHandlerExpectation specifies expectation struct of the HostNetwork.RegisterRequestHandler
type HostNetworkMockRegisterRequestHandlerExpectation struct {
	mock   *HostNetworkMock
	params *HostNetworkMockRegisterRequestHandlerParams

	Counter uint64
}

// HostNetworkMockRegisterRequestHandlerParams contains parameters of the HostNetwork.RegisterRequestHandler
type HostNetworkMockRegisterRequestHandlerParams struct {
	t       types.PacketType
	handler mm_network.RequestHandler
}

// Expect sets up expected params for HostNetwork.RegisterRequestHandler
func (mmRegisterRequestHandler *mHostNetworkMockRegisterRequestHandler) Expect(t types.PacketType, handler mm_network.RequestHandler) *mHostNetworkMockRegisterRequestHandler {
	if mmRegisterRequestHandler.mock.funcRegisterRequestHandler != nil {
		mmRegisterRequestHandler.mock.t.Fatalf("HostNetworkMock.RegisterRequestHandler mock is already set by Set")
	}

	if mmRegisterRequestHandler.defaultExpectation == nil {
		mmRegisterRequestHandler.defaultExpectation = &HostNetworkMockRegisterRequestHandlerExpectation{}
	}

	mmRegisterRequestHandler.defaultExpectation.params = &HostNetworkMockRegisterRequestHandlerParams{t, handler}
	for _, e := range mmRegisterRequestHandler.expectations {
		if minimock.Equal(e.params, mmRegisterRequestHandler.defaultExpectation.params) {
			mmRegisterRequestHandler.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegisterRequestHandler.defaultExpectation.params)
		}
	}

	return mmRegisterRequestHandler
}

// Inspect accepts an inspector function that has same arguments as the HostNetwork.RegisterRequestHandler
func (mmRegisterRequestHandler *mHostNetworkMockRegisterRequestHandler) Inspect(f func(t types.PacketType, handler mm_network.RequestHandler)) *mHostNetworkMockRegisterRequestHandler {
	if mmRegisterRequestHandler.mock.inspectFuncRegisterRequestHandler != nil {
		mmRegisterRequestHandler.mock.t.Fatalf("Inspect function is already set for HostNetworkMock.RegisterRequestHandler")
	}

	mmRegisterRequestHandler.mock.inspectFuncRegisterRequestHandler = f

	return mmRegisterRequestHandler
}

// Return sets up results that will be returned by HostNetwork.RegisterRequestHandler
func (mmRegisterRequestHandler *mHostNetworkMockRegisterRequestHandler) Return() *HostNetworkMock {
	if mmRegisterRequestHandler.mock.funcRegisterRequestHandler != nil {
		mmRegisterRequestHandler.mock.t.Fatalf("HostNetworkMock.RegisterRequestHandler mock is already set by Set")
	}

	if mmRegisterRequestHandler.defaultExpectation == nil {
		mmRegisterRequestHandler.defaultExpectation = &HostNetworkMockRegisterRequestHandlerExpectation{mock: mmRegisterRequestHandler.mock}
	}

	return mmRegisterRequestHandler.mock
}

//Set uses given function f to mock the HostNetwork.RegisterRequestHandler method
func (mmRegisterRequestHandler *mHostNetworkMockRegisterRequestHandler) Set(f func(t types.PacketType, handler mm_network.RequestHandler)) *HostNetworkMock {
	if mmRegisterRequestHandler.defaultExpectation != nil {
		mmRegisterRequestHandler.mock.t.Fatalf("Default expectation is already set for the HostNetwork.RegisterRequestHandler method")
	}

	if len(mmRegisterRequestHandler.expectations) > 0 {
		mmRegisterRequestHandler.mock.t.Fatalf("Some expectations are already set for the HostNetwork.RegisterRequestHandler method")
	}

	mmRegisterRequestHandler.mock.funcRegisterRequestHandler = f
	return mmRegisterRequestHandler.mock
}

// RegisterRequestHandler implements network.HostNetwork
func (mmRegisterRequestHandler *HostNetworkMock) RegisterRequestHandler(t types.PacketType, handler mm_network.RequestHandler) {
	mm_atomic.AddUint64(&mmRegisterRequestHandler.beforeRegisterRequestHandlerCounter, 1)
	defer mm_atomic.AddUint64(&mmRegisterRequestHandler.afterRegisterRequestHandlerCounter, 1)

	if mmRegisterRequestHandler.inspectFuncRegisterRequestHandler != nil {
		mmRegisterRequestHandler.inspectFuncRegisterRequestHandler(t, handler)
	}

	params := &HostNetworkMockRegisterRequestHandlerParams{t, handler}

	// Record call args
	mmRegisterRequestHandler.RegisterRequestHandlerMock.mutex.Lock()
	mmRegisterRequestHandler.RegisterRequestHandlerMock.callArgs = append(mmRegisterRequestHandler.RegisterRequestHandlerMock.callArgs, params)
	mmRegisterRequestHandler.RegisterRequestHandlerMock.mutex.Unlock()

	for _, e := range mmRegisterRequestHandler.RegisterRequestHandlerMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmRegisterRequestHandler.RegisterRequestHandlerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegisterRequestHandler.RegisterRequestHandlerMock.defaultExpectation.Counter, 1)
		want := mmRegisterRequestHandler.RegisterRequestHandlerMock.defaultExpectation.params
		got := HostNetworkMockRegisterRequestHandlerParams{t, handler}
		if want != nil && !minimock.Equal(*want, got) {
			mmRegisterRequestHandler.t.Errorf("HostNetworkMock.RegisterRequestHandler got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmRegisterRequestHandler.funcRegisterRequestHandler != nil {
		mmRegisterRequestHandler.funcRegisterRequestHandler(t, handler)
		return
	}
	mmRegisterRequestHandler.t.Fatalf("Unexpected call to HostNetworkMock.RegisterRequestHandler. %v %v", t, handler)

}

// RegisterRequestHandlerAfterCounter returns a count of finished HostNetworkMock.RegisterRequestHandler invocations
func (mmRegisterRequestHandler *HostNetworkMock) RegisterRequestHandlerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterRequestHandler.afterRegisterRequestHandlerCounter)
}

// RegisterRequestHandlerBeforeCounter returns a count of HostNetworkMock.RegisterRequestHandler invocations
func (mmRegisterRequestHandler *HostNetworkMock) RegisterRequestHandlerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterRequestHandler.beforeRegisterRequestHandlerCounter)
}

// Calls returns a list of arguments used in each call to HostNetworkMock.RegisterRequestHandler.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegisterRequestHandler *mHostNetworkMockRegisterRequestHandler) Calls() []*HostNetworkMockRegisterRequestHandlerParams {
	mmRegisterRequestHandler.mutex.RLock()

	argCopy := make([]*HostNetworkMockRegisterRequestHandlerParams, len(mmRegisterRequestHandler.callArgs))
	copy(argCopy, mmRegisterRequestHandler.callArgs)

	mmRegisterRequestHandler.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterRequestHandlerDone returns true if the count of the RegisterRequestHandler invocations corresponds
// the number of defined expectations
func (m *HostNetworkMock) MinimockRegisterRequestHandlerDone() bool {
	for _, e := range m.RegisterRequestHandlerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterRequestHandlerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterRequestHandlerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterRequestHandler != nil && mm_atomic.LoadUint64(&m.afterRegisterRequestHandlerCounter) < 1 {
		return false
	}
	return true
}

// MinimockRegisterRequestHandlerInspect logs each unmet expectation
func (m *HostNetworkMock) MinimockRegisterRequestHandlerInspect() {
	for _, e := range m.RegisterRequestHandlerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to HostNetworkMock.RegisterRequestHandler with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterRequestHandlerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterRequestHandlerCounter) < 1 {
		if m.RegisterRequestHandlerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to HostNetworkMock.RegisterRequestHandler")
		} else {
			m.t.Errorf("Expected call to HostNetworkMock.RegisterRequestHandler with params: %#v", *m.RegisterRequestHandlerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterRequestHandler != nil && mm_atomic.LoadUint64(&m.afterRegisterRequestHandlerCounter) < 1 {
		m.t.Error("Expected call to HostNetworkMock.RegisterRequestHandler")
	}
}

type mHostNetworkMockSendRequest struct {
	mock               *HostNetworkMock
	defaultExpectation *HostNetworkMockSendRequestExpectation
	expectations       []*HostNetworkMockSendRequestExpectation

	callArgs []*HostNetworkMockSendRequestParams
	mutex    sync.RWMutex
}

// HostNetworkMockSendRequestExpectation specifies expectation struct of the HostNetwork.SendRequest
type HostNetworkMockSendRequestExpectation struct {
	mock    *HostNetworkMock
	params  *HostNetworkMockSendRequestParams
	results *HostNetworkMockSendRequestResults
	Counter uint64
}

// HostNetworkMockSendRequestParams contains parameters of the HostNetwork.SendRequest
type HostNetworkMockSendRequestParams struct {
	ctx         context.Context
	t           types.PacketType
	requestData interface{}
	receiver    insolar.Reference
}

// HostNetworkMockSendRequestResults contains results of the HostNetwork.SendRequest
type HostNetworkMockSendRequestResults struct {
	f1  mm_network.Future
	err error
}

// Expect sets up expected params for HostNetwork.SendRequest
func (mmSendRequest *mHostNetworkMockSendRequest) Expect(ctx context.Context, t types.PacketType, requestData interface{}, receiver insolar.Reference) *mHostNetworkMockSendRequest {
	if mmSendRequest.mock.funcSendRequest != nil {
		mmSendRequest.mock.t.Fatalf("HostNetworkMock.SendRequest mock is already set by Set")
	}

	if mmSendRequest.defaultExpectation == nil {
		mmSendRequest.defaultExpectation = &HostNetworkMockSendRequestExpectation{}
	}

	mmSendRequest.defaultExpectation.params = &HostNetworkMockSendRequestParams{ctx, t, requestData, receiver}
	for _, e := range mmSendRequest.expectations {
		if minimock.Equal(e.params, mmSendRequest.defaultExpectation.params) {
			mmSendRequest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendRequest.defaultExpectation.params)
		}
	}

	return mmSendRequest
}

// Inspect accepts an inspector function that has same arguments as the HostNetwork.SendRequest
func (mmSendRequest *mHostNetworkMockSendRequest) Inspect(f func(ctx context.Context, t types.PacketType, requestData interface{}, receiver insolar.Reference)) *mHostNetworkMockSendRequest {
	if mmSendRequest.mock.inspectFuncSendRequest != nil {
		mmSendRequest.mock.t.Fatalf("Inspect function is already set for HostNetworkMock.SendRequest")
	}

	mmSendRequest.mock.inspectFuncSendRequest = f

	return mmSendRequest
}

// Return sets up results that will be returned by HostNetwork.SendRequest
func (mmSendRequest *mHostNetworkMockSendRequest) Return(f1 mm_network.Future, err error) *HostNetworkMock {
	if mmSendRequest.mock.funcSendRequest != nil {
		mmSendRequest.mock.t.Fatalf("HostNetworkMock.SendRequest mock is already set by Set")
	}

	if mmSendRequest.defaultExpectation == nil {
		mmSendRequest.defaultExpectation = &HostNetworkMockSendRequestExpectation{mock: mmSendRequest.mock}
	}
	mmSendRequest.defaultExpectation.results = &HostNetworkMockSendRequestResults{f1, err}
	return mmSendRequest.mock
}

//Set uses given function f to mock the HostNetwork.SendRequest method
func (mmSendRequest *mHostNetworkMockSendRequest) Set(f func(ctx context.Context, t types.PacketType, requestData interface{}, receiver insolar.Reference) (f1 mm_network.Future, err error)) *HostNetworkMock {
	if mmSendRequest.defaultExpectation != nil {
		mmSendRequest.mock.t.Fatalf("Default expectation is already set for the HostNetwork.SendRequest method")
	}

	if len(mmSendRequest.expectations) > 0 {
		mmSendRequest.mock.t.Fatalf("Some expectations are already set for the HostNetwork.SendRequest method")
	}

	mmSendRequest.mock.funcSendRequest = f
	return mmSendRequest.mock
}

// When sets expectation for the HostNetwork.SendRequest which will trigger the result defined by the following
// Then helper
func (mmSendRequest *mHostNetworkMockSendRequest) When(ctx context.Context, t types.PacketType, requestData interface{}, receiver insolar.Reference) *HostNetworkMockSendRequestExpectation {
	if mmSendRequest.mock.funcSendRequest != nil {
		mmSendRequest.mock.t.Fatalf("HostNetworkMock.SendRequest mock is already set by Set")
	}

	expectation := &HostNetworkMockSendRequestExpectation{
		mock:   mmSendRequest.mock,
		params: &HostNetworkMockSendRequestParams{ctx, t, requestData, receiver},
	}
	mmSendRequest.expectations = append(mmSendRequest.expectations, expectation)
	return expectation
}

// Then sets up HostNetwork.SendRequest return parameters for the expectation previously defined by the When method
func (e *HostNetworkMockSendRequestExpectation) Then(f1 mm_network.Future, err error) *HostNetworkMock {
	e.results = &HostNetworkMockSendRequestResults{f1, err}
	return e.mock
}

// SendRequest implements network.HostNetwork
func (mmSendRequest *HostNetworkMock) SendRequest(ctx context.Context, t types.PacketType, requestData interface{}, receiver insolar.Reference) (f1 mm_network.Future, err error) {
	mm_atomic.AddUint64(&mmSendRequest.beforeSendRequestCounter, 1)
	defer mm_atomic.AddUint64(&mmSendRequest.afterSendRequestCounter, 1)

	if mmSendRequest.inspectFuncSendRequest != nil {
		mmSendRequest.inspectFuncSendRequest(ctx, t, requestData, receiver)
	}

	params := &HostNetworkMockSendRequestParams{ctx, t, requestData, receiver}

	// Record call args
	mmSendRequest.SendRequestMock.mutex.Lock()
	mmSendRequest.SendRequestMock.callArgs = append(mmSendRequest.SendRequestMock.callArgs, params)
	mmSendRequest.SendRequestMock.mutex.Unlock()

	for _, e := range mmSendRequest.SendRequestMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.f1, e.results.err
		}
	}

	if mmSendRequest.SendRequestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendRequest.SendRequestMock.defaultExpectation.Counter, 1)
		want := mmSendRequest.SendRequestMock.defaultExpectation.params
		got := HostNetworkMockSendRequestParams{ctx, t, requestData, receiver}
		if want != nil && !minimock.Equal(*want, got) {
			mmSendRequest.t.Errorf("HostNetworkMock.SendRequest got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmSendRequest.SendRequestMock.defaultExpectation.results
		if results == nil {
			mmSendRequest.t.Fatal("No results are set for the HostNetworkMock.SendRequest")
		}
		return (*results).f1, (*results).err
	}
	if mmSendRequest.funcSendRequest != nil {
		return mmSendRequest.funcSendRequest(ctx, t, requestData, receiver)
	}
	mmSendRequest.t.Fatalf("Unexpected call to HostNetworkMock.SendRequest. %v %v %v %v", ctx, t, requestData, receiver)
	return
}

// SendRequestAfterCounter returns a count of finished HostNetworkMock.SendRequest invocations
func (mmSendRequest *HostNetworkMock) SendRequestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendRequest.afterSendRequestCounter)
}

// SendRequestBeforeCounter returns a count of HostNetworkMock.SendRequest invocations
func (mmSendRequest *HostNetworkMock) SendRequestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendRequest.beforeSendRequestCounter)
}

// Calls returns a list of arguments used in each call to HostNetworkMock.SendRequest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendRequest *mHostNetworkMockSendRequest) Calls() []*HostNetworkMockSendRequestParams {
	mmSendRequest.mutex.RLock()

	argCopy := make([]*HostNetworkMockSendRequestParams, len(mmSendRequest.callArgs))
	copy(argCopy, mmSendRequest.callArgs)

	mmSendRequest.mutex.RUnlock()

	return argCopy
}

// MinimockSendRequestDone returns true if the count of the SendRequest invocations corresponds
// the number of defined expectations
func (m *HostNetworkMock) MinimockSendRequestDone() bool {
	for _, e := range m.SendRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendRequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendRequestCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendRequest != nil && mm_atomic.LoadUint64(&m.afterSendRequestCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendRequestInspect logs each unmet expectation
func (m *HostNetworkMock) MinimockSendRequestInspect() {
	for _, e := range m.SendRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to HostNetworkMock.SendRequest with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendRequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendRequestCounter) < 1 {
		if m.SendRequestMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to HostNetworkMock.SendRequest")
		} else {
			m.t.Errorf("Expected call to HostNetworkMock.SendRequest with params: %#v", *m.SendRequestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendRequest != nil && mm_atomic.LoadUint64(&m.afterSendRequestCounter) < 1 {
		m.t.Error("Expected call to HostNetworkMock.SendRequest")
	}
}

type mHostNetworkMockSendRequestToHost struct {
	mock               *HostNetworkMock
	defaultExpectation *HostNetworkMockSendRequestToHostExpectation
	expectations       []*HostNetworkMockSendRequestToHostExpectation

	callArgs []*HostNetworkMockSendRequestToHostParams
	mutex    sync.RWMutex
}

// HostNetworkMockSendRequestToHostExpectation specifies expectation struct of the HostNetwork.SendRequestToHost
type HostNetworkMockSendRequestToHostExpectation struct {
	mock    *HostNetworkMock
	params  *HostNetworkMockSendRequestToHostParams
	results *HostNetworkMockSendRequestToHostResults
	Counter uint64
}

// HostNetworkMockSendRequestToHostParams contains parameters of the HostNetwork.SendRequestToHost
type HostNetworkMockSendRequestToHostParams struct {
	ctx         context.Context
	t           types.PacketType
	requestData interface{}
	receiver    *host.Host
}

// HostNetworkMockSendRequestToHostResults contains results of the HostNetwork.SendRequestToHost
type HostNetworkMockSendRequestToHostResults struct {
	f1  mm_network.Future
	err error
}

// Expect sets up expected params for HostNetwork.SendRequestToHost
func (mmSendRequestToHost *mHostNetworkMockSendRequestToHost) Expect(ctx context.Context, t types.PacketType, requestData interface{}, receiver *host.Host) *mHostNetworkMockSendRequestToHost {
	if mmSendRequestToHost.mock.funcSendRequestToHost != nil {
		mmSendRequestToHost.mock.t.Fatalf("HostNetworkMock.SendRequestToHost mock is already set by Set")
	}

	if mmSendRequestToHost.defaultExpectation == nil {
		mmSendRequestToHost.defaultExpectation = &HostNetworkMockSendRequestToHostExpectation{}
	}

	mmSendRequestToHost.defaultExpectation.params = &HostNetworkMockSendRequestToHostParams{ctx, t, requestData, receiver}
	for _, e := range mmSendRequestToHost.expectations {
		if minimock.Equal(e.params, mmSendRequestToHost.defaultExpectation.params) {
			mmSendRequestToHost.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendRequestToHost.defaultExpectation.params)
		}
	}

	return mmSendRequestToHost
}

// Inspect accepts an inspector function that has same arguments as the HostNetwork.SendRequestToHost
func (mmSendRequestToHost *mHostNetworkMockSendRequestToHost) Inspect(f func(ctx context.Context, t types.PacketType, requestData interface{}, receiver *host.Host)) *mHostNetworkMockSendRequestToHost {
	if mmSendRequestToHost.mock.inspectFuncSendRequestToHost != nil {
		mmSendRequestToHost.mock.t.Fatalf("Inspect function is already set for HostNetworkMock.SendRequestToHost")
	}

	mmSendRequestToHost.mock.inspectFuncSendRequestToHost = f

	return mmSendRequestToHost
}

// Return sets up results that will be returned by HostNetwork.SendRequestToHost
func (mmSendRequestToHost *mHostNetworkMockSendRequestToHost) Return(f1 mm_network.Future, err error) *HostNetworkMock {
	if mmSendRequestToHost.mock.funcSendRequestToHost != nil {
		mmSendRequestToHost.mock.t.Fatalf("HostNetworkMock.SendRequestToHost mock is already set by Set")
	}

	if mmSendRequestToHost.defaultExpectation == nil {
		mmSendRequestToHost.defaultExpectation = &HostNetworkMockSendRequestToHostExpectation{mock: mmSendRequestToHost.mock}
	}
	mmSendRequestToHost.defaultExpectation.results = &HostNetworkMockSendRequestToHostResults{f1, err}
	return mmSendRequestToHost.mock
}

//Set uses given function f to mock the HostNetwork.SendRequestToHost method
func (mmSendRequestToHost *mHostNetworkMockSendRequestToHost) Set(f func(ctx context.Context, t types.PacketType, requestData interface{}, receiver *host.Host) (f1 mm_network.Future, err error)) *HostNetworkMock {
	if mmSendRequestToHost.defaultExpectation != nil {
		mmSendRequestToHost.mock.t.Fatalf("Default expectation is already set for the HostNetwork.SendRequestToHost method")
	}

	if len(mmSendRequestToHost.expectations) > 0 {
		mmSendRequestToHost.mock.t.Fatalf("Some expectations are already set for the HostNetwork.SendRequestToHost method")
	}

	mmSendRequestToHost.mock.funcSendRequestToHost = f
	return mmSendRequestToHost.mock
}

// When sets expectation for the HostNetwork.SendRequestToHost which will trigger the result defined by the following
// Then helper
func (mmSendRequestToHost *mHostNetworkMockSendRequestToHost) When(ctx context.Context, t types.PacketType, requestData interface{}, receiver *host.Host) *HostNetworkMockSendRequestToHostExpectation {
	if mmSendRequestToHost.mock.funcSendRequestToHost != nil {
		mmSendRequestToHost.mock.t.Fatalf("HostNetworkMock.SendRequestToHost mock is already set by Set")
	}

	expectation := &HostNetworkMockSendRequestToHostExpectation{
		mock:   mmSendRequestToHost.mock,
		params: &HostNetworkMockSendRequestToHostParams{ctx, t, requestData, receiver},
	}
	mmSendRequestToHost.expectations = append(mmSendRequestToHost.expectations, expectation)
	return expectation
}

// Then sets up HostNetwork.SendRequestToHost return parameters for the expectation previously defined by the When method
func (e *HostNetworkMockSendRequestToHostExpectation) Then(f1 mm_network.Future, err error) *HostNetworkMock {
	e.results = &HostNetworkMockSendRequestToHostResults{f1, err}
	return e.mock
}

// SendRequestToHost implements network.HostNetwork
func (mmSendRequestToHost *HostNetworkMock) SendRequestToHost(ctx context.Context, t types.PacketType, requestData interface{}, receiver *host.Host) (f1 mm_network.Future, err error) {
	mm_atomic.AddUint64(&mmSendRequestToHost.beforeSendRequestToHostCounter, 1)
	defer mm_atomic.AddUint64(&mmSendRequestToHost.afterSendRequestToHostCounter, 1)

	if mmSendRequestToHost.inspectFuncSendRequestToHost != nil {
		mmSendRequestToHost.inspectFuncSendRequestToHost(ctx, t, requestData, receiver)
	}

	params := &HostNetworkMockSendRequestToHostParams{ctx, t, requestData, receiver}

	// Record call args
	mmSendRequestToHost.SendRequestToHostMock.mutex.Lock()
	mmSendRequestToHost.SendRequestToHostMock.callArgs = append(mmSendRequestToHost.SendRequestToHostMock.callArgs, params)
	mmSendRequestToHost.SendRequestToHostMock.mutex.Unlock()

	for _, e := range mmSendRequestToHost.SendRequestToHostMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.f1, e.results.err
		}
	}

	if mmSendRequestToHost.SendRequestToHostMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendRequestToHost.SendRequestToHostMock.defaultExpectation.Counter, 1)
		want := mmSendRequestToHost.SendRequestToHostMock.defaultExpectation.params
		got := HostNetworkMockSendRequestToHostParams{ctx, t, requestData, receiver}
		if want != nil && !minimock.Equal(*want, got) {
			mmSendRequestToHost.t.Errorf("HostNetworkMock.SendRequestToHost got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmSendRequestToHost.SendRequestToHostMock.defaultExpectation.results
		if results == nil {
			mmSendRequestToHost.t.Fatal("No results are set for the HostNetworkMock.SendRequestToHost")
		}
		return (*results).f1, (*results).err
	}
	if mmSendRequestToHost.funcSendRequestToHost != nil {
		return mmSendRequestToHost.funcSendRequestToHost(ctx, t, requestData, receiver)
	}
	mmSendRequestToHost.t.Fatalf("Unexpected call to HostNetworkMock.SendRequestToHost. %v %v %v %v", ctx, t, requestData, receiver)
	return
}

// SendRequestToHostAfterCounter returns a count of finished HostNetworkMock.SendRequestToHost invocations
func (mmSendRequestToHost *HostNetworkMock) SendRequestToHostAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendRequestToHost.afterSendRequestToHostCounter)
}

// SendRequestToHostBeforeCounter returns a count of HostNetworkMock.SendRequestToHost invocations
func (mmSendRequestToHost *HostNetworkMock) SendRequestToHostBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendRequestToHost.beforeSendRequestToHostCounter)
}

// Calls returns a list of arguments used in each call to HostNetworkMock.SendRequestToHost.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendRequestToHost *mHostNetworkMockSendRequestToHost) Calls() []*HostNetworkMockSendRequestToHostParams {
	mmSendRequestToHost.mutex.RLock()

	argCopy := make([]*HostNetworkMockSendRequestToHostParams, len(mmSendRequestToHost.callArgs))
	copy(argCopy, mmSendRequestToHost.callArgs)

	mmSendRequestToHost.mutex.RUnlock()

	return argCopy
}

// MinimockSendRequestToHostDone returns true if the count of the SendRequestToHost invocations corresponds
// the number of defined expectations
func (m *HostNetworkMock) MinimockSendRequestToHostDone() bool {
	for _, e := range m.SendRequestToHostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendRequestToHostMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendRequestToHostCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendRequestToHost != nil && mm_atomic.LoadUint64(&m.afterSendRequestToHostCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendRequestToHostInspect logs each unmet expectation
func (m *HostNetworkMock) MinimockSendRequestToHostInspect() {
	for _, e := range m.SendRequestToHostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to HostNetworkMock.SendRequestToHost with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendRequestToHostMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendRequestToHostCounter) < 1 {
		if m.SendRequestToHostMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to HostNetworkMock.SendRequestToHost")
		} else {
			m.t.Errorf("Expected call to HostNetworkMock.SendRequestToHost with params: %#v", *m.SendRequestToHostMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendRequestToHost != nil && mm_atomic.LoadUint64(&m.afterSendRequestToHostCounter) < 1 {
		m.t.Error("Expected call to HostNetworkMock.SendRequestToHost")
	}
}

type mHostNetworkMockStart struct {
	mock               *HostNetworkMock
	defaultExpectation *HostNetworkMockStartExpectation
	expectations       []*HostNetworkMockStartExpectation

	callArgs []*HostNetworkMockStartParams
	mutex    sync.RWMutex
}

// HostNetworkMockStartExpectation specifies expectation struct of the HostNetwork.Start
type HostNetworkMockStartExpectation struct {
	mock    *HostNetworkMock
	params  *HostNetworkMockStartParams
	results *HostNetworkMockStartResults
	Counter uint64
}

// HostNetworkMockStartParams contains parameters of the HostNetwork.Start
type HostNetworkMockStartParams struct {
	ctx context.Context
}

// HostNetworkMockStartResults contains results of the HostNetwork.Start
type HostNetworkMockStartResults struct {
	err error
}

// Expect sets up expected params for HostNetwork.Start
func (mmStart *mHostNetworkMockStart) Expect(ctx context.Context) *mHostNetworkMockStart {
	if mmStart.mock.funcStart != nil {
		mmStart.mock.t.Fatalf("HostNetworkMock.Start mock is already set by Set")
	}

	if mmStart.defaultExpectation == nil {
		mmStart.defaultExpectation = &HostNetworkMockStartExpectation{}
	}

	mmStart.defaultExpectation.params = &HostNetworkMockStartParams{ctx}
	for _, e := range mmStart.expectations {
		if minimock.Equal(e.params, mmStart.defaultExpectation.params) {
			mmStart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStart.defaultExpectation.params)
		}
	}

	return mmStart
}

// Inspect accepts an inspector function that has same arguments as the HostNetwork.Start
func (mmStart *mHostNetworkMockStart) Inspect(f func(ctx context.Context)) *mHostNetworkMockStart {
	if mmStart.mock.inspectFuncStart != nil {
		mmStart.mock.t.Fatalf("Inspect function is already set for HostNetworkMock.Start")
	}

	mmStart.mock.inspectFuncStart = f

	return mmStart
}

// Return sets up results that will be returned by HostNetwork.Start
func (mmStart *mHostNetworkMockStart) Return(err error) *HostNetworkMock {
	if mmStart.mock.funcStart != nil {
		mmStart.mock.t.Fatalf("HostNetworkMock.Start mock is already set by Set")
	}

	if mmStart.defaultExpectation == nil {
		mmStart.defaultExpectation = &HostNetworkMockStartExpectation{mock: mmStart.mock}
	}
	mmStart.defaultExpectation.results = &HostNetworkMockStartResults{err}
	return mmStart.mock
}

//Set uses given function f to mock the HostNetwork.Start method
func (mmStart *mHostNetworkMockStart) Set(f func(ctx context.Context) (err error)) *HostNetworkMock {
	if mmStart.defaultExpectation != nil {
		mmStart.mock.t.Fatalf("Default expectation is already set for the HostNetwork.Start method")
	}

	if len(mmStart.expectations) > 0 {
		mmStart.mock.t.Fatalf("Some expectations are already set for the HostNetwork.Start method")
	}

	mmStart.mock.funcStart = f
	return mmStart.mock
}

// When sets expectation for the HostNetwork.Start which will trigger the result defined by the following
// Then helper
func (mmStart *mHostNetworkMockStart) When(ctx context.Context) *HostNetworkMockStartExpectation {
	if mmStart.mock.funcStart != nil {
		mmStart.mock.t.Fatalf("HostNetworkMock.Start mock is already set by Set")
	}

	expectation := &HostNetworkMockStartExpectation{
		mock:   mmStart.mock,
		params: &HostNetworkMockStartParams{ctx},
	}
	mmStart.expectations = append(mmStart.expectations, expectation)
	return expectation
}

// Then sets up HostNetwork.Start return parameters for the expectation previously defined by the When method
func (e *HostNetworkMockStartExpectation) Then(err error) *HostNetworkMock {
	e.results = &HostNetworkMockStartResults{err}
	return e.mock
}

// Start implements network.HostNetwork
func (mmStart *HostNetworkMock) Start(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmStart.beforeStartCounter, 1)
	defer mm_atomic.AddUint64(&mmStart.afterStartCounter, 1)

	if mmStart.inspectFuncStart != nil {
		mmStart.inspectFuncStart(ctx)
	}

	params := &HostNetworkMockStartParams{ctx}

	// Record call args
	mmStart.StartMock.mutex.Lock()
	mmStart.StartMock.callArgs = append(mmStart.StartMock.callArgs, params)
	mmStart.StartMock.mutex.Unlock()

	for _, e := range mmStart.StartMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmStart.StartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStart.StartMock.defaultExpectation.Counter, 1)
		want := mmStart.StartMock.defaultExpectation.params
		got := HostNetworkMockStartParams{ctx}
		if want != nil && !minimock.Equal(*want, got) {
			mmStart.t.Errorf("HostNetworkMock.Start got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmStart.StartMock.defaultExpectation.results
		if results == nil {
			mmStart.t.Fatal("No results are set for the HostNetworkMock.Start")
		}
		return (*results).err
	}
	if mmStart.funcStart != nil {
		return mmStart.funcStart(ctx)
	}
	mmStart.t.Fatalf("Unexpected call to HostNetworkMock.Start. %v", ctx)
	return
}

// StartAfterCounter returns a count of finished HostNetworkMock.Start invocations
func (mmStart *HostNetworkMock) StartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStart.afterStartCounter)
}

// StartBeforeCounter returns a count of HostNetworkMock.Start invocations
func (mmStart *HostNetworkMock) StartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStart.beforeStartCounter)
}

// Calls returns a list of arguments used in each call to HostNetworkMock.Start.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStart *mHostNetworkMockStart) Calls() []*HostNetworkMockStartParams {
	mmStart.mutex.RLock()

	argCopy := make([]*HostNetworkMockStartParams, len(mmStart.callArgs))
	copy(argCopy, mmStart.callArgs)

	mmStart.mutex.RUnlock()

	return argCopy
}

// MinimockStartDone returns true if the count of the Start invocations corresponds
// the number of defined expectations
func (m *HostNetworkMock) MinimockStartDone() bool {
	for _, e := range m.StartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStart != nil && mm_atomic.LoadUint64(&m.afterStartCounter) < 1 {
		return false
	}
	return true
}

// MinimockStartInspect logs each unmet expectation
func (m *HostNetworkMock) MinimockStartInspect() {
	for _, e := range m.StartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to HostNetworkMock.Start with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStartCounter) < 1 {
		if m.StartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to HostNetworkMock.Start")
		} else {
			m.t.Errorf("Expected call to HostNetworkMock.Start with params: %#v", *m.StartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStart != nil && mm_atomic.LoadUint64(&m.afterStartCounter) < 1 {
		m.t.Error("Expected call to HostNetworkMock.Start")
	}
}

type mHostNetworkMockStop struct {
	mock               *HostNetworkMock
	defaultExpectation *HostNetworkMockStopExpectation
	expectations       []*HostNetworkMockStopExpectation

	callArgs []*HostNetworkMockStopParams
	mutex    sync.RWMutex
}

// HostNetworkMockStopExpectation specifies expectation struct of the HostNetwork.Stop
type HostNetworkMockStopExpectation struct {
	mock    *HostNetworkMock
	params  *HostNetworkMockStopParams
	results *HostNetworkMockStopResults
	Counter uint64
}

// HostNetworkMockStopParams contains parameters of the HostNetwork.Stop
type HostNetworkMockStopParams struct {
	ctx context.Context
}

// HostNetworkMockStopResults contains results of the HostNetwork.Stop
type HostNetworkMockStopResults struct {
	err error
}

// Expect sets up expected params for HostNetwork.Stop
func (mmStop *mHostNetworkMockStop) Expect(ctx context.Context) *mHostNetworkMockStop {
	if mmStop.mock.funcStop != nil {
		mmStop.mock.t.Fatalf("HostNetworkMock.Stop mock is already set by Set")
	}

	if mmStop.defaultExpectation == nil {
		mmStop.defaultExpectation = &HostNetworkMockStopExpectation{}
	}

	mmStop.defaultExpectation.params = &HostNetworkMockStopParams{ctx}
	for _, e := range mmStop.expectations {
		if minimock.Equal(e.params, mmStop.defaultExpectation.params) {
			mmStop.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStop.defaultExpectation.params)
		}
	}

	return mmStop
}

// Inspect accepts an inspector function that has same arguments as the HostNetwork.Stop
func (mmStop *mHostNetworkMockStop) Inspect(f func(ctx context.Context)) *mHostNetworkMockStop {
	if mmStop.mock.inspectFuncStop != nil {
		mmStop.mock.t.Fatalf("Inspect function is already set for HostNetworkMock.Stop")
	}

	mmStop.mock.inspectFuncStop = f

	return mmStop
}

// Return sets up results that will be returned by HostNetwork.Stop
func (mmStop *mHostNetworkMockStop) Return(err error) *HostNetworkMock {
	if mmStop.mock.funcStop != nil {
		mmStop.mock.t.Fatalf("HostNetworkMock.Stop mock is already set by Set")
	}

	if mmStop.defaultExpectation == nil {
		mmStop.defaultExpectation = &HostNetworkMockStopExpectation{mock: mmStop.mock}
	}
	mmStop.defaultExpectation.results = &HostNetworkMockStopResults{err}
	return mmStop.mock
}

//Set uses given function f to mock the HostNetwork.Stop method
func (mmStop *mHostNetworkMockStop) Set(f func(ctx context.Context) (err error)) *HostNetworkMock {
	if mmStop.defaultExpectation != nil {
		mmStop.mock.t.Fatalf("Default expectation is already set for the HostNetwork.Stop method")
	}

	if len(mmStop.expectations) > 0 {
		mmStop.mock.t.Fatalf("Some expectations are already set for the HostNetwork.Stop method")
	}

	mmStop.mock.funcStop = f
	return mmStop.mock
}

// When sets expectation for the HostNetwork.Stop which will trigger the result defined by the following
// Then helper
func (mmStop *mHostNetworkMockStop) When(ctx context.Context) *HostNetworkMockStopExpectation {
	if mmStop.mock.funcStop != nil {
		mmStop.mock.t.Fatalf("HostNetworkMock.Stop mock is already set by Set")
	}

	expectation := &HostNetworkMockStopExpectation{
		mock:   mmStop.mock,
		params: &HostNetworkMockStopParams{ctx},
	}
	mmStop.expectations = append(mmStop.expectations, expectation)
	return expectation
}

// Then sets up HostNetwork.Stop return parameters for the expectation previously defined by the When method
func (e *HostNetworkMockStopExpectation) Then(err error) *HostNetworkMock {
	e.results = &HostNetworkMockStopResults{err}
	return e.mock
}

// Stop implements network.HostNetwork
func (mmStop *HostNetworkMock) Stop(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmStop.beforeStopCounter, 1)
	defer mm_atomic.AddUint64(&mmStop.afterStopCounter, 1)

	if mmStop.inspectFuncStop != nil {
		mmStop.inspectFuncStop(ctx)
	}

	params := &HostNetworkMockStopParams{ctx}

	// Record call args
	mmStop.StopMock.mutex.Lock()
	mmStop.StopMock.callArgs = append(mmStop.StopMock.callArgs, params)
	mmStop.StopMock.mutex.Unlock()

	for _, e := range mmStop.StopMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmStop.StopMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStop.StopMock.defaultExpectation.Counter, 1)
		want := mmStop.StopMock.defaultExpectation.params
		got := HostNetworkMockStopParams{ctx}
		if want != nil && !minimock.Equal(*want, got) {
			mmStop.t.Errorf("HostNetworkMock.Stop got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmStop.StopMock.defaultExpectation.results
		if results == nil {
			mmStop.t.Fatal("No results are set for the HostNetworkMock.Stop")
		}
		return (*results).err
	}
	if mmStop.funcStop != nil {
		return mmStop.funcStop(ctx)
	}
	mmStop.t.Fatalf("Unexpected call to HostNetworkMock.Stop. %v", ctx)
	return
}

// StopAfterCounter returns a count of finished HostNetworkMock.Stop invocations
func (mmStop *HostNetworkMock) StopAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStop.afterStopCounter)
}

// StopBeforeCounter returns a count of HostNetworkMock.Stop invocations
func (mmStop *HostNetworkMock) StopBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStop.beforeStopCounter)
}

// Calls returns a list of arguments used in each call to HostNetworkMock.Stop.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStop *mHostNetworkMockStop) Calls() []*HostNetworkMockStopParams {
	mmStop.mutex.RLock()

	argCopy := make([]*HostNetworkMockStopParams, len(mmStop.callArgs))
	copy(argCopy, mmStop.callArgs)

	mmStop.mutex.RUnlock()

	return argCopy
}

// MinimockStopDone returns true if the count of the Stop invocations corresponds
// the number of defined expectations
func (m *HostNetworkMock) MinimockStopDone() bool {
	for _, e := range m.StopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStop != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		return false
	}
	return true
}

// MinimockStopInspect logs each unmet expectation
func (m *HostNetworkMock) MinimockStopInspect() {
	for _, e := range m.StopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to HostNetworkMock.Stop with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		if m.StopMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to HostNetworkMock.Stop")
		} else {
			m.t.Errorf("Expected call to HostNetworkMock.Stop with params: %#v", *m.StopMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStop != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		m.t.Error("Expected call to HostNetworkMock.Stop")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *HostNetworkMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockBuildResponseInspect()

		m.MinimockPublicAddressInspect()

		m.MinimockRegisterRequestHandlerInspect()

		m.MinimockSendRequestInspect()

		m.MinimockSendRequestToHostInspect()

		m.MinimockStartInspect()

		m.MinimockStopInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *HostNetworkMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *HostNetworkMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBuildResponseDone() &&
		m.MinimockPublicAddressDone() &&
		m.MinimockRegisterRequestHandlerDone() &&
		m.MinimockSendRequestDone() &&
		m.MinimockSendRequestToHostDone() &&
		m.MinimockStartDone() &&
		m.MinimockStopDone()
}
