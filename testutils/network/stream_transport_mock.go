package network

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// StreamTransportMock implements transport.StreamTransport
type StreamTransportMock struct {
	t minimock.Tester

	funcAddress          func() (s1 string)
	inspectFuncAddress   func()
	afterAddressCounter  uint64
	beforeAddressCounter uint64
	AddressMock          mStreamTransportMockAddress

	funcDial          func(ctx context.Context, address string) (r1 io.ReadWriteCloser, err error)
	inspectFuncDial   func(ctx context.Context, address string)
	afterDialCounter  uint64
	beforeDialCounter uint64
	DialMock          mStreamTransportMockDial

	funcStart          func(ctx context.Context) (err error)
	inspectFuncStart   func(ctx context.Context)
	afterStartCounter  uint64
	beforeStartCounter uint64
	StartMock          mStreamTransportMockStart

	funcStop          func(ctx context.Context) (err error)
	inspectFuncStop   func(ctx context.Context)
	afterStopCounter  uint64
	beforeStopCounter uint64
	StopMock          mStreamTransportMockStop
}

// NewStreamTransportMock returns a mock for transport.StreamTransport
func NewStreamTransportMock(t minimock.Tester) *StreamTransportMock {
	m := &StreamTransportMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddressMock = mStreamTransportMockAddress{mock: m}

	m.DialMock = mStreamTransportMockDial{mock: m}
	m.DialMock.callArgs = []*StreamTransportMockDialParams{}

	m.StartMock = mStreamTransportMockStart{mock: m}
	m.StartMock.callArgs = []*StreamTransportMockStartParams{}

	m.StopMock = mStreamTransportMockStop{mock: m}
	m.StopMock.callArgs = []*StreamTransportMockStopParams{}

	return m
}

type mStreamTransportMockAddress struct {
	mock               *StreamTransportMock
	defaultExpectation *StreamTransportMockAddressExpectation
	expectations       []*StreamTransportMockAddressExpectation
}

// StreamTransportMockAddressExpectation specifies expectation struct of the StreamTransport.Address
type StreamTransportMockAddressExpectation struct {
	mock *StreamTransportMock

	results *StreamTransportMockAddressResults
	Counter uint64
}

// StreamTransportMockAddressResults contains results of the StreamTransport.Address
type StreamTransportMockAddressResults struct {
	s1 string
}

// Expect sets up expected params for StreamTransport.Address
func (mmAddress *mStreamTransportMockAddress) Expect() *mStreamTransportMockAddress {
	if mmAddress.mock.funcAddress != nil {
		mmAddress.mock.t.Fatalf("StreamTransportMock.Address mock is already set by Set")
	}

	if mmAddress.defaultExpectation == nil {
		mmAddress.defaultExpectation = &StreamTransportMockAddressExpectation{}
	}

	return mmAddress
}

// Inspect accepts an inspector function that has same arguments as the StreamTransport.Address
func (mmAddress *mStreamTransportMockAddress) Inspect(f func()) *mStreamTransportMockAddress {
	if mmAddress.mock.inspectFuncAddress != nil {
		mmAddress.mock.t.Fatalf("Inspect function is already set for StreamTransportMock.Address")
	}

	mmAddress.mock.inspectFuncAddress = f

	return mmAddress
}

// Return sets up results that will be returned by StreamTransport.Address
func (mmAddress *mStreamTransportMockAddress) Return(s1 string) *StreamTransportMock {
	if mmAddress.mock.funcAddress != nil {
		mmAddress.mock.t.Fatalf("StreamTransportMock.Address mock is already set by Set")
	}

	if mmAddress.defaultExpectation == nil {
		mmAddress.defaultExpectation = &StreamTransportMockAddressExpectation{mock: mmAddress.mock}
	}
	mmAddress.defaultExpectation.results = &StreamTransportMockAddressResults{s1}
	return mmAddress.mock
}

//Set uses given function f to mock the StreamTransport.Address method
func (mmAddress *mStreamTransportMockAddress) Set(f func() (s1 string)) *StreamTransportMock {
	if mmAddress.defaultExpectation != nil {
		mmAddress.mock.t.Fatalf("Default expectation is already set for the StreamTransport.Address method")
	}

	if len(mmAddress.expectations) > 0 {
		mmAddress.mock.t.Fatalf("Some expectations are already set for the StreamTransport.Address method")
	}

	mmAddress.mock.funcAddress = f
	return mmAddress.mock
}

// Address implements transport.StreamTransport
func (mmAddress *StreamTransportMock) Address() (s1 string) {
	mm_atomic.AddUint64(&mmAddress.beforeAddressCounter, 1)
	defer mm_atomic.AddUint64(&mmAddress.afterAddressCounter, 1)

	if mmAddress.inspectFuncAddress != nil {
		mmAddress.inspectFuncAddress()
	}

	if mmAddress.AddressMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddress.AddressMock.defaultExpectation.Counter, 1)

		mm_results := mmAddress.AddressMock.defaultExpectation.results
		if mm_results == nil {
			mmAddress.t.Fatal("No results are set for the StreamTransportMock.Address")
		}
		return (*mm_results).s1
	}
	if mmAddress.funcAddress != nil {
		return mmAddress.funcAddress()
	}
	mmAddress.t.Fatalf("Unexpected call to StreamTransportMock.Address.")
	return
}

// AddressAfterCounter returns a count of finished StreamTransportMock.Address invocations
func (mmAddress *StreamTransportMock) AddressAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddress.afterAddressCounter)
}

// AddressBeforeCounter returns a count of StreamTransportMock.Address invocations
func (mmAddress *StreamTransportMock) AddressBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddress.beforeAddressCounter)
}

// MinimockAddressDone returns true if the count of the Address invocations corresponds
// the number of defined expectations
func (m *StreamTransportMock) MinimockAddressDone() bool {
	for _, e := range m.AddressMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddressMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddressCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddress != nil && mm_atomic.LoadUint64(&m.afterAddressCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddressInspect logs each unmet expectation
func (m *StreamTransportMock) MinimockAddressInspect() {
	for _, e := range m.AddressMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StreamTransportMock.Address")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddressMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddressCounter) < 1 {
		m.t.Error("Expected call to StreamTransportMock.Address")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddress != nil && mm_atomic.LoadUint64(&m.afterAddressCounter) < 1 {
		m.t.Error("Expected call to StreamTransportMock.Address")
	}
}

type mStreamTransportMockDial struct {
	mock               *StreamTransportMock
	defaultExpectation *StreamTransportMockDialExpectation
	expectations       []*StreamTransportMockDialExpectation

	callArgs []*StreamTransportMockDialParams
	mutex    sync.RWMutex
}

// StreamTransportMockDialExpectation specifies expectation struct of the StreamTransport.Dial
type StreamTransportMockDialExpectation struct {
	mock    *StreamTransportMock
	params  *StreamTransportMockDialParams
	results *StreamTransportMockDialResults
	Counter uint64
}

// StreamTransportMockDialParams contains parameters of the StreamTransport.Dial
type StreamTransportMockDialParams struct {
	ctx     context.Context
	address string
}

// StreamTransportMockDialResults contains results of the StreamTransport.Dial
type StreamTransportMockDialResults struct {
	r1  io.ReadWriteCloser
	err error
}

// Expect sets up expected params for StreamTransport.Dial
func (mmDial *mStreamTransportMockDial) Expect(ctx context.Context, address string) *mStreamTransportMockDial {
	if mmDial.mock.funcDial != nil {
		mmDial.mock.t.Fatalf("StreamTransportMock.Dial mock is already set by Set")
	}

	if mmDial.defaultExpectation == nil {
		mmDial.defaultExpectation = &StreamTransportMockDialExpectation{}
	}

	mmDial.defaultExpectation.params = &StreamTransportMockDialParams{ctx, address}
	for _, e := range mmDial.expectations {
		if minimock.Equal(e.params, mmDial.defaultExpectation.params) {
			mmDial.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDial.defaultExpectation.params)
		}
	}

	return mmDial
}

// Inspect accepts an inspector function that has same arguments as the StreamTransport.Dial
func (mmDial *mStreamTransportMockDial) Inspect(f func(ctx context.Context, address string)) *mStreamTransportMockDial {
	if mmDial.mock.inspectFuncDial != nil {
		mmDial.mock.t.Fatalf("Inspect function is already set for StreamTransportMock.Dial")
	}

	mmDial.mock.inspectFuncDial = f

	return mmDial
}

// Return sets up results that will be returned by StreamTransport.Dial
func (mmDial *mStreamTransportMockDial) Return(r1 io.ReadWriteCloser, err error) *StreamTransportMock {
	if mmDial.mock.funcDial != nil {
		mmDial.mock.t.Fatalf("StreamTransportMock.Dial mock is already set by Set")
	}

	if mmDial.defaultExpectation == nil {
		mmDial.defaultExpectation = &StreamTransportMockDialExpectation{mock: mmDial.mock}
	}
	mmDial.defaultExpectation.results = &StreamTransportMockDialResults{r1, err}
	return mmDial.mock
}

//Set uses given function f to mock the StreamTransport.Dial method
func (mmDial *mStreamTransportMockDial) Set(f func(ctx context.Context, address string) (r1 io.ReadWriteCloser, err error)) *StreamTransportMock {
	if mmDial.defaultExpectation != nil {
		mmDial.mock.t.Fatalf("Default expectation is already set for the StreamTransport.Dial method")
	}

	if len(mmDial.expectations) > 0 {
		mmDial.mock.t.Fatalf("Some expectations are already set for the StreamTransport.Dial method")
	}

	mmDial.mock.funcDial = f
	return mmDial.mock
}

// When sets expectation for the StreamTransport.Dial which will trigger the result defined by the following
// Then helper
func (mmDial *mStreamTransportMockDial) When(ctx context.Context, address string) *StreamTransportMockDialExpectation {
	if mmDial.mock.funcDial != nil {
		mmDial.mock.t.Fatalf("StreamTransportMock.Dial mock is already set by Set")
	}

	expectation := &StreamTransportMockDialExpectation{
		mock:   mmDial.mock,
		params: &StreamTransportMockDialParams{ctx, address},
	}
	mmDial.expectations = append(mmDial.expectations, expectation)
	return expectation
}

// Then sets up StreamTransport.Dial return parameters for the expectation previously defined by the When method
func (e *StreamTransportMockDialExpectation) Then(r1 io.ReadWriteCloser, err error) *StreamTransportMock {
	e.results = &StreamTransportMockDialResults{r1, err}
	return e.mock
}

// Dial implements transport.StreamTransport
func (mmDial *StreamTransportMock) Dial(ctx context.Context, address string) (r1 io.ReadWriteCloser, err error) {
	mm_atomic.AddUint64(&mmDial.beforeDialCounter, 1)
	defer mm_atomic.AddUint64(&mmDial.afterDialCounter, 1)

	if mmDial.inspectFuncDial != nil {
		mmDial.inspectFuncDial(ctx, address)
	}

	mm_params := &StreamTransportMockDialParams{ctx, address}

	// Record call args
	mmDial.DialMock.mutex.Lock()
	mmDial.DialMock.callArgs = append(mmDial.DialMock.callArgs, mm_params)
	mmDial.DialMock.mutex.Unlock()

	for _, e := range mmDial.DialMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmDial.DialMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDial.DialMock.defaultExpectation.Counter, 1)
		mm_want := mmDial.DialMock.defaultExpectation.params
		mm_got := StreamTransportMockDialParams{ctx, address}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDial.t.Errorf("StreamTransportMock.Dial got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDial.DialMock.defaultExpectation.results
		if mm_results == nil {
			mmDial.t.Fatal("No results are set for the StreamTransportMock.Dial")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmDial.funcDial != nil {
		return mmDial.funcDial(ctx, address)
	}
	mmDial.t.Fatalf("Unexpected call to StreamTransportMock.Dial. %v %v", ctx, address)
	return
}

// DialAfterCounter returns a count of finished StreamTransportMock.Dial invocations
func (mmDial *StreamTransportMock) DialAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDial.afterDialCounter)
}

// DialBeforeCounter returns a count of StreamTransportMock.Dial invocations
func (mmDial *StreamTransportMock) DialBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDial.beforeDialCounter)
}

// Calls returns a list of arguments used in each call to StreamTransportMock.Dial.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDial *mStreamTransportMockDial) Calls() []*StreamTransportMockDialParams {
	mmDial.mutex.RLock()

	argCopy := make([]*StreamTransportMockDialParams, len(mmDial.callArgs))
	copy(argCopy, mmDial.callArgs)

	mmDial.mutex.RUnlock()

	return argCopy
}

// MinimockDialDone returns true if the count of the Dial invocations corresponds
// the number of defined expectations
func (m *StreamTransportMock) MinimockDialDone() bool {
	for _, e := range m.DialMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DialMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDialCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDial != nil && mm_atomic.LoadUint64(&m.afterDialCounter) < 1 {
		return false
	}
	return true
}

// MinimockDialInspect logs each unmet expectation
func (m *StreamTransportMock) MinimockDialInspect() {
	for _, e := range m.DialMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StreamTransportMock.Dial with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DialMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDialCounter) < 1 {
		if m.DialMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StreamTransportMock.Dial")
		} else {
			m.t.Errorf("Expected call to StreamTransportMock.Dial with params: %#v", *m.DialMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDial != nil && mm_atomic.LoadUint64(&m.afterDialCounter) < 1 {
		m.t.Error("Expected call to StreamTransportMock.Dial")
	}
}

type mStreamTransportMockStart struct {
	mock               *StreamTransportMock
	defaultExpectation *StreamTransportMockStartExpectation
	expectations       []*StreamTransportMockStartExpectation

	callArgs []*StreamTransportMockStartParams
	mutex    sync.RWMutex
}

// StreamTransportMockStartExpectation specifies expectation struct of the StreamTransport.Start
type StreamTransportMockStartExpectation struct {
	mock    *StreamTransportMock
	params  *StreamTransportMockStartParams
	results *StreamTransportMockStartResults
	Counter uint64
}

// StreamTransportMockStartParams contains parameters of the StreamTransport.Start
type StreamTransportMockStartParams struct {
	ctx context.Context
}

// StreamTransportMockStartResults contains results of the StreamTransport.Start
type StreamTransportMockStartResults struct {
	err error
}

// Expect sets up expected params for StreamTransport.Start
func (mmStart *mStreamTransportMockStart) Expect(ctx context.Context) *mStreamTransportMockStart {
	if mmStart.mock.funcStart != nil {
		mmStart.mock.t.Fatalf("StreamTransportMock.Start mock is already set by Set")
	}

	if mmStart.defaultExpectation == nil {
		mmStart.defaultExpectation = &StreamTransportMockStartExpectation{}
	}

	mmStart.defaultExpectation.params = &StreamTransportMockStartParams{ctx}
	for _, e := range mmStart.expectations {
		if minimock.Equal(e.params, mmStart.defaultExpectation.params) {
			mmStart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStart.defaultExpectation.params)
		}
	}

	return mmStart
}

// Inspect accepts an inspector function that has same arguments as the StreamTransport.Start
func (mmStart *mStreamTransportMockStart) Inspect(f func(ctx context.Context)) *mStreamTransportMockStart {
	if mmStart.mock.inspectFuncStart != nil {
		mmStart.mock.t.Fatalf("Inspect function is already set for StreamTransportMock.Start")
	}

	mmStart.mock.inspectFuncStart = f

	return mmStart
}

// Return sets up results that will be returned by StreamTransport.Start
func (mmStart *mStreamTransportMockStart) Return(err error) *StreamTransportMock {
	if mmStart.mock.funcStart != nil {
		mmStart.mock.t.Fatalf("StreamTransportMock.Start mock is already set by Set")
	}

	if mmStart.defaultExpectation == nil {
		mmStart.defaultExpectation = &StreamTransportMockStartExpectation{mock: mmStart.mock}
	}
	mmStart.defaultExpectation.results = &StreamTransportMockStartResults{err}
	return mmStart.mock
}

//Set uses given function f to mock the StreamTransport.Start method
func (mmStart *mStreamTransportMockStart) Set(f func(ctx context.Context) (err error)) *StreamTransportMock {
	if mmStart.defaultExpectation != nil {
		mmStart.mock.t.Fatalf("Default expectation is already set for the StreamTransport.Start method")
	}

	if len(mmStart.expectations) > 0 {
		mmStart.mock.t.Fatalf("Some expectations are already set for the StreamTransport.Start method")
	}

	mmStart.mock.funcStart = f
	return mmStart.mock
}

// When sets expectation for the StreamTransport.Start which will trigger the result defined by the following
// Then helper
func (mmStart *mStreamTransportMockStart) When(ctx context.Context) *StreamTransportMockStartExpectation {
	if mmStart.mock.funcStart != nil {
		mmStart.mock.t.Fatalf("StreamTransportMock.Start mock is already set by Set")
	}

	expectation := &StreamTransportMockStartExpectation{
		mock:   mmStart.mock,
		params: &StreamTransportMockStartParams{ctx},
	}
	mmStart.expectations = append(mmStart.expectations, expectation)
	return expectation
}

// Then sets up StreamTransport.Start return parameters for the expectation previously defined by the When method
func (e *StreamTransportMockStartExpectation) Then(err error) *StreamTransportMock {
	e.results = &StreamTransportMockStartResults{err}
	return e.mock
}

// Start implements transport.StreamTransport
func (mmStart *StreamTransportMock) Start(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmStart.beforeStartCounter, 1)
	defer mm_atomic.AddUint64(&mmStart.afterStartCounter, 1)

	if mmStart.inspectFuncStart != nil {
		mmStart.inspectFuncStart(ctx)
	}

	mm_params := &StreamTransportMockStartParams{ctx}

	// Record call args
	mmStart.StartMock.mutex.Lock()
	mmStart.StartMock.callArgs = append(mmStart.StartMock.callArgs, mm_params)
	mmStart.StartMock.mutex.Unlock()

	for _, e := range mmStart.StartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmStart.StartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStart.StartMock.defaultExpectation.Counter, 1)
		mm_want := mmStart.StartMock.defaultExpectation.params
		mm_got := StreamTransportMockStartParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStart.t.Errorf("StreamTransportMock.Start got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStart.StartMock.defaultExpectation.results
		if mm_results == nil {
			mmStart.t.Fatal("No results are set for the StreamTransportMock.Start")
		}
		return (*mm_results).err
	}
	if mmStart.funcStart != nil {
		return mmStart.funcStart(ctx)
	}
	mmStart.t.Fatalf("Unexpected call to StreamTransportMock.Start. %v", ctx)
	return
}

// StartAfterCounter returns a count of finished StreamTransportMock.Start invocations
func (mmStart *StreamTransportMock) StartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStart.afterStartCounter)
}

// StartBeforeCounter returns a count of StreamTransportMock.Start invocations
func (mmStart *StreamTransportMock) StartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStart.beforeStartCounter)
}

// Calls returns a list of arguments used in each call to StreamTransportMock.Start.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStart *mStreamTransportMockStart) Calls() []*StreamTransportMockStartParams {
	mmStart.mutex.RLock()

	argCopy := make([]*StreamTransportMockStartParams, len(mmStart.callArgs))
	copy(argCopy, mmStart.callArgs)

	mmStart.mutex.RUnlock()

	return argCopy
}

// MinimockStartDone returns true if the count of the Start invocations corresponds
// the number of defined expectations
func (m *StreamTransportMock) MinimockStartDone() bool {
	for _, e := range m.StartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStart != nil && mm_atomic.LoadUint64(&m.afterStartCounter) < 1 {
		return false
	}
	return true
}

// MinimockStartInspect logs each unmet expectation
func (m *StreamTransportMock) MinimockStartInspect() {
	for _, e := range m.StartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StreamTransportMock.Start with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStartCounter) < 1 {
		if m.StartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StreamTransportMock.Start")
		} else {
			m.t.Errorf("Expected call to StreamTransportMock.Start with params: %#v", *m.StartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStart != nil && mm_atomic.LoadUint64(&m.afterStartCounter) < 1 {
		m.t.Error("Expected call to StreamTransportMock.Start")
	}
}

type mStreamTransportMockStop struct {
	mock               *StreamTransportMock
	defaultExpectation *StreamTransportMockStopExpectation
	expectations       []*StreamTransportMockStopExpectation

	callArgs []*StreamTransportMockStopParams
	mutex    sync.RWMutex
}

// StreamTransportMockStopExpectation specifies expectation struct of the StreamTransport.Stop
type StreamTransportMockStopExpectation struct {
	mock    *StreamTransportMock
	params  *StreamTransportMockStopParams
	results *StreamTransportMockStopResults
	Counter uint64
}

// StreamTransportMockStopParams contains parameters of the StreamTransport.Stop
type StreamTransportMockStopParams struct {
	ctx context.Context
}

// StreamTransportMockStopResults contains results of the StreamTransport.Stop
type StreamTransportMockStopResults struct {
	err error
}

// Expect sets up expected params for StreamTransport.Stop
func (mmStop *mStreamTransportMockStop) Expect(ctx context.Context) *mStreamTransportMockStop {
	if mmStop.mock.funcStop != nil {
		mmStop.mock.t.Fatalf("StreamTransportMock.Stop mock is already set by Set")
	}

	if mmStop.defaultExpectation == nil {
		mmStop.defaultExpectation = &StreamTransportMockStopExpectation{}
	}

	mmStop.defaultExpectation.params = &StreamTransportMockStopParams{ctx}
	for _, e := range mmStop.expectations {
		if minimock.Equal(e.params, mmStop.defaultExpectation.params) {
			mmStop.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStop.defaultExpectation.params)
		}
	}

	return mmStop
}

// Inspect accepts an inspector function that has same arguments as the StreamTransport.Stop
func (mmStop *mStreamTransportMockStop) Inspect(f func(ctx context.Context)) *mStreamTransportMockStop {
	if mmStop.mock.inspectFuncStop != nil {
		mmStop.mock.t.Fatalf("Inspect function is already set for StreamTransportMock.Stop")
	}

	mmStop.mock.inspectFuncStop = f

	return mmStop
}

// Return sets up results that will be returned by StreamTransport.Stop
func (mmStop *mStreamTransportMockStop) Return(err error) *StreamTransportMock {
	if mmStop.mock.funcStop != nil {
		mmStop.mock.t.Fatalf("StreamTransportMock.Stop mock is already set by Set")
	}

	if mmStop.defaultExpectation == nil {
		mmStop.defaultExpectation = &StreamTransportMockStopExpectation{mock: mmStop.mock}
	}
	mmStop.defaultExpectation.results = &StreamTransportMockStopResults{err}
	return mmStop.mock
}

//Set uses given function f to mock the StreamTransport.Stop method
func (mmStop *mStreamTransportMockStop) Set(f func(ctx context.Context) (err error)) *StreamTransportMock {
	if mmStop.defaultExpectation != nil {
		mmStop.mock.t.Fatalf("Default expectation is already set for the StreamTransport.Stop method")
	}

	if len(mmStop.expectations) > 0 {
		mmStop.mock.t.Fatalf("Some expectations are already set for the StreamTransport.Stop method")
	}

	mmStop.mock.funcStop = f
	return mmStop.mock
}

// When sets expectation for the StreamTransport.Stop which will trigger the result defined by the following
// Then helper
func (mmStop *mStreamTransportMockStop) When(ctx context.Context) *StreamTransportMockStopExpectation {
	if mmStop.mock.funcStop != nil {
		mmStop.mock.t.Fatalf("StreamTransportMock.Stop mock is already set by Set")
	}

	expectation := &StreamTransportMockStopExpectation{
		mock:   mmStop.mock,
		params: &StreamTransportMockStopParams{ctx},
	}
	mmStop.expectations = append(mmStop.expectations, expectation)
	return expectation
}

// Then sets up StreamTransport.Stop return parameters for the expectation previously defined by the When method
func (e *StreamTransportMockStopExpectation) Then(err error) *StreamTransportMock {
	e.results = &StreamTransportMockStopResults{err}
	return e.mock
}

// Stop implements transport.StreamTransport
func (mmStop *StreamTransportMock) Stop(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmStop.beforeStopCounter, 1)
	defer mm_atomic.AddUint64(&mmStop.afterStopCounter, 1)

	if mmStop.inspectFuncStop != nil {
		mmStop.inspectFuncStop(ctx)
	}

	mm_params := &StreamTransportMockStopParams{ctx}

	// Record call args
	mmStop.StopMock.mutex.Lock()
	mmStop.StopMock.callArgs = append(mmStop.StopMock.callArgs, mm_params)
	mmStop.StopMock.mutex.Unlock()

	for _, e := range mmStop.StopMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmStop.StopMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStop.StopMock.defaultExpectation.Counter, 1)
		mm_want := mmStop.StopMock.defaultExpectation.params
		mm_got := StreamTransportMockStopParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStop.t.Errorf("StreamTransportMock.Stop got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStop.StopMock.defaultExpectation.results
		if mm_results == nil {
			mmStop.t.Fatal("No results are set for the StreamTransportMock.Stop")
		}
		return (*mm_results).err
	}
	if mmStop.funcStop != nil {
		return mmStop.funcStop(ctx)
	}
	mmStop.t.Fatalf("Unexpected call to StreamTransportMock.Stop. %v", ctx)
	return
}

// StopAfterCounter returns a count of finished StreamTransportMock.Stop invocations
func (mmStop *StreamTransportMock) StopAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStop.afterStopCounter)
}

// StopBeforeCounter returns a count of StreamTransportMock.Stop invocations
func (mmStop *StreamTransportMock) StopBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStop.beforeStopCounter)
}

// Calls returns a list of arguments used in each call to StreamTransportMock.Stop.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStop *mStreamTransportMockStop) Calls() []*StreamTransportMockStopParams {
	mmStop.mutex.RLock()

	argCopy := make([]*StreamTransportMockStopParams, len(mmStop.callArgs))
	copy(argCopy, mmStop.callArgs)

	mmStop.mutex.RUnlock()

	return argCopy
}

// MinimockStopDone returns true if the count of the Stop invocations corresponds
// the number of defined expectations
func (m *StreamTransportMock) MinimockStopDone() bool {
	for _, e := range m.StopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStop != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		return false
	}
	return true
}

// MinimockStopInspect logs each unmet expectation
func (m *StreamTransportMock) MinimockStopInspect() {
	for _, e := range m.StopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StreamTransportMock.Stop with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		if m.StopMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StreamTransportMock.Stop")
		} else {
			m.t.Errorf("Expected call to StreamTransportMock.Stop with params: %#v", *m.StopMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStop != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		m.t.Error("Expected call to StreamTransportMock.Stop")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StreamTransportMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddressInspect()

		m.MinimockDialInspect()

		m.MinimockStartInspect()

		m.MinimockStopInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StreamTransportMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StreamTransportMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddressDone() &&
		m.MinimockDialDone() &&
		m.MinimockStartDone() &&
		m.MinimockStopDone()
}
