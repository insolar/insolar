package network

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/insolar"
)

// AccessorMock implements network.Accessor
type AccessorMock struct {
	t minimock.Tester

	funcGetActiveNode          func(ref insolar.Reference) (n1 insolar.NetworkNode)
	inspectFuncGetActiveNode   func(ref insolar.Reference)
	afterGetActiveNodeCounter  uint64
	beforeGetActiveNodeCounter uint64
	GetActiveNodeMock          mAccessorMockGetActiveNode

	funcGetActiveNodeByAddr          func(address string) (n1 insolar.NetworkNode)
	inspectFuncGetActiveNodeByAddr   func(address string)
	afterGetActiveNodeByAddrCounter  uint64
	beforeGetActiveNodeByAddrCounter uint64
	GetActiveNodeByAddrMock          mAccessorMockGetActiveNodeByAddr

	funcGetActiveNodeByShortID          func(shortID insolar.ShortNodeID) (n1 insolar.NetworkNode)
	inspectFuncGetActiveNodeByShortID   func(shortID insolar.ShortNodeID)
	afterGetActiveNodeByShortIDCounter  uint64
	beforeGetActiveNodeByShortIDCounter uint64
	GetActiveNodeByShortIDMock          mAccessorMockGetActiveNodeByShortID

	funcGetActiveNodes          func() (na1 []insolar.NetworkNode)
	inspectFuncGetActiveNodes   func()
	afterGetActiveNodesCounter  uint64
	beforeGetActiveNodesCounter uint64
	GetActiveNodesMock          mAccessorMockGetActiveNodes

	funcGetWorkingNode          func(ref insolar.Reference) (n1 insolar.NetworkNode)
	inspectFuncGetWorkingNode   func(ref insolar.Reference)
	afterGetWorkingNodeCounter  uint64
	beforeGetWorkingNodeCounter uint64
	GetWorkingNodeMock          mAccessorMockGetWorkingNode

	funcGetWorkingNodes          func() (na1 []insolar.NetworkNode)
	inspectFuncGetWorkingNodes   func()
	afterGetWorkingNodesCounter  uint64
	beforeGetWorkingNodesCounter uint64
	GetWorkingNodesMock          mAccessorMockGetWorkingNodes
}

// NewAccessorMock returns a mock for network.Accessor
func NewAccessorMock(t minimock.Tester) *AccessorMock {
	m := &AccessorMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetActiveNodeMock = mAccessorMockGetActiveNode{mock: m}
	m.GetActiveNodeMock.callArgs = []*AccessorMockGetActiveNodeParams{}

	m.GetActiveNodeByAddrMock = mAccessorMockGetActiveNodeByAddr{mock: m}
	m.GetActiveNodeByAddrMock.callArgs = []*AccessorMockGetActiveNodeByAddrParams{}

	m.GetActiveNodeByShortIDMock = mAccessorMockGetActiveNodeByShortID{mock: m}
	m.GetActiveNodeByShortIDMock.callArgs = []*AccessorMockGetActiveNodeByShortIDParams{}

	m.GetActiveNodesMock = mAccessorMockGetActiveNodes{mock: m}

	m.GetWorkingNodeMock = mAccessorMockGetWorkingNode{mock: m}
	m.GetWorkingNodeMock.callArgs = []*AccessorMockGetWorkingNodeParams{}

	m.GetWorkingNodesMock = mAccessorMockGetWorkingNodes{mock: m}

	return m
}

type mAccessorMockGetActiveNode struct {
	mock               *AccessorMock
	defaultExpectation *AccessorMockGetActiveNodeExpectation
	expectations       []*AccessorMockGetActiveNodeExpectation

	callArgs []*AccessorMockGetActiveNodeParams
	mutex    sync.RWMutex
}

// AccessorMockGetActiveNodeExpectation specifies expectation struct of the Accessor.GetActiveNode
type AccessorMockGetActiveNodeExpectation struct {
	mock    *AccessorMock
	params  *AccessorMockGetActiveNodeParams
	results *AccessorMockGetActiveNodeResults
	Counter uint64
}

// AccessorMockGetActiveNodeParams contains parameters of the Accessor.GetActiveNode
type AccessorMockGetActiveNodeParams struct {
	ref insolar.Reference
}

// AccessorMockGetActiveNodeResults contains results of the Accessor.GetActiveNode
type AccessorMockGetActiveNodeResults struct {
	n1 insolar.NetworkNode
}

// Expect sets up expected params for Accessor.GetActiveNode
func (mmGetActiveNode *mAccessorMockGetActiveNode) Expect(ref insolar.Reference) *mAccessorMockGetActiveNode {
	if mmGetActiveNode.mock.funcGetActiveNode != nil {
		mmGetActiveNode.mock.t.Fatalf("AccessorMock.GetActiveNode mock is already set by Set")
	}

	if mmGetActiveNode.defaultExpectation == nil {
		mmGetActiveNode.defaultExpectation = &AccessorMockGetActiveNodeExpectation{}
	}

	mmGetActiveNode.defaultExpectation.params = &AccessorMockGetActiveNodeParams{ref}
	for _, e := range mmGetActiveNode.expectations {
		if minimock.Equal(e.params, mmGetActiveNode.defaultExpectation.params) {
			mmGetActiveNode.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetActiveNode.defaultExpectation.params)
		}
	}

	return mmGetActiveNode
}

// Inspect accepts an inspector function that has same arguments as the Accessor.GetActiveNode
func (mmGetActiveNode *mAccessorMockGetActiveNode) Inspect(f func(ref insolar.Reference)) *mAccessorMockGetActiveNode {
	if mmGetActiveNode.mock.inspectFuncGetActiveNode != nil {
		mmGetActiveNode.mock.t.Fatalf("Inspect function is already set for AccessorMock.GetActiveNode")
	}

	mmGetActiveNode.mock.inspectFuncGetActiveNode = f

	return mmGetActiveNode
}

// Return sets up results that will be returned by Accessor.GetActiveNode
func (mmGetActiveNode *mAccessorMockGetActiveNode) Return(n1 insolar.NetworkNode) *AccessorMock {
	if mmGetActiveNode.mock.funcGetActiveNode != nil {
		mmGetActiveNode.mock.t.Fatalf("AccessorMock.GetActiveNode mock is already set by Set")
	}

	if mmGetActiveNode.defaultExpectation == nil {
		mmGetActiveNode.defaultExpectation = &AccessorMockGetActiveNodeExpectation{mock: mmGetActiveNode.mock}
	}
	mmGetActiveNode.defaultExpectation.results = &AccessorMockGetActiveNodeResults{n1}
	return mmGetActiveNode.mock
}

//Set uses given function f to mock the Accessor.GetActiveNode method
func (mmGetActiveNode *mAccessorMockGetActiveNode) Set(f func(ref insolar.Reference) (n1 insolar.NetworkNode)) *AccessorMock {
	if mmGetActiveNode.defaultExpectation != nil {
		mmGetActiveNode.mock.t.Fatalf("Default expectation is already set for the Accessor.GetActiveNode method")
	}

	if len(mmGetActiveNode.expectations) > 0 {
		mmGetActiveNode.mock.t.Fatalf("Some expectations are already set for the Accessor.GetActiveNode method")
	}

	mmGetActiveNode.mock.funcGetActiveNode = f
	return mmGetActiveNode.mock
}

// When sets expectation for the Accessor.GetActiveNode which will trigger the result defined by the following
// Then helper
func (mmGetActiveNode *mAccessorMockGetActiveNode) When(ref insolar.Reference) *AccessorMockGetActiveNodeExpectation {
	if mmGetActiveNode.mock.funcGetActiveNode != nil {
		mmGetActiveNode.mock.t.Fatalf("AccessorMock.GetActiveNode mock is already set by Set")
	}

	expectation := &AccessorMockGetActiveNodeExpectation{
		mock:   mmGetActiveNode.mock,
		params: &AccessorMockGetActiveNodeParams{ref},
	}
	mmGetActiveNode.expectations = append(mmGetActiveNode.expectations, expectation)
	return expectation
}

// Then sets up Accessor.GetActiveNode return parameters for the expectation previously defined by the When method
func (e *AccessorMockGetActiveNodeExpectation) Then(n1 insolar.NetworkNode) *AccessorMock {
	e.results = &AccessorMockGetActiveNodeResults{n1}
	return e.mock
}

// GetActiveNode implements network.Accessor
func (mmGetActiveNode *AccessorMock) GetActiveNode(ref insolar.Reference) (n1 insolar.NetworkNode) {
	mm_atomic.AddUint64(&mmGetActiveNode.beforeGetActiveNodeCounter, 1)
	defer mm_atomic.AddUint64(&mmGetActiveNode.afterGetActiveNodeCounter, 1)

	if mmGetActiveNode.inspectFuncGetActiveNode != nil {
		mmGetActiveNode.inspectFuncGetActiveNode(ref)
	}

	params := &AccessorMockGetActiveNodeParams{ref}

	// Record call args
	mmGetActiveNode.GetActiveNodeMock.mutex.Lock()
	mmGetActiveNode.GetActiveNodeMock.callArgs = append(mmGetActiveNode.GetActiveNodeMock.callArgs, params)
	mmGetActiveNode.GetActiveNodeMock.mutex.Unlock()

	for _, e := range mmGetActiveNode.GetActiveNodeMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n1
		}
	}

	if mmGetActiveNode.GetActiveNodeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetActiveNode.GetActiveNodeMock.defaultExpectation.Counter, 1)
		want := mmGetActiveNode.GetActiveNodeMock.defaultExpectation.params
		got := AccessorMockGetActiveNodeParams{ref}
		if want != nil && !minimock.Equal(*want, got) {
			mmGetActiveNode.t.Errorf("AccessorMock.GetActiveNode got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmGetActiveNode.GetActiveNodeMock.defaultExpectation.results
		if results == nil {
			mmGetActiveNode.t.Fatal("No results are set for the AccessorMock.GetActiveNode")
		}
		return (*results).n1
	}
	if mmGetActiveNode.funcGetActiveNode != nil {
		return mmGetActiveNode.funcGetActiveNode(ref)
	}
	mmGetActiveNode.t.Fatalf("Unexpected call to AccessorMock.GetActiveNode. %v", ref)
	return
}

// GetActiveNodeAfterCounter returns a count of finished AccessorMock.GetActiveNode invocations
func (mmGetActiveNode *AccessorMock) GetActiveNodeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetActiveNode.afterGetActiveNodeCounter)
}

// GetActiveNodeBeforeCounter returns a count of AccessorMock.GetActiveNode invocations
func (mmGetActiveNode *AccessorMock) GetActiveNodeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetActiveNode.beforeGetActiveNodeCounter)
}

// Calls returns a list of arguments used in each call to AccessorMock.GetActiveNode.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetActiveNode *mAccessorMockGetActiveNode) Calls() []*AccessorMockGetActiveNodeParams {
	mmGetActiveNode.mutex.RLock()

	argCopy := make([]*AccessorMockGetActiveNodeParams, len(mmGetActiveNode.callArgs))
	copy(argCopy, mmGetActiveNode.callArgs)

	mmGetActiveNode.mutex.RUnlock()

	return argCopy
}

// MinimockGetActiveNodeDone returns true if the count of the GetActiveNode invocations corresponds
// the number of defined expectations
func (m *AccessorMock) MinimockGetActiveNodeDone() bool {
	for _, e := range m.GetActiveNodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetActiveNodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetActiveNodeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetActiveNode != nil && mm_atomic.LoadUint64(&m.afterGetActiveNodeCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetActiveNodeInspect logs each unmet expectation
func (m *AccessorMock) MinimockGetActiveNodeInspect() {
	for _, e := range m.GetActiveNodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AccessorMock.GetActiveNode with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetActiveNodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetActiveNodeCounter) < 1 {
		if m.GetActiveNodeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AccessorMock.GetActiveNode")
		} else {
			m.t.Errorf("Expected call to AccessorMock.GetActiveNode with params: %#v", *m.GetActiveNodeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetActiveNode != nil && mm_atomic.LoadUint64(&m.afterGetActiveNodeCounter) < 1 {
		m.t.Error("Expected call to AccessorMock.GetActiveNode")
	}
}

type mAccessorMockGetActiveNodeByAddr struct {
	mock               *AccessorMock
	defaultExpectation *AccessorMockGetActiveNodeByAddrExpectation
	expectations       []*AccessorMockGetActiveNodeByAddrExpectation

	callArgs []*AccessorMockGetActiveNodeByAddrParams
	mutex    sync.RWMutex
}

// AccessorMockGetActiveNodeByAddrExpectation specifies expectation struct of the Accessor.GetActiveNodeByAddr
type AccessorMockGetActiveNodeByAddrExpectation struct {
	mock    *AccessorMock
	params  *AccessorMockGetActiveNodeByAddrParams
	results *AccessorMockGetActiveNodeByAddrResults
	Counter uint64
}

// AccessorMockGetActiveNodeByAddrParams contains parameters of the Accessor.GetActiveNodeByAddr
type AccessorMockGetActiveNodeByAddrParams struct {
	address string
}

// AccessorMockGetActiveNodeByAddrResults contains results of the Accessor.GetActiveNodeByAddr
type AccessorMockGetActiveNodeByAddrResults struct {
	n1 insolar.NetworkNode
}

// Expect sets up expected params for Accessor.GetActiveNodeByAddr
func (mmGetActiveNodeByAddr *mAccessorMockGetActiveNodeByAddr) Expect(address string) *mAccessorMockGetActiveNodeByAddr {
	if mmGetActiveNodeByAddr.mock.funcGetActiveNodeByAddr != nil {
		mmGetActiveNodeByAddr.mock.t.Fatalf("AccessorMock.GetActiveNodeByAddr mock is already set by Set")
	}

	if mmGetActiveNodeByAddr.defaultExpectation == nil {
		mmGetActiveNodeByAddr.defaultExpectation = &AccessorMockGetActiveNodeByAddrExpectation{}
	}

	mmGetActiveNodeByAddr.defaultExpectation.params = &AccessorMockGetActiveNodeByAddrParams{address}
	for _, e := range mmGetActiveNodeByAddr.expectations {
		if minimock.Equal(e.params, mmGetActiveNodeByAddr.defaultExpectation.params) {
			mmGetActiveNodeByAddr.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetActiveNodeByAddr.defaultExpectation.params)
		}
	}

	return mmGetActiveNodeByAddr
}

// Inspect accepts an inspector function that has same arguments as the Accessor.GetActiveNodeByAddr
func (mmGetActiveNodeByAddr *mAccessorMockGetActiveNodeByAddr) Inspect(f func(address string)) *mAccessorMockGetActiveNodeByAddr {
	if mmGetActiveNodeByAddr.mock.inspectFuncGetActiveNodeByAddr != nil {
		mmGetActiveNodeByAddr.mock.t.Fatalf("Inspect function is already set for AccessorMock.GetActiveNodeByAddr")
	}

	mmGetActiveNodeByAddr.mock.inspectFuncGetActiveNodeByAddr = f

	return mmGetActiveNodeByAddr
}

// Return sets up results that will be returned by Accessor.GetActiveNodeByAddr
func (mmGetActiveNodeByAddr *mAccessorMockGetActiveNodeByAddr) Return(n1 insolar.NetworkNode) *AccessorMock {
	if mmGetActiveNodeByAddr.mock.funcGetActiveNodeByAddr != nil {
		mmGetActiveNodeByAddr.mock.t.Fatalf("AccessorMock.GetActiveNodeByAddr mock is already set by Set")
	}

	if mmGetActiveNodeByAddr.defaultExpectation == nil {
		mmGetActiveNodeByAddr.defaultExpectation = &AccessorMockGetActiveNodeByAddrExpectation{mock: mmGetActiveNodeByAddr.mock}
	}
	mmGetActiveNodeByAddr.defaultExpectation.results = &AccessorMockGetActiveNodeByAddrResults{n1}
	return mmGetActiveNodeByAddr.mock
}

//Set uses given function f to mock the Accessor.GetActiveNodeByAddr method
func (mmGetActiveNodeByAddr *mAccessorMockGetActiveNodeByAddr) Set(f func(address string) (n1 insolar.NetworkNode)) *AccessorMock {
	if mmGetActiveNodeByAddr.defaultExpectation != nil {
		mmGetActiveNodeByAddr.mock.t.Fatalf("Default expectation is already set for the Accessor.GetActiveNodeByAddr method")
	}

	if len(mmGetActiveNodeByAddr.expectations) > 0 {
		mmGetActiveNodeByAddr.mock.t.Fatalf("Some expectations are already set for the Accessor.GetActiveNodeByAddr method")
	}

	mmGetActiveNodeByAddr.mock.funcGetActiveNodeByAddr = f
	return mmGetActiveNodeByAddr.mock
}

// When sets expectation for the Accessor.GetActiveNodeByAddr which will trigger the result defined by the following
// Then helper
func (mmGetActiveNodeByAddr *mAccessorMockGetActiveNodeByAddr) When(address string) *AccessorMockGetActiveNodeByAddrExpectation {
	if mmGetActiveNodeByAddr.mock.funcGetActiveNodeByAddr != nil {
		mmGetActiveNodeByAddr.mock.t.Fatalf("AccessorMock.GetActiveNodeByAddr mock is already set by Set")
	}

	expectation := &AccessorMockGetActiveNodeByAddrExpectation{
		mock:   mmGetActiveNodeByAddr.mock,
		params: &AccessorMockGetActiveNodeByAddrParams{address},
	}
	mmGetActiveNodeByAddr.expectations = append(mmGetActiveNodeByAddr.expectations, expectation)
	return expectation
}

// Then sets up Accessor.GetActiveNodeByAddr return parameters for the expectation previously defined by the When method
func (e *AccessorMockGetActiveNodeByAddrExpectation) Then(n1 insolar.NetworkNode) *AccessorMock {
	e.results = &AccessorMockGetActiveNodeByAddrResults{n1}
	return e.mock
}

// GetActiveNodeByAddr implements network.Accessor
func (mmGetActiveNodeByAddr *AccessorMock) GetActiveNodeByAddr(address string) (n1 insolar.NetworkNode) {
	mm_atomic.AddUint64(&mmGetActiveNodeByAddr.beforeGetActiveNodeByAddrCounter, 1)
	defer mm_atomic.AddUint64(&mmGetActiveNodeByAddr.afterGetActiveNodeByAddrCounter, 1)

	if mmGetActiveNodeByAddr.inspectFuncGetActiveNodeByAddr != nil {
		mmGetActiveNodeByAddr.inspectFuncGetActiveNodeByAddr(address)
	}

	params := &AccessorMockGetActiveNodeByAddrParams{address}

	// Record call args
	mmGetActiveNodeByAddr.GetActiveNodeByAddrMock.mutex.Lock()
	mmGetActiveNodeByAddr.GetActiveNodeByAddrMock.callArgs = append(mmGetActiveNodeByAddr.GetActiveNodeByAddrMock.callArgs, params)
	mmGetActiveNodeByAddr.GetActiveNodeByAddrMock.mutex.Unlock()

	for _, e := range mmGetActiveNodeByAddr.GetActiveNodeByAddrMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n1
		}
	}

	if mmGetActiveNodeByAddr.GetActiveNodeByAddrMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetActiveNodeByAddr.GetActiveNodeByAddrMock.defaultExpectation.Counter, 1)
		want := mmGetActiveNodeByAddr.GetActiveNodeByAddrMock.defaultExpectation.params
		got := AccessorMockGetActiveNodeByAddrParams{address}
		if want != nil && !minimock.Equal(*want, got) {
			mmGetActiveNodeByAddr.t.Errorf("AccessorMock.GetActiveNodeByAddr got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmGetActiveNodeByAddr.GetActiveNodeByAddrMock.defaultExpectation.results
		if results == nil {
			mmGetActiveNodeByAddr.t.Fatal("No results are set for the AccessorMock.GetActiveNodeByAddr")
		}
		return (*results).n1
	}
	if mmGetActiveNodeByAddr.funcGetActiveNodeByAddr != nil {
		return mmGetActiveNodeByAddr.funcGetActiveNodeByAddr(address)
	}
	mmGetActiveNodeByAddr.t.Fatalf("Unexpected call to AccessorMock.GetActiveNodeByAddr. %v", address)
	return
}

// GetActiveNodeByAddrAfterCounter returns a count of finished AccessorMock.GetActiveNodeByAddr invocations
func (mmGetActiveNodeByAddr *AccessorMock) GetActiveNodeByAddrAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetActiveNodeByAddr.afterGetActiveNodeByAddrCounter)
}

// GetActiveNodeByAddrBeforeCounter returns a count of AccessorMock.GetActiveNodeByAddr invocations
func (mmGetActiveNodeByAddr *AccessorMock) GetActiveNodeByAddrBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetActiveNodeByAddr.beforeGetActiveNodeByAddrCounter)
}

// Calls returns a list of arguments used in each call to AccessorMock.GetActiveNodeByAddr.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetActiveNodeByAddr *mAccessorMockGetActiveNodeByAddr) Calls() []*AccessorMockGetActiveNodeByAddrParams {
	mmGetActiveNodeByAddr.mutex.RLock()

	argCopy := make([]*AccessorMockGetActiveNodeByAddrParams, len(mmGetActiveNodeByAddr.callArgs))
	copy(argCopy, mmGetActiveNodeByAddr.callArgs)

	mmGetActiveNodeByAddr.mutex.RUnlock()

	return argCopy
}

// MinimockGetActiveNodeByAddrDone returns true if the count of the GetActiveNodeByAddr invocations corresponds
// the number of defined expectations
func (m *AccessorMock) MinimockGetActiveNodeByAddrDone() bool {
	for _, e := range m.GetActiveNodeByAddrMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetActiveNodeByAddrMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetActiveNodeByAddrCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetActiveNodeByAddr != nil && mm_atomic.LoadUint64(&m.afterGetActiveNodeByAddrCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetActiveNodeByAddrInspect logs each unmet expectation
func (m *AccessorMock) MinimockGetActiveNodeByAddrInspect() {
	for _, e := range m.GetActiveNodeByAddrMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AccessorMock.GetActiveNodeByAddr with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetActiveNodeByAddrMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetActiveNodeByAddrCounter) < 1 {
		if m.GetActiveNodeByAddrMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AccessorMock.GetActiveNodeByAddr")
		} else {
			m.t.Errorf("Expected call to AccessorMock.GetActiveNodeByAddr with params: %#v", *m.GetActiveNodeByAddrMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetActiveNodeByAddr != nil && mm_atomic.LoadUint64(&m.afterGetActiveNodeByAddrCounter) < 1 {
		m.t.Error("Expected call to AccessorMock.GetActiveNodeByAddr")
	}
}

type mAccessorMockGetActiveNodeByShortID struct {
	mock               *AccessorMock
	defaultExpectation *AccessorMockGetActiveNodeByShortIDExpectation
	expectations       []*AccessorMockGetActiveNodeByShortIDExpectation

	callArgs []*AccessorMockGetActiveNodeByShortIDParams
	mutex    sync.RWMutex
}

// AccessorMockGetActiveNodeByShortIDExpectation specifies expectation struct of the Accessor.GetActiveNodeByShortID
type AccessorMockGetActiveNodeByShortIDExpectation struct {
	mock    *AccessorMock
	params  *AccessorMockGetActiveNodeByShortIDParams
	results *AccessorMockGetActiveNodeByShortIDResults
	Counter uint64
}

// AccessorMockGetActiveNodeByShortIDParams contains parameters of the Accessor.GetActiveNodeByShortID
type AccessorMockGetActiveNodeByShortIDParams struct {
	shortID insolar.ShortNodeID
}

// AccessorMockGetActiveNodeByShortIDResults contains results of the Accessor.GetActiveNodeByShortID
type AccessorMockGetActiveNodeByShortIDResults struct {
	n1 insolar.NetworkNode
}

// Expect sets up expected params for Accessor.GetActiveNodeByShortID
func (mmGetActiveNodeByShortID *mAccessorMockGetActiveNodeByShortID) Expect(shortID insolar.ShortNodeID) *mAccessorMockGetActiveNodeByShortID {
	if mmGetActiveNodeByShortID.mock.funcGetActiveNodeByShortID != nil {
		mmGetActiveNodeByShortID.mock.t.Fatalf("AccessorMock.GetActiveNodeByShortID mock is already set by Set")
	}

	if mmGetActiveNodeByShortID.defaultExpectation == nil {
		mmGetActiveNodeByShortID.defaultExpectation = &AccessorMockGetActiveNodeByShortIDExpectation{}
	}

	mmGetActiveNodeByShortID.defaultExpectation.params = &AccessorMockGetActiveNodeByShortIDParams{shortID}
	for _, e := range mmGetActiveNodeByShortID.expectations {
		if minimock.Equal(e.params, mmGetActiveNodeByShortID.defaultExpectation.params) {
			mmGetActiveNodeByShortID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetActiveNodeByShortID.defaultExpectation.params)
		}
	}

	return mmGetActiveNodeByShortID
}

// Inspect accepts an inspector function that has same arguments as the Accessor.GetActiveNodeByShortID
func (mmGetActiveNodeByShortID *mAccessorMockGetActiveNodeByShortID) Inspect(f func(shortID insolar.ShortNodeID)) *mAccessorMockGetActiveNodeByShortID {
	if mmGetActiveNodeByShortID.mock.inspectFuncGetActiveNodeByShortID != nil {
		mmGetActiveNodeByShortID.mock.t.Fatalf("Inspect function is already set for AccessorMock.GetActiveNodeByShortID")
	}

	mmGetActiveNodeByShortID.mock.inspectFuncGetActiveNodeByShortID = f

	return mmGetActiveNodeByShortID
}

// Return sets up results that will be returned by Accessor.GetActiveNodeByShortID
func (mmGetActiveNodeByShortID *mAccessorMockGetActiveNodeByShortID) Return(n1 insolar.NetworkNode) *AccessorMock {
	if mmGetActiveNodeByShortID.mock.funcGetActiveNodeByShortID != nil {
		mmGetActiveNodeByShortID.mock.t.Fatalf("AccessorMock.GetActiveNodeByShortID mock is already set by Set")
	}

	if mmGetActiveNodeByShortID.defaultExpectation == nil {
		mmGetActiveNodeByShortID.defaultExpectation = &AccessorMockGetActiveNodeByShortIDExpectation{mock: mmGetActiveNodeByShortID.mock}
	}
	mmGetActiveNodeByShortID.defaultExpectation.results = &AccessorMockGetActiveNodeByShortIDResults{n1}
	return mmGetActiveNodeByShortID.mock
}

//Set uses given function f to mock the Accessor.GetActiveNodeByShortID method
func (mmGetActiveNodeByShortID *mAccessorMockGetActiveNodeByShortID) Set(f func(shortID insolar.ShortNodeID) (n1 insolar.NetworkNode)) *AccessorMock {
	if mmGetActiveNodeByShortID.defaultExpectation != nil {
		mmGetActiveNodeByShortID.mock.t.Fatalf("Default expectation is already set for the Accessor.GetActiveNodeByShortID method")
	}

	if len(mmGetActiveNodeByShortID.expectations) > 0 {
		mmGetActiveNodeByShortID.mock.t.Fatalf("Some expectations are already set for the Accessor.GetActiveNodeByShortID method")
	}

	mmGetActiveNodeByShortID.mock.funcGetActiveNodeByShortID = f
	return mmGetActiveNodeByShortID.mock
}

// When sets expectation for the Accessor.GetActiveNodeByShortID which will trigger the result defined by the following
// Then helper
func (mmGetActiveNodeByShortID *mAccessorMockGetActiveNodeByShortID) When(shortID insolar.ShortNodeID) *AccessorMockGetActiveNodeByShortIDExpectation {
	if mmGetActiveNodeByShortID.mock.funcGetActiveNodeByShortID != nil {
		mmGetActiveNodeByShortID.mock.t.Fatalf("AccessorMock.GetActiveNodeByShortID mock is already set by Set")
	}

	expectation := &AccessorMockGetActiveNodeByShortIDExpectation{
		mock:   mmGetActiveNodeByShortID.mock,
		params: &AccessorMockGetActiveNodeByShortIDParams{shortID},
	}
	mmGetActiveNodeByShortID.expectations = append(mmGetActiveNodeByShortID.expectations, expectation)
	return expectation
}

// Then sets up Accessor.GetActiveNodeByShortID return parameters for the expectation previously defined by the When method
func (e *AccessorMockGetActiveNodeByShortIDExpectation) Then(n1 insolar.NetworkNode) *AccessorMock {
	e.results = &AccessorMockGetActiveNodeByShortIDResults{n1}
	return e.mock
}

// GetActiveNodeByShortID implements network.Accessor
func (mmGetActiveNodeByShortID *AccessorMock) GetActiveNodeByShortID(shortID insolar.ShortNodeID) (n1 insolar.NetworkNode) {
	mm_atomic.AddUint64(&mmGetActiveNodeByShortID.beforeGetActiveNodeByShortIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetActiveNodeByShortID.afterGetActiveNodeByShortIDCounter, 1)

	if mmGetActiveNodeByShortID.inspectFuncGetActiveNodeByShortID != nil {
		mmGetActiveNodeByShortID.inspectFuncGetActiveNodeByShortID(shortID)
	}

	params := &AccessorMockGetActiveNodeByShortIDParams{shortID}

	// Record call args
	mmGetActiveNodeByShortID.GetActiveNodeByShortIDMock.mutex.Lock()
	mmGetActiveNodeByShortID.GetActiveNodeByShortIDMock.callArgs = append(mmGetActiveNodeByShortID.GetActiveNodeByShortIDMock.callArgs, params)
	mmGetActiveNodeByShortID.GetActiveNodeByShortIDMock.mutex.Unlock()

	for _, e := range mmGetActiveNodeByShortID.GetActiveNodeByShortIDMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n1
		}
	}

	if mmGetActiveNodeByShortID.GetActiveNodeByShortIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetActiveNodeByShortID.GetActiveNodeByShortIDMock.defaultExpectation.Counter, 1)
		want := mmGetActiveNodeByShortID.GetActiveNodeByShortIDMock.defaultExpectation.params
		got := AccessorMockGetActiveNodeByShortIDParams{shortID}
		if want != nil && !minimock.Equal(*want, got) {
			mmGetActiveNodeByShortID.t.Errorf("AccessorMock.GetActiveNodeByShortID got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmGetActiveNodeByShortID.GetActiveNodeByShortIDMock.defaultExpectation.results
		if results == nil {
			mmGetActiveNodeByShortID.t.Fatal("No results are set for the AccessorMock.GetActiveNodeByShortID")
		}
		return (*results).n1
	}
	if mmGetActiveNodeByShortID.funcGetActiveNodeByShortID != nil {
		return mmGetActiveNodeByShortID.funcGetActiveNodeByShortID(shortID)
	}
	mmGetActiveNodeByShortID.t.Fatalf("Unexpected call to AccessorMock.GetActiveNodeByShortID. %v", shortID)
	return
}

// GetActiveNodeByShortIDAfterCounter returns a count of finished AccessorMock.GetActiveNodeByShortID invocations
func (mmGetActiveNodeByShortID *AccessorMock) GetActiveNodeByShortIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetActiveNodeByShortID.afterGetActiveNodeByShortIDCounter)
}

// GetActiveNodeByShortIDBeforeCounter returns a count of AccessorMock.GetActiveNodeByShortID invocations
func (mmGetActiveNodeByShortID *AccessorMock) GetActiveNodeByShortIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetActiveNodeByShortID.beforeGetActiveNodeByShortIDCounter)
}

// Calls returns a list of arguments used in each call to AccessorMock.GetActiveNodeByShortID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetActiveNodeByShortID *mAccessorMockGetActiveNodeByShortID) Calls() []*AccessorMockGetActiveNodeByShortIDParams {
	mmGetActiveNodeByShortID.mutex.RLock()

	argCopy := make([]*AccessorMockGetActiveNodeByShortIDParams, len(mmGetActiveNodeByShortID.callArgs))
	copy(argCopy, mmGetActiveNodeByShortID.callArgs)

	mmGetActiveNodeByShortID.mutex.RUnlock()

	return argCopy
}

// MinimockGetActiveNodeByShortIDDone returns true if the count of the GetActiveNodeByShortID invocations corresponds
// the number of defined expectations
func (m *AccessorMock) MinimockGetActiveNodeByShortIDDone() bool {
	for _, e := range m.GetActiveNodeByShortIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetActiveNodeByShortIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetActiveNodeByShortIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetActiveNodeByShortID != nil && mm_atomic.LoadUint64(&m.afterGetActiveNodeByShortIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetActiveNodeByShortIDInspect logs each unmet expectation
func (m *AccessorMock) MinimockGetActiveNodeByShortIDInspect() {
	for _, e := range m.GetActiveNodeByShortIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AccessorMock.GetActiveNodeByShortID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetActiveNodeByShortIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetActiveNodeByShortIDCounter) < 1 {
		if m.GetActiveNodeByShortIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AccessorMock.GetActiveNodeByShortID")
		} else {
			m.t.Errorf("Expected call to AccessorMock.GetActiveNodeByShortID with params: %#v", *m.GetActiveNodeByShortIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetActiveNodeByShortID != nil && mm_atomic.LoadUint64(&m.afterGetActiveNodeByShortIDCounter) < 1 {
		m.t.Error("Expected call to AccessorMock.GetActiveNodeByShortID")
	}
}

type mAccessorMockGetActiveNodes struct {
	mock               *AccessorMock
	defaultExpectation *AccessorMockGetActiveNodesExpectation
	expectations       []*AccessorMockGetActiveNodesExpectation
}

// AccessorMockGetActiveNodesExpectation specifies expectation struct of the Accessor.GetActiveNodes
type AccessorMockGetActiveNodesExpectation struct {
	mock *AccessorMock

	results *AccessorMockGetActiveNodesResults
	Counter uint64
}

// AccessorMockGetActiveNodesResults contains results of the Accessor.GetActiveNodes
type AccessorMockGetActiveNodesResults struct {
	na1 []insolar.NetworkNode
}

// Expect sets up expected params for Accessor.GetActiveNodes
func (mmGetActiveNodes *mAccessorMockGetActiveNodes) Expect() *mAccessorMockGetActiveNodes {
	if mmGetActiveNodes.mock.funcGetActiveNodes != nil {
		mmGetActiveNodes.mock.t.Fatalf("AccessorMock.GetActiveNodes mock is already set by Set")
	}

	if mmGetActiveNodes.defaultExpectation == nil {
		mmGetActiveNodes.defaultExpectation = &AccessorMockGetActiveNodesExpectation{}
	}

	return mmGetActiveNodes
}

// Inspect accepts an inspector function that has same arguments as the Accessor.GetActiveNodes
func (mmGetActiveNodes *mAccessorMockGetActiveNodes) Inspect(f func()) *mAccessorMockGetActiveNodes {
	if mmGetActiveNodes.mock.inspectFuncGetActiveNodes != nil {
		mmGetActiveNodes.mock.t.Fatalf("Inspect function is already set for AccessorMock.GetActiveNodes")
	}

	mmGetActiveNodes.mock.inspectFuncGetActiveNodes = f

	return mmGetActiveNodes
}

// Return sets up results that will be returned by Accessor.GetActiveNodes
func (mmGetActiveNodes *mAccessorMockGetActiveNodes) Return(na1 []insolar.NetworkNode) *AccessorMock {
	if mmGetActiveNodes.mock.funcGetActiveNodes != nil {
		mmGetActiveNodes.mock.t.Fatalf("AccessorMock.GetActiveNodes mock is already set by Set")
	}

	if mmGetActiveNodes.defaultExpectation == nil {
		mmGetActiveNodes.defaultExpectation = &AccessorMockGetActiveNodesExpectation{mock: mmGetActiveNodes.mock}
	}
	mmGetActiveNodes.defaultExpectation.results = &AccessorMockGetActiveNodesResults{na1}
	return mmGetActiveNodes.mock
}

//Set uses given function f to mock the Accessor.GetActiveNodes method
func (mmGetActiveNodes *mAccessorMockGetActiveNodes) Set(f func() (na1 []insolar.NetworkNode)) *AccessorMock {
	if mmGetActiveNodes.defaultExpectation != nil {
		mmGetActiveNodes.mock.t.Fatalf("Default expectation is already set for the Accessor.GetActiveNodes method")
	}

	if len(mmGetActiveNodes.expectations) > 0 {
		mmGetActiveNodes.mock.t.Fatalf("Some expectations are already set for the Accessor.GetActiveNodes method")
	}

	mmGetActiveNodes.mock.funcGetActiveNodes = f
	return mmGetActiveNodes.mock
}

// GetActiveNodes implements network.Accessor
func (mmGetActiveNodes *AccessorMock) GetActiveNodes() (na1 []insolar.NetworkNode) {
	mm_atomic.AddUint64(&mmGetActiveNodes.beforeGetActiveNodesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetActiveNodes.afterGetActiveNodesCounter, 1)

	if mmGetActiveNodes.inspectFuncGetActiveNodes != nil {
		mmGetActiveNodes.inspectFuncGetActiveNodes()
	}

	if mmGetActiveNodes.GetActiveNodesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetActiveNodes.GetActiveNodesMock.defaultExpectation.Counter, 1)

		results := mmGetActiveNodes.GetActiveNodesMock.defaultExpectation.results
		if results == nil {
			mmGetActiveNodes.t.Fatal("No results are set for the AccessorMock.GetActiveNodes")
		}
		return (*results).na1
	}
	if mmGetActiveNodes.funcGetActiveNodes != nil {
		return mmGetActiveNodes.funcGetActiveNodes()
	}
	mmGetActiveNodes.t.Fatalf("Unexpected call to AccessorMock.GetActiveNodes.")
	return
}

// GetActiveNodesAfterCounter returns a count of finished AccessorMock.GetActiveNodes invocations
func (mmGetActiveNodes *AccessorMock) GetActiveNodesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetActiveNodes.afterGetActiveNodesCounter)
}

// GetActiveNodesBeforeCounter returns a count of AccessorMock.GetActiveNodes invocations
func (mmGetActiveNodes *AccessorMock) GetActiveNodesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetActiveNodes.beforeGetActiveNodesCounter)
}

// MinimockGetActiveNodesDone returns true if the count of the GetActiveNodes invocations corresponds
// the number of defined expectations
func (m *AccessorMock) MinimockGetActiveNodesDone() bool {
	for _, e := range m.GetActiveNodesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetActiveNodesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetActiveNodesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetActiveNodes != nil && mm_atomic.LoadUint64(&m.afterGetActiveNodesCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetActiveNodesInspect logs each unmet expectation
func (m *AccessorMock) MinimockGetActiveNodesInspect() {
	for _, e := range m.GetActiveNodesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AccessorMock.GetActiveNodes")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetActiveNodesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetActiveNodesCounter) < 1 {
		m.t.Error("Expected call to AccessorMock.GetActiveNodes")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetActiveNodes != nil && mm_atomic.LoadUint64(&m.afterGetActiveNodesCounter) < 1 {
		m.t.Error("Expected call to AccessorMock.GetActiveNodes")
	}
}

type mAccessorMockGetWorkingNode struct {
	mock               *AccessorMock
	defaultExpectation *AccessorMockGetWorkingNodeExpectation
	expectations       []*AccessorMockGetWorkingNodeExpectation

	callArgs []*AccessorMockGetWorkingNodeParams
	mutex    sync.RWMutex
}

// AccessorMockGetWorkingNodeExpectation specifies expectation struct of the Accessor.GetWorkingNode
type AccessorMockGetWorkingNodeExpectation struct {
	mock    *AccessorMock
	params  *AccessorMockGetWorkingNodeParams
	results *AccessorMockGetWorkingNodeResults
	Counter uint64
}

// AccessorMockGetWorkingNodeParams contains parameters of the Accessor.GetWorkingNode
type AccessorMockGetWorkingNodeParams struct {
	ref insolar.Reference
}

// AccessorMockGetWorkingNodeResults contains results of the Accessor.GetWorkingNode
type AccessorMockGetWorkingNodeResults struct {
	n1 insolar.NetworkNode
}

// Expect sets up expected params for Accessor.GetWorkingNode
func (mmGetWorkingNode *mAccessorMockGetWorkingNode) Expect(ref insolar.Reference) *mAccessorMockGetWorkingNode {
	if mmGetWorkingNode.mock.funcGetWorkingNode != nil {
		mmGetWorkingNode.mock.t.Fatalf("AccessorMock.GetWorkingNode mock is already set by Set")
	}

	if mmGetWorkingNode.defaultExpectation == nil {
		mmGetWorkingNode.defaultExpectation = &AccessorMockGetWorkingNodeExpectation{}
	}

	mmGetWorkingNode.defaultExpectation.params = &AccessorMockGetWorkingNodeParams{ref}
	for _, e := range mmGetWorkingNode.expectations {
		if minimock.Equal(e.params, mmGetWorkingNode.defaultExpectation.params) {
			mmGetWorkingNode.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetWorkingNode.defaultExpectation.params)
		}
	}

	return mmGetWorkingNode
}

// Inspect accepts an inspector function that has same arguments as the Accessor.GetWorkingNode
func (mmGetWorkingNode *mAccessorMockGetWorkingNode) Inspect(f func(ref insolar.Reference)) *mAccessorMockGetWorkingNode {
	if mmGetWorkingNode.mock.inspectFuncGetWorkingNode != nil {
		mmGetWorkingNode.mock.t.Fatalf("Inspect function is already set for AccessorMock.GetWorkingNode")
	}

	mmGetWorkingNode.mock.inspectFuncGetWorkingNode = f

	return mmGetWorkingNode
}

// Return sets up results that will be returned by Accessor.GetWorkingNode
func (mmGetWorkingNode *mAccessorMockGetWorkingNode) Return(n1 insolar.NetworkNode) *AccessorMock {
	if mmGetWorkingNode.mock.funcGetWorkingNode != nil {
		mmGetWorkingNode.mock.t.Fatalf("AccessorMock.GetWorkingNode mock is already set by Set")
	}

	if mmGetWorkingNode.defaultExpectation == nil {
		mmGetWorkingNode.defaultExpectation = &AccessorMockGetWorkingNodeExpectation{mock: mmGetWorkingNode.mock}
	}
	mmGetWorkingNode.defaultExpectation.results = &AccessorMockGetWorkingNodeResults{n1}
	return mmGetWorkingNode.mock
}

//Set uses given function f to mock the Accessor.GetWorkingNode method
func (mmGetWorkingNode *mAccessorMockGetWorkingNode) Set(f func(ref insolar.Reference) (n1 insolar.NetworkNode)) *AccessorMock {
	if mmGetWorkingNode.defaultExpectation != nil {
		mmGetWorkingNode.mock.t.Fatalf("Default expectation is already set for the Accessor.GetWorkingNode method")
	}

	if len(mmGetWorkingNode.expectations) > 0 {
		mmGetWorkingNode.mock.t.Fatalf("Some expectations are already set for the Accessor.GetWorkingNode method")
	}

	mmGetWorkingNode.mock.funcGetWorkingNode = f
	return mmGetWorkingNode.mock
}

// When sets expectation for the Accessor.GetWorkingNode which will trigger the result defined by the following
// Then helper
func (mmGetWorkingNode *mAccessorMockGetWorkingNode) When(ref insolar.Reference) *AccessorMockGetWorkingNodeExpectation {
	if mmGetWorkingNode.mock.funcGetWorkingNode != nil {
		mmGetWorkingNode.mock.t.Fatalf("AccessorMock.GetWorkingNode mock is already set by Set")
	}

	expectation := &AccessorMockGetWorkingNodeExpectation{
		mock:   mmGetWorkingNode.mock,
		params: &AccessorMockGetWorkingNodeParams{ref},
	}
	mmGetWorkingNode.expectations = append(mmGetWorkingNode.expectations, expectation)
	return expectation
}

// Then sets up Accessor.GetWorkingNode return parameters for the expectation previously defined by the When method
func (e *AccessorMockGetWorkingNodeExpectation) Then(n1 insolar.NetworkNode) *AccessorMock {
	e.results = &AccessorMockGetWorkingNodeResults{n1}
	return e.mock
}

// GetWorkingNode implements network.Accessor
func (mmGetWorkingNode *AccessorMock) GetWorkingNode(ref insolar.Reference) (n1 insolar.NetworkNode) {
	mm_atomic.AddUint64(&mmGetWorkingNode.beforeGetWorkingNodeCounter, 1)
	defer mm_atomic.AddUint64(&mmGetWorkingNode.afterGetWorkingNodeCounter, 1)

	if mmGetWorkingNode.inspectFuncGetWorkingNode != nil {
		mmGetWorkingNode.inspectFuncGetWorkingNode(ref)
	}

	params := &AccessorMockGetWorkingNodeParams{ref}

	// Record call args
	mmGetWorkingNode.GetWorkingNodeMock.mutex.Lock()
	mmGetWorkingNode.GetWorkingNodeMock.callArgs = append(mmGetWorkingNode.GetWorkingNodeMock.callArgs, params)
	mmGetWorkingNode.GetWorkingNodeMock.mutex.Unlock()

	for _, e := range mmGetWorkingNode.GetWorkingNodeMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n1
		}
	}

	if mmGetWorkingNode.GetWorkingNodeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetWorkingNode.GetWorkingNodeMock.defaultExpectation.Counter, 1)
		want := mmGetWorkingNode.GetWorkingNodeMock.defaultExpectation.params
		got := AccessorMockGetWorkingNodeParams{ref}
		if want != nil && !minimock.Equal(*want, got) {
			mmGetWorkingNode.t.Errorf("AccessorMock.GetWorkingNode got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmGetWorkingNode.GetWorkingNodeMock.defaultExpectation.results
		if results == nil {
			mmGetWorkingNode.t.Fatal("No results are set for the AccessorMock.GetWorkingNode")
		}
		return (*results).n1
	}
	if mmGetWorkingNode.funcGetWorkingNode != nil {
		return mmGetWorkingNode.funcGetWorkingNode(ref)
	}
	mmGetWorkingNode.t.Fatalf("Unexpected call to AccessorMock.GetWorkingNode. %v", ref)
	return
}

// GetWorkingNodeAfterCounter returns a count of finished AccessorMock.GetWorkingNode invocations
func (mmGetWorkingNode *AccessorMock) GetWorkingNodeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetWorkingNode.afterGetWorkingNodeCounter)
}

// GetWorkingNodeBeforeCounter returns a count of AccessorMock.GetWorkingNode invocations
func (mmGetWorkingNode *AccessorMock) GetWorkingNodeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetWorkingNode.beforeGetWorkingNodeCounter)
}

// Calls returns a list of arguments used in each call to AccessorMock.GetWorkingNode.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetWorkingNode *mAccessorMockGetWorkingNode) Calls() []*AccessorMockGetWorkingNodeParams {
	mmGetWorkingNode.mutex.RLock()

	argCopy := make([]*AccessorMockGetWorkingNodeParams, len(mmGetWorkingNode.callArgs))
	copy(argCopy, mmGetWorkingNode.callArgs)

	mmGetWorkingNode.mutex.RUnlock()

	return argCopy
}

// MinimockGetWorkingNodeDone returns true if the count of the GetWorkingNode invocations corresponds
// the number of defined expectations
func (m *AccessorMock) MinimockGetWorkingNodeDone() bool {
	for _, e := range m.GetWorkingNodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetWorkingNodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetWorkingNodeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetWorkingNode != nil && mm_atomic.LoadUint64(&m.afterGetWorkingNodeCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetWorkingNodeInspect logs each unmet expectation
func (m *AccessorMock) MinimockGetWorkingNodeInspect() {
	for _, e := range m.GetWorkingNodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AccessorMock.GetWorkingNode with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetWorkingNodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetWorkingNodeCounter) < 1 {
		if m.GetWorkingNodeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AccessorMock.GetWorkingNode")
		} else {
			m.t.Errorf("Expected call to AccessorMock.GetWorkingNode with params: %#v", *m.GetWorkingNodeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetWorkingNode != nil && mm_atomic.LoadUint64(&m.afterGetWorkingNodeCounter) < 1 {
		m.t.Error("Expected call to AccessorMock.GetWorkingNode")
	}
}

type mAccessorMockGetWorkingNodes struct {
	mock               *AccessorMock
	defaultExpectation *AccessorMockGetWorkingNodesExpectation
	expectations       []*AccessorMockGetWorkingNodesExpectation
}

// AccessorMockGetWorkingNodesExpectation specifies expectation struct of the Accessor.GetWorkingNodes
type AccessorMockGetWorkingNodesExpectation struct {
	mock *AccessorMock

	results *AccessorMockGetWorkingNodesResults
	Counter uint64
}

// AccessorMockGetWorkingNodesResults contains results of the Accessor.GetWorkingNodes
type AccessorMockGetWorkingNodesResults struct {
	na1 []insolar.NetworkNode
}

// Expect sets up expected params for Accessor.GetWorkingNodes
func (mmGetWorkingNodes *mAccessorMockGetWorkingNodes) Expect() *mAccessorMockGetWorkingNodes {
	if mmGetWorkingNodes.mock.funcGetWorkingNodes != nil {
		mmGetWorkingNodes.mock.t.Fatalf("AccessorMock.GetWorkingNodes mock is already set by Set")
	}

	if mmGetWorkingNodes.defaultExpectation == nil {
		mmGetWorkingNodes.defaultExpectation = &AccessorMockGetWorkingNodesExpectation{}
	}

	return mmGetWorkingNodes
}

// Inspect accepts an inspector function that has same arguments as the Accessor.GetWorkingNodes
func (mmGetWorkingNodes *mAccessorMockGetWorkingNodes) Inspect(f func()) *mAccessorMockGetWorkingNodes {
	if mmGetWorkingNodes.mock.inspectFuncGetWorkingNodes != nil {
		mmGetWorkingNodes.mock.t.Fatalf("Inspect function is already set for AccessorMock.GetWorkingNodes")
	}

	mmGetWorkingNodes.mock.inspectFuncGetWorkingNodes = f

	return mmGetWorkingNodes
}

// Return sets up results that will be returned by Accessor.GetWorkingNodes
func (mmGetWorkingNodes *mAccessorMockGetWorkingNodes) Return(na1 []insolar.NetworkNode) *AccessorMock {
	if mmGetWorkingNodes.mock.funcGetWorkingNodes != nil {
		mmGetWorkingNodes.mock.t.Fatalf("AccessorMock.GetWorkingNodes mock is already set by Set")
	}

	if mmGetWorkingNodes.defaultExpectation == nil {
		mmGetWorkingNodes.defaultExpectation = &AccessorMockGetWorkingNodesExpectation{mock: mmGetWorkingNodes.mock}
	}
	mmGetWorkingNodes.defaultExpectation.results = &AccessorMockGetWorkingNodesResults{na1}
	return mmGetWorkingNodes.mock
}

//Set uses given function f to mock the Accessor.GetWorkingNodes method
func (mmGetWorkingNodes *mAccessorMockGetWorkingNodes) Set(f func() (na1 []insolar.NetworkNode)) *AccessorMock {
	if mmGetWorkingNodes.defaultExpectation != nil {
		mmGetWorkingNodes.mock.t.Fatalf("Default expectation is already set for the Accessor.GetWorkingNodes method")
	}

	if len(mmGetWorkingNodes.expectations) > 0 {
		mmGetWorkingNodes.mock.t.Fatalf("Some expectations are already set for the Accessor.GetWorkingNodes method")
	}

	mmGetWorkingNodes.mock.funcGetWorkingNodes = f
	return mmGetWorkingNodes.mock
}

// GetWorkingNodes implements network.Accessor
func (mmGetWorkingNodes *AccessorMock) GetWorkingNodes() (na1 []insolar.NetworkNode) {
	mm_atomic.AddUint64(&mmGetWorkingNodes.beforeGetWorkingNodesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetWorkingNodes.afterGetWorkingNodesCounter, 1)

	if mmGetWorkingNodes.inspectFuncGetWorkingNodes != nil {
		mmGetWorkingNodes.inspectFuncGetWorkingNodes()
	}

	if mmGetWorkingNodes.GetWorkingNodesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetWorkingNodes.GetWorkingNodesMock.defaultExpectation.Counter, 1)

		results := mmGetWorkingNodes.GetWorkingNodesMock.defaultExpectation.results
		if results == nil {
			mmGetWorkingNodes.t.Fatal("No results are set for the AccessorMock.GetWorkingNodes")
		}
		return (*results).na1
	}
	if mmGetWorkingNodes.funcGetWorkingNodes != nil {
		return mmGetWorkingNodes.funcGetWorkingNodes()
	}
	mmGetWorkingNodes.t.Fatalf("Unexpected call to AccessorMock.GetWorkingNodes.")
	return
}

// GetWorkingNodesAfterCounter returns a count of finished AccessorMock.GetWorkingNodes invocations
func (mmGetWorkingNodes *AccessorMock) GetWorkingNodesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetWorkingNodes.afterGetWorkingNodesCounter)
}

// GetWorkingNodesBeforeCounter returns a count of AccessorMock.GetWorkingNodes invocations
func (mmGetWorkingNodes *AccessorMock) GetWorkingNodesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetWorkingNodes.beforeGetWorkingNodesCounter)
}

// MinimockGetWorkingNodesDone returns true if the count of the GetWorkingNodes invocations corresponds
// the number of defined expectations
func (m *AccessorMock) MinimockGetWorkingNodesDone() bool {
	for _, e := range m.GetWorkingNodesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetWorkingNodesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetWorkingNodesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetWorkingNodes != nil && mm_atomic.LoadUint64(&m.afterGetWorkingNodesCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetWorkingNodesInspect logs each unmet expectation
func (m *AccessorMock) MinimockGetWorkingNodesInspect() {
	for _, e := range m.GetWorkingNodesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AccessorMock.GetWorkingNodes")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetWorkingNodesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetWorkingNodesCounter) < 1 {
		m.t.Error("Expected call to AccessorMock.GetWorkingNodes")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetWorkingNodes != nil && mm_atomic.LoadUint64(&m.afterGetWorkingNodesCounter) < 1 {
		m.t.Error("Expected call to AccessorMock.GetWorkingNodes")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AccessorMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetActiveNodeInspect()

		m.MinimockGetActiveNodeByAddrInspect()

		m.MinimockGetActiveNodeByShortIDInspect()

		m.MinimockGetActiveNodesInspect()

		m.MinimockGetWorkingNodeInspect()

		m.MinimockGetWorkingNodesInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AccessorMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AccessorMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetActiveNodeDone() &&
		m.MinimockGetActiveNodeByAddrDone() &&
		m.MinimockGetActiveNodeByShortIDDone() &&
		m.MinimockGetActiveNodesDone() &&
		m.MinimockGetWorkingNodeDone() &&
		m.MinimockGetWorkingNodesDone()
}
