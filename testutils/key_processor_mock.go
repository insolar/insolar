package testutils

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"crypto"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// KeyProcessorMock implements insolar.KeyProcessor
type KeyProcessorMock struct {
	t minimock.Tester

	funcExportPrivateKeyPEM          func(p1 crypto.PrivateKey) (ba1 []byte, err error)
	inspectFuncExportPrivateKeyPEM   func(p1 crypto.PrivateKey)
	afterExportPrivateKeyPEMCounter  uint64
	beforeExportPrivateKeyPEMCounter uint64
	ExportPrivateKeyPEMMock          mKeyProcessorMockExportPrivateKeyPEM

	funcExportPublicKeyBinary          func(p1 crypto.PublicKey) (ba1 []byte, err error)
	inspectFuncExportPublicKeyBinary   func(p1 crypto.PublicKey)
	afterExportPublicKeyBinaryCounter  uint64
	beforeExportPublicKeyBinaryCounter uint64
	ExportPublicKeyBinaryMock          mKeyProcessorMockExportPublicKeyBinary

	funcExportPublicKeyPEM          func(p1 crypto.PublicKey) (ba1 []byte, err error)
	inspectFuncExportPublicKeyPEM   func(p1 crypto.PublicKey)
	afterExportPublicKeyPEMCounter  uint64
	beforeExportPublicKeyPEMCounter uint64
	ExportPublicKeyPEMMock          mKeyProcessorMockExportPublicKeyPEM

	funcExtractPublicKey          func(p1 crypto.PrivateKey) (p2 crypto.PublicKey)
	inspectFuncExtractPublicKey   func(p1 crypto.PrivateKey)
	afterExtractPublicKeyCounter  uint64
	beforeExtractPublicKeyCounter uint64
	ExtractPublicKeyMock          mKeyProcessorMockExtractPublicKey

	funcGeneratePrivateKey          func() (p1 crypto.PrivateKey, err error)
	inspectFuncGeneratePrivateKey   func()
	afterGeneratePrivateKeyCounter  uint64
	beforeGeneratePrivateKeyCounter uint64
	GeneratePrivateKeyMock          mKeyProcessorMockGeneratePrivateKey

	funcImportPrivateKeyPEM          func(ba1 []byte) (p1 crypto.PrivateKey, err error)
	inspectFuncImportPrivateKeyPEM   func(ba1 []byte)
	afterImportPrivateKeyPEMCounter  uint64
	beforeImportPrivateKeyPEMCounter uint64
	ImportPrivateKeyPEMMock          mKeyProcessorMockImportPrivateKeyPEM

	funcImportPublicKeyBinary          func(ba1 []byte) (p1 crypto.PublicKey, err error)
	inspectFuncImportPublicKeyBinary   func(ba1 []byte)
	afterImportPublicKeyBinaryCounter  uint64
	beforeImportPublicKeyBinaryCounter uint64
	ImportPublicKeyBinaryMock          mKeyProcessorMockImportPublicKeyBinary

	funcImportPublicKeyPEM          func(ba1 []byte) (p1 crypto.PublicKey, err error)
	inspectFuncImportPublicKeyPEM   func(ba1 []byte)
	afterImportPublicKeyPEMCounter  uint64
	beforeImportPublicKeyPEMCounter uint64
	ImportPublicKeyPEMMock          mKeyProcessorMockImportPublicKeyPEM
}

// NewKeyProcessorMock returns a mock for insolar.KeyProcessor
func NewKeyProcessorMock(t minimock.Tester) *KeyProcessorMock {
	m := &KeyProcessorMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ExportPrivateKeyPEMMock = mKeyProcessorMockExportPrivateKeyPEM{mock: m}
	m.ExportPrivateKeyPEMMock.callArgs = []*KeyProcessorMockExportPrivateKeyPEMParams{}

	m.ExportPublicKeyBinaryMock = mKeyProcessorMockExportPublicKeyBinary{mock: m}
	m.ExportPublicKeyBinaryMock.callArgs = []*KeyProcessorMockExportPublicKeyBinaryParams{}

	m.ExportPublicKeyPEMMock = mKeyProcessorMockExportPublicKeyPEM{mock: m}
	m.ExportPublicKeyPEMMock.callArgs = []*KeyProcessorMockExportPublicKeyPEMParams{}

	m.ExtractPublicKeyMock = mKeyProcessorMockExtractPublicKey{mock: m}
	m.ExtractPublicKeyMock.callArgs = []*KeyProcessorMockExtractPublicKeyParams{}

	m.GeneratePrivateKeyMock = mKeyProcessorMockGeneratePrivateKey{mock: m}

	m.ImportPrivateKeyPEMMock = mKeyProcessorMockImportPrivateKeyPEM{mock: m}
	m.ImportPrivateKeyPEMMock.callArgs = []*KeyProcessorMockImportPrivateKeyPEMParams{}

	m.ImportPublicKeyBinaryMock = mKeyProcessorMockImportPublicKeyBinary{mock: m}
	m.ImportPublicKeyBinaryMock.callArgs = []*KeyProcessorMockImportPublicKeyBinaryParams{}

	m.ImportPublicKeyPEMMock = mKeyProcessorMockImportPublicKeyPEM{mock: m}
	m.ImportPublicKeyPEMMock.callArgs = []*KeyProcessorMockImportPublicKeyPEMParams{}

	return m
}

type mKeyProcessorMockExportPrivateKeyPEM struct {
	mock               *KeyProcessorMock
	defaultExpectation *KeyProcessorMockExportPrivateKeyPEMExpectation
	expectations       []*KeyProcessorMockExportPrivateKeyPEMExpectation

	callArgs []*KeyProcessorMockExportPrivateKeyPEMParams
	mutex    sync.RWMutex
}

// KeyProcessorMockExportPrivateKeyPEMExpectation specifies expectation struct of the KeyProcessor.ExportPrivateKeyPEM
type KeyProcessorMockExportPrivateKeyPEMExpectation struct {
	mock    *KeyProcessorMock
	params  *KeyProcessorMockExportPrivateKeyPEMParams
	results *KeyProcessorMockExportPrivateKeyPEMResults
	Counter uint64
}

// KeyProcessorMockExportPrivateKeyPEMParams contains parameters of the KeyProcessor.ExportPrivateKeyPEM
type KeyProcessorMockExportPrivateKeyPEMParams struct {
	p1 crypto.PrivateKey
}

// KeyProcessorMockExportPrivateKeyPEMResults contains results of the KeyProcessor.ExportPrivateKeyPEM
type KeyProcessorMockExportPrivateKeyPEMResults struct {
	ba1 []byte
	err error
}

// Expect sets up expected params for KeyProcessor.ExportPrivateKeyPEM
func (mmExportPrivateKeyPEM *mKeyProcessorMockExportPrivateKeyPEM) Expect(p1 crypto.PrivateKey) *mKeyProcessorMockExportPrivateKeyPEM {
	if mmExportPrivateKeyPEM.mock.funcExportPrivateKeyPEM != nil {
		mmExportPrivateKeyPEM.mock.t.Fatalf("KeyProcessorMock.ExportPrivateKeyPEM mock is already set by Set")
	}

	if mmExportPrivateKeyPEM.defaultExpectation == nil {
		mmExportPrivateKeyPEM.defaultExpectation = &KeyProcessorMockExportPrivateKeyPEMExpectation{}
	}

	mmExportPrivateKeyPEM.defaultExpectation.params = &KeyProcessorMockExportPrivateKeyPEMParams{p1}
	for _, e := range mmExportPrivateKeyPEM.expectations {
		if minimock.Equal(e.params, mmExportPrivateKeyPEM.defaultExpectation.params) {
			mmExportPrivateKeyPEM.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExportPrivateKeyPEM.defaultExpectation.params)
		}
	}

	return mmExportPrivateKeyPEM
}

// Inspect accepts an inspector function that has same arguments as the KeyProcessor.ExportPrivateKeyPEM
func (mmExportPrivateKeyPEM *mKeyProcessorMockExportPrivateKeyPEM) Inspect(f func(p1 crypto.PrivateKey)) *mKeyProcessorMockExportPrivateKeyPEM {
	if mmExportPrivateKeyPEM.mock.inspectFuncExportPrivateKeyPEM != nil {
		mmExportPrivateKeyPEM.mock.t.Fatalf("Inspect function is already set for KeyProcessorMock.ExportPrivateKeyPEM")
	}

	mmExportPrivateKeyPEM.mock.inspectFuncExportPrivateKeyPEM = f

	return mmExportPrivateKeyPEM
}

// Return sets up results that will be returned by KeyProcessor.ExportPrivateKeyPEM
func (mmExportPrivateKeyPEM *mKeyProcessorMockExportPrivateKeyPEM) Return(ba1 []byte, err error) *KeyProcessorMock {
	if mmExportPrivateKeyPEM.mock.funcExportPrivateKeyPEM != nil {
		mmExportPrivateKeyPEM.mock.t.Fatalf("KeyProcessorMock.ExportPrivateKeyPEM mock is already set by Set")
	}

	if mmExportPrivateKeyPEM.defaultExpectation == nil {
		mmExportPrivateKeyPEM.defaultExpectation = &KeyProcessorMockExportPrivateKeyPEMExpectation{mock: mmExportPrivateKeyPEM.mock}
	}
	mmExportPrivateKeyPEM.defaultExpectation.results = &KeyProcessorMockExportPrivateKeyPEMResults{ba1, err}
	return mmExportPrivateKeyPEM.mock
}

//Set uses given function f to mock the KeyProcessor.ExportPrivateKeyPEM method
func (mmExportPrivateKeyPEM *mKeyProcessorMockExportPrivateKeyPEM) Set(f func(p1 crypto.PrivateKey) (ba1 []byte, err error)) *KeyProcessorMock {
	if mmExportPrivateKeyPEM.defaultExpectation != nil {
		mmExportPrivateKeyPEM.mock.t.Fatalf("Default expectation is already set for the KeyProcessor.ExportPrivateKeyPEM method")
	}

	if len(mmExportPrivateKeyPEM.expectations) > 0 {
		mmExportPrivateKeyPEM.mock.t.Fatalf("Some expectations are already set for the KeyProcessor.ExportPrivateKeyPEM method")
	}

	mmExportPrivateKeyPEM.mock.funcExportPrivateKeyPEM = f
	return mmExportPrivateKeyPEM.mock
}

// When sets expectation for the KeyProcessor.ExportPrivateKeyPEM which will trigger the result defined by the following
// Then helper
func (mmExportPrivateKeyPEM *mKeyProcessorMockExportPrivateKeyPEM) When(p1 crypto.PrivateKey) *KeyProcessorMockExportPrivateKeyPEMExpectation {
	if mmExportPrivateKeyPEM.mock.funcExportPrivateKeyPEM != nil {
		mmExportPrivateKeyPEM.mock.t.Fatalf("KeyProcessorMock.ExportPrivateKeyPEM mock is already set by Set")
	}

	expectation := &KeyProcessorMockExportPrivateKeyPEMExpectation{
		mock:   mmExportPrivateKeyPEM.mock,
		params: &KeyProcessorMockExportPrivateKeyPEMParams{p1},
	}
	mmExportPrivateKeyPEM.expectations = append(mmExportPrivateKeyPEM.expectations, expectation)
	return expectation
}

// Then sets up KeyProcessor.ExportPrivateKeyPEM return parameters for the expectation previously defined by the When method
func (e *KeyProcessorMockExportPrivateKeyPEMExpectation) Then(ba1 []byte, err error) *KeyProcessorMock {
	e.results = &KeyProcessorMockExportPrivateKeyPEMResults{ba1, err}
	return e.mock
}

// ExportPrivateKeyPEM implements insolar.KeyProcessor
func (mmExportPrivateKeyPEM *KeyProcessorMock) ExportPrivateKeyPEM(p1 crypto.PrivateKey) (ba1 []byte, err error) {
	mm_atomic.AddUint64(&mmExportPrivateKeyPEM.beforeExportPrivateKeyPEMCounter, 1)
	defer mm_atomic.AddUint64(&mmExportPrivateKeyPEM.afterExportPrivateKeyPEMCounter, 1)

	if mmExportPrivateKeyPEM.inspectFuncExportPrivateKeyPEM != nil {
		mmExportPrivateKeyPEM.inspectFuncExportPrivateKeyPEM(p1)
	}

	mm_params := &KeyProcessorMockExportPrivateKeyPEMParams{p1}

	// Record call args
	mmExportPrivateKeyPEM.ExportPrivateKeyPEMMock.mutex.Lock()
	mmExportPrivateKeyPEM.ExportPrivateKeyPEMMock.callArgs = append(mmExportPrivateKeyPEM.ExportPrivateKeyPEMMock.callArgs, mm_params)
	mmExportPrivateKeyPEM.ExportPrivateKeyPEMMock.mutex.Unlock()

	for _, e := range mmExportPrivateKeyPEM.ExportPrivateKeyPEMMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ba1, e.results.err
		}
	}

	if mmExportPrivateKeyPEM.ExportPrivateKeyPEMMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExportPrivateKeyPEM.ExportPrivateKeyPEMMock.defaultExpectation.Counter, 1)
		mm_want := mmExportPrivateKeyPEM.ExportPrivateKeyPEMMock.defaultExpectation.params
		mm_got := KeyProcessorMockExportPrivateKeyPEMParams{p1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExportPrivateKeyPEM.t.Errorf("KeyProcessorMock.ExportPrivateKeyPEM got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExportPrivateKeyPEM.ExportPrivateKeyPEMMock.defaultExpectation.results
		if mm_results == nil {
			mmExportPrivateKeyPEM.t.Fatal("No results are set for the KeyProcessorMock.ExportPrivateKeyPEM")
		}
		return (*mm_results).ba1, (*mm_results).err
	}
	if mmExportPrivateKeyPEM.funcExportPrivateKeyPEM != nil {
		return mmExportPrivateKeyPEM.funcExportPrivateKeyPEM(p1)
	}
	mmExportPrivateKeyPEM.t.Fatalf("Unexpected call to KeyProcessorMock.ExportPrivateKeyPEM. %v", p1)
	return
}

// ExportPrivateKeyPEMAfterCounter returns a count of finished KeyProcessorMock.ExportPrivateKeyPEM invocations
func (mmExportPrivateKeyPEM *KeyProcessorMock) ExportPrivateKeyPEMAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExportPrivateKeyPEM.afterExportPrivateKeyPEMCounter)
}

// ExportPrivateKeyPEMBeforeCounter returns a count of KeyProcessorMock.ExportPrivateKeyPEM invocations
func (mmExportPrivateKeyPEM *KeyProcessorMock) ExportPrivateKeyPEMBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExportPrivateKeyPEM.beforeExportPrivateKeyPEMCounter)
}

// Calls returns a list of arguments used in each call to KeyProcessorMock.ExportPrivateKeyPEM.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExportPrivateKeyPEM *mKeyProcessorMockExportPrivateKeyPEM) Calls() []*KeyProcessorMockExportPrivateKeyPEMParams {
	mmExportPrivateKeyPEM.mutex.RLock()

	argCopy := make([]*KeyProcessorMockExportPrivateKeyPEMParams, len(mmExportPrivateKeyPEM.callArgs))
	copy(argCopy, mmExportPrivateKeyPEM.callArgs)

	mmExportPrivateKeyPEM.mutex.RUnlock()

	return argCopy
}

// MinimockExportPrivateKeyPEMDone returns true if the count of the ExportPrivateKeyPEM invocations corresponds
// the number of defined expectations
func (m *KeyProcessorMock) MinimockExportPrivateKeyPEMDone() bool {
	for _, e := range m.ExportPrivateKeyPEMMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExportPrivateKeyPEMMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExportPrivateKeyPEMCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExportPrivateKeyPEM != nil && mm_atomic.LoadUint64(&m.afterExportPrivateKeyPEMCounter) < 1 {
		return false
	}
	return true
}

// MinimockExportPrivateKeyPEMInspect logs each unmet expectation
func (m *KeyProcessorMock) MinimockExportPrivateKeyPEMInspect() {
	for _, e := range m.ExportPrivateKeyPEMMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KeyProcessorMock.ExportPrivateKeyPEM with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExportPrivateKeyPEMMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExportPrivateKeyPEMCounter) < 1 {
		if m.ExportPrivateKeyPEMMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to KeyProcessorMock.ExportPrivateKeyPEM")
		} else {
			m.t.Errorf("Expected call to KeyProcessorMock.ExportPrivateKeyPEM with params: %#v", *m.ExportPrivateKeyPEMMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExportPrivateKeyPEM != nil && mm_atomic.LoadUint64(&m.afterExportPrivateKeyPEMCounter) < 1 {
		m.t.Error("Expected call to KeyProcessorMock.ExportPrivateKeyPEM")
	}
}

type mKeyProcessorMockExportPublicKeyBinary struct {
	mock               *KeyProcessorMock
	defaultExpectation *KeyProcessorMockExportPublicKeyBinaryExpectation
	expectations       []*KeyProcessorMockExportPublicKeyBinaryExpectation

	callArgs []*KeyProcessorMockExportPublicKeyBinaryParams
	mutex    sync.RWMutex
}

// KeyProcessorMockExportPublicKeyBinaryExpectation specifies expectation struct of the KeyProcessor.ExportPublicKeyBinary
type KeyProcessorMockExportPublicKeyBinaryExpectation struct {
	mock    *KeyProcessorMock
	params  *KeyProcessorMockExportPublicKeyBinaryParams
	results *KeyProcessorMockExportPublicKeyBinaryResults
	Counter uint64
}

// KeyProcessorMockExportPublicKeyBinaryParams contains parameters of the KeyProcessor.ExportPublicKeyBinary
type KeyProcessorMockExportPublicKeyBinaryParams struct {
	p1 crypto.PublicKey
}

// KeyProcessorMockExportPublicKeyBinaryResults contains results of the KeyProcessor.ExportPublicKeyBinary
type KeyProcessorMockExportPublicKeyBinaryResults struct {
	ba1 []byte
	err error
}

// Expect sets up expected params for KeyProcessor.ExportPublicKeyBinary
func (mmExportPublicKeyBinary *mKeyProcessorMockExportPublicKeyBinary) Expect(p1 crypto.PublicKey) *mKeyProcessorMockExportPublicKeyBinary {
	if mmExportPublicKeyBinary.mock.funcExportPublicKeyBinary != nil {
		mmExportPublicKeyBinary.mock.t.Fatalf("KeyProcessorMock.ExportPublicKeyBinary mock is already set by Set")
	}

	if mmExportPublicKeyBinary.defaultExpectation == nil {
		mmExportPublicKeyBinary.defaultExpectation = &KeyProcessorMockExportPublicKeyBinaryExpectation{}
	}

	mmExportPublicKeyBinary.defaultExpectation.params = &KeyProcessorMockExportPublicKeyBinaryParams{p1}
	for _, e := range mmExportPublicKeyBinary.expectations {
		if minimock.Equal(e.params, mmExportPublicKeyBinary.defaultExpectation.params) {
			mmExportPublicKeyBinary.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExportPublicKeyBinary.defaultExpectation.params)
		}
	}

	return mmExportPublicKeyBinary
}

// Inspect accepts an inspector function that has same arguments as the KeyProcessor.ExportPublicKeyBinary
func (mmExportPublicKeyBinary *mKeyProcessorMockExportPublicKeyBinary) Inspect(f func(p1 crypto.PublicKey)) *mKeyProcessorMockExportPublicKeyBinary {
	if mmExportPublicKeyBinary.mock.inspectFuncExportPublicKeyBinary != nil {
		mmExportPublicKeyBinary.mock.t.Fatalf("Inspect function is already set for KeyProcessorMock.ExportPublicKeyBinary")
	}

	mmExportPublicKeyBinary.mock.inspectFuncExportPublicKeyBinary = f

	return mmExportPublicKeyBinary
}

// Return sets up results that will be returned by KeyProcessor.ExportPublicKeyBinary
func (mmExportPublicKeyBinary *mKeyProcessorMockExportPublicKeyBinary) Return(ba1 []byte, err error) *KeyProcessorMock {
	if mmExportPublicKeyBinary.mock.funcExportPublicKeyBinary != nil {
		mmExportPublicKeyBinary.mock.t.Fatalf("KeyProcessorMock.ExportPublicKeyBinary mock is already set by Set")
	}

	if mmExportPublicKeyBinary.defaultExpectation == nil {
		mmExportPublicKeyBinary.defaultExpectation = &KeyProcessorMockExportPublicKeyBinaryExpectation{mock: mmExportPublicKeyBinary.mock}
	}
	mmExportPublicKeyBinary.defaultExpectation.results = &KeyProcessorMockExportPublicKeyBinaryResults{ba1, err}
	return mmExportPublicKeyBinary.mock
}

//Set uses given function f to mock the KeyProcessor.ExportPublicKeyBinary method
func (mmExportPublicKeyBinary *mKeyProcessorMockExportPublicKeyBinary) Set(f func(p1 crypto.PublicKey) (ba1 []byte, err error)) *KeyProcessorMock {
	if mmExportPublicKeyBinary.defaultExpectation != nil {
		mmExportPublicKeyBinary.mock.t.Fatalf("Default expectation is already set for the KeyProcessor.ExportPublicKeyBinary method")
	}

	if len(mmExportPublicKeyBinary.expectations) > 0 {
		mmExportPublicKeyBinary.mock.t.Fatalf("Some expectations are already set for the KeyProcessor.ExportPublicKeyBinary method")
	}

	mmExportPublicKeyBinary.mock.funcExportPublicKeyBinary = f
	return mmExportPublicKeyBinary.mock
}

// When sets expectation for the KeyProcessor.ExportPublicKeyBinary which will trigger the result defined by the following
// Then helper
func (mmExportPublicKeyBinary *mKeyProcessorMockExportPublicKeyBinary) When(p1 crypto.PublicKey) *KeyProcessorMockExportPublicKeyBinaryExpectation {
	if mmExportPublicKeyBinary.mock.funcExportPublicKeyBinary != nil {
		mmExportPublicKeyBinary.mock.t.Fatalf("KeyProcessorMock.ExportPublicKeyBinary mock is already set by Set")
	}

	expectation := &KeyProcessorMockExportPublicKeyBinaryExpectation{
		mock:   mmExportPublicKeyBinary.mock,
		params: &KeyProcessorMockExportPublicKeyBinaryParams{p1},
	}
	mmExportPublicKeyBinary.expectations = append(mmExportPublicKeyBinary.expectations, expectation)
	return expectation
}

// Then sets up KeyProcessor.ExportPublicKeyBinary return parameters for the expectation previously defined by the When method
func (e *KeyProcessorMockExportPublicKeyBinaryExpectation) Then(ba1 []byte, err error) *KeyProcessorMock {
	e.results = &KeyProcessorMockExportPublicKeyBinaryResults{ba1, err}
	return e.mock
}

// ExportPublicKeyBinary implements insolar.KeyProcessor
func (mmExportPublicKeyBinary *KeyProcessorMock) ExportPublicKeyBinary(p1 crypto.PublicKey) (ba1 []byte, err error) {
	mm_atomic.AddUint64(&mmExportPublicKeyBinary.beforeExportPublicKeyBinaryCounter, 1)
	defer mm_atomic.AddUint64(&mmExportPublicKeyBinary.afterExportPublicKeyBinaryCounter, 1)

	if mmExportPublicKeyBinary.inspectFuncExportPublicKeyBinary != nil {
		mmExportPublicKeyBinary.inspectFuncExportPublicKeyBinary(p1)
	}

	mm_params := &KeyProcessorMockExportPublicKeyBinaryParams{p1}

	// Record call args
	mmExportPublicKeyBinary.ExportPublicKeyBinaryMock.mutex.Lock()
	mmExportPublicKeyBinary.ExportPublicKeyBinaryMock.callArgs = append(mmExportPublicKeyBinary.ExportPublicKeyBinaryMock.callArgs, mm_params)
	mmExportPublicKeyBinary.ExportPublicKeyBinaryMock.mutex.Unlock()

	for _, e := range mmExportPublicKeyBinary.ExportPublicKeyBinaryMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ba1, e.results.err
		}
	}

	if mmExportPublicKeyBinary.ExportPublicKeyBinaryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExportPublicKeyBinary.ExportPublicKeyBinaryMock.defaultExpectation.Counter, 1)
		mm_want := mmExportPublicKeyBinary.ExportPublicKeyBinaryMock.defaultExpectation.params
		mm_got := KeyProcessorMockExportPublicKeyBinaryParams{p1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExportPublicKeyBinary.t.Errorf("KeyProcessorMock.ExportPublicKeyBinary got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExportPublicKeyBinary.ExportPublicKeyBinaryMock.defaultExpectation.results
		if mm_results == nil {
			mmExportPublicKeyBinary.t.Fatal("No results are set for the KeyProcessorMock.ExportPublicKeyBinary")
		}
		return (*mm_results).ba1, (*mm_results).err
	}
	if mmExportPublicKeyBinary.funcExportPublicKeyBinary != nil {
		return mmExportPublicKeyBinary.funcExportPublicKeyBinary(p1)
	}
	mmExportPublicKeyBinary.t.Fatalf("Unexpected call to KeyProcessorMock.ExportPublicKeyBinary. %v", p1)
	return
}

// ExportPublicKeyBinaryAfterCounter returns a count of finished KeyProcessorMock.ExportPublicKeyBinary invocations
func (mmExportPublicKeyBinary *KeyProcessorMock) ExportPublicKeyBinaryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExportPublicKeyBinary.afterExportPublicKeyBinaryCounter)
}

// ExportPublicKeyBinaryBeforeCounter returns a count of KeyProcessorMock.ExportPublicKeyBinary invocations
func (mmExportPublicKeyBinary *KeyProcessorMock) ExportPublicKeyBinaryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExportPublicKeyBinary.beforeExportPublicKeyBinaryCounter)
}

// Calls returns a list of arguments used in each call to KeyProcessorMock.ExportPublicKeyBinary.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExportPublicKeyBinary *mKeyProcessorMockExportPublicKeyBinary) Calls() []*KeyProcessorMockExportPublicKeyBinaryParams {
	mmExportPublicKeyBinary.mutex.RLock()

	argCopy := make([]*KeyProcessorMockExportPublicKeyBinaryParams, len(mmExportPublicKeyBinary.callArgs))
	copy(argCopy, mmExportPublicKeyBinary.callArgs)

	mmExportPublicKeyBinary.mutex.RUnlock()

	return argCopy
}

// MinimockExportPublicKeyBinaryDone returns true if the count of the ExportPublicKeyBinary invocations corresponds
// the number of defined expectations
func (m *KeyProcessorMock) MinimockExportPublicKeyBinaryDone() bool {
	for _, e := range m.ExportPublicKeyBinaryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExportPublicKeyBinaryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExportPublicKeyBinaryCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExportPublicKeyBinary != nil && mm_atomic.LoadUint64(&m.afterExportPublicKeyBinaryCounter) < 1 {
		return false
	}
	return true
}

// MinimockExportPublicKeyBinaryInspect logs each unmet expectation
func (m *KeyProcessorMock) MinimockExportPublicKeyBinaryInspect() {
	for _, e := range m.ExportPublicKeyBinaryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KeyProcessorMock.ExportPublicKeyBinary with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExportPublicKeyBinaryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExportPublicKeyBinaryCounter) < 1 {
		if m.ExportPublicKeyBinaryMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to KeyProcessorMock.ExportPublicKeyBinary")
		} else {
			m.t.Errorf("Expected call to KeyProcessorMock.ExportPublicKeyBinary with params: %#v", *m.ExportPublicKeyBinaryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExportPublicKeyBinary != nil && mm_atomic.LoadUint64(&m.afterExportPublicKeyBinaryCounter) < 1 {
		m.t.Error("Expected call to KeyProcessorMock.ExportPublicKeyBinary")
	}
}

type mKeyProcessorMockExportPublicKeyPEM struct {
	mock               *KeyProcessorMock
	defaultExpectation *KeyProcessorMockExportPublicKeyPEMExpectation
	expectations       []*KeyProcessorMockExportPublicKeyPEMExpectation

	callArgs []*KeyProcessorMockExportPublicKeyPEMParams
	mutex    sync.RWMutex
}

// KeyProcessorMockExportPublicKeyPEMExpectation specifies expectation struct of the KeyProcessor.ExportPublicKeyPEM
type KeyProcessorMockExportPublicKeyPEMExpectation struct {
	mock    *KeyProcessorMock
	params  *KeyProcessorMockExportPublicKeyPEMParams
	results *KeyProcessorMockExportPublicKeyPEMResults
	Counter uint64
}

// KeyProcessorMockExportPublicKeyPEMParams contains parameters of the KeyProcessor.ExportPublicKeyPEM
type KeyProcessorMockExportPublicKeyPEMParams struct {
	p1 crypto.PublicKey
}

// KeyProcessorMockExportPublicKeyPEMResults contains results of the KeyProcessor.ExportPublicKeyPEM
type KeyProcessorMockExportPublicKeyPEMResults struct {
	ba1 []byte
	err error
}

// Expect sets up expected params for KeyProcessor.ExportPublicKeyPEM
func (mmExportPublicKeyPEM *mKeyProcessorMockExportPublicKeyPEM) Expect(p1 crypto.PublicKey) *mKeyProcessorMockExportPublicKeyPEM {
	if mmExportPublicKeyPEM.mock.funcExportPublicKeyPEM != nil {
		mmExportPublicKeyPEM.mock.t.Fatalf("KeyProcessorMock.ExportPublicKeyPEM mock is already set by Set")
	}

	if mmExportPublicKeyPEM.defaultExpectation == nil {
		mmExportPublicKeyPEM.defaultExpectation = &KeyProcessorMockExportPublicKeyPEMExpectation{}
	}

	mmExportPublicKeyPEM.defaultExpectation.params = &KeyProcessorMockExportPublicKeyPEMParams{p1}
	for _, e := range mmExportPublicKeyPEM.expectations {
		if minimock.Equal(e.params, mmExportPublicKeyPEM.defaultExpectation.params) {
			mmExportPublicKeyPEM.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExportPublicKeyPEM.defaultExpectation.params)
		}
	}

	return mmExportPublicKeyPEM
}

// Inspect accepts an inspector function that has same arguments as the KeyProcessor.ExportPublicKeyPEM
func (mmExportPublicKeyPEM *mKeyProcessorMockExportPublicKeyPEM) Inspect(f func(p1 crypto.PublicKey)) *mKeyProcessorMockExportPublicKeyPEM {
	if mmExportPublicKeyPEM.mock.inspectFuncExportPublicKeyPEM != nil {
		mmExportPublicKeyPEM.mock.t.Fatalf("Inspect function is already set for KeyProcessorMock.ExportPublicKeyPEM")
	}

	mmExportPublicKeyPEM.mock.inspectFuncExportPublicKeyPEM = f

	return mmExportPublicKeyPEM
}

// Return sets up results that will be returned by KeyProcessor.ExportPublicKeyPEM
func (mmExportPublicKeyPEM *mKeyProcessorMockExportPublicKeyPEM) Return(ba1 []byte, err error) *KeyProcessorMock {
	if mmExportPublicKeyPEM.mock.funcExportPublicKeyPEM != nil {
		mmExportPublicKeyPEM.mock.t.Fatalf("KeyProcessorMock.ExportPublicKeyPEM mock is already set by Set")
	}

	if mmExportPublicKeyPEM.defaultExpectation == nil {
		mmExportPublicKeyPEM.defaultExpectation = &KeyProcessorMockExportPublicKeyPEMExpectation{mock: mmExportPublicKeyPEM.mock}
	}
	mmExportPublicKeyPEM.defaultExpectation.results = &KeyProcessorMockExportPublicKeyPEMResults{ba1, err}
	return mmExportPublicKeyPEM.mock
}

//Set uses given function f to mock the KeyProcessor.ExportPublicKeyPEM method
func (mmExportPublicKeyPEM *mKeyProcessorMockExportPublicKeyPEM) Set(f func(p1 crypto.PublicKey) (ba1 []byte, err error)) *KeyProcessorMock {
	if mmExportPublicKeyPEM.defaultExpectation != nil {
		mmExportPublicKeyPEM.mock.t.Fatalf("Default expectation is already set for the KeyProcessor.ExportPublicKeyPEM method")
	}

	if len(mmExportPublicKeyPEM.expectations) > 0 {
		mmExportPublicKeyPEM.mock.t.Fatalf("Some expectations are already set for the KeyProcessor.ExportPublicKeyPEM method")
	}

	mmExportPublicKeyPEM.mock.funcExportPublicKeyPEM = f
	return mmExportPublicKeyPEM.mock
}

// When sets expectation for the KeyProcessor.ExportPublicKeyPEM which will trigger the result defined by the following
// Then helper
func (mmExportPublicKeyPEM *mKeyProcessorMockExportPublicKeyPEM) When(p1 crypto.PublicKey) *KeyProcessorMockExportPublicKeyPEMExpectation {
	if mmExportPublicKeyPEM.mock.funcExportPublicKeyPEM != nil {
		mmExportPublicKeyPEM.mock.t.Fatalf("KeyProcessorMock.ExportPublicKeyPEM mock is already set by Set")
	}

	expectation := &KeyProcessorMockExportPublicKeyPEMExpectation{
		mock:   mmExportPublicKeyPEM.mock,
		params: &KeyProcessorMockExportPublicKeyPEMParams{p1},
	}
	mmExportPublicKeyPEM.expectations = append(mmExportPublicKeyPEM.expectations, expectation)
	return expectation
}

// Then sets up KeyProcessor.ExportPublicKeyPEM return parameters for the expectation previously defined by the When method
func (e *KeyProcessorMockExportPublicKeyPEMExpectation) Then(ba1 []byte, err error) *KeyProcessorMock {
	e.results = &KeyProcessorMockExportPublicKeyPEMResults{ba1, err}
	return e.mock
}

// ExportPublicKeyPEM implements insolar.KeyProcessor
func (mmExportPublicKeyPEM *KeyProcessorMock) ExportPublicKeyPEM(p1 crypto.PublicKey) (ba1 []byte, err error) {
	mm_atomic.AddUint64(&mmExportPublicKeyPEM.beforeExportPublicKeyPEMCounter, 1)
	defer mm_atomic.AddUint64(&mmExportPublicKeyPEM.afterExportPublicKeyPEMCounter, 1)

	if mmExportPublicKeyPEM.inspectFuncExportPublicKeyPEM != nil {
		mmExportPublicKeyPEM.inspectFuncExportPublicKeyPEM(p1)
	}

	mm_params := &KeyProcessorMockExportPublicKeyPEMParams{p1}

	// Record call args
	mmExportPublicKeyPEM.ExportPublicKeyPEMMock.mutex.Lock()
	mmExportPublicKeyPEM.ExportPublicKeyPEMMock.callArgs = append(mmExportPublicKeyPEM.ExportPublicKeyPEMMock.callArgs, mm_params)
	mmExportPublicKeyPEM.ExportPublicKeyPEMMock.mutex.Unlock()

	for _, e := range mmExportPublicKeyPEM.ExportPublicKeyPEMMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ba1, e.results.err
		}
	}

	if mmExportPublicKeyPEM.ExportPublicKeyPEMMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExportPublicKeyPEM.ExportPublicKeyPEMMock.defaultExpectation.Counter, 1)
		mm_want := mmExportPublicKeyPEM.ExportPublicKeyPEMMock.defaultExpectation.params
		mm_got := KeyProcessorMockExportPublicKeyPEMParams{p1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExportPublicKeyPEM.t.Errorf("KeyProcessorMock.ExportPublicKeyPEM got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExportPublicKeyPEM.ExportPublicKeyPEMMock.defaultExpectation.results
		if mm_results == nil {
			mmExportPublicKeyPEM.t.Fatal("No results are set for the KeyProcessorMock.ExportPublicKeyPEM")
		}
		return (*mm_results).ba1, (*mm_results).err
	}
	if mmExportPublicKeyPEM.funcExportPublicKeyPEM != nil {
		return mmExportPublicKeyPEM.funcExportPublicKeyPEM(p1)
	}
	mmExportPublicKeyPEM.t.Fatalf("Unexpected call to KeyProcessorMock.ExportPublicKeyPEM. %v", p1)
	return
}

// ExportPublicKeyPEMAfterCounter returns a count of finished KeyProcessorMock.ExportPublicKeyPEM invocations
func (mmExportPublicKeyPEM *KeyProcessorMock) ExportPublicKeyPEMAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExportPublicKeyPEM.afterExportPublicKeyPEMCounter)
}

// ExportPublicKeyPEMBeforeCounter returns a count of KeyProcessorMock.ExportPublicKeyPEM invocations
func (mmExportPublicKeyPEM *KeyProcessorMock) ExportPublicKeyPEMBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExportPublicKeyPEM.beforeExportPublicKeyPEMCounter)
}

// Calls returns a list of arguments used in each call to KeyProcessorMock.ExportPublicKeyPEM.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExportPublicKeyPEM *mKeyProcessorMockExportPublicKeyPEM) Calls() []*KeyProcessorMockExportPublicKeyPEMParams {
	mmExportPublicKeyPEM.mutex.RLock()

	argCopy := make([]*KeyProcessorMockExportPublicKeyPEMParams, len(mmExportPublicKeyPEM.callArgs))
	copy(argCopy, mmExportPublicKeyPEM.callArgs)

	mmExportPublicKeyPEM.mutex.RUnlock()

	return argCopy
}

// MinimockExportPublicKeyPEMDone returns true if the count of the ExportPublicKeyPEM invocations corresponds
// the number of defined expectations
func (m *KeyProcessorMock) MinimockExportPublicKeyPEMDone() bool {
	for _, e := range m.ExportPublicKeyPEMMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExportPublicKeyPEMMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExportPublicKeyPEMCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExportPublicKeyPEM != nil && mm_atomic.LoadUint64(&m.afterExportPublicKeyPEMCounter) < 1 {
		return false
	}
	return true
}

// MinimockExportPublicKeyPEMInspect logs each unmet expectation
func (m *KeyProcessorMock) MinimockExportPublicKeyPEMInspect() {
	for _, e := range m.ExportPublicKeyPEMMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KeyProcessorMock.ExportPublicKeyPEM with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExportPublicKeyPEMMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExportPublicKeyPEMCounter) < 1 {
		if m.ExportPublicKeyPEMMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to KeyProcessorMock.ExportPublicKeyPEM")
		} else {
			m.t.Errorf("Expected call to KeyProcessorMock.ExportPublicKeyPEM with params: %#v", *m.ExportPublicKeyPEMMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExportPublicKeyPEM != nil && mm_atomic.LoadUint64(&m.afterExportPublicKeyPEMCounter) < 1 {
		m.t.Error("Expected call to KeyProcessorMock.ExportPublicKeyPEM")
	}
}

type mKeyProcessorMockExtractPublicKey struct {
	mock               *KeyProcessorMock
	defaultExpectation *KeyProcessorMockExtractPublicKeyExpectation
	expectations       []*KeyProcessorMockExtractPublicKeyExpectation

	callArgs []*KeyProcessorMockExtractPublicKeyParams
	mutex    sync.RWMutex
}

// KeyProcessorMockExtractPublicKeyExpectation specifies expectation struct of the KeyProcessor.ExtractPublicKey
type KeyProcessorMockExtractPublicKeyExpectation struct {
	mock    *KeyProcessorMock
	params  *KeyProcessorMockExtractPublicKeyParams
	results *KeyProcessorMockExtractPublicKeyResults
	Counter uint64
}

// KeyProcessorMockExtractPublicKeyParams contains parameters of the KeyProcessor.ExtractPublicKey
type KeyProcessorMockExtractPublicKeyParams struct {
	p1 crypto.PrivateKey
}

// KeyProcessorMockExtractPublicKeyResults contains results of the KeyProcessor.ExtractPublicKey
type KeyProcessorMockExtractPublicKeyResults struct {
	p2 crypto.PublicKey
}

// Expect sets up expected params for KeyProcessor.ExtractPublicKey
func (mmExtractPublicKey *mKeyProcessorMockExtractPublicKey) Expect(p1 crypto.PrivateKey) *mKeyProcessorMockExtractPublicKey {
	if mmExtractPublicKey.mock.funcExtractPublicKey != nil {
		mmExtractPublicKey.mock.t.Fatalf("KeyProcessorMock.ExtractPublicKey mock is already set by Set")
	}

	if mmExtractPublicKey.defaultExpectation == nil {
		mmExtractPublicKey.defaultExpectation = &KeyProcessorMockExtractPublicKeyExpectation{}
	}

	mmExtractPublicKey.defaultExpectation.params = &KeyProcessorMockExtractPublicKeyParams{p1}
	for _, e := range mmExtractPublicKey.expectations {
		if minimock.Equal(e.params, mmExtractPublicKey.defaultExpectation.params) {
			mmExtractPublicKey.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExtractPublicKey.defaultExpectation.params)
		}
	}

	return mmExtractPublicKey
}

// Inspect accepts an inspector function that has same arguments as the KeyProcessor.ExtractPublicKey
func (mmExtractPublicKey *mKeyProcessorMockExtractPublicKey) Inspect(f func(p1 crypto.PrivateKey)) *mKeyProcessorMockExtractPublicKey {
	if mmExtractPublicKey.mock.inspectFuncExtractPublicKey != nil {
		mmExtractPublicKey.mock.t.Fatalf("Inspect function is already set for KeyProcessorMock.ExtractPublicKey")
	}

	mmExtractPublicKey.mock.inspectFuncExtractPublicKey = f

	return mmExtractPublicKey
}

// Return sets up results that will be returned by KeyProcessor.ExtractPublicKey
func (mmExtractPublicKey *mKeyProcessorMockExtractPublicKey) Return(p2 crypto.PublicKey) *KeyProcessorMock {
	if mmExtractPublicKey.mock.funcExtractPublicKey != nil {
		mmExtractPublicKey.mock.t.Fatalf("KeyProcessorMock.ExtractPublicKey mock is already set by Set")
	}

	if mmExtractPublicKey.defaultExpectation == nil {
		mmExtractPublicKey.defaultExpectation = &KeyProcessorMockExtractPublicKeyExpectation{mock: mmExtractPublicKey.mock}
	}
	mmExtractPublicKey.defaultExpectation.results = &KeyProcessorMockExtractPublicKeyResults{p2}
	return mmExtractPublicKey.mock
}

//Set uses given function f to mock the KeyProcessor.ExtractPublicKey method
func (mmExtractPublicKey *mKeyProcessorMockExtractPublicKey) Set(f func(p1 crypto.PrivateKey) (p2 crypto.PublicKey)) *KeyProcessorMock {
	if mmExtractPublicKey.defaultExpectation != nil {
		mmExtractPublicKey.mock.t.Fatalf("Default expectation is already set for the KeyProcessor.ExtractPublicKey method")
	}

	if len(mmExtractPublicKey.expectations) > 0 {
		mmExtractPublicKey.mock.t.Fatalf("Some expectations are already set for the KeyProcessor.ExtractPublicKey method")
	}

	mmExtractPublicKey.mock.funcExtractPublicKey = f
	return mmExtractPublicKey.mock
}

// When sets expectation for the KeyProcessor.ExtractPublicKey which will trigger the result defined by the following
// Then helper
func (mmExtractPublicKey *mKeyProcessorMockExtractPublicKey) When(p1 crypto.PrivateKey) *KeyProcessorMockExtractPublicKeyExpectation {
	if mmExtractPublicKey.mock.funcExtractPublicKey != nil {
		mmExtractPublicKey.mock.t.Fatalf("KeyProcessorMock.ExtractPublicKey mock is already set by Set")
	}

	expectation := &KeyProcessorMockExtractPublicKeyExpectation{
		mock:   mmExtractPublicKey.mock,
		params: &KeyProcessorMockExtractPublicKeyParams{p1},
	}
	mmExtractPublicKey.expectations = append(mmExtractPublicKey.expectations, expectation)
	return expectation
}

// Then sets up KeyProcessor.ExtractPublicKey return parameters for the expectation previously defined by the When method
func (e *KeyProcessorMockExtractPublicKeyExpectation) Then(p2 crypto.PublicKey) *KeyProcessorMock {
	e.results = &KeyProcessorMockExtractPublicKeyResults{p2}
	return e.mock
}

// ExtractPublicKey implements insolar.KeyProcessor
func (mmExtractPublicKey *KeyProcessorMock) ExtractPublicKey(p1 crypto.PrivateKey) (p2 crypto.PublicKey) {
	mm_atomic.AddUint64(&mmExtractPublicKey.beforeExtractPublicKeyCounter, 1)
	defer mm_atomic.AddUint64(&mmExtractPublicKey.afterExtractPublicKeyCounter, 1)

	if mmExtractPublicKey.inspectFuncExtractPublicKey != nil {
		mmExtractPublicKey.inspectFuncExtractPublicKey(p1)
	}

	mm_params := &KeyProcessorMockExtractPublicKeyParams{p1}

	// Record call args
	mmExtractPublicKey.ExtractPublicKeyMock.mutex.Lock()
	mmExtractPublicKey.ExtractPublicKeyMock.callArgs = append(mmExtractPublicKey.ExtractPublicKeyMock.callArgs, mm_params)
	mmExtractPublicKey.ExtractPublicKeyMock.mutex.Unlock()

	for _, e := range mmExtractPublicKey.ExtractPublicKeyMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p2
		}
	}

	if mmExtractPublicKey.ExtractPublicKeyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExtractPublicKey.ExtractPublicKeyMock.defaultExpectation.Counter, 1)
		mm_want := mmExtractPublicKey.ExtractPublicKeyMock.defaultExpectation.params
		mm_got := KeyProcessorMockExtractPublicKeyParams{p1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExtractPublicKey.t.Errorf("KeyProcessorMock.ExtractPublicKey got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExtractPublicKey.ExtractPublicKeyMock.defaultExpectation.results
		if mm_results == nil {
			mmExtractPublicKey.t.Fatal("No results are set for the KeyProcessorMock.ExtractPublicKey")
		}
		return (*mm_results).p2
	}
	if mmExtractPublicKey.funcExtractPublicKey != nil {
		return mmExtractPublicKey.funcExtractPublicKey(p1)
	}
	mmExtractPublicKey.t.Fatalf("Unexpected call to KeyProcessorMock.ExtractPublicKey. %v", p1)
	return
}

// ExtractPublicKeyAfterCounter returns a count of finished KeyProcessorMock.ExtractPublicKey invocations
func (mmExtractPublicKey *KeyProcessorMock) ExtractPublicKeyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExtractPublicKey.afterExtractPublicKeyCounter)
}

// ExtractPublicKeyBeforeCounter returns a count of KeyProcessorMock.ExtractPublicKey invocations
func (mmExtractPublicKey *KeyProcessorMock) ExtractPublicKeyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExtractPublicKey.beforeExtractPublicKeyCounter)
}

// Calls returns a list of arguments used in each call to KeyProcessorMock.ExtractPublicKey.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExtractPublicKey *mKeyProcessorMockExtractPublicKey) Calls() []*KeyProcessorMockExtractPublicKeyParams {
	mmExtractPublicKey.mutex.RLock()

	argCopy := make([]*KeyProcessorMockExtractPublicKeyParams, len(mmExtractPublicKey.callArgs))
	copy(argCopy, mmExtractPublicKey.callArgs)

	mmExtractPublicKey.mutex.RUnlock()

	return argCopy
}

// MinimockExtractPublicKeyDone returns true if the count of the ExtractPublicKey invocations corresponds
// the number of defined expectations
func (m *KeyProcessorMock) MinimockExtractPublicKeyDone() bool {
	for _, e := range m.ExtractPublicKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExtractPublicKeyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExtractPublicKeyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExtractPublicKey != nil && mm_atomic.LoadUint64(&m.afterExtractPublicKeyCounter) < 1 {
		return false
	}
	return true
}

// MinimockExtractPublicKeyInspect logs each unmet expectation
func (m *KeyProcessorMock) MinimockExtractPublicKeyInspect() {
	for _, e := range m.ExtractPublicKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KeyProcessorMock.ExtractPublicKey with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExtractPublicKeyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExtractPublicKeyCounter) < 1 {
		if m.ExtractPublicKeyMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to KeyProcessorMock.ExtractPublicKey")
		} else {
			m.t.Errorf("Expected call to KeyProcessorMock.ExtractPublicKey with params: %#v", *m.ExtractPublicKeyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExtractPublicKey != nil && mm_atomic.LoadUint64(&m.afterExtractPublicKeyCounter) < 1 {
		m.t.Error("Expected call to KeyProcessorMock.ExtractPublicKey")
	}
}

type mKeyProcessorMockGeneratePrivateKey struct {
	mock               *KeyProcessorMock
	defaultExpectation *KeyProcessorMockGeneratePrivateKeyExpectation
	expectations       []*KeyProcessorMockGeneratePrivateKeyExpectation
}

// KeyProcessorMockGeneratePrivateKeyExpectation specifies expectation struct of the KeyProcessor.GeneratePrivateKey
type KeyProcessorMockGeneratePrivateKeyExpectation struct {
	mock *KeyProcessorMock

	results *KeyProcessorMockGeneratePrivateKeyResults
	Counter uint64
}

// KeyProcessorMockGeneratePrivateKeyResults contains results of the KeyProcessor.GeneratePrivateKey
type KeyProcessorMockGeneratePrivateKeyResults struct {
	p1  crypto.PrivateKey
	err error
}

// Expect sets up expected params for KeyProcessor.GeneratePrivateKey
func (mmGeneratePrivateKey *mKeyProcessorMockGeneratePrivateKey) Expect() *mKeyProcessorMockGeneratePrivateKey {
	if mmGeneratePrivateKey.mock.funcGeneratePrivateKey != nil {
		mmGeneratePrivateKey.mock.t.Fatalf("KeyProcessorMock.GeneratePrivateKey mock is already set by Set")
	}

	if mmGeneratePrivateKey.defaultExpectation == nil {
		mmGeneratePrivateKey.defaultExpectation = &KeyProcessorMockGeneratePrivateKeyExpectation{}
	}

	return mmGeneratePrivateKey
}

// Inspect accepts an inspector function that has same arguments as the KeyProcessor.GeneratePrivateKey
func (mmGeneratePrivateKey *mKeyProcessorMockGeneratePrivateKey) Inspect(f func()) *mKeyProcessorMockGeneratePrivateKey {
	if mmGeneratePrivateKey.mock.inspectFuncGeneratePrivateKey != nil {
		mmGeneratePrivateKey.mock.t.Fatalf("Inspect function is already set for KeyProcessorMock.GeneratePrivateKey")
	}

	mmGeneratePrivateKey.mock.inspectFuncGeneratePrivateKey = f

	return mmGeneratePrivateKey
}

// Return sets up results that will be returned by KeyProcessor.GeneratePrivateKey
func (mmGeneratePrivateKey *mKeyProcessorMockGeneratePrivateKey) Return(p1 crypto.PrivateKey, err error) *KeyProcessorMock {
	if mmGeneratePrivateKey.mock.funcGeneratePrivateKey != nil {
		mmGeneratePrivateKey.mock.t.Fatalf("KeyProcessorMock.GeneratePrivateKey mock is already set by Set")
	}

	if mmGeneratePrivateKey.defaultExpectation == nil {
		mmGeneratePrivateKey.defaultExpectation = &KeyProcessorMockGeneratePrivateKeyExpectation{mock: mmGeneratePrivateKey.mock}
	}
	mmGeneratePrivateKey.defaultExpectation.results = &KeyProcessorMockGeneratePrivateKeyResults{p1, err}
	return mmGeneratePrivateKey.mock
}

//Set uses given function f to mock the KeyProcessor.GeneratePrivateKey method
func (mmGeneratePrivateKey *mKeyProcessorMockGeneratePrivateKey) Set(f func() (p1 crypto.PrivateKey, err error)) *KeyProcessorMock {
	if mmGeneratePrivateKey.defaultExpectation != nil {
		mmGeneratePrivateKey.mock.t.Fatalf("Default expectation is already set for the KeyProcessor.GeneratePrivateKey method")
	}

	if len(mmGeneratePrivateKey.expectations) > 0 {
		mmGeneratePrivateKey.mock.t.Fatalf("Some expectations are already set for the KeyProcessor.GeneratePrivateKey method")
	}

	mmGeneratePrivateKey.mock.funcGeneratePrivateKey = f
	return mmGeneratePrivateKey.mock
}

// GeneratePrivateKey implements insolar.KeyProcessor
func (mmGeneratePrivateKey *KeyProcessorMock) GeneratePrivateKey() (p1 crypto.PrivateKey, err error) {
	mm_atomic.AddUint64(&mmGeneratePrivateKey.beforeGeneratePrivateKeyCounter, 1)
	defer mm_atomic.AddUint64(&mmGeneratePrivateKey.afterGeneratePrivateKeyCounter, 1)

	if mmGeneratePrivateKey.inspectFuncGeneratePrivateKey != nil {
		mmGeneratePrivateKey.inspectFuncGeneratePrivateKey()
	}

	if mmGeneratePrivateKey.GeneratePrivateKeyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGeneratePrivateKey.GeneratePrivateKeyMock.defaultExpectation.Counter, 1)

		mm_results := mmGeneratePrivateKey.GeneratePrivateKeyMock.defaultExpectation.results
		if mm_results == nil {
			mmGeneratePrivateKey.t.Fatal("No results are set for the KeyProcessorMock.GeneratePrivateKey")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmGeneratePrivateKey.funcGeneratePrivateKey != nil {
		return mmGeneratePrivateKey.funcGeneratePrivateKey()
	}
	mmGeneratePrivateKey.t.Fatalf("Unexpected call to KeyProcessorMock.GeneratePrivateKey.")
	return
}

// GeneratePrivateKeyAfterCounter returns a count of finished KeyProcessorMock.GeneratePrivateKey invocations
func (mmGeneratePrivateKey *KeyProcessorMock) GeneratePrivateKeyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGeneratePrivateKey.afterGeneratePrivateKeyCounter)
}

// GeneratePrivateKeyBeforeCounter returns a count of KeyProcessorMock.GeneratePrivateKey invocations
func (mmGeneratePrivateKey *KeyProcessorMock) GeneratePrivateKeyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGeneratePrivateKey.beforeGeneratePrivateKeyCounter)
}

// MinimockGeneratePrivateKeyDone returns true if the count of the GeneratePrivateKey invocations corresponds
// the number of defined expectations
func (m *KeyProcessorMock) MinimockGeneratePrivateKeyDone() bool {
	for _, e := range m.GeneratePrivateKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GeneratePrivateKeyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGeneratePrivateKeyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGeneratePrivateKey != nil && mm_atomic.LoadUint64(&m.afterGeneratePrivateKeyCounter) < 1 {
		return false
	}
	return true
}

// MinimockGeneratePrivateKeyInspect logs each unmet expectation
func (m *KeyProcessorMock) MinimockGeneratePrivateKeyInspect() {
	for _, e := range m.GeneratePrivateKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to KeyProcessorMock.GeneratePrivateKey")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GeneratePrivateKeyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGeneratePrivateKeyCounter) < 1 {
		m.t.Error("Expected call to KeyProcessorMock.GeneratePrivateKey")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGeneratePrivateKey != nil && mm_atomic.LoadUint64(&m.afterGeneratePrivateKeyCounter) < 1 {
		m.t.Error("Expected call to KeyProcessorMock.GeneratePrivateKey")
	}
}

type mKeyProcessorMockImportPrivateKeyPEM struct {
	mock               *KeyProcessorMock
	defaultExpectation *KeyProcessorMockImportPrivateKeyPEMExpectation
	expectations       []*KeyProcessorMockImportPrivateKeyPEMExpectation

	callArgs []*KeyProcessorMockImportPrivateKeyPEMParams
	mutex    sync.RWMutex
}

// KeyProcessorMockImportPrivateKeyPEMExpectation specifies expectation struct of the KeyProcessor.ImportPrivateKeyPEM
type KeyProcessorMockImportPrivateKeyPEMExpectation struct {
	mock    *KeyProcessorMock
	params  *KeyProcessorMockImportPrivateKeyPEMParams
	results *KeyProcessorMockImportPrivateKeyPEMResults
	Counter uint64
}

// KeyProcessorMockImportPrivateKeyPEMParams contains parameters of the KeyProcessor.ImportPrivateKeyPEM
type KeyProcessorMockImportPrivateKeyPEMParams struct {
	ba1 []byte
}

// KeyProcessorMockImportPrivateKeyPEMResults contains results of the KeyProcessor.ImportPrivateKeyPEM
type KeyProcessorMockImportPrivateKeyPEMResults struct {
	p1  crypto.PrivateKey
	err error
}

// Expect sets up expected params for KeyProcessor.ImportPrivateKeyPEM
func (mmImportPrivateKeyPEM *mKeyProcessorMockImportPrivateKeyPEM) Expect(ba1 []byte) *mKeyProcessorMockImportPrivateKeyPEM {
	if mmImportPrivateKeyPEM.mock.funcImportPrivateKeyPEM != nil {
		mmImportPrivateKeyPEM.mock.t.Fatalf("KeyProcessorMock.ImportPrivateKeyPEM mock is already set by Set")
	}

	if mmImportPrivateKeyPEM.defaultExpectation == nil {
		mmImportPrivateKeyPEM.defaultExpectation = &KeyProcessorMockImportPrivateKeyPEMExpectation{}
	}

	mmImportPrivateKeyPEM.defaultExpectation.params = &KeyProcessorMockImportPrivateKeyPEMParams{ba1}
	for _, e := range mmImportPrivateKeyPEM.expectations {
		if minimock.Equal(e.params, mmImportPrivateKeyPEM.defaultExpectation.params) {
			mmImportPrivateKeyPEM.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmImportPrivateKeyPEM.defaultExpectation.params)
		}
	}

	return mmImportPrivateKeyPEM
}

// Inspect accepts an inspector function that has same arguments as the KeyProcessor.ImportPrivateKeyPEM
func (mmImportPrivateKeyPEM *mKeyProcessorMockImportPrivateKeyPEM) Inspect(f func(ba1 []byte)) *mKeyProcessorMockImportPrivateKeyPEM {
	if mmImportPrivateKeyPEM.mock.inspectFuncImportPrivateKeyPEM != nil {
		mmImportPrivateKeyPEM.mock.t.Fatalf("Inspect function is already set for KeyProcessorMock.ImportPrivateKeyPEM")
	}

	mmImportPrivateKeyPEM.mock.inspectFuncImportPrivateKeyPEM = f

	return mmImportPrivateKeyPEM
}

// Return sets up results that will be returned by KeyProcessor.ImportPrivateKeyPEM
func (mmImportPrivateKeyPEM *mKeyProcessorMockImportPrivateKeyPEM) Return(p1 crypto.PrivateKey, err error) *KeyProcessorMock {
	if mmImportPrivateKeyPEM.mock.funcImportPrivateKeyPEM != nil {
		mmImportPrivateKeyPEM.mock.t.Fatalf("KeyProcessorMock.ImportPrivateKeyPEM mock is already set by Set")
	}

	if mmImportPrivateKeyPEM.defaultExpectation == nil {
		mmImportPrivateKeyPEM.defaultExpectation = &KeyProcessorMockImportPrivateKeyPEMExpectation{mock: mmImportPrivateKeyPEM.mock}
	}
	mmImportPrivateKeyPEM.defaultExpectation.results = &KeyProcessorMockImportPrivateKeyPEMResults{p1, err}
	return mmImportPrivateKeyPEM.mock
}

//Set uses given function f to mock the KeyProcessor.ImportPrivateKeyPEM method
func (mmImportPrivateKeyPEM *mKeyProcessorMockImportPrivateKeyPEM) Set(f func(ba1 []byte) (p1 crypto.PrivateKey, err error)) *KeyProcessorMock {
	if mmImportPrivateKeyPEM.defaultExpectation != nil {
		mmImportPrivateKeyPEM.mock.t.Fatalf("Default expectation is already set for the KeyProcessor.ImportPrivateKeyPEM method")
	}

	if len(mmImportPrivateKeyPEM.expectations) > 0 {
		mmImportPrivateKeyPEM.mock.t.Fatalf("Some expectations are already set for the KeyProcessor.ImportPrivateKeyPEM method")
	}

	mmImportPrivateKeyPEM.mock.funcImportPrivateKeyPEM = f
	return mmImportPrivateKeyPEM.mock
}

// When sets expectation for the KeyProcessor.ImportPrivateKeyPEM which will trigger the result defined by the following
// Then helper
func (mmImportPrivateKeyPEM *mKeyProcessorMockImportPrivateKeyPEM) When(ba1 []byte) *KeyProcessorMockImportPrivateKeyPEMExpectation {
	if mmImportPrivateKeyPEM.mock.funcImportPrivateKeyPEM != nil {
		mmImportPrivateKeyPEM.mock.t.Fatalf("KeyProcessorMock.ImportPrivateKeyPEM mock is already set by Set")
	}

	expectation := &KeyProcessorMockImportPrivateKeyPEMExpectation{
		mock:   mmImportPrivateKeyPEM.mock,
		params: &KeyProcessorMockImportPrivateKeyPEMParams{ba1},
	}
	mmImportPrivateKeyPEM.expectations = append(mmImportPrivateKeyPEM.expectations, expectation)
	return expectation
}

// Then sets up KeyProcessor.ImportPrivateKeyPEM return parameters for the expectation previously defined by the When method
func (e *KeyProcessorMockImportPrivateKeyPEMExpectation) Then(p1 crypto.PrivateKey, err error) *KeyProcessorMock {
	e.results = &KeyProcessorMockImportPrivateKeyPEMResults{p1, err}
	return e.mock
}

// ImportPrivateKeyPEM implements insolar.KeyProcessor
func (mmImportPrivateKeyPEM *KeyProcessorMock) ImportPrivateKeyPEM(ba1 []byte) (p1 crypto.PrivateKey, err error) {
	mm_atomic.AddUint64(&mmImportPrivateKeyPEM.beforeImportPrivateKeyPEMCounter, 1)
	defer mm_atomic.AddUint64(&mmImportPrivateKeyPEM.afterImportPrivateKeyPEMCounter, 1)

	if mmImportPrivateKeyPEM.inspectFuncImportPrivateKeyPEM != nil {
		mmImportPrivateKeyPEM.inspectFuncImportPrivateKeyPEM(ba1)
	}

	mm_params := &KeyProcessorMockImportPrivateKeyPEMParams{ba1}

	// Record call args
	mmImportPrivateKeyPEM.ImportPrivateKeyPEMMock.mutex.Lock()
	mmImportPrivateKeyPEM.ImportPrivateKeyPEMMock.callArgs = append(mmImportPrivateKeyPEM.ImportPrivateKeyPEMMock.callArgs, mm_params)
	mmImportPrivateKeyPEM.ImportPrivateKeyPEMMock.mutex.Unlock()

	for _, e := range mmImportPrivateKeyPEM.ImportPrivateKeyPEMMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmImportPrivateKeyPEM.ImportPrivateKeyPEMMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmImportPrivateKeyPEM.ImportPrivateKeyPEMMock.defaultExpectation.Counter, 1)
		mm_want := mmImportPrivateKeyPEM.ImportPrivateKeyPEMMock.defaultExpectation.params
		mm_got := KeyProcessorMockImportPrivateKeyPEMParams{ba1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmImportPrivateKeyPEM.t.Errorf("KeyProcessorMock.ImportPrivateKeyPEM got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmImportPrivateKeyPEM.ImportPrivateKeyPEMMock.defaultExpectation.results
		if mm_results == nil {
			mmImportPrivateKeyPEM.t.Fatal("No results are set for the KeyProcessorMock.ImportPrivateKeyPEM")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmImportPrivateKeyPEM.funcImportPrivateKeyPEM != nil {
		return mmImportPrivateKeyPEM.funcImportPrivateKeyPEM(ba1)
	}
	mmImportPrivateKeyPEM.t.Fatalf("Unexpected call to KeyProcessorMock.ImportPrivateKeyPEM. %v", ba1)
	return
}

// ImportPrivateKeyPEMAfterCounter returns a count of finished KeyProcessorMock.ImportPrivateKeyPEM invocations
func (mmImportPrivateKeyPEM *KeyProcessorMock) ImportPrivateKeyPEMAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmImportPrivateKeyPEM.afterImportPrivateKeyPEMCounter)
}

// ImportPrivateKeyPEMBeforeCounter returns a count of KeyProcessorMock.ImportPrivateKeyPEM invocations
func (mmImportPrivateKeyPEM *KeyProcessorMock) ImportPrivateKeyPEMBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmImportPrivateKeyPEM.beforeImportPrivateKeyPEMCounter)
}

// Calls returns a list of arguments used in each call to KeyProcessorMock.ImportPrivateKeyPEM.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmImportPrivateKeyPEM *mKeyProcessorMockImportPrivateKeyPEM) Calls() []*KeyProcessorMockImportPrivateKeyPEMParams {
	mmImportPrivateKeyPEM.mutex.RLock()

	argCopy := make([]*KeyProcessorMockImportPrivateKeyPEMParams, len(mmImportPrivateKeyPEM.callArgs))
	copy(argCopy, mmImportPrivateKeyPEM.callArgs)

	mmImportPrivateKeyPEM.mutex.RUnlock()

	return argCopy
}

// MinimockImportPrivateKeyPEMDone returns true if the count of the ImportPrivateKeyPEM invocations corresponds
// the number of defined expectations
func (m *KeyProcessorMock) MinimockImportPrivateKeyPEMDone() bool {
	for _, e := range m.ImportPrivateKeyPEMMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ImportPrivateKeyPEMMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterImportPrivateKeyPEMCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcImportPrivateKeyPEM != nil && mm_atomic.LoadUint64(&m.afterImportPrivateKeyPEMCounter) < 1 {
		return false
	}
	return true
}

// MinimockImportPrivateKeyPEMInspect logs each unmet expectation
func (m *KeyProcessorMock) MinimockImportPrivateKeyPEMInspect() {
	for _, e := range m.ImportPrivateKeyPEMMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KeyProcessorMock.ImportPrivateKeyPEM with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ImportPrivateKeyPEMMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterImportPrivateKeyPEMCounter) < 1 {
		if m.ImportPrivateKeyPEMMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to KeyProcessorMock.ImportPrivateKeyPEM")
		} else {
			m.t.Errorf("Expected call to KeyProcessorMock.ImportPrivateKeyPEM with params: %#v", *m.ImportPrivateKeyPEMMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcImportPrivateKeyPEM != nil && mm_atomic.LoadUint64(&m.afterImportPrivateKeyPEMCounter) < 1 {
		m.t.Error("Expected call to KeyProcessorMock.ImportPrivateKeyPEM")
	}
}

type mKeyProcessorMockImportPublicKeyBinary struct {
	mock               *KeyProcessorMock
	defaultExpectation *KeyProcessorMockImportPublicKeyBinaryExpectation
	expectations       []*KeyProcessorMockImportPublicKeyBinaryExpectation

	callArgs []*KeyProcessorMockImportPublicKeyBinaryParams
	mutex    sync.RWMutex
}

// KeyProcessorMockImportPublicKeyBinaryExpectation specifies expectation struct of the KeyProcessor.ImportPublicKeyBinary
type KeyProcessorMockImportPublicKeyBinaryExpectation struct {
	mock    *KeyProcessorMock
	params  *KeyProcessorMockImportPublicKeyBinaryParams
	results *KeyProcessorMockImportPublicKeyBinaryResults
	Counter uint64
}

// KeyProcessorMockImportPublicKeyBinaryParams contains parameters of the KeyProcessor.ImportPublicKeyBinary
type KeyProcessorMockImportPublicKeyBinaryParams struct {
	ba1 []byte
}

// KeyProcessorMockImportPublicKeyBinaryResults contains results of the KeyProcessor.ImportPublicKeyBinary
type KeyProcessorMockImportPublicKeyBinaryResults struct {
	p1  crypto.PublicKey
	err error
}

// Expect sets up expected params for KeyProcessor.ImportPublicKeyBinary
func (mmImportPublicKeyBinary *mKeyProcessorMockImportPublicKeyBinary) Expect(ba1 []byte) *mKeyProcessorMockImportPublicKeyBinary {
	if mmImportPublicKeyBinary.mock.funcImportPublicKeyBinary != nil {
		mmImportPublicKeyBinary.mock.t.Fatalf("KeyProcessorMock.ImportPublicKeyBinary mock is already set by Set")
	}

	if mmImportPublicKeyBinary.defaultExpectation == nil {
		mmImportPublicKeyBinary.defaultExpectation = &KeyProcessorMockImportPublicKeyBinaryExpectation{}
	}

	mmImportPublicKeyBinary.defaultExpectation.params = &KeyProcessorMockImportPublicKeyBinaryParams{ba1}
	for _, e := range mmImportPublicKeyBinary.expectations {
		if minimock.Equal(e.params, mmImportPublicKeyBinary.defaultExpectation.params) {
			mmImportPublicKeyBinary.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmImportPublicKeyBinary.defaultExpectation.params)
		}
	}

	return mmImportPublicKeyBinary
}

// Inspect accepts an inspector function that has same arguments as the KeyProcessor.ImportPublicKeyBinary
func (mmImportPublicKeyBinary *mKeyProcessorMockImportPublicKeyBinary) Inspect(f func(ba1 []byte)) *mKeyProcessorMockImportPublicKeyBinary {
	if mmImportPublicKeyBinary.mock.inspectFuncImportPublicKeyBinary != nil {
		mmImportPublicKeyBinary.mock.t.Fatalf("Inspect function is already set for KeyProcessorMock.ImportPublicKeyBinary")
	}

	mmImportPublicKeyBinary.mock.inspectFuncImportPublicKeyBinary = f

	return mmImportPublicKeyBinary
}

// Return sets up results that will be returned by KeyProcessor.ImportPublicKeyBinary
func (mmImportPublicKeyBinary *mKeyProcessorMockImportPublicKeyBinary) Return(p1 crypto.PublicKey, err error) *KeyProcessorMock {
	if mmImportPublicKeyBinary.mock.funcImportPublicKeyBinary != nil {
		mmImportPublicKeyBinary.mock.t.Fatalf("KeyProcessorMock.ImportPublicKeyBinary mock is already set by Set")
	}

	if mmImportPublicKeyBinary.defaultExpectation == nil {
		mmImportPublicKeyBinary.defaultExpectation = &KeyProcessorMockImportPublicKeyBinaryExpectation{mock: mmImportPublicKeyBinary.mock}
	}
	mmImportPublicKeyBinary.defaultExpectation.results = &KeyProcessorMockImportPublicKeyBinaryResults{p1, err}
	return mmImportPublicKeyBinary.mock
}

//Set uses given function f to mock the KeyProcessor.ImportPublicKeyBinary method
func (mmImportPublicKeyBinary *mKeyProcessorMockImportPublicKeyBinary) Set(f func(ba1 []byte) (p1 crypto.PublicKey, err error)) *KeyProcessorMock {
	if mmImportPublicKeyBinary.defaultExpectation != nil {
		mmImportPublicKeyBinary.mock.t.Fatalf("Default expectation is already set for the KeyProcessor.ImportPublicKeyBinary method")
	}

	if len(mmImportPublicKeyBinary.expectations) > 0 {
		mmImportPublicKeyBinary.mock.t.Fatalf("Some expectations are already set for the KeyProcessor.ImportPublicKeyBinary method")
	}

	mmImportPublicKeyBinary.mock.funcImportPublicKeyBinary = f
	return mmImportPublicKeyBinary.mock
}

// When sets expectation for the KeyProcessor.ImportPublicKeyBinary which will trigger the result defined by the following
// Then helper
func (mmImportPublicKeyBinary *mKeyProcessorMockImportPublicKeyBinary) When(ba1 []byte) *KeyProcessorMockImportPublicKeyBinaryExpectation {
	if mmImportPublicKeyBinary.mock.funcImportPublicKeyBinary != nil {
		mmImportPublicKeyBinary.mock.t.Fatalf("KeyProcessorMock.ImportPublicKeyBinary mock is already set by Set")
	}

	expectation := &KeyProcessorMockImportPublicKeyBinaryExpectation{
		mock:   mmImportPublicKeyBinary.mock,
		params: &KeyProcessorMockImportPublicKeyBinaryParams{ba1},
	}
	mmImportPublicKeyBinary.expectations = append(mmImportPublicKeyBinary.expectations, expectation)
	return expectation
}

// Then sets up KeyProcessor.ImportPublicKeyBinary return parameters for the expectation previously defined by the When method
func (e *KeyProcessorMockImportPublicKeyBinaryExpectation) Then(p1 crypto.PublicKey, err error) *KeyProcessorMock {
	e.results = &KeyProcessorMockImportPublicKeyBinaryResults{p1, err}
	return e.mock
}

// ImportPublicKeyBinary implements insolar.KeyProcessor
func (mmImportPublicKeyBinary *KeyProcessorMock) ImportPublicKeyBinary(ba1 []byte) (p1 crypto.PublicKey, err error) {
	mm_atomic.AddUint64(&mmImportPublicKeyBinary.beforeImportPublicKeyBinaryCounter, 1)
	defer mm_atomic.AddUint64(&mmImportPublicKeyBinary.afterImportPublicKeyBinaryCounter, 1)

	if mmImportPublicKeyBinary.inspectFuncImportPublicKeyBinary != nil {
		mmImportPublicKeyBinary.inspectFuncImportPublicKeyBinary(ba1)
	}

	mm_params := &KeyProcessorMockImportPublicKeyBinaryParams{ba1}

	// Record call args
	mmImportPublicKeyBinary.ImportPublicKeyBinaryMock.mutex.Lock()
	mmImportPublicKeyBinary.ImportPublicKeyBinaryMock.callArgs = append(mmImportPublicKeyBinary.ImportPublicKeyBinaryMock.callArgs, mm_params)
	mmImportPublicKeyBinary.ImportPublicKeyBinaryMock.mutex.Unlock()

	for _, e := range mmImportPublicKeyBinary.ImportPublicKeyBinaryMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmImportPublicKeyBinary.ImportPublicKeyBinaryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmImportPublicKeyBinary.ImportPublicKeyBinaryMock.defaultExpectation.Counter, 1)
		mm_want := mmImportPublicKeyBinary.ImportPublicKeyBinaryMock.defaultExpectation.params
		mm_got := KeyProcessorMockImportPublicKeyBinaryParams{ba1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmImportPublicKeyBinary.t.Errorf("KeyProcessorMock.ImportPublicKeyBinary got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmImportPublicKeyBinary.ImportPublicKeyBinaryMock.defaultExpectation.results
		if mm_results == nil {
			mmImportPublicKeyBinary.t.Fatal("No results are set for the KeyProcessorMock.ImportPublicKeyBinary")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmImportPublicKeyBinary.funcImportPublicKeyBinary != nil {
		return mmImportPublicKeyBinary.funcImportPublicKeyBinary(ba1)
	}
	mmImportPublicKeyBinary.t.Fatalf("Unexpected call to KeyProcessorMock.ImportPublicKeyBinary. %v", ba1)
	return
}

// ImportPublicKeyBinaryAfterCounter returns a count of finished KeyProcessorMock.ImportPublicKeyBinary invocations
func (mmImportPublicKeyBinary *KeyProcessorMock) ImportPublicKeyBinaryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmImportPublicKeyBinary.afterImportPublicKeyBinaryCounter)
}

// ImportPublicKeyBinaryBeforeCounter returns a count of KeyProcessorMock.ImportPublicKeyBinary invocations
func (mmImportPublicKeyBinary *KeyProcessorMock) ImportPublicKeyBinaryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmImportPublicKeyBinary.beforeImportPublicKeyBinaryCounter)
}

// Calls returns a list of arguments used in each call to KeyProcessorMock.ImportPublicKeyBinary.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmImportPublicKeyBinary *mKeyProcessorMockImportPublicKeyBinary) Calls() []*KeyProcessorMockImportPublicKeyBinaryParams {
	mmImportPublicKeyBinary.mutex.RLock()

	argCopy := make([]*KeyProcessorMockImportPublicKeyBinaryParams, len(mmImportPublicKeyBinary.callArgs))
	copy(argCopy, mmImportPublicKeyBinary.callArgs)

	mmImportPublicKeyBinary.mutex.RUnlock()

	return argCopy
}

// MinimockImportPublicKeyBinaryDone returns true if the count of the ImportPublicKeyBinary invocations corresponds
// the number of defined expectations
func (m *KeyProcessorMock) MinimockImportPublicKeyBinaryDone() bool {
	for _, e := range m.ImportPublicKeyBinaryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ImportPublicKeyBinaryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterImportPublicKeyBinaryCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcImportPublicKeyBinary != nil && mm_atomic.LoadUint64(&m.afterImportPublicKeyBinaryCounter) < 1 {
		return false
	}
	return true
}

// MinimockImportPublicKeyBinaryInspect logs each unmet expectation
func (m *KeyProcessorMock) MinimockImportPublicKeyBinaryInspect() {
	for _, e := range m.ImportPublicKeyBinaryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KeyProcessorMock.ImportPublicKeyBinary with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ImportPublicKeyBinaryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterImportPublicKeyBinaryCounter) < 1 {
		if m.ImportPublicKeyBinaryMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to KeyProcessorMock.ImportPublicKeyBinary")
		} else {
			m.t.Errorf("Expected call to KeyProcessorMock.ImportPublicKeyBinary with params: %#v", *m.ImportPublicKeyBinaryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcImportPublicKeyBinary != nil && mm_atomic.LoadUint64(&m.afterImportPublicKeyBinaryCounter) < 1 {
		m.t.Error("Expected call to KeyProcessorMock.ImportPublicKeyBinary")
	}
}

type mKeyProcessorMockImportPublicKeyPEM struct {
	mock               *KeyProcessorMock
	defaultExpectation *KeyProcessorMockImportPublicKeyPEMExpectation
	expectations       []*KeyProcessorMockImportPublicKeyPEMExpectation

	callArgs []*KeyProcessorMockImportPublicKeyPEMParams
	mutex    sync.RWMutex
}

// KeyProcessorMockImportPublicKeyPEMExpectation specifies expectation struct of the KeyProcessor.ImportPublicKeyPEM
type KeyProcessorMockImportPublicKeyPEMExpectation struct {
	mock    *KeyProcessorMock
	params  *KeyProcessorMockImportPublicKeyPEMParams
	results *KeyProcessorMockImportPublicKeyPEMResults
	Counter uint64
}

// KeyProcessorMockImportPublicKeyPEMParams contains parameters of the KeyProcessor.ImportPublicKeyPEM
type KeyProcessorMockImportPublicKeyPEMParams struct {
	ba1 []byte
}

// KeyProcessorMockImportPublicKeyPEMResults contains results of the KeyProcessor.ImportPublicKeyPEM
type KeyProcessorMockImportPublicKeyPEMResults struct {
	p1  crypto.PublicKey
	err error
}

// Expect sets up expected params for KeyProcessor.ImportPublicKeyPEM
func (mmImportPublicKeyPEM *mKeyProcessorMockImportPublicKeyPEM) Expect(ba1 []byte) *mKeyProcessorMockImportPublicKeyPEM {
	if mmImportPublicKeyPEM.mock.funcImportPublicKeyPEM != nil {
		mmImportPublicKeyPEM.mock.t.Fatalf("KeyProcessorMock.ImportPublicKeyPEM mock is already set by Set")
	}

	if mmImportPublicKeyPEM.defaultExpectation == nil {
		mmImportPublicKeyPEM.defaultExpectation = &KeyProcessorMockImportPublicKeyPEMExpectation{}
	}

	mmImportPublicKeyPEM.defaultExpectation.params = &KeyProcessorMockImportPublicKeyPEMParams{ba1}
	for _, e := range mmImportPublicKeyPEM.expectations {
		if minimock.Equal(e.params, mmImportPublicKeyPEM.defaultExpectation.params) {
			mmImportPublicKeyPEM.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmImportPublicKeyPEM.defaultExpectation.params)
		}
	}

	return mmImportPublicKeyPEM
}

// Inspect accepts an inspector function that has same arguments as the KeyProcessor.ImportPublicKeyPEM
func (mmImportPublicKeyPEM *mKeyProcessorMockImportPublicKeyPEM) Inspect(f func(ba1 []byte)) *mKeyProcessorMockImportPublicKeyPEM {
	if mmImportPublicKeyPEM.mock.inspectFuncImportPublicKeyPEM != nil {
		mmImportPublicKeyPEM.mock.t.Fatalf("Inspect function is already set for KeyProcessorMock.ImportPublicKeyPEM")
	}

	mmImportPublicKeyPEM.mock.inspectFuncImportPublicKeyPEM = f

	return mmImportPublicKeyPEM
}

// Return sets up results that will be returned by KeyProcessor.ImportPublicKeyPEM
func (mmImportPublicKeyPEM *mKeyProcessorMockImportPublicKeyPEM) Return(p1 crypto.PublicKey, err error) *KeyProcessorMock {
	if mmImportPublicKeyPEM.mock.funcImportPublicKeyPEM != nil {
		mmImportPublicKeyPEM.mock.t.Fatalf("KeyProcessorMock.ImportPublicKeyPEM mock is already set by Set")
	}

	if mmImportPublicKeyPEM.defaultExpectation == nil {
		mmImportPublicKeyPEM.defaultExpectation = &KeyProcessorMockImportPublicKeyPEMExpectation{mock: mmImportPublicKeyPEM.mock}
	}
	mmImportPublicKeyPEM.defaultExpectation.results = &KeyProcessorMockImportPublicKeyPEMResults{p1, err}
	return mmImportPublicKeyPEM.mock
}

//Set uses given function f to mock the KeyProcessor.ImportPublicKeyPEM method
func (mmImportPublicKeyPEM *mKeyProcessorMockImportPublicKeyPEM) Set(f func(ba1 []byte) (p1 crypto.PublicKey, err error)) *KeyProcessorMock {
	if mmImportPublicKeyPEM.defaultExpectation != nil {
		mmImportPublicKeyPEM.mock.t.Fatalf("Default expectation is already set for the KeyProcessor.ImportPublicKeyPEM method")
	}

	if len(mmImportPublicKeyPEM.expectations) > 0 {
		mmImportPublicKeyPEM.mock.t.Fatalf("Some expectations are already set for the KeyProcessor.ImportPublicKeyPEM method")
	}

	mmImportPublicKeyPEM.mock.funcImportPublicKeyPEM = f
	return mmImportPublicKeyPEM.mock
}

// When sets expectation for the KeyProcessor.ImportPublicKeyPEM which will trigger the result defined by the following
// Then helper
func (mmImportPublicKeyPEM *mKeyProcessorMockImportPublicKeyPEM) When(ba1 []byte) *KeyProcessorMockImportPublicKeyPEMExpectation {
	if mmImportPublicKeyPEM.mock.funcImportPublicKeyPEM != nil {
		mmImportPublicKeyPEM.mock.t.Fatalf("KeyProcessorMock.ImportPublicKeyPEM mock is already set by Set")
	}

	expectation := &KeyProcessorMockImportPublicKeyPEMExpectation{
		mock:   mmImportPublicKeyPEM.mock,
		params: &KeyProcessorMockImportPublicKeyPEMParams{ba1},
	}
	mmImportPublicKeyPEM.expectations = append(mmImportPublicKeyPEM.expectations, expectation)
	return expectation
}

// Then sets up KeyProcessor.ImportPublicKeyPEM return parameters for the expectation previously defined by the When method
func (e *KeyProcessorMockImportPublicKeyPEMExpectation) Then(p1 crypto.PublicKey, err error) *KeyProcessorMock {
	e.results = &KeyProcessorMockImportPublicKeyPEMResults{p1, err}
	return e.mock
}

// ImportPublicKeyPEM implements insolar.KeyProcessor
func (mmImportPublicKeyPEM *KeyProcessorMock) ImportPublicKeyPEM(ba1 []byte) (p1 crypto.PublicKey, err error) {
	mm_atomic.AddUint64(&mmImportPublicKeyPEM.beforeImportPublicKeyPEMCounter, 1)
	defer mm_atomic.AddUint64(&mmImportPublicKeyPEM.afterImportPublicKeyPEMCounter, 1)

	if mmImportPublicKeyPEM.inspectFuncImportPublicKeyPEM != nil {
		mmImportPublicKeyPEM.inspectFuncImportPublicKeyPEM(ba1)
	}

	mm_params := &KeyProcessorMockImportPublicKeyPEMParams{ba1}

	// Record call args
	mmImportPublicKeyPEM.ImportPublicKeyPEMMock.mutex.Lock()
	mmImportPublicKeyPEM.ImportPublicKeyPEMMock.callArgs = append(mmImportPublicKeyPEM.ImportPublicKeyPEMMock.callArgs, mm_params)
	mmImportPublicKeyPEM.ImportPublicKeyPEMMock.mutex.Unlock()

	for _, e := range mmImportPublicKeyPEM.ImportPublicKeyPEMMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmImportPublicKeyPEM.ImportPublicKeyPEMMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmImportPublicKeyPEM.ImportPublicKeyPEMMock.defaultExpectation.Counter, 1)
		mm_want := mmImportPublicKeyPEM.ImportPublicKeyPEMMock.defaultExpectation.params
		mm_got := KeyProcessorMockImportPublicKeyPEMParams{ba1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmImportPublicKeyPEM.t.Errorf("KeyProcessorMock.ImportPublicKeyPEM got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmImportPublicKeyPEM.ImportPublicKeyPEMMock.defaultExpectation.results
		if mm_results == nil {
			mmImportPublicKeyPEM.t.Fatal("No results are set for the KeyProcessorMock.ImportPublicKeyPEM")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmImportPublicKeyPEM.funcImportPublicKeyPEM != nil {
		return mmImportPublicKeyPEM.funcImportPublicKeyPEM(ba1)
	}
	mmImportPublicKeyPEM.t.Fatalf("Unexpected call to KeyProcessorMock.ImportPublicKeyPEM. %v", ba1)
	return
}

// ImportPublicKeyPEMAfterCounter returns a count of finished KeyProcessorMock.ImportPublicKeyPEM invocations
func (mmImportPublicKeyPEM *KeyProcessorMock) ImportPublicKeyPEMAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmImportPublicKeyPEM.afterImportPublicKeyPEMCounter)
}

// ImportPublicKeyPEMBeforeCounter returns a count of KeyProcessorMock.ImportPublicKeyPEM invocations
func (mmImportPublicKeyPEM *KeyProcessorMock) ImportPublicKeyPEMBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmImportPublicKeyPEM.beforeImportPublicKeyPEMCounter)
}

// Calls returns a list of arguments used in each call to KeyProcessorMock.ImportPublicKeyPEM.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmImportPublicKeyPEM *mKeyProcessorMockImportPublicKeyPEM) Calls() []*KeyProcessorMockImportPublicKeyPEMParams {
	mmImportPublicKeyPEM.mutex.RLock()

	argCopy := make([]*KeyProcessorMockImportPublicKeyPEMParams, len(mmImportPublicKeyPEM.callArgs))
	copy(argCopy, mmImportPublicKeyPEM.callArgs)

	mmImportPublicKeyPEM.mutex.RUnlock()

	return argCopy
}

// MinimockImportPublicKeyPEMDone returns true if the count of the ImportPublicKeyPEM invocations corresponds
// the number of defined expectations
func (m *KeyProcessorMock) MinimockImportPublicKeyPEMDone() bool {
	for _, e := range m.ImportPublicKeyPEMMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ImportPublicKeyPEMMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterImportPublicKeyPEMCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcImportPublicKeyPEM != nil && mm_atomic.LoadUint64(&m.afterImportPublicKeyPEMCounter) < 1 {
		return false
	}
	return true
}

// MinimockImportPublicKeyPEMInspect logs each unmet expectation
func (m *KeyProcessorMock) MinimockImportPublicKeyPEMInspect() {
	for _, e := range m.ImportPublicKeyPEMMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KeyProcessorMock.ImportPublicKeyPEM with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ImportPublicKeyPEMMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterImportPublicKeyPEMCounter) < 1 {
		if m.ImportPublicKeyPEMMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to KeyProcessorMock.ImportPublicKeyPEM")
		} else {
			m.t.Errorf("Expected call to KeyProcessorMock.ImportPublicKeyPEM with params: %#v", *m.ImportPublicKeyPEMMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcImportPublicKeyPEM != nil && mm_atomic.LoadUint64(&m.afterImportPublicKeyPEMCounter) < 1 {
		m.t.Error("Expected call to KeyProcessorMock.ImportPublicKeyPEM")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *KeyProcessorMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockExportPrivateKeyPEMInspect()

		m.MinimockExportPublicKeyBinaryInspect()

		m.MinimockExportPublicKeyPEMInspect()

		m.MinimockExtractPublicKeyInspect()

		m.MinimockGeneratePrivateKeyInspect()

		m.MinimockImportPrivateKeyPEMInspect()

		m.MinimockImportPublicKeyBinaryInspect()

		m.MinimockImportPublicKeyPEMInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *KeyProcessorMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *KeyProcessorMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockExportPrivateKeyPEMDone() &&
		m.MinimockExportPublicKeyBinaryDone() &&
		m.MinimockExportPublicKeyPEMDone() &&
		m.MinimockExtractPublicKeyDone() &&
		m.MinimockGeneratePrivateKeyDone() &&
		m.MinimockImportPrivateKeyPEMDone() &&
		m.MinimockImportPublicKeyBinaryDone() &&
		m.MinimockImportPublicKeyPEMDone()
}
