package testutils

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	mm_insolar "github.com/insolar/insolar/insolar"
)

// MachineLogicExecutorMock implements insolar.MachineLogicExecutor
type MachineLogicExecutorMock struct {
	t minimock.Tester

	funcCallConstructor          func(ctx context.Context, callContext *mm_insolar.LogicCallContext, code mm_insolar.Reference, name string, args mm_insolar.Arguments) (objectState []byte, result mm_insolar.Arguments, err error)
	inspectFuncCallConstructor   func(ctx context.Context, callContext *mm_insolar.LogicCallContext, code mm_insolar.Reference, name string, args mm_insolar.Arguments)
	afterCallConstructorCounter  uint64
	beforeCallConstructorCounter uint64
	CallConstructorMock          mMachineLogicExecutorMockCallConstructor

	funcCallMethod          func(ctx context.Context, callContext *mm_insolar.LogicCallContext, code mm_insolar.Reference, data []byte, method string, args mm_insolar.Arguments) (newObjectState []byte, methodResults mm_insolar.Arguments, err error)
	inspectFuncCallMethod   func(ctx context.Context, callContext *mm_insolar.LogicCallContext, code mm_insolar.Reference, data []byte, method string, args mm_insolar.Arguments)
	afterCallMethodCounter  uint64
	beforeCallMethodCounter uint64
	CallMethodMock          mMachineLogicExecutorMockCallMethod
}

// NewMachineLogicExecutorMock returns a mock for insolar.MachineLogicExecutor
func NewMachineLogicExecutorMock(t minimock.Tester) *MachineLogicExecutorMock {
	m := &MachineLogicExecutorMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CallConstructorMock = mMachineLogicExecutorMockCallConstructor{mock: m}
	m.CallConstructorMock.callArgs = []*MachineLogicExecutorMockCallConstructorParams{}

	m.CallMethodMock = mMachineLogicExecutorMockCallMethod{mock: m}
	m.CallMethodMock.callArgs = []*MachineLogicExecutorMockCallMethodParams{}

	return m
}

type mMachineLogicExecutorMockCallConstructor struct {
	mock               *MachineLogicExecutorMock
	defaultExpectation *MachineLogicExecutorMockCallConstructorExpectation
	expectations       []*MachineLogicExecutorMockCallConstructorExpectation

	callArgs []*MachineLogicExecutorMockCallConstructorParams
	mutex    sync.RWMutex
}

// MachineLogicExecutorMockCallConstructorExpectation specifies expectation struct of the MachineLogicExecutor.CallConstructor
type MachineLogicExecutorMockCallConstructorExpectation struct {
	mock    *MachineLogicExecutorMock
	params  *MachineLogicExecutorMockCallConstructorParams
	results *MachineLogicExecutorMockCallConstructorResults
	Counter uint64
}

// MachineLogicExecutorMockCallConstructorParams contains parameters of the MachineLogicExecutor.CallConstructor
type MachineLogicExecutorMockCallConstructorParams struct {
	ctx         context.Context
	callContext *mm_insolar.LogicCallContext
	code        mm_insolar.Reference
	name        string
	args        mm_insolar.Arguments
}

// MachineLogicExecutorMockCallConstructorResults contains results of the MachineLogicExecutor.CallConstructor
type MachineLogicExecutorMockCallConstructorResults struct {
	objectState []byte
	result      mm_insolar.Arguments
	err         error
}

// Expect sets up expected params for MachineLogicExecutor.CallConstructor
func (mmCallConstructor *mMachineLogicExecutorMockCallConstructor) Expect(ctx context.Context, callContext *mm_insolar.LogicCallContext, code mm_insolar.Reference, name string, args mm_insolar.Arguments) *mMachineLogicExecutorMockCallConstructor {
	if mmCallConstructor.mock.funcCallConstructor != nil {
		mmCallConstructor.mock.t.Fatalf("MachineLogicExecutorMock.CallConstructor mock is already set by Set")
	}

	if mmCallConstructor.defaultExpectation == nil {
		mmCallConstructor.defaultExpectation = &MachineLogicExecutorMockCallConstructorExpectation{}
	}

	mmCallConstructor.defaultExpectation.params = &MachineLogicExecutorMockCallConstructorParams{ctx, callContext, code, name, args}
	for _, e := range mmCallConstructor.expectations {
		if minimock.Equal(e.params, mmCallConstructor.defaultExpectation.params) {
			mmCallConstructor.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCallConstructor.defaultExpectation.params)
		}
	}

	return mmCallConstructor
}

// Inspect accepts an inspector function that has same arguments as the MachineLogicExecutor.CallConstructor
func (mmCallConstructor *mMachineLogicExecutorMockCallConstructor) Inspect(f func(ctx context.Context, callContext *mm_insolar.LogicCallContext, code mm_insolar.Reference, name string, args mm_insolar.Arguments)) *mMachineLogicExecutorMockCallConstructor {
	if mmCallConstructor.mock.inspectFuncCallConstructor != nil {
		mmCallConstructor.mock.t.Fatalf("Inspect function is already set for MachineLogicExecutorMock.CallConstructor")
	}

	mmCallConstructor.mock.inspectFuncCallConstructor = f

	return mmCallConstructor
}

// Return sets up results that will be returned by MachineLogicExecutor.CallConstructor
func (mmCallConstructor *mMachineLogicExecutorMockCallConstructor) Return(objectState []byte, result mm_insolar.Arguments, err error) *MachineLogicExecutorMock {
	if mmCallConstructor.mock.funcCallConstructor != nil {
		mmCallConstructor.mock.t.Fatalf("MachineLogicExecutorMock.CallConstructor mock is already set by Set")
	}

	if mmCallConstructor.defaultExpectation == nil {
		mmCallConstructor.defaultExpectation = &MachineLogicExecutorMockCallConstructorExpectation{mock: mmCallConstructor.mock}
	}
	mmCallConstructor.defaultExpectation.results = &MachineLogicExecutorMockCallConstructorResults{objectState, result, err}
	return mmCallConstructor.mock
}

//Set uses given function f to mock the MachineLogicExecutor.CallConstructor method
func (mmCallConstructor *mMachineLogicExecutorMockCallConstructor) Set(f func(ctx context.Context, callContext *mm_insolar.LogicCallContext, code mm_insolar.Reference, name string, args mm_insolar.Arguments) (objectState []byte, result mm_insolar.Arguments, err error)) *MachineLogicExecutorMock {
	if mmCallConstructor.defaultExpectation != nil {
		mmCallConstructor.mock.t.Fatalf("Default expectation is already set for the MachineLogicExecutor.CallConstructor method")
	}

	if len(mmCallConstructor.expectations) > 0 {
		mmCallConstructor.mock.t.Fatalf("Some expectations are already set for the MachineLogicExecutor.CallConstructor method")
	}

	mmCallConstructor.mock.funcCallConstructor = f
	return mmCallConstructor.mock
}

// When sets expectation for the MachineLogicExecutor.CallConstructor which will trigger the result defined by the following
// Then helper
func (mmCallConstructor *mMachineLogicExecutorMockCallConstructor) When(ctx context.Context, callContext *mm_insolar.LogicCallContext, code mm_insolar.Reference, name string, args mm_insolar.Arguments) *MachineLogicExecutorMockCallConstructorExpectation {
	if mmCallConstructor.mock.funcCallConstructor != nil {
		mmCallConstructor.mock.t.Fatalf("MachineLogicExecutorMock.CallConstructor mock is already set by Set")
	}

	expectation := &MachineLogicExecutorMockCallConstructorExpectation{
		mock:   mmCallConstructor.mock,
		params: &MachineLogicExecutorMockCallConstructorParams{ctx, callContext, code, name, args},
	}
	mmCallConstructor.expectations = append(mmCallConstructor.expectations, expectation)
	return expectation
}

// Then sets up MachineLogicExecutor.CallConstructor return parameters for the expectation previously defined by the When method
func (e *MachineLogicExecutorMockCallConstructorExpectation) Then(objectState []byte, result mm_insolar.Arguments, err error) *MachineLogicExecutorMock {
	e.results = &MachineLogicExecutorMockCallConstructorResults{objectState, result, err}
	return e.mock
}

// CallConstructor implements insolar.MachineLogicExecutor
func (mmCallConstructor *MachineLogicExecutorMock) CallConstructor(ctx context.Context, callContext *mm_insolar.LogicCallContext, code mm_insolar.Reference, name string, args mm_insolar.Arguments) (objectState []byte, result mm_insolar.Arguments, err error) {
	mm_atomic.AddUint64(&mmCallConstructor.beforeCallConstructorCounter, 1)
	defer mm_atomic.AddUint64(&mmCallConstructor.afterCallConstructorCounter, 1)

	if mmCallConstructor.inspectFuncCallConstructor != nil {
		mmCallConstructor.inspectFuncCallConstructor(ctx, callContext, code, name, args)
	}

	mm_params := &MachineLogicExecutorMockCallConstructorParams{ctx, callContext, code, name, args}

	// Record call args
	mmCallConstructor.CallConstructorMock.mutex.Lock()
	mmCallConstructor.CallConstructorMock.callArgs = append(mmCallConstructor.CallConstructorMock.callArgs, mm_params)
	mmCallConstructor.CallConstructorMock.mutex.Unlock()

	for _, e := range mmCallConstructor.CallConstructorMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.objectState, e.results.result, e.results.err
		}
	}

	if mmCallConstructor.CallConstructorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCallConstructor.CallConstructorMock.defaultExpectation.Counter, 1)
		mm_want := mmCallConstructor.CallConstructorMock.defaultExpectation.params
		mm_got := MachineLogicExecutorMockCallConstructorParams{ctx, callContext, code, name, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCallConstructor.t.Errorf("MachineLogicExecutorMock.CallConstructor got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCallConstructor.CallConstructorMock.defaultExpectation.results
		if mm_results == nil {
			mmCallConstructor.t.Fatal("No results are set for the MachineLogicExecutorMock.CallConstructor")
		}
		return (*mm_results).objectState, (*mm_results).result, (*mm_results).err
	}
	if mmCallConstructor.funcCallConstructor != nil {
		return mmCallConstructor.funcCallConstructor(ctx, callContext, code, name, args)
	}
	mmCallConstructor.t.Fatalf("Unexpected call to MachineLogicExecutorMock.CallConstructor. %v %v %v %v %v", ctx, callContext, code, name, args)
	return
}

// CallConstructorAfterCounter returns a count of finished MachineLogicExecutorMock.CallConstructor invocations
func (mmCallConstructor *MachineLogicExecutorMock) CallConstructorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCallConstructor.afterCallConstructorCounter)
}

// CallConstructorBeforeCounter returns a count of MachineLogicExecutorMock.CallConstructor invocations
func (mmCallConstructor *MachineLogicExecutorMock) CallConstructorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCallConstructor.beforeCallConstructorCounter)
}

// Calls returns a list of arguments used in each call to MachineLogicExecutorMock.CallConstructor.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCallConstructor *mMachineLogicExecutorMockCallConstructor) Calls() []*MachineLogicExecutorMockCallConstructorParams {
	mmCallConstructor.mutex.RLock()

	argCopy := make([]*MachineLogicExecutorMockCallConstructorParams, len(mmCallConstructor.callArgs))
	copy(argCopy, mmCallConstructor.callArgs)

	mmCallConstructor.mutex.RUnlock()

	return argCopy
}

// MinimockCallConstructorDone returns true if the count of the CallConstructor invocations corresponds
// the number of defined expectations
func (m *MachineLogicExecutorMock) MinimockCallConstructorDone() bool {
	for _, e := range m.CallConstructorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CallConstructorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCallConstructorCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCallConstructor != nil && mm_atomic.LoadUint64(&m.afterCallConstructorCounter) < 1 {
		return false
	}
	return true
}

// MinimockCallConstructorInspect logs each unmet expectation
func (m *MachineLogicExecutorMock) MinimockCallConstructorInspect() {
	for _, e := range m.CallConstructorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MachineLogicExecutorMock.CallConstructor with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CallConstructorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCallConstructorCounter) < 1 {
		if m.CallConstructorMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MachineLogicExecutorMock.CallConstructor")
		} else {
			m.t.Errorf("Expected call to MachineLogicExecutorMock.CallConstructor with params: %#v", *m.CallConstructorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCallConstructor != nil && mm_atomic.LoadUint64(&m.afterCallConstructorCounter) < 1 {
		m.t.Error("Expected call to MachineLogicExecutorMock.CallConstructor")
	}
}

type mMachineLogicExecutorMockCallMethod struct {
	mock               *MachineLogicExecutorMock
	defaultExpectation *MachineLogicExecutorMockCallMethodExpectation
	expectations       []*MachineLogicExecutorMockCallMethodExpectation

	callArgs []*MachineLogicExecutorMockCallMethodParams
	mutex    sync.RWMutex
}

// MachineLogicExecutorMockCallMethodExpectation specifies expectation struct of the MachineLogicExecutor.CallMethod
type MachineLogicExecutorMockCallMethodExpectation struct {
	mock    *MachineLogicExecutorMock
	params  *MachineLogicExecutorMockCallMethodParams
	results *MachineLogicExecutorMockCallMethodResults
	Counter uint64
}

// MachineLogicExecutorMockCallMethodParams contains parameters of the MachineLogicExecutor.CallMethod
type MachineLogicExecutorMockCallMethodParams struct {
	ctx         context.Context
	callContext *mm_insolar.LogicCallContext
	code        mm_insolar.Reference
	data        []byte
	method      string
	args        mm_insolar.Arguments
}

// MachineLogicExecutorMockCallMethodResults contains results of the MachineLogicExecutor.CallMethod
type MachineLogicExecutorMockCallMethodResults struct {
	newObjectState []byte
	methodResults  mm_insolar.Arguments
	err            error
}

// Expect sets up expected params for MachineLogicExecutor.CallMethod
func (mmCallMethod *mMachineLogicExecutorMockCallMethod) Expect(ctx context.Context, callContext *mm_insolar.LogicCallContext, code mm_insolar.Reference, data []byte, method string, args mm_insolar.Arguments) *mMachineLogicExecutorMockCallMethod {
	if mmCallMethod.mock.funcCallMethod != nil {
		mmCallMethod.mock.t.Fatalf("MachineLogicExecutorMock.CallMethod mock is already set by Set")
	}

	if mmCallMethod.defaultExpectation == nil {
		mmCallMethod.defaultExpectation = &MachineLogicExecutorMockCallMethodExpectation{}
	}

	mmCallMethod.defaultExpectation.params = &MachineLogicExecutorMockCallMethodParams{ctx, callContext, code, data, method, args}
	for _, e := range mmCallMethod.expectations {
		if minimock.Equal(e.params, mmCallMethod.defaultExpectation.params) {
			mmCallMethod.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCallMethod.defaultExpectation.params)
		}
	}

	return mmCallMethod
}

// Inspect accepts an inspector function that has same arguments as the MachineLogicExecutor.CallMethod
func (mmCallMethod *mMachineLogicExecutorMockCallMethod) Inspect(f func(ctx context.Context, callContext *mm_insolar.LogicCallContext, code mm_insolar.Reference, data []byte, method string, args mm_insolar.Arguments)) *mMachineLogicExecutorMockCallMethod {
	if mmCallMethod.mock.inspectFuncCallMethod != nil {
		mmCallMethod.mock.t.Fatalf("Inspect function is already set for MachineLogicExecutorMock.CallMethod")
	}

	mmCallMethod.mock.inspectFuncCallMethod = f

	return mmCallMethod
}

// Return sets up results that will be returned by MachineLogicExecutor.CallMethod
func (mmCallMethod *mMachineLogicExecutorMockCallMethod) Return(newObjectState []byte, methodResults mm_insolar.Arguments, err error) *MachineLogicExecutorMock {
	if mmCallMethod.mock.funcCallMethod != nil {
		mmCallMethod.mock.t.Fatalf("MachineLogicExecutorMock.CallMethod mock is already set by Set")
	}

	if mmCallMethod.defaultExpectation == nil {
		mmCallMethod.defaultExpectation = &MachineLogicExecutorMockCallMethodExpectation{mock: mmCallMethod.mock}
	}
	mmCallMethod.defaultExpectation.results = &MachineLogicExecutorMockCallMethodResults{newObjectState, methodResults, err}
	return mmCallMethod.mock
}

//Set uses given function f to mock the MachineLogicExecutor.CallMethod method
func (mmCallMethod *mMachineLogicExecutorMockCallMethod) Set(f func(ctx context.Context, callContext *mm_insolar.LogicCallContext, code mm_insolar.Reference, data []byte, method string, args mm_insolar.Arguments) (newObjectState []byte, methodResults mm_insolar.Arguments, err error)) *MachineLogicExecutorMock {
	if mmCallMethod.defaultExpectation != nil {
		mmCallMethod.mock.t.Fatalf("Default expectation is already set for the MachineLogicExecutor.CallMethod method")
	}

	if len(mmCallMethod.expectations) > 0 {
		mmCallMethod.mock.t.Fatalf("Some expectations are already set for the MachineLogicExecutor.CallMethod method")
	}

	mmCallMethod.mock.funcCallMethod = f
	return mmCallMethod.mock
}

// When sets expectation for the MachineLogicExecutor.CallMethod which will trigger the result defined by the following
// Then helper
func (mmCallMethod *mMachineLogicExecutorMockCallMethod) When(ctx context.Context, callContext *mm_insolar.LogicCallContext, code mm_insolar.Reference, data []byte, method string, args mm_insolar.Arguments) *MachineLogicExecutorMockCallMethodExpectation {
	if mmCallMethod.mock.funcCallMethod != nil {
		mmCallMethod.mock.t.Fatalf("MachineLogicExecutorMock.CallMethod mock is already set by Set")
	}

	expectation := &MachineLogicExecutorMockCallMethodExpectation{
		mock:   mmCallMethod.mock,
		params: &MachineLogicExecutorMockCallMethodParams{ctx, callContext, code, data, method, args},
	}
	mmCallMethod.expectations = append(mmCallMethod.expectations, expectation)
	return expectation
}

// Then sets up MachineLogicExecutor.CallMethod return parameters for the expectation previously defined by the When method
func (e *MachineLogicExecutorMockCallMethodExpectation) Then(newObjectState []byte, methodResults mm_insolar.Arguments, err error) *MachineLogicExecutorMock {
	e.results = &MachineLogicExecutorMockCallMethodResults{newObjectState, methodResults, err}
	return e.mock
}

// CallMethod implements insolar.MachineLogicExecutor
func (mmCallMethod *MachineLogicExecutorMock) CallMethod(ctx context.Context, callContext *mm_insolar.LogicCallContext, code mm_insolar.Reference, data []byte, method string, args mm_insolar.Arguments) (newObjectState []byte, methodResults mm_insolar.Arguments, err error) {
	mm_atomic.AddUint64(&mmCallMethod.beforeCallMethodCounter, 1)
	defer mm_atomic.AddUint64(&mmCallMethod.afterCallMethodCounter, 1)

	if mmCallMethod.inspectFuncCallMethod != nil {
		mmCallMethod.inspectFuncCallMethod(ctx, callContext, code, data, method, args)
	}

	mm_params := &MachineLogicExecutorMockCallMethodParams{ctx, callContext, code, data, method, args}

	// Record call args
	mmCallMethod.CallMethodMock.mutex.Lock()
	mmCallMethod.CallMethodMock.callArgs = append(mmCallMethod.CallMethodMock.callArgs, mm_params)
	mmCallMethod.CallMethodMock.mutex.Unlock()

	for _, e := range mmCallMethod.CallMethodMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.newObjectState, e.results.methodResults, e.results.err
		}
	}

	if mmCallMethod.CallMethodMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCallMethod.CallMethodMock.defaultExpectation.Counter, 1)
		mm_want := mmCallMethod.CallMethodMock.defaultExpectation.params
		mm_got := MachineLogicExecutorMockCallMethodParams{ctx, callContext, code, data, method, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCallMethod.t.Errorf("MachineLogicExecutorMock.CallMethod got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCallMethod.CallMethodMock.defaultExpectation.results
		if mm_results == nil {
			mmCallMethod.t.Fatal("No results are set for the MachineLogicExecutorMock.CallMethod")
		}
		return (*mm_results).newObjectState, (*mm_results).methodResults, (*mm_results).err
	}
	if mmCallMethod.funcCallMethod != nil {
		return mmCallMethod.funcCallMethod(ctx, callContext, code, data, method, args)
	}
	mmCallMethod.t.Fatalf("Unexpected call to MachineLogicExecutorMock.CallMethod. %v %v %v %v %v %v", ctx, callContext, code, data, method, args)
	return
}

// CallMethodAfterCounter returns a count of finished MachineLogicExecutorMock.CallMethod invocations
func (mmCallMethod *MachineLogicExecutorMock) CallMethodAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCallMethod.afterCallMethodCounter)
}

// CallMethodBeforeCounter returns a count of MachineLogicExecutorMock.CallMethod invocations
func (mmCallMethod *MachineLogicExecutorMock) CallMethodBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCallMethod.beforeCallMethodCounter)
}

// Calls returns a list of arguments used in each call to MachineLogicExecutorMock.CallMethod.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCallMethod *mMachineLogicExecutorMockCallMethod) Calls() []*MachineLogicExecutorMockCallMethodParams {
	mmCallMethod.mutex.RLock()

	argCopy := make([]*MachineLogicExecutorMockCallMethodParams, len(mmCallMethod.callArgs))
	copy(argCopy, mmCallMethod.callArgs)

	mmCallMethod.mutex.RUnlock()

	return argCopy
}

// MinimockCallMethodDone returns true if the count of the CallMethod invocations corresponds
// the number of defined expectations
func (m *MachineLogicExecutorMock) MinimockCallMethodDone() bool {
	for _, e := range m.CallMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CallMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCallMethodCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCallMethod != nil && mm_atomic.LoadUint64(&m.afterCallMethodCounter) < 1 {
		return false
	}
	return true
}

// MinimockCallMethodInspect logs each unmet expectation
func (m *MachineLogicExecutorMock) MinimockCallMethodInspect() {
	for _, e := range m.CallMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MachineLogicExecutorMock.CallMethod with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CallMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCallMethodCounter) < 1 {
		if m.CallMethodMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MachineLogicExecutorMock.CallMethod")
		} else {
			m.t.Errorf("Expected call to MachineLogicExecutorMock.CallMethod with params: %#v", *m.CallMethodMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCallMethod != nil && mm_atomic.LoadUint64(&m.afterCallMethodCounter) < 1 {
		m.t.Error("Expected call to MachineLogicExecutorMock.CallMethod")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *MachineLogicExecutorMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCallConstructorInspect()

		m.MinimockCallMethodInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *MachineLogicExecutorMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *MachineLogicExecutorMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCallConstructorDone() &&
		m.MinimockCallMethodDone()
}
