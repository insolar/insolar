package testutils

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"crypto"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	mm_insolar "github.com/insolar/insolar/insolar"
)

// CertificateMock implements insolar.Certificate
type CertificateMock struct {
	t minimock.Tester

	funcGetDiscoveryNodes          func() (da1 []mm_insolar.DiscoveryNode)
	inspectFuncGetDiscoveryNodes   func()
	afterGetDiscoveryNodesCounter  uint64
	beforeGetDiscoveryNodesCounter uint64
	GetDiscoveryNodesMock          mCertificateMockGetDiscoveryNodes

	funcGetDiscoverySigns          func() (m1 map[mm_insolar.Reference][]byte)
	inspectFuncGetDiscoverySigns   func()
	afterGetDiscoverySignsCounter  uint64
	beforeGetDiscoverySignsCounter uint64
	GetDiscoverySignsMock          mCertificateMockGetDiscoverySigns

	funcGetMajorityRule          func() (i1 int)
	inspectFuncGetMajorityRule   func()
	afterGetMajorityRuleCounter  uint64
	beforeGetMajorityRuleCounter uint64
	GetMajorityRuleMock          mCertificateMockGetMajorityRule

	funcGetMinRoles          func() (virtual uint, heavyMaterial uint, lightMaterial uint)
	inspectFuncGetMinRoles   func()
	afterGetMinRolesCounter  uint64
	beforeGetMinRolesCounter uint64
	GetMinRolesMock          mCertificateMockGetMinRoles

	funcGetNodeRef          func() (rp1 *mm_insolar.Reference)
	inspectFuncGetNodeRef   func()
	afterGetNodeRefCounter  uint64
	beforeGetNodeRefCounter uint64
	GetNodeRefMock          mCertificateMockGetNodeRef

	funcGetPublicKey          func() (p1 crypto.PublicKey)
	inspectFuncGetPublicKey   func()
	afterGetPublicKeyCounter  uint64
	beforeGetPublicKeyCounter uint64
	GetPublicKeyMock          mCertificateMockGetPublicKey

	funcGetRole          func() (s1 mm_insolar.StaticRole)
	inspectFuncGetRole   func()
	afterGetRoleCounter  uint64
	beforeGetRoleCounter uint64
	GetRoleMock          mCertificateMockGetRole

	funcGetRootDomainReference          func() (rp1 *mm_insolar.Reference)
	inspectFuncGetRootDomainReference   func()
	afterGetRootDomainReferenceCounter  uint64
	beforeGetRootDomainReferenceCounter uint64
	GetRootDomainReferenceMock          mCertificateMockGetRootDomainReference

	funcSerializeNodePart          func() (ba1 []byte)
	inspectFuncSerializeNodePart   func()
	afterSerializeNodePartCounter  uint64
	beforeSerializeNodePartCounter uint64
	SerializeNodePartMock          mCertificateMockSerializeNodePart
}

// NewCertificateMock returns a mock for insolar.Certificate
func NewCertificateMock(t minimock.Tester) *CertificateMock {
	m := &CertificateMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetDiscoveryNodesMock = mCertificateMockGetDiscoveryNodes{mock: m}

	m.GetDiscoverySignsMock = mCertificateMockGetDiscoverySigns{mock: m}

	m.GetMajorityRuleMock = mCertificateMockGetMajorityRule{mock: m}

	m.GetMinRolesMock = mCertificateMockGetMinRoles{mock: m}

	m.GetNodeRefMock = mCertificateMockGetNodeRef{mock: m}

	m.GetPublicKeyMock = mCertificateMockGetPublicKey{mock: m}

	m.GetRoleMock = mCertificateMockGetRole{mock: m}

	m.GetRootDomainReferenceMock = mCertificateMockGetRootDomainReference{mock: m}

	m.SerializeNodePartMock = mCertificateMockSerializeNodePart{mock: m}

	return m
}

type mCertificateMockGetDiscoveryNodes struct {
	mock               *CertificateMock
	defaultExpectation *CertificateMockGetDiscoveryNodesExpectation
	expectations       []*CertificateMockGetDiscoveryNodesExpectation
}

// CertificateMockGetDiscoveryNodesExpectation specifies expectation struct of the Certificate.GetDiscoveryNodes
type CertificateMockGetDiscoveryNodesExpectation struct {
	mock *CertificateMock

	results *CertificateMockGetDiscoveryNodesResults
	Counter uint64
}

// CertificateMockGetDiscoveryNodesResults contains results of the Certificate.GetDiscoveryNodes
type CertificateMockGetDiscoveryNodesResults struct {
	da1 []mm_insolar.DiscoveryNode
}

// Expect sets up expected params for Certificate.GetDiscoveryNodes
func (mmGetDiscoveryNodes *mCertificateMockGetDiscoveryNodes) Expect() *mCertificateMockGetDiscoveryNodes {
	if mmGetDiscoveryNodes.mock.funcGetDiscoveryNodes != nil {
		mmGetDiscoveryNodes.mock.t.Fatalf("CertificateMock.GetDiscoveryNodes mock is already set by Set")
	}

	if mmGetDiscoveryNodes.defaultExpectation == nil {
		mmGetDiscoveryNodes.defaultExpectation = &CertificateMockGetDiscoveryNodesExpectation{}
	}

	return mmGetDiscoveryNodes
}

// Inspect accepts an inspector function that has same arguments as the Certificate.GetDiscoveryNodes
func (mmGetDiscoveryNodes *mCertificateMockGetDiscoveryNodes) Inspect(f func()) *mCertificateMockGetDiscoveryNodes {
	if mmGetDiscoveryNodes.mock.inspectFuncGetDiscoveryNodes != nil {
		mmGetDiscoveryNodes.mock.t.Fatalf("Inspect function is already set for CertificateMock.GetDiscoveryNodes")
	}

	mmGetDiscoveryNodes.mock.inspectFuncGetDiscoveryNodes = f

	return mmGetDiscoveryNodes
}

// Return sets up results that will be returned by Certificate.GetDiscoveryNodes
func (mmGetDiscoveryNodes *mCertificateMockGetDiscoveryNodes) Return(da1 []mm_insolar.DiscoveryNode) *CertificateMock {
	if mmGetDiscoveryNodes.mock.funcGetDiscoveryNodes != nil {
		mmGetDiscoveryNodes.mock.t.Fatalf("CertificateMock.GetDiscoveryNodes mock is already set by Set")
	}

	if mmGetDiscoveryNodes.defaultExpectation == nil {
		mmGetDiscoveryNodes.defaultExpectation = &CertificateMockGetDiscoveryNodesExpectation{mock: mmGetDiscoveryNodes.mock}
	}
	mmGetDiscoveryNodes.defaultExpectation.results = &CertificateMockGetDiscoveryNodesResults{da1}
	return mmGetDiscoveryNodes.mock
}

//Set uses given function f to mock the Certificate.GetDiscoveryNodes method
func (mmGetDiscoveryNodes *mCertificateMockGetDiscoveryNodes) Set(f func() (da1 []mm_insolar.DiscoveryNode)) *CertificateMock {
	if mmGetDiscoveryNodes.defaultExpectation != nil {
		mmGetDiscoveryNodes.mock.t.Fatalf("Default expectation is already set for the Certificate.GetDiscoveryNodes method")
	}

	if len(mmGetDiscoveryNodes.expectations) > 0 {
		mmGetDiscoveryNodes.mock.t.Fatalf("Some expectations are already set for the Certificate.GetDiscoveryNodes method")
	}

	mmGetDiscoveryNodes.mock.funcGetDiscoveryNodes = f
	return mmGetDiscoveryNodes.mock
}

// GetDiscoveryNodes implements insolar.Certificate
func (mmGetDiscoveryNodes *CertificateMock) GetDiscoveryNodes() (da1 []mm_insolar.DiscoveryNode) {
	mm_atomic.AddUint64(&mmGetDiscoveryNodes.beforeGetDiscoveryNodesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDiscoveryNodes.afterGetDiscoveryNodesCounter, 1)

	if mmGetDiscoveryNodes.inspectFuncGetDiscoveryNodes != nil {
		mmGetDiscoveryNodes.inspectFuncGetDiscoveryNodes()
	}

	if mmGetDiscoveryNodes.GetDiscoveryNodesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDiscoveryNodes.GetDiscoveryNodesMock.defaultExpectation.Counter, 1)

		results := mmGetDiscoveryNodes.GetDiscoveryNodesMock.defaultExpectation.results
		if results == nil {
			mmGetDiscoveryNodes.t.Fatal("No results are set for the CertificateMock.GetDiscoveryNodes")
		}
		return (*results).da1
	}
	if mmGetDiscoveryNodes.funcGetDiscoveryNodes != nil {
		return mmGetDiscoveryNodes.funcGetDiscoveryNodes()
	}
	mmGetDiscoveryNodes.t.Fatalf("Unexpected call to CertificateMock.GetDiscoveryNodes.")
	return
}

// GetDiscoveryNodesAfterCounter returns a count of finished CertificateMock.GetDiscoveryNodes invocations
func (mmGetDiscoveryNodes *CertificateMock) GetDiscoveryNodesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDiscoveryNodes.afterGetDiscoveryNodesCounter)
}

// GetDiscoveryNodesBeforeCounter returns a count of CertificateMock.GetDiscoveryNodes invocations
func (mmGetDiscoveryNodes *CertificateMock) GetDiscoveryNodesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDiscoveryNodes.beforeGetDiscoveryNodesCounter)
}

// MinimockGetDiscoveryNodesDone returns true if the count of the GetDiscoveryNodes invocations corresponds
// the number of defined expectations
func (m *CertificateMock) MinimockGetDiscoveryNodesDone() bool {
	for _, e := range m.GetDiscoveryNodesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDiscoveryNodesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDiscoveryNodesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDiscoveryNodes != nil && mm_atomic.LoadUint64(&m.afterGetDiscoveryNodesCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetDiscoveryNodesInspect logs each unmet expectation
func (m *CertificateMock) MinimockGetDiscoveryNodesInspect() {
	for _, e := range m.GetDiscoveryNodesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to CertificateMock.GetDiscoveryNodes")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDiscoveryNodesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDiscoveryNodesCounter) < 1 {
		m.t.Error("Expected call to CertificateMock.GetDiscoveryNodes")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDiscoveryNodes != nil && mm_atomic.LoadUint64(&m.afterGetDiscoveryNodesCounter) < 1 {
		m.t.Error("Expected call to CertificateMock.GetDiscoveryNodes")
	}
}

type mCertificateMockGetDiscoverySigns struct {
	mock               *CertificateMock
	defaultExpectation *CertificateMockGetDiscoverySignsExpectation
	expectations       []*CertificateMockGetDiscoverySignsExpectation
}

// CertificateMockGetDiscoverySignsExpectation specifies expectation struct of the Certificate.GetDiscoverySigns
type CertificateMockGetDiscoverySignsExpectation struct {
	mock *CertificateMock

	results *CertificateMockGetDiscoverySignsResults
	Counter uint64
}

// CertificateMockGetDiscoverySignsResults contains results of the Certificate.GetDiscoverySigns
type CertificateMockGetDiscoverySignsResults struct {
	m1 map[mm_insolar.Reference][]byte
}

// Expect sets up expected params for Certificate.GetDiscoverySigns
func (mmGetDiscoverySigns *mCertificateMockGetDiscoverySigns) Expect() *mCertificateMockGetDiscoverySigns {
	if mmGetDiscoverySigns.mock.funcGetDiscoverySigns != nil {
		mmGetDiscoverySigns.mock.t.Fatalf("CertificateMock.GetDiscoverySigns mock is already set by Set")
	}

	if mmGetDiscoverySigns.defaultExpectation == nil {
		mmGetDiscoverySigns.defaultExpectation = &CertificateMockGetDiscoverySignsExpectation{}
	}

	return mmGetDiscoverySigns
}

// Inspect accepts an inspector function that has same arguments as the Certificate.GetDiscoverySigns
func (mmGetDiscoverySigns *mCertificateMockGetDiscoverySigns) Inspect(f func()) *mCertificateMockGetDiscoverySigns {
	if mmGetDiscoverySigns.mock.inspectFuncGetDiscoverySigns != nil {
		mmGetDiscoverySigns.mock.t.Fatalf("Inspect function is already set for CertificateMock.GetDiscoverySigns")
	}

	mmGetDiscoverySigns.mock.inspectFuncGetDiscoverySigns = f

	return mmGetDiscoverySigns
}

// Return sets up results that will be returned by Certificate.GetDiscoverySigns
func (mmGetDiscoverySigns *mCertificateMockGetDiscoverySigns) Return(m1 map[mm_insolar.Reference][]byte) *CertificateMock {
	if mmGetDiscoverySigns.mock.funcGetDiscoverySigns != nil {
		mmGetDiscoverySigns.mock.t.Fatalf("CertificateMock.GetDiscoverySigns mock is already set by Set")
	}

	if mmGetDiscoverySigns.defaultExpectation == nil {
		mmGetDiscoverySigns.defaultExpectation = &CertificateMockGetDiscoverySignsExpectation{mock: mmGetDiscoverySigns.mock}
	}
	mmGetDiscoverySigns.defaultExpectation.results = &CertificateMockGetDiscoverySignsResults{m1}
	return mmGetDiscoverySigns.mock
}

//Set uses given function f to mock the Certificate.GetDiscoverySigns method
func (mmGetDiscoverySigns *mCertificateMockGetDiscoverySigns) Set(f func() (m1 map[mm_insolar.Reference][]byte)) *CertificateMock {
	if mmGetDiscoverySigns.defaultExpectation != nil {
		mmGetDiscoverySigns.mock.t.Fatalf("Default expectation is already set for the Certificate.GetDiscoverySigns method")
	}

	if len(mmGetDiscoverySigns.expectations) > 0 {
		mmGetDiscoverySigns.mock.t.Fatalf("Some expectations are already set for the Certificate.GetDiscoverySigns method")
	}

	mmGetDiscoverySigns.mock.funcGetDiscoverySigns = f
	return mmGetDiscoverySigns.mock
}

// GetDiscoverySigns implements insolar.Certificate
func (mmGetDiscoverySigns *CertificateMock) GetDiscoverySigns() (m1 map[mm_insolar.Reference][]byte) {
	mm_atomic.AddUint64(&mmGetDiscoverySigns.beforeGetDiscoverySignsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDiscoverySigns.afterGetDiscoverySignsCounter, 1)

	if mmGetDiscoverySigns.inspectFuncGetDiscoverySigns != nil {
		mmGetDiscoverySigns.inspectFuncGetDiscoverySigns()
	}

	if mmGetDiscoverySigns.GetDiscoverySignsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDiscoverySigns.GetDiscoverySignsMock.defaultExpectation.Counter, 1)

		results := mmGetDiscoverySigns.GetDiscoverySignsMock.defaultExpectation.results
		if results == nil {
			mmGetDiscoverySigns.t.Fatal("No results are set for the CertificateMock.GetDiscoverySigns")
		}
		return (*results).m1
	}
	if mmGetDiscoverySigns.funcGetDiscoverySigns != nil {
		return mmGetDiscoverySigns.funcGetDiscoverySigns()
	}
	mmGetDiscoverySigns.t.Fatalf("Unexpected call to CertificateMock.GetDiscoverySigns.")
	return
}

// GetDiscoverySignsAfterCounter returns a count of finished CertificateMock.GetDiscoverySigns invocations
func (mmGetDiscoverySigns *CertificateMock) GetDiscoverySignsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDiscoverySigns.afterGetDiscoverySignsCounter)
}

// GetDiscoverySignsBeforeCounter returns a count of CertificateMock.GetDiscoverySigns invocations
func (mmGetDiscoverySigns *CertificateMock) GetDiscoverySignsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDiscoverySigns.beforeGetDiscoverySignsCounter)
}

// MinimockGetDiscoverySignsDone returns true if the count of the GetDiscoverySigns invocations corresponds
// the number of defined expectations
func (m *CertificateMock) MinimockGetDiscoverySignsDone() bool {
	for _, e := range m.GetDiscoverySignsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDiscoverySignsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDiscoverySignsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDiscoverySigns != nil && mm_atomic.LoadUint64(&m.afterGetDiscoverySignsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetDiscoverySignsInspect logs each unmet expectation
func (m *CertificateMock) MinimockGetDiscoverySignsInspect() {
	for _, e := range m.GetDiscoverySignsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to CertificateMock.GetDiscoverySigns")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDiscoverySignsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDiscoverySignsCounter) < 1 {
		m.t.Error("Expected call to CertificateMock.GetDiscoverySigns")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDiscoverySigns != nil && mm_atomic.LoadUint64(&m.afterGetDiscoverySignsCounter) < 1 {
		m.t.Error("Expected call to CertificateMock.GetDiscoverySigns")
	}
}

type mCertificateMockGetMajorityRule struct {
	mock               *CertificateMock
	defaultExpectation *CertificateMockGetMajorityRuleExpectation
	expectations       []*CertificateMockGetMajorityRuleExpectation
}

// CertificateMockGetMajorityRuleExpectation specifies expectation struct of the Certificate.GetMajorityRule
type CertificateMockGetMajorityRuleExpectation struct {
	mock *CertificateMock

	results *CertificateMockGetMajorityRuleResults
	Counter uint64
}

// CertificateMockGetMajorityRuleResults contains results of the Certificate.GetMajorityRule
type CertificateMockGetMajorityRuleResults struct {
	i1 int
}

// Expect sets up expected params for Certificate.GetMajorityRule
func (mmGetMajorityRule *mCertificateMockGetMajorityRule) Expect() *mCertificateMockGetMajorityRule {
	if mmGetMajorityRule.mock.funcGetMajorityRule != nil {
		mmGetMajorityRule.mock.t.Fatalf("CertificateMock.GetMajorityRule mock is already set by Set")
	}

	if mmGetMajorityRule.defaultExpectation == nil {
		mmGetMajorityRule.defaultExpectation = &CertificateMockGetMajorityRuleExpectation{}
	}

	return mmGetMajorityRule
}

// Inspect accepts an inspector function that has same arguments as the Certificate.GetMajorityRule
func (mmGetMajorityRule *mCertificateMockGetMajorityRule) Inspect(f func()) *mCertificateMockGetMajorityRule {
	if mmGetMajorityRule.mock.inspectFuncGetMajorityRule != nil {
		mmGetMajorityRule.mock.t.Fatalf("Inspect function is already set for CertificateMock.GetMajorityRule")
	}

	mmGetMajorityRule.mock.inspectFuncGetMajorityRule = f

	return mmGetMajorityRule
}

// Return sets up results that will be returned by Certificate.GetMajorityRule
func (mmGetMajorityRule *mCertificateMockGetMajorityRule) Return(i1 int) *CertificateMock {
	if mmGetMajorityRule.mock.funcGetMajorityRule != nil {
		mmGetMajorityRule.mock.t.Fatalf("CertificateMock.GetMajorityRule mock is already set by Set")
	}

	if mmGetMajorityRule.defaultExpectation == nil {
		mmGetMajorityRule.defaultExpectation = &CertificateMockGetMajorityRuleExpectation{mock: mmGetMajorityRule.mock}
	}
	mmGetMajorityRule.defaultExpectation.results = &CertificateMockGetMajorityRuleResults{i1}
	return mmGetMajorityRule.mock
}

//Set uses given function f to mock the Certificate.GetMajorityRule method
func (mmGetMajorityRule *mCertificateMockGetMajorityRule) Set(f func() (i1 int)) *CertificateMock {
	if mmGetMajorityRule.defaultExpectation != nil {
		mmGetMajorityRule.mock.t.Fatalf("Default expectation is already set for the Certificate.GetMajorityRule method")
	}

	if len(mmGetMajorityRule.expectations) > 0 {
		mmGetMajorityRule.mock.t.Fatalf("Some expectations are already set for the Certificate.GetMajorityRule method")
	}

	mmGetMajorityRule.mock.funcGetMajorityRule = f
	return mmGetMajorityRule.mock
}

// GetMajorityRule implements insolar.Certificate
func (mmGetMajorityRule *CertificateMock) GetMajorityRule() (i1 int) {
	mm_atomic.AddUint64(&mmGetMajorityRule.beforeGetMajorityRuleCounter, 1)
	defer mm_atomic.AddUint64(&mmGetMajorityRule.afterGetMajorityRuleCounter, 1)

	if mmGetMajorityRule.inspectFuncGetMajorityRule != nil {
		mmGetMajorityRule.inspectFuncGetMajorityRule()
	}

	if mmGetMajorityRule.GetMajorityRuleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetMajorityRule.GetMajorityRuleMock.defaultExpectation.Counter, 1)

		results := mmGetMajorityRule.GetMajorityRuleMock.defaultExpectation.results
		if results == nil {
			mmGetMajorityRule.t.Fatal("No results are set for the CertificateMock.GetMajorityRule")
		}
		return (*results).i1
	}
	if mmGetMajorityRule.funcGetMajorityRule != nil {
		return mmGetMajorityRule.funcGetMajorityRule()
	}
	mmGetMajorityRule.t.Fatalf("Unexpected call to CertificateMock.GetMajorityRule.")
	return
}

// GetMajorityRuleAfterCounter returns a count of finished CertificateMock.GetMajorityRule invocations
func (mmGetMajorityRule *CertificateMock) GetMajorityRuleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMajorityRule.afterGetMajorityRuleCounter)
}

// GetMajorityRuleBeforeCounter returns a count of CertificateMock.GetMajorityRule invocations
func (mmGetMajorityRule *CertificateMock) GetMajorityRuleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMajorityRule.beforeGetMajorityRuleCounter)
}

// MinimockGetMajorityRuleDone returns true if the count of the GetMajorityRule invocations corresponds
// the number of defined expectations
func (m *CertificateMock) MinimockGetMajorityRuleDone() bool {
	for _, e := range m.GetMajorityRuleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMajorityRuleMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetMajorityRuleCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetMajorityRule != nil && mm_atomic.LoadUint64(&m.afterGetMajorityRuleCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetMajorityRuleInspect logs each unmet expectation
func (m *CertificateMock) MinimockGetMajorityRuleInspect() {
	for _, e := range m.GetMajorityRuleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to CertificateMock.GetMajorityRule")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMajorityRuleMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetMajorityRuleCounter) < 1 {
		m.t.Error("Expected call to CertificateMock.GetMajorityRule")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetMajorityRule != nil && mm_atomic.LoadUint64(&m.afterGetMajorityRuleCounter) < 1 {
		m.t.Error("Expected call to CertificateMock.GetMajorityRule")
	}
}

type mCertificateMockGetMinRoles struct {
	mock               *CertificateMock
	defaultExpectation *CertificateMockGetMinRolesExpectation
	expectations       []*CertificateMockGetMinRolesExpectation
}

// CertificateMockGetMinRolesExpectation specifies expectation struct of the Certificate.GetMinRoles
type CertificateMockGetMinRolesExpectation struct {
	mock *CertificateMock

	results *CertificateMockGetMinRolesResults
	Counter uint64
}

// CertificateMockGetMinRolesResults contains results of the Certificate.GetMinRoles
type CertificateMockGetMinRolesResults struct {
	virtual       uint
	heavyMaterial uint
	lightMaterial uint
}

// Expect sets up expected params for Certificate.GetMinRoles
func (mmGetMinRoles *mCertificateMockGetMinRoles) Expect() *mCertificateMockGetMinRoles {
	if mmGetMinRoles.mock.funcGetMinRoles != nil {
		mmGetMinRoles.mock.t.Fatalf("CertificateMock.GetMinRoles mock is already set by Set")
	}

	if mmGetMinRoles.defaultExpectation == nil {
		mmGetMinRoles.defaultExpectation = &CertificateMockGetMinRolesExpectation{}
	}

	return mmGetMinRoles
}

// Inspect accepts an inspector function that has same arguments as the Certificate.GetMinRoles
func (mmGetMinRoles *mCertificateMockGetMinRoles) Inspect(f func()) *mCertificateMockGetMinRoles {
	if mmGetMinRoles.mock.inspectFuncGetMinRoles != nil {
		mmGetMinRoles.mock.t.Fatalf("Inspect function is already set for CertificateMock.GetMinRoles")
	}

	mmGetMinRoles.mock.inspectFuncGetMinRoles = f

	return mmGetMinRoles
}

// Return sets up results that will be returned by Certificate.GetMinRoles
func (mmGetMinRoles *mCertificateMockGetMinRoles) Return(virtual uint, heavyMaterial uint, lightMaterial uint) *CertificateMock {
	if mmGetMinRoles.mock.funcGetMinRoles != nil {
		mmGetMinRoles.mock.t.Fatalf("CertificateMock.GetMinRoles mock is already set by Set")
	}

	if mmGetMinRoles.defaultExpectation == nil {
		mmGetMinRoles.defaultExpectation = &CertificateMockGetMinRolesExpectation{mock: mmGetMinRoles.mock}
	}
	mmGetMinRoles.defaultExpectation.results = &CertificateMockGetMinRolesResults{virtual, heavyMaterial, lightMaterial}
	return mmGetMinRoles.mock
}

//Set uses given function f to mock the Certificate.GetMinRoles method
func (mmGetMinRoles *mCertificateMockGetMinRoles) Set(f func() (virtual uint, heavyMaterial uint, lightMaterial uint)) *CertificateMock {
	if mmGetMinRoles.defaultExpectation != nil {
		mmGetMinRoles.mock.t.Fatalf("Default expectation is already set for the Certificate.GetMinRoles method")
	}

	if len(mmGetMinRoles.expectations) > 0 {
		mmGetMinRoles.mock.t.Fatalf("Some expectations are already set for the Certificate.GetMinRoles method")
	}

	mmGetMinRoles.mock.funcGetMinRoles = f
	return mmGetMinRoles.mock
}

// GetMinRoles implements insolar.Certificate
func (mmGetMinRoles *CertificateMock) GetMinRoles() (virtual uint, heavyMaterial uint, lightMaterial uint) {
	mm_atomic.AddUint64(&mmGetMinRoles.beforeGetMinRolesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetMinRoles.afterGetMinRolesCounter, 1)

	if mmGetMinRoles.inspectFuncGetMinRoles != nil {
		mmGetMinRoles.inspectFuncGetMinRoles()
	}

	if mmGetMinRoles.GetMinRolesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetMinRoles.GetMinRolesMock.defaultExpectation.Counter, 1)

		results := mmGetMinRoles.GetMinRolesMock.defaultExpectation.results
		if results == nil {
			mmGetMinRoles.t.Fatal("No results are set for the CertificateMock.GetMinRoles")
		}
		return (*results).virtual, (*results).heavyMaterial, (*results).lightMaterial
	}
	if mmGetMinRoles.funcGetMinRoles != nil {
		return mmGetMinRoles.funcGetMinRoles()
	}
	mmGetMinRoles.t.Fatalf("Unexpected call to CertificateMock.GetMinRoles.")
	return
}

// GetMinRolesAfterCounter returns a count of finished CertificateMock.GetMinRoles invocations
func (mmGetMinRoles *CertificateMock) GetMinRolesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMinRoles.afterGetMinRolesCounter)
}

// GetMinRolesBeforeCounter returns a count of CertificateMock.GetMinRoles invocations
func (mmGetMinRoles *CertificateMock) GetMinRolesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMinRoles.beforeGetMinRolesCounter)
}

// MinimockGetMinRolesDone returns true if the count of the GetMinRoles invocations corresponds
// the number of defined expectations
func (m *CertificateMock) MinimockGetMinRolesDone() bool {
	for _, e := range m.GetMinRolesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMinRolesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetMinRolesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetMinRoles != nil && mm_atomic.LoadUint64(&m.afterGetMinRolesCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetMinRolesInspect logs each unmet expectation
func (m *CertificateMock) MinimockGetMinRolesInspect() {
	for _, e := range m.GetMinRolesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to CertificateMock.GetMinRoles")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMinRolesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetMinRolesCounter) < 1 {
		m.t.Error("Expected call to CertificateMock.GetMinRoles")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetMinRoles != nil && mm_atomic.LoadUint64(&m.afterGetMinRolesCounter) < 1 {
		m.t.Error("Expected call to CertificateMock.GetMinRoles")
	}
}

type mCertificateMockGetNodeRef struct {
	mock               *CertificateMock
	defaultExpectation *CertificateMockGetNodeRefExpectation
	expectations       []*CertificateMockGetNodeRefExpectation
}

// CertificateMockGetNodeRefExpectation specifies expectation struct of the Certificate.GetNodeRef
type CertificateMockGetNodeRefExpectation struct {
	mock *CertificateMock

	results *CertificateMockGetNodeRefResults
	Counter uint64
}

// CertificateMockGetNodeRefResults contains results of the Certificate.GetNodeRef
type CertificateMockGetNodeRefResults struct {
	rp1 *mm_insolar.Reference
}

// Expect sets up expected params for Certificate.GetNodeRef
func (mmGetNodeRef *mCertificateMockGetNodeRef) Expect() *mCertificateMockGetNodeRef {
	if mmGetNodeRef.mock.funcGetNodeRef != nil {
		mmGetNodeRef.mock.t.Fatalf("CertificateMock.GetNodeRef mock is already set by Set")
	}

	if mmGetNodeRef.defaultExpectation == nil {
		mmGetNodeRef.defaultExpectation = &CertificateMockGetNodeRefExpectation{}
	}

	return mmGetNodeRef
}

// Inspect accepts an inspector function that has same arguments as the Certificate.GetNodeRef
func (mmGetNodeRef *mCertificateMockGetNodeRef) Inspect(f func()) *mCertificateMockGetNodeRef {
	if mmGetNodeRef.mock.inspectFuncGetNodeRef != nil {
		mmGetNodeRef.mock.t.Fatalf("Inspect function is already set for CertificateMock.GetNodeRef")
	}

	mmGetNodeRef.mock.inspectFuncGetNodeRef = f

	return mmGetNodeRef
}

// Return sets up results that will be returned by Certificate.GetNodeRef
func (mmGetNodeRef *mCertificateMockGetNodeRef) Return(rp1 *mm_insolar.Reference) *CertificateMock {
	if mmGetNodeRef.mock.funcGetNodeRef != nil {
		mmGetNodeRef.mock.t.Fatalf("CertificateMock.GetNodeRef mock is already set by Set")
	}

	if mmGetNodeRef.defaultExpectation == nil {
		mmGetNodeRef.defaultExpectation = &CertificateMockGetNodeRefExpectation{mock: mmGetNodeRef.mock}
	}
	mmGetNodeRef.defaultExpectation.results = &CertificateMockGetNodeRefResults{rp1}
	return mmGetNodeRef.mock
}

//Set uses given function f to mock the Certificate.GetNodeRef method
func (mmGetNodeRef *mCertificateMockGetNodeRef) Set(f func() (rp1 *mm_insolar.Reference)) *CertificateMock {
	if mmGetNodeRef.defaultExpectation != nil {
		mmGetNodeRef.mock.t.Fatalf("Default expectation is already set for the Certificate.GetNodeRef method")
	}

	if len(mmGetNodeRef.expectations) > 0 {
		mmGetNodeRef.mock.t.Fatalf("Some expectations are already set for the Certificate.GetNodeRef method")
	}

	mmGetNodeRef.mock.funcGetNodeRef = f
	return mmGetNodeRef.mock
}

// GetNodeRef implements insolar.Certificate
func (mmGetNodeRef *CertificateMock) GetNodeRef() (rp1 *mm_insolar.Reference) {
	mm_atomic.AddUint64(&mmGetNodeRef.beforeGetNodeRefCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNodeRef.afterGetNodeRefCounter, 1)

	if mmGetNodeRef.inspectFuncGetNodeRef != nil {
		mmGetNodeRef.inspectFuncGetNodeRef()
	}

	if mmGetNodeRef.GetNodeRefMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNodeRef.GetNodeRefMock.defaultExpectation.Counter, 1)

		results := mmGetNodeRef.GetNodeRefMock.defaultExpectation.results
		if results == nil {
			mmGetNodeRef.t.Fatal("No results are set for the CertificateMock.GetNodeRef")
		}
		return (*results).rp1
	}
	if mmGetNodeRef.funcGetNodeRef != nil {
		return mmGetNodeRef.funcGetNodeRef()
	}
	mmGetNodeRef.t.Fatalf("Unexpected call to CertificateMock.GetNodeRef.")
	return
}

// GetNodeRefAfterCounter returns a count of finished CertificateMock.GetNodeRef invocations
func (mmGetNodeRef *CertificateMock) GetNodeRefAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNodeRef.afterGetNodeRefCounter)
}

// GetNodeRefBeforeCounter returns a count of CertificateMock.GetNodeRef invocations
func (mmGetNodeRef *CertificateMock) GetNodeRefBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNodeRef.beforeGetNodeRefCounter)
}

// MinimockGetNodeRefDone returns true if the count of the GetNodeRef invocations corresponds
// the number of defined expectations
func (m *CertificateMock) MinimockGetNodeRefDone() bool {
	for _, e := range m.GetNodeRefMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetNodeRefMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetNodeRefCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNodeRef != nil && mm_atomic.LoadUint64(&m.afterGetNodeRefCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetNodeRefInspect logs each unmet expectation
func (m *CertificateMock) MinimockGetNodeRefInspect() {
	for _, e := range m.GetNodeRefMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to CertificateMock.GetNodeRef")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetNodeRefMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetNodeRefCounter) < 1 {
		m.t.Error("Expected call to CertificateMock.GetNodeRef")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNodeRef != nil && mm_atomic.LoadUint64(&m.afterGetNodeRefCounter) < 1 {
		m.t.Error("Expected call to CertificateMock.GetNodeRef")
	}
}

type mCertificateMockGetPublicKey struct {
	mock               *CertificateMock
	defaultExpectation *CertificateMockGetPublicKeyExpectation
	expectations       []*CertificateMockGetPublicKeyExpectation
}

// CertificateMockGetPublicKeyExpectation specifies expectation struct of the Certificate.GetPublicKey
type CertificateMockGetPublicKeyExpectation struct {
	mock *CertificateMock

	results *CertificateMockGetPublicKeyResults
	Counter uint64
}

// CertificateMockGetPublicKeyResults contains results of the Certificate.GetPublicKey
type CertificateMockGetPublicKeyResults struct {
	p1 crypto.PublicKey
}

// Expect sets up expected params for Certificate.GetPublicKey
func (mmGetPublicKey *mCertificateMockGetPublicKey) Expect() *mCertificateMockGetPublicKey {
	if mmGetPublicKey.mock.funcGetPublicKey != nil {
		mmGetPublicKey.mock.t.Fatalf("CertificateMock.GetPublicKey mock is already set by Set")
	}

	if mmGetPublicKey.defaultExpectation == nil {
		mmGetPublicKey.defaultExpectation = &CertificateMockGetPublicKeyExpectation{}
	}

	return mmGetPublicKey
}

// Inspect accepts an inspector function that has same arguments as the Certificate.GetPublicKey
func (mmGetPublicKey *mCertificateMockGetPublicKey) Inspect(f func()) *mCertificateMockGetPublicKey {
	if mmGetPublicKey.mock.inspectFuncGetPublicKey != nil {
		mmGetPublicKey.mock.t.Fatalf("Inspect function is already set for CertificateMock.GetPublicKey")
	}

	mmGetPublicKey.mock.inspectFuncGetPublicKey = f

	return mmGetPublicKey
}

// Return sets up results that will be returned by Certificate.GetPublicKey
func (mmGetPublicKey *mCertificateMockGetPublicKey) Return(p1 crypto.PublicKey) *CertificateMock {
	if mmGetPublicKey.mock.funcGetPublicKey != nil {
		mmGetPublicKey.mock.t.Fatalf("CertificateMock.GetPublicKey mock is already set by Set")
	}

	if mmGetPublicKey.defaultExpectation == nil {
		mmGetPublicKey.defaultExpectation = &CertificateMockGetPublicKeyExpectation{mock: mmGetPublicKey.mock}
	}
	mmGetPublicKey.defaultExpectation.results = &CertificateMockGetPublicKeyResults{p1}
	return mmGetPublicKey.mock
}

//Set uses given function f to mock the Certificate.GetPublicKey method
func (mmGetPublicKey *mCertificateMockGetPublicKey) Set(f func() (p1 crypto.PublicKey)) *CertificateMock {
	if mmGetPublicKey.defaultExpectation != nil {
		mmGetPublicKey.mock.t.Fatalf("Default expectation is already set for the Certificate.GetPublicKey method")
	}

	if len(mmGetPublicKey.expectations) > 0 {
		mmGetPublicKey.mock.t.Fatalf("Some expectations are already set for the Certificate.GetPublicKey method")
	}

	mmGetPublicKey.mock.funcGetPublicKey = f
	return mmGetPublicKey.mock
}

// GetPublicKey implements insolar.Certificate
func (mmGetPublicKey *CertificateMock) GetPublicKey() (p1 crypto.PublicKey) {
	mm_atomic.AddUint64(&mmGetPublicKey.beforeGetPublicKeyCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPublicKey.afterGetPublicKeyCounter, 1)

	if mmGetPublicKey.inspectFuncGetPublicKey != nil {
		mmGetPublicKey.inspectFuncGetPublicKey()
	}

	if mmGetPublicKey.GetPublicKeyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPublicKey.GetPublicKeyMock.defaultExpectation.Counter, 1)

		results := mmGetPublicKey.GetPublicKeyMock.defaultExpectation.results
		if results == nil {
			mmGetPublicKey.t.Fatal("No results are set for the CertificateMock.GetPublicKey")
		}
		return (*results).p1
	}
	if mmGetPublicKey.funcGetPublicKey != nil {
		return mmGetPublicKey.funcGetPublicKey()
	}
	mmGetPublicKey.t.Fatalf("Unexpected call to CertificateMock.GetPublicKey.")
	return
}

// GetPublicKeyAfterCounter returns a count of finished CertificateMock.GetPublicKey invocations
func (mmGetPublicKey *CertificateMock) GetPublicKeyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPublicKey.afterGetPublicKeyCounter)
}

// GetPublicKeyBeforeCounter returns a count of CertificateMock.GetPublicKey invocations
func (mmGetPublicKey *CertificateMock) GetPublicKeyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPublicKey.beforeGetPublicKeyCounter)
}

// MinimockGetPublicKeyDone returns true if the count of the GetPublicKey invocations corresponds
// the number of defined expectations
func (m *CertificateMock) MinimockGetPublicKeyDone() bool {
	for _, e := range m.GetPublicKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPublicKeyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPublicKeyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPublicKey != nil && mm_atomic.LoadUint64(&m.afterGetPublicKeyCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPublicKeyInspect logs each unmet expectation
func (m *CertificateMock) MinimockGetPublicKeyInspect() {
	for _, e := range m.GetPublicKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to CertificateMock.GetPublicKey")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPublicKeyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPublicKeyCounter) < 1 {
		m.t.Error("Expected call to CertificateMock.GetPublicKey")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPublicKey != nil && mm_atomic.LoadUint64(&m.afterGetPublicKeyCounter) < 1 {
		m.t.Error("Expected call to CertificateMock.GetPublicKey")
	}
}

type mCertificateMockGetRole struct {
	mock               *CertificateMock
	defaultExpectation *CertificateMockGetRoleExpectation
	expectations       []*CertificateMockGetRoleExpectation
}

// CertificateMockGetRoleExpectation specifies expectation struct of the Certificate.GetRole
type CertificateMockGetRoleExpectation struct {
	mock *CertificateMock

	results *CertificateMockGetRoleResults
	Counter uint64
}

// CertificateMockGetRoleResults contains results of the Certificate.GetRole
type CertificateMockGetRoleResults struct {
	s1 mm_insolar.StaticRole
}

// Expect sets up expected params for Certificate.GetRole
func (mmGetRole *mCertificateMockGetRole) Expect() *mCertificateMockGetRole {
	if mmGetRole.mock.funcGetRole != nil {
		mmGetRole.mock.t.Fatalf("CertificateMock.GetRole mock is already set by Set")
	}

	if mmGetRole.defaultExpectation == nil {
		mmGetRole.defaultExpectation = &CertificateMockGetRoleExpectation{}
	}

	return mmGetRole
}

// Inspect accepts an inspector function that has same arguments as the Certificate.GetRole
func (mmGetRole *mCertificateMockGetRole) Inspect(f func()) *mCertificateMockGetRole {
	if mmGetRole.mock.inspectFuncGetRole != nil {
		mmGetRole.mock.t.Fatalf("Inspect function is already set for CertificateMock.GetRole")
	}

	mmGetRole.mock.inspectFuncGetRole = f

	return mmGetRole
}

// Return sets up results that will be returned by Certificate.GetRole
func (mmGetRole *mCertificateMockGetRole) Return(s1 mm_insolar.StaticRole) *CertificateMock {
	if mmGetRole.mock.funcGetRole != nil {
		mmGetRole.mock.t.Fatalf("CertificateMock.GetRole mock is already set by Set")
	}

	if mmGetRole.defaultExpectation == nil {
		mmGetRole.defaultExpectation = &CertificateMockGetRoleExpectation{mock: mmGetRole.mock}
	}
	mmGetRole.defaultExpectation.results = &CertificateMockGetRoleResults{s1}
	return mmGetRole.mock
}

//Set uses given function f to mock the Certificate.GetRole method
func (mmGetRole *mCertificateMockGetRole) Set(f func() (s1 mm_insolar.StaticRole)) *CertificateMock {
	if mmGetRole.defaultExpectation != nil {
		mmGetRole.mock.t.Fatalf("Default expectation is already set for the Certificate.GetRole method")
	}

	if len(mmGetRole.expectations) > 0 {
		mmGetRole.mock.t.Fatalf("Some expectations are already set for the Certificate.GetRole method")
	}

	mmGetRole.mock.funcGetRole = f
	return mmGetRole.mock
}

// GetRole implements insolar.Certificate
func (mmGetRole *CertificateMock) GetRole() (s1 mm_insolar.StaticRole) {
	mm_atomic.AddUint64(&mmGetRole.beforeGetRoleCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRole.afterGetRoleCounter, 1)

	if mmGetRole.inspectFuncGetRole != nil {
		mmGetRole.inspectFuncGetRole()
	}

	if mmGetRole.GetRoleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRole.GetRoleMock.defaultExpectation.Counter, 1)

		results := mmGetRole.GetRoleMock.defaultExpectation.results
		if results == nil {
			mmGetRole.t.Fatal("No results are set for the CertificateMock.GetRole")
		}
		return (*results).s1
	}
	if mmGetRole.funcGetRole != nil {
		return mmGetRole.funcGetRole()
	}
	mmGetRole.t.Fatalf("Unexpected call to CertificateMock.GetRole.")
	return
}

// GetRoleAfterCounter returns a count of finished CertificateMock.GetRole invocations
func (mmGetRole *CertificateMock) GetRoleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRole.afterGetRoleCounter)
}

// GetRoleBeforeCounter returns a count of CertificateMock.GetRole invocations
func (mmGetRole *CertificateMock) GetRoleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRole.beforeGetRoleCounter)
}

// MinimockGetRoleDone returns true if the count of the GetRole invocations corresponds
// the number of defined expectations
func (m *CertificateMock) MinimockGetRoleDone() bool {
	for _, e := range m.GetRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRoleMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRoleCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRole != nil && mm_atomic.LoadUint64(&m.afterGetRoleCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetRoleInspect logs each unmet expectation
func (m *CertificateMock) MinimockGetRoleInspect() {
	for _, e := range m.GetRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to CertificateMock.GetRole")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRoleMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRoleCounter) < 1 {
		m.t.Error("Expected call to CertificateMock.GetRole")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRole != nil && mm_atomic.LoadUint64(&m.afterGetRoleCounter) < 1 {
		m.t.Error("Expected call to CertificateMock.GetRole")
	}
}

type mCertificateMockGetRootDomainReference struct {
	mock               *CertificateMock
	defaultExpectation *CertificateMockGetRootDomainReferenceExpectation
	expectations       []*CertificateMockGetRootDomainReferenceExpectation
}

// CertificateMockGetRootDomainReferenceExpectation specifies expectation struct of the Certificate.GetRootDomainReference
type CertificateMockGetRootDomainReferenceExpectation struct {
	mock *CertificateMock

	results *CertificateMockGetRootDomainReferenceResults
	Counter uint64
}

// CertificateMockGetRootDomainReferenceResults contains results of the Certificate.GetRootDomainReference
type CertificateMockGetRootDomainReferenceResults struct {
	rp1 *mm_insolar.Reference
}

// Expect sets up expected params for Certificate.GetRootDomainReference
func (mmGetRootDomainReference *mCertificateMockGetRootDomainReference) Expect() *mCertificateMockGetRootDomainReference {
	if mmGetRootDomainReference.mock.funcGetRootDomainReference != nil {
		mmGetRootDomainReference.mock.t.Fatalf("CertificateMock.GetRootDomainReference mock is already set by Set")
	}

	if mmGetRootDomainReference.defaultExpectation == nil {
		mmGetRootDomainReference.defaultExpectation = &CertificateMockGetRootDomainReferenceExpectation{}
	}

	return mmGetRootDomainReference
}

// Inspect accepts an inspector function that has same arguments as the Certificate.GetRootDomainReference
func (mmGetRootDomainReference *mCertificateMockGetRootDomainReference) Inspect(f func()) *mCertificateMockGetRootDomainReference {
	if mmGetRootDomainReference.mock.inspectFuncGetRootDomainReference != nil {
		mmGetRootDomainReference.mock.t.Fatalf("Inspect function is already set for CertificateMock.GetRootDomainReference")
	}

	mmGetRootDomainReference.mock.inspectFuncGetRootDomainReference = f

	return mmGetRootDomainReference
}

// Return sets up results that will be returned by Certificate.GetRootDomainReference
func (mmGetRootDomainReference *mCertificateMockGetRootDomainReference) Return(rp1 *mm_insolar.Reference) *CertificateMock {
	if mmGetRootDomainReference.mock.funcGetRootDomainReference != nil {
		mmGetRootDomainReference.mock.t.Fatalf("CertificateMock.GetRootDomainReference mock is already set by Set")
	}

	if mmGetRootDomainReference.defaultExpectation == nil {
		mmGetRootDomainReference.defaultExpectation = &CertificateMockGetRootDomainReferenceExpectation{mock: mmGetRootDomainReference.mock}
	}
	mmGetRootDomainReference.defaultExpectation.results = &CertificateMockGetRootDomainReferenceResults{rp1}
	return mmGetRootDomainReference.mock
}

//Set uses given function f to mock the Certificate.GetRootDomainReference method
func (mmGetRootDomainReference *mCertificateMockGetRootDomainReference) Set(f func() (rp1 *mm_insolar.Reference)) *CertificateMock {
	if mmGetRootDomainReference.defaultExpectation != nil {
		mmGetRootDomainReference.mock.t.Fatalf("Default expectation is already set for the Certificate.GetRootDomainReference method")
	}

	if len(mmGetRootDomainReference.expectations) > 0 {
		mmGetRootDomainReference.mock.t.Fatalf("Some expectations are already set for the Certificate.GetRootDomainReference method")
	}

	mmGetRootDomainReference.mock.funcGetRootDomainReference = f
	return mmGetRootDomainReference.mock
}

// GetRootDomainReference implements insolar.Certificate
func (mmGetRootDomainReference *CertificateMock) GetRootDomainReference() (rp1 *mm_insolar.Reference) {
	mm_atomic.AddUint64(&mmGetRootDomainReference.beforeGetRootDomainReferenceCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRootDomainReference.afterGetRootDomainReferenceCounter, 1)

	if mmGetRootDomainReference.inspectFuncGetRootDomainReference != nil {
		mmGetRootDomainReference.inspectFuncGetRootDomainReference()
	}

	if mmGetRootDomainReference.GetRootDomainReferenceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRootDomainReference.GetRootDomainReferenceMock.defaultExpectation.Counter, 1)

		results := mmGetRootDomainReference.GetRootDomainReferenceMock.defaultExpectation.results
		if results == nil {
			mmGetRootDomainReference.t.Fatal("No results are set for the CertificateMock.GetRootDomainReference")
		}
		return (*results).rp1
	}
	if mmGetRootDomainReference.funcGetRootDomainReference != nil {
		return mmGetRootDomainReference.funcGetRootDomainReference()
	}
	mmGetRootDomainReference.t.Fatalf("Unexpected call to CertificateMock.GetRootDomainReference.")
	return
}

// GetRootDomainReferenceAfterCounter returns a count of finished CertificateMock.GetRootDomainReference invocations
func (mmGetRootDomainReference *CertificateMock) GetRootDomainReferenceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRootDomainReference.afterGetRootDomainReferenceCounter)
}

// GetRootDomainReferenceBeforeCounter returns a count of CertificateMock.GetRootDomainReference invocations
func (mmGetRootDomainReference *CertificateMock) GetRootDomainReferenceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRootDomainReference.beforeGetRootDomainReferenceCounter)
}

// MinimockGetRootDomainReferenceDone returns true if the count of the GetRootDomainReference invocations corresponds
// the number of defined expectations
func (m *CertificateMock) MinimockGetRootDomainReferenceDone() bool {
	for _, e := range m.GetRootDomainReferenceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRootDomainReferenceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRootDomainReferenceCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRootDomainReference != nil && mm_atomic.LoadUint64(&m.afterGetRootDomainReferenceCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetRootDomainReferenceInspect logs each unmet expectation
func (m *CertificateMock) MinimockGetRootDomainReferenceInspect() {
	for _, e := range m.GetRootDomainReferenceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to CertificateMock.GetRootDomainReference")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRootDomainReferenceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRootDomainReferenceCounter) < 1 {
		m.t.Error("Expected call to CertificateMock.GetRootDomainReference")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRootDomainReference != nil && mm_atomic.LoadUint64(&m.afterGetRootDomainReferenceCounter) < 1 {
		m.t.Error("Expected call to CertificateMock.GetRootDomainReference")
	}
}

type mCertificateMockSerializeNodePart struct {
	mock               *CertificateMock
	defaultExpectation *CertificateMockSerializeNodePartExpectation
	expectations       []*CertificateMockSerializeNodePartExpectation
}

// CertificateMockSerializeNodePartExpectation specifies expectation struct of the Certificate.SerializeNodePart
type CertificateMockSerializeNodePartExpectation struct {
	mock *CertificateMock

	results *CertificateMockSerializeNodePartResults
	Counter uint64
}

// CertificateMockSerializeNodePartResults contains results of the Certificate.SerializeNodePart
type CertificateMockSerializeNodePartResults struct {
	ba1 []byte
}

// Expect sets up expected params for Certificate.SerializeNodePart
func (mmSerializeNodePart *mCertificateMockSerializeNodePart) Expect() *mCertificateMockSerializeNodePart {
	if mmSerializeNodePart.mock.funcSerializeNodePart != nil {
		mmSerializeNodePart.mock.t.Fatalf("CertificateMock.SerializeNodePart mock is already set by Set")
	}

	if mmSerializeNodePart.defaultExpectation == nil {
		mmSerializeNodePart.defaultExpectation = &CertificateMockSerializeNodePartExpectation{}
	}

	return mmSerializeNodePart
}

// Inspect accepts an inspector function that has same arguments as the Certificate.SerializeNodePart
func (mmSerializeNodePart *mCertificateMockSerializeNodePart) Inspect(f func()) *mCertificateMockSerializeNodePart {
	if mmSerializeNodePart.mock.inspectFuncSerializeNodePart != nil {
		mmSerializeNodePart.mock.t.Fatalf("Inspect function is already set for CertificateMock.SerializeNodePart")
	}

	mmSerializeNodePart.mock.inspectFuncSerializeNodePart = f

	return mmSerializeNodePart
}

// Return sets up results that will be returned by Certificate.SerializeNodePart
func (mmSerializeNodePart *mCertificateMockSerializeNodePart) Return(ba1 []byte) *CertificateMock {
	if mmSerializeNodePart.mock.funcSerializeNodePart != nil {
		mmSerializeNodePart.mock.t.Fatalf("CertificateMock.SerializeNodePart mock is already set by Set")
	}

	if mmSerializeNodePart.defaultExpectation == nil {
		mmSerializeNodePart.defaultExpectation = &CertificateMockSerializeNodePartExpectation{mock: mmSerializeNodePart.mock}
	}
	mmSerializeNodePart.defaultExpectation.results = &CertificateMockSerializeNodePartResults{ba1}
	return mmSerializeNodePart.mock
}

//Set uses given function f to mock the Certificate.SerializeNodePart method
func (mmSerializeNodePart *mCertificateMockSerializeNodePart) Set(f func() (ba1 []byte)) *CertificateMock {
	if mmSerializeNodePart.defaultExpectation != nil {
		mmSerializeNodePart.mock.t.Fatalf("Default expectation is already set for the Certificate.SerializeNodePart method")
	}

	if len(mmSerializeNodePart.expectations) > 0 {
		mmSerializeNodePart.mock.t.Fatalf("Some expectations are already set for the Certificate.SerializeNodePart method")
	}

	mmSerializeNodePart.mock.funcSerializeNodePart = f
	return mmSerializeNodePart.mock
}

// SerializeNodePart implements insolar.Certificate
func (mmSerializeNodePart *CertificateMock) SerializeNodePart() (ba1 []byte) {
	mm_atomic.AddUint64(&mmSerializeNodePart.beforeSerializeNodePartCounter, 1)
	defer mm_atomic.AddUint64(&mmSerializeNodePart.afterSerializeNodePartCounter, 1)

	if mmSerializeNodePart.inspectFuncSerializeNodePart != nil {
		mmSerializeNodePart.inspectFuncSerializeNodePart()
	}

	if mmSerializeNodePart.SerializeNodePartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSerializeNodePart.SerializeNodePartMock.defaultExpectation.Counter, 1)

		results := mmSerializeNodePart.SerializeNodePartMock.defaultExpectation.results
		if results == nil {
			mmSerializeNodePart.t.Fatal("No results are set for the CertificateMock.SerializeNodePart")
		}
		return (*results).ba1
	}
	if mmSerializeNodePart.funcSerializeNodePart != nil {
		return mmSerializeNodePart.funcSerializeNodePart()
	}
	mmSerializeNodePart.t.Fatalf("Unexpected call to CertificateMock.SerializeNodePart.")
	return
}

// SerializeNodePartAfterCounter returns a count of finished CertificateMock.SerializeNodePart invocations
func (mmSerializeNodePart *CertificateMock) SerializeNodePartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSerializeNodePart.afterSerializeNodePartCounter)
}

// SerializeNodePartBeforeCounter returns a count of CertificateMock.SerializeNodePart invocations
func (mmSerializeNodePart *CertificateMock) SerializeNodePartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSerializeNodePart.beforeSerializeNodePartCounter)
}

// MinimockSerializeNodePartDone returns true if the count of the SerializeNodePart invocations corresponds
// the number of defined expectations
func (m *CertificateMock) MinimockSerializeNodePartDone() bool {
	for _, e := range m.SerializeNodePartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SerializeNodePartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSerializeNodePartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSerializeNodePart != nil && mm_atomic.LoadUint64(&m.afterSerializeNodePartCounter) < 1 {
		return false
	}
	return true
}

// MinimockSerializeNodePartInspect logs each unmet expectation
func (m *CertificateMock) MinimockSerializeNodePartInspect() {
	for _, e := range m.SerializeNodePartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to CertificateMock.SerializeNodePart")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SerializeNodePartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSerializeNodePartCounter) < 1 {
		m.t.Error("Expected call to CertificateMock.SerializeNodePart")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSerializeNodePart != nil && mm_atomic.LoadUint64(&m.afterSerializeNodePartCounter) < 1 {
		m.t.Error("Expected call to CertificateMock.SerializeNodePart")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CertificateMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetDiscoveryNodesInspect()

		m.MinimockGetDiscoverySignsInspect()

		m.MinimockGetMajorityRuleInspect()

		m.MinimockGetMinRolesInspect()

		m.MinimockGetNodeRefInspect()

		m.MinimockGetPublicKeyInspect()

		m.MinimockGetRoleInspect()

		m.MinimockGetRootDomainReferenceInspect()

		m.MinimockSerializeNodePartInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CertificateMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CertificateMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetDiscoveryNodesDone() &&
		m.MinimockGetDiscoverySignsDone() &&
		m.MinimockGetMajorityRuleDone() &&
		m.MinimockGetMinRolesDone() &&
		m.MinimockGetNodeRefDone() &&
		m.MinimockGetPublicKeyDone() &&
		m.MinimockGetRoleDone() &&
		m.MinimockGetRootDomainReferenceDone() &&
		m.MinimockSerializeNodePartDone()
}
