package controller

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/insolar"
)

// RPCControllerMock implements RPCController
type RPCControllerMock struct {
	t minimock.Tester

	funcRemoteProcedureRegister          func(name string, method RemoteProcedure)
	inspectFuncRemoteProcedureRegister   func(name string, method RemoteProcedure)
	afterRemoteProcedureRegisterCounter  uint64
	beforeRemoteProcedureRegisterCounter uint64
	RemoteProcedureRegisterMock          mRPCControllerMockRemoteProcedureRegister

	funcSendBytes          func(ctx context.Context, nodeID insolar.Reference, name string, msgBytes []byte) (ba1 []byte, err error)
	inspectFuncSendBytes   func(ctx context.Context, nodeID insolar.Reference, name string, msgBytes []byte)
	afterSendBytesCounter  uint64
	beforeSendBytesCounter uint64
	SendBytesMock          mRPCControllerMockSendBytes
}

// NewRPCControllerMock returns a mock for RPCController
func NewRPCControllerMock(t minimock.Tester) *RPCControllerMock {
	m := &RPCControllerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.RemoteProcedureRegisterMock = mRPCControllerMockRemoteProcedureRegister{mock: m}
	m.RemoteProcedureRegisterMock.callArgs = []*RPCControllerMockRemoteProcedureRegisterParams{}

	m.SendBytesMock = mRPCControllerMockSendBytes{mock: m}
	m.SendBytesMock.callArgs = []*RPCControllerMockSendBytesParams{}

	return m
}

type mRPCControllerMockRemoteProcedureRegister struct {
	mock               *RPCControllerMock
	defaultExpectation *RPCControllerMockRemoteProcedureRegisterExpectation
	expectations       []*RPCControllerMockRemoteProcedureRegisterExpectation

	callArgs []*RPCControllerMockRemoteProcedureRegisterParams
	mutex    sync.RWMutex
}

// RPCControllerMockRemoteProcedureRegisterExpectation specifies expectation struct of the RPCController.RemoteProcedureRegister
type RPCControllerMockRemoteProcedureRegisterExpectation struct {
	mock   *RPCControllerMock
	params *RPCControllerMockRemoteProcedureRegisterParams

	Counter uint64
}

// RPCControllerMockRemoteProcedureRegisterParams contains parameters of the RPCController.RemoteProcedureRegister
type RPCControllerMockRemoteProcedureRegisterParams struct {
	name   string
	method RemoteProcedure
}

// Expect sets up expected params for RPCController.RemoteProcedureRegister
func (mmRemoteProcedureRegister *mRPCControllerMockRemoteProcedureRegister) Expect(name string, method RemoteProcedure) *mRPCControllerMockRemoteProcedureRegister {
	if mmRemoteProcedureRegister.mock.funcRemoteProcedureRegister != nil {
		mmRemoteProcedureRegister.mock.t.Fatalf("RPCControllerMock.RemoteProcedureRegister mock is already set by Set")
	}

	if mmRemoteProcedureRegister.defaultExpectation == nil {
		mmRemoteProcedureRegister.defaultExpectation = &RPCControllerMockRemoteProcedureRegisterExpectation{}
	}

	mmRemoteProcedureRegister.defaultExpectation.params = &RPCControllerMockRemoteProcedureRegisterParams{name, method}
	for _, e := range mmRemoteProcedureRegister.expectations {
		if minimock.Equal(e.params, mmRemoteProcedureRegister.defaultExpectation.params) {
			mmRemoteProcedureRegister.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoteProcedureRegister.defaultExpectation.params)
		}
	}

	return mmRemoteProcedureRegister
}

// Inspect accepts an inspector function that has same arguments as the RPCController.RemoteProcedureRegister
func (mmRemoteProcedureRegister *mRPCControllerMockRemoteProcedureRegister) Inspect(f func(name string, method RemoteProcedure)) *mRPCControllerMockRemoteProcedureRegister {
	if mmRemoteProcedureRegister.mock.inspectFuncRemoteProcedureRegister != nil {
		mmRemoteProcedureRegister.mock.t.Fatalf("Inspect function is already set for RPCControllerMock.RemoteProcedureRegister")
	}

	mmRemoteProcedureRegister.mock.inspectFuncRemoteProcedureRegister = f

	return mmRemoteProcedureRegister
}

// Return sets up results that will be returned by RPCController.RemoteProcedureRegister
func (mmRemoteProcedureRegister *mRPCControllerMockRemoteProcedureRegister) Return() *RPCControllerMock {
	if mmRemoteProcedureRegister.mock.funcRemoteProcedureRegister != nil {
		mmRemoteProcedureRegister.mock.t.Fatalf("RPCControllerMock.RemoteProcedureRegister mock is already set by Set")
	}

	if mmRemoteProcedureRegister.defaultExpectation == nil {
		mmRemoteProcedureRegister.defaultExpectation = &RPCControllerMockRemoteProcedureRegisterExpectation{mock: mmRemoteProcedureRegister.mock}
	}

	return mmRemoteProcedureRegister.mock
}

//Set uses given function f to mock the RPCController.RemoteProcedureRegister method
func (mmRemoteProcedureRegister *mRPCControllerMockRemoteProcedureRegister) Set(f func(name string, method RemoteProcedure)) *RPCControllerMock {
	if mmRemoteProcedureRegister.defaultExpectation != nil {
		mmRemoteProcedureRegister.mock.t.Fatalf("Default expectation is already set for the RPCController.RemoteProcedureRegister method")
	}

	if len(mmRemoteProcedureRegister.expectations) > 0 {
		mmRemoteProcedureRegister.mock.t.Fatalf("Some expectations are already set for the RPCController.RemoteProcedureRegister method")
	}

	mmRemoteProcedureRegister.mock.funcRemoteProcedureRegister = f
	return mmRemoteProcedureRegister.mock
}

// RemoteProcedureRegister implements RPCController
func (mmRemoteProcedureRegister *RPCControllerMock) RemoteProcedureRegister(name string, method RemoteProcedure) {
	mm_atomic.AddUint64(&mmRemoteProcedureRegister.beforeRemoteProcedureRegisterCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoteProcedureRegister.afterRemoteProcedureRegisterCounter, 1)

	if mmRemoteProcedureRegister.inspectFuncRemoteProcedureRegister != nil {
		mmRemoteProcedureRegister.inspectFuncRemoteProcedureRegister(name, method)
	}

	params := &RPCControllerMockRemoteProcedureRegisterParams{name, method}

	// Record call args
	mmRemoteProcedureRegister.RemoteProcedureRegisterMock.mutex.Lock()
	mmRemoteProcedureRegister.RemoteProcedureRegisterMock.callArgs = append(mmRemoteProcedureRegister.RemoteProcedureRegisterMock.callArgs, params)
	mmRemoteProcedureRegister.RemoteProcedureRegisterMock.mutex.Unlock()

	for _, e := range mmRemoteProcedureRegister.RemoteProcedureRegisterMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmRemoteProcedureRegister.RemoteProcedureRegisterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoteProcedureRegister.RemoteProcedureRegisterMock.defaultExpectation.Counter, 1)
		want := mmRemoteProcedureRegister.RemoteProcedureRegisterMock.defaultExpectation.params
		got := RPCControllerMockRemoteProcedureRegisterParams{name, method}
		if want != nil && !minimock.Equal(*want, got) {
			mmRemoteProcedureRegister.t.Errorf("RPCControllerMock.RemoteProcedureRegister got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmRemoteProcedureRegister.funcRemoteProcedureRegister != nil {
		mmRemoteProcedureRegister.funcRemoteProcedureRegister(name, method)
		return
	}
	mmRemoteProcedureRegister.t.Fatalf("Unexpected call to RPCControllerMock.RemoteProcedureRegister. %v %v", name, method)

}

// RemoteProcedureRegisterAfterCounter returns a count of finished RPCControllerMock.RemoteProcedureRegister invocations
func (mmRemoteProcedureRegister *RPCControllerMock) RemoteProcedureRegisterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoteProcedureRegister.afterRemoteProcedureRegisterCounter)
}

// RemoteProcedureRegisterBeforeCounter returns a count of RPCControllerMock.RemoteProcedureRegister invocations
func (mmRemoteProcedureRegister *RPCControllerMock) RemoteProcedureRegisterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoteProcedureRegister.beforeRemoteProcedureRegisterCounter)
}

// Calls returns a list of arguments used in each call to RPCControllerMock.RemoteProcedureRegister.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoteProcedureRegister *mRPCControllerMockRemoteProcedureRegister) Calls() []*RPCControllerMockRemoteProcedureRegisterParams {
	mmRemoteProcedureRegister.mutex.RLock()

	argCopy := make([]*RPCControllerMockRemoteProcedureRegisterParams, len(mmRemoteProcedureRegister.callArgs))
	copy(argCopy, mmRemoteProcedureRegister.callArgs)

	mmRemoteProcedureRegister.mutex.RUnlock()

	return argCopy
}

// MinimockRemoteProcedureRegisterDone returns true if the count of the RemoteProcedureRegister invocations corresponds
// the number of defined expectations
func (m *RPCControllerMock) MinimockRemoteProcedureRegisterDone() bool {
	for _, e := range m.RemoteProcedureRegisterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoteProcedureRegisterMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoteProcedureRegisterCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoteProcedureRegister != nil && mm_atomic.LoadUint64(&m.afterRemoteProcedureRegisterCounter) < 1 {
		return false
	}
	return true
}

// MinimockRemoteProcedureRegisterInspect logs each unmet expectation
func (m *RPCControllerMock) MinimockRemoteProcedureRegisterInspect() {
	for _, e := range m.RemoteProcedureRegisterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RPCControllerMock.RemoteProcedureRegister with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoteProcedureRegisterMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoteProcedureRegisterCounter) < 1 {
		if m.RemoteProcedureRegisterMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RPCControllerMock.RemoteProcedureRegister")
		} else {
			m.t.Errorf("Expected call to RPCControllerMock.RemoteProcedureRegister with params: %#v", *m.RemoteProcedureRegisterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoteProcedureRegister != nil && mm_atomic.LoadUint64(&m.afterRemoteProcedureRegisterCounter) < 1 {
		m.t.Error("Expected call to RPCControllerMock.RemoteProcedureRegister")
	}
}

type mRPCControllerMockSendBytes struct {
	mock               *RPCControllerMock
	defaultExpectation *RPCControllerMockSendBytesExpectation
	expectations       []*RPCControllerMockSendBytesExpectation

	callArgs []*RPCControllerMockSendBytesParams
	mutex    sync.RWMutex
}

// RPCControllerMockSendBytesExpectation specifies expectation struct of the RPCController.SendBytes
type RPCControllerMockSendBytesExpectation struct {
	mock    *RPCControllerMock
	params  *RPCControllerMockSendBytesParams
	results *RPCControllerMockSendBytesResults
	Counter uint64
}

// RPCControllerMockSendBytesParams contains parameters of the RPCController.SendBytes
type RPCControllerMockSendBytesParams struct {
	ctx      context.Context
	nodeID   insolar.Reference
	name     string
	msgBytes []byte
}

// RPCControllerMockSendBytesResults contains results of the RPCController.SendBytes
type RPCControllerMockSendBytesResults struct {
	ba1 []byte
	err error
}

// Expect sets up expected params for RPCController.SendBytes
func (mmSendBytes *mRPCControllerMockSendBytes) Expect(ctx context.Context, nodeID insolar.Reference, name string, msgBytes []byte) *mRPCControllerMockSendBytes {
	if mmSendBytes.mock.funcSendBytes != nil {
		mmSendBytes.mock.t.Fatalf("RPCControllerMock.SendBytes mock is already set by Set")
	}

	if mmSendBytes.defaultExpectation == nil {
		mmSendBytes.defaultExpectation = &RPCControllerMockSendBytesExpectation{}
	}

	mmSendBytes.defaultExpectation.params = &RPCControllerMockSendBytesParams{ctx, nodeID, name, msgBytes}
	for _, e := range mmSendBytes.expectations {
		if minimock.Equal(e.params, mmSendBytes.defaultExpectation.params) {
			mmSendBytes.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendBytes.defaultExpectation.params)
		}
	}

	return mmSendBytes
}

// Inspect accepts an inspector function that has same arguments as the RPCController.SendBytes
func (mmSendBytes *mRPCControllerMockSendBytes) Inspect(f func(ctx context.Context, nodeID insolar.Reference, name string, msgBytes []byte)) *mRPCControllerMockSendBytes {
	if mmSendBytes.mock.inspectFuncSendBytes != nil {
		mmSendBytes.mock.t.Fatalf("Inspect function is already set for RPCControllerMock.SendBytes")
	}

	mmSendBytes.mock.inspectFuncSendBytes = f

	return mmSendBytes
}

// Return sets up results that will be returned by RPCController.SendBytes
func (mmSendBytes *mRPCControllerMockSendBytes) Return(ba1 []byte, err error) *RPCControllerMock {
	if mmSendBytes.mock.funcSendBytes != nil {
		mmSendBytes.mock.t.Fatalf("RPCControllerMock.SendBytes mock is already set by Set")
	}

	if mmSendBytes.defaultExpectation == nil {
		mmSendBytes.defaultExpectation = &RPCControllerMockSendBytesExpectation{mock: mmSendBytes.mock}
	}
	mmSendBytes.defaultExpectation.results = &RPCControllerMockSendBytesResults{ba1, err}
	return mmSendBytes.mock
}

//Set uses given function f to mock the RPCController.SendBytes method
func (mmSendBytes *mRPCControllerMockSendBytes) Set(f func(ctx context.Context, nodeID insolar.Reference, name string, msgBytes []byte) (ba1 []byte, err error)) *RPCControllerMock {
	if mmSendBytes.defaultExpectation != nil {
		mmSendBytes.mock.t.Fatalf("Default expectation is already set for the RPCController.SendBytes method")
	}

	if len(mmSendBytes.expectations) > 0 {
		mmSendBytes.mock.t.Fatalf("Some expectations are already set for the RPCController.SendBytes method")
	}

	mmSendBytes.mock.funcSendBytes = f
	return mmSendBytes.mock
}

// When sets expectation for the RPCController.SendBytes which will trigger the result defined by the following
// Then helper
func (mmSendBytes *mRPCControllerMockSendBytes) When(ctx context.Context, nodeID insolar.Reference, name string, msgBytes []byte) *RPCControllerMockSendBytesExpectation {
	if mmSendBytes.mock.funcSendBytes != nil {
		mmSendBytes.mock.t.Fatalf("RPCControllerMock.SendBytes mock is already set by Set")
	}

	expectation := &RPCControllerMockSendBytesExpectation{
		mock:   mmSendBytes.mock,
		params: &RPCControllerMockSendBytesParams{ctx, nodeID, name, msgBytes},
	}
	mmSendBytes.expectations = append(mmSendBytes.expectations, expectation)
	return expectation
}

// Then sets up RPCController.SendBytes return parameters for the expectation previously defined by the When method
func (e *RPCControllerMockSendBytesExpectation) Then(ba1 []byte, err error) *RPCControllerMock {
	e.results = &RPCControllerMockSendBytesResults{ba1, err}
	return e.mock
}

// SendBytes implements RPCController
func (mmSendBytes *RPCControllerMock) SendBytes(ctx context.Context, nodeID insolar.Reference, name string, msgBytes []byte) (ba1 []byte, err error) {
	mm_atomic.AddUint64(&mmSendBytes.beforeSendBytesCounter, 1)
	defer mm_atomic.AddUint64(&mmSendBytes.afterSendBytesCounter, 1)

	if mmSendBytes.inspectFuncSendBytes != nil {
		mmSendBytes.inspectFuncSendBytes(ctx, nodeID, name, msgBytes)
	}

	params := &RPCControllerMockSendBytesParams{ctx, nodeID, name, msgBytes}

	// Record call args
	mmSendBytes.SendBytesMock.mutex.Lock()
	mmSendBytes.SendBytesMock.callArgs = append(mmSendBytes.SendBytesMock.callArgs, params)
	mmSendBytes.SendBytesMock.mutex.Unlock()

	for _, e := range mmSendBytes.SendBytesMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ba1, e.results.err
		}
	}

	if mmSendBytes.SendBytesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendBytes.SendBytesMock.defaultExpectation.Counter, 1)
		want := mmSendBytes.SendBytesMock.defaultExpectation.params
		got := RPCControllerMockSendBytesParams{ctx, nodeID, name, msgBytes}
		if want != nil && !minimock.Equal(*want, got) {
			mmSendBytes.t.Errorf("RPCControllerMock.SendBytes got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmSendBytes.SendBytesMock.defaultExpectation.results
		if results == nil {
			mmSendBytes.t.Fatal("No results are set for the RPCControllerMock.SendBytes")
		}
		return (*results).ba1, (*results).err
	}
	if mmSendBytes.funcSendBytes != nil {
		return mmSendBytes.funcSendBytes(ctx, nodeID, name, msgBytes)
	}
	mmSendBytes.t.Fatalf("Unexpected call to RPCControllerMock.SendBytes. %v %v %v %v", ctx, nodeID, name, msgBytes)
	return
}

// SendBytesAfterCounter returns a count of finished RPCControllerMock.SendBytes invocations
func (mmSendBytes *RPCControllerMock) SendBytesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendBytes.afterSendBytesCounter)
}

// SendBytesBeforeCounter returns a count of RPCControllerMock.SendBytes invocations
func (mmSendBytes *RPCControllerMock) SendBytesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendBytes.beforeSendBytesCounter)
}

// Calls returns a list of arguments used in each call to RPCControllerMock.SendBytes.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendBytes *mRPCControllerMockSendBytes) Calls() []*RPCControllerMockSendBytesParams {
	mmSendBytes.mutex.RLock()

	argCopy := make([]*RPCControllerMockSendBytesParams, len(mmSendBytes.callArgs))
	copy(argCopy, mmSendBytes.callArgs)

	mmSendBytes.mutex.RUnlock()

	return argCopy
}

// MinimockSendBytesDone returns true if the count of the SendBytes invocations corresponds
// the number of defined expectations
func (m *RPCControllerMock) MinimockSendBytesDone() bool {
	for _, e := range m.SendBytesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendBytesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendBytesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendBytes != nil && mm_atomic.LoadUint64(&m.afterSendBytesCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendBytesInspect logs each unmet expectation
func (m *RPCControllerMock) MinimockSendBytesInspect() {
	for _, e := range m.SendBytesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RPCControllerMock.SendBytes with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendBytesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendBytesCounter) < 1 {
		if m.SendBytesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RPCControllerMock.SendBytes")
		} else {
			m.t.Errorf("Expected call to RPCControllerMock.SendBytes with params: %#v", *m.SendBytesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendBytes != nil && mm_atomic.LoadUint64(&m.afterSendBytesCounter) < 1 {
		m.t.Error("Expected call to RPCControllerMock.SendBytes")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RPCControllerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockRemoteProcedureRegisterInspect()

		m.MinimockSendBytesInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RPCControllerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RPCControllerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockRemoteProcedureRegisterDone() &&
		m.MinimockSendBytesDone()
}
