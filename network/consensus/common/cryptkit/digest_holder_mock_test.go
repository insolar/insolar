package cryptkit

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/longbits"
)

// DigestHolderMock implements DigestHolder
type DigestHolderMock struct {
	t minimock.Tester

	funcAsByteString          func() (b1 longbits.ByteString)
	inspectFuncAsByteString   func()
	afterAsByteStringCounter  uint64
	beforeAsByteStringCounter uint64
	AsByteStringMock          mDigestHolderMockAsByteString

	funcAsBytes          func() (ba1 []byte)
	inspectFuncAsBytes   func()
	afterAsBytesCounter  uint64
	beforeAsBytesCounter uint64
	AsBytesMock          mDigestHolderMockAsBytes

	funcCopyOfDigest          func() (d1 Digest)
	inspectFuncCopyOfDigest   func()
	afterCopyOfDigestCounter  uint64
	beforeCopyOfDigestCounter uint64
	CopyOfDigestMock          mDigestHolderMockCopyOfDigest

	funcEquals          func(other DigestHolder) (b1 bool)
	inspectFuncEquals   func(other DigestHolder)
	afterEqualsCounter  uint64
	beforeEqualsCounter uint64
	EqualsMock          mDigestHolderMockEquals

	funcFixedByteSize          func() (i1 int)
	inspectFuncFixedByteSize   func()
	afterFixedByteSizeCounter  uint64
	beforeFixedByteSizeCounter uint64
	FixedByteSizeMock          mDigestHolderMockFixedByteSize

	funcFoldToUint64          func() (u1 uint64)
	inspectFuncFoldToUint64   func()
	afterFoldToUint64Counter  uint64
	beforeFoldToUint64Counter uint64
	FoldToUint64Mock          mDigestHolderMockFoldToUint64

	funcGetDigestMethod          func() (d1 DigestMethod)
	inspectFuncGetDigestMethod   func()
	afterGetDigestMethodCounter  uint64
	beforeGetDigestMethodCounter uint64
	GetDigestMethodMock          mDigestHolderMockGetDigestMethod

	funcRead          func(p []byte) (n int, err error)
	inspectFuncRead   func(p []byte)
	afterReadCounter  uint64
	beforeReadCounter uint64
	ReadMock          mDigestHolderMockRead

	funcSignWith          func(signer DigestSigner) (s1 SignedDigestHolder)
	inspectFuncSignWith   func(signer DigestSigner)
	afterSignWithCounter  uint64
	beforeSignWithCounter uint64
	SignWithMock          mDigestHolderMockSignWith

	funcWriteTo          func(w io.Writer) (n int64, err error)
	inspectFuncWriteTo   func(w io.Writer)
	afterWriteToCounter  uint64
	beforeWriteToCounter uint64
	WriteToMock          mDigestHolderMockWriteTo
}

// NewDigestHolderMock returns a mock for DigestHolder
func NewDigestHolderMock(t minimock.Tester) *DigestHolderMock {
	m := &DigestHolderMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AsByteStringMock = mDigestHolderMockAsByteString{mock: m}

	m.AsBytesMock = mDigestHolderMockAsBytes{mock: m}

	m.CopyOfDigestMock = mDigestHolderMockCopyOfDigest{mock: m}

	m.EqualsMock = mDigestHolderMockEquals{mock: m}
	m.EqualsMock.callArgs = []*DigestHolderMockEqualsParams{}

	m.FixedByteSizeMock = mDigestHolderMockFixedByteSize{mock: m}

	m.FoldToUint64Mock = mDigestHolderMockFoldToUint64{mock: m}

	m.GetDigestMethodMock = mDigestHolderMockGetDigestMethod{mock: m}

	m.ReadMock = mDigestHolderMockRead{mock: m}
	m.ReadMock.callArgs = []*DigestHolderMockReadParams{}

	m.SignWithMock = mDigestHolderMockSignWith{mock: m}
	m.SignWithMock.callArgs = []*DigestHolderMockSignWithParams{}

	m.WriteToMock = mDigestHolderMockWriteTo{mock: m}
	m.WriteToMock.callArgs = []*DigestHolderMockWriteToParams{}

	return m
}

type mDigestHolderMockAsByteString struct {
	mock               *DigestHolderMock
	defaultExpectation *DigestHolderMockAsByteStringExpectation
	expectations       []*DigestHolderMockAsByteStringExpectation
}

// DigestHolderMockAsByteStringExpectation specifies expectation struct of the DigestHolder.AsByteString
type DigestHolderMockAsByteStringExpectation struct {
	mock *DigestHolderMock

	results *DigestHolderMockAsByteStringResults
	Counter uint64
}

// DigestHolderMockAsByteStringResults contains results of the DigestHolder.AsByteString
type DigestHolderMockAsByteStringResults struct {
	b1 longbits.ByteString
}

// Expect sets up expected params for DigestHolder.AsByteString
func (mmAsByteString *mDigestHolderMockAsByteString) Expect() *mDigestHolderMockAsByteString {
	if mmAsByteString.mock.funcAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("DigestHolderMock.AsByteString mock is already set by Set")
	}

	if mmAsByteString.defaultExpectation == nil {
		mmAsByteString.defaultExpectation = &DigestHolderMockAsByteStringExpectation{}
	}

	return mmAsByteString
}

// Inspect accepts an inspector function that has same arguments as the DigestHolder.AsByteString
func (mmAsByteString *mDigestHolderMockAsByteString) Inspect(f func()) *mDigestHolderMockAsByteString {
	if mmAsByteString.mock.inspectFuncAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("Inspect function is already set for DigestHolderMock.AsByteString")
	}

	mmAsByteString.mock.inspectFuncAsByteString = f

	return mmAsByteString
}

// Return sets up results that will be returned by DigestHolder.AsByteString
func (mmAsByteString *mDigestHolderMockAsByteString) Return(b1 longbits.ByteString) *DigestHolderMock {
	if mmAsByteString.mock.funcAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("DigestHolderMock.AsByteString mock is already set by Set")
	}

	if mmAsByteString.defaultExpectation == nil {
		mmAsByteString.defaultExpectation = &DigestHolderMockAsByteStringExpectation{mock: mmAsByteString.mock}
	}
	mmAsByteString.defaultExpectation.results = &DigestHolderMockAsByteStringResults{b1}
	return mmAsByteString.mock
}

//Set uses given function f to mock the DigestHolder.AsByteString method
func (mmAsByteString *mDigestHolderMockAsByteString) Set(f func() (b1 longbits.ByteString)) *DigestHolderMock {
	if mmAsByteString.defaultExpectation != nil {
		mmAsByteString.mock.t.Fatalf("Default expectation is already set for the DigestHolder.AsByteString method")
	}

	if len(mmAsByteString.expectations) > 0 {
		mmAsByteString.mock.t.Fatalf("Some expectations are already set for the DigestHolder.AsByteString method")
	}

	mmAsByteString.mock.funcAsByteString = f
	return mmAsByteString.mock
}

// AsByteString implements DigestHolder
func (mmAsByteString *DigestHolderMock) AsByteString() (b1 longbits.ByteString) {
	mm_atomic.AddUint64(&mmAsByteString.beforeAsByteStringCounter, 1)
	defer mm_atomic.AddUint64(&mmAsByteString.afterAsByteStringCounter, 1)

	if mmAsByteString.inspectFuncAsByteString != nil {
		mmAsByteString.inspectFuncAsByteString()
	}

	if mmAsByteString.AsByteStringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAsByteString.AsByteStringMock.defaultExpectation.Counter, 1)

		results := mmAsByteString.AsByteStringMock.defaultExpectation.results
		if results == nil {
			mmAsByteString.t.Fatal("No results are set for the DigestHolderMock.AsByteString")
		}
		return (*results).b1
	}
	if mmAsByteString.funcAsByteString != nil {
		return mmAsByteString.funcAsByteString()
	}
	mmAsByteString.t.Fatalf("Unexpected call to DigestHolderMock.AsByteString.")
	return
}

// AsByteStringAfterCounter returns a count of finished DigestHolderMock.AsByteString invocations
func (mmAsByteString *DigestHolderMock) AsByteStringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsByteString.afterAsByteStringCounter)
}

// AsByteStringBeforeCounter returns a count of DigestHolderMock.AsByteString invocations
func (mmAsByteString *DigestHolderMock) AsByteStringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsByteString.beforeAsByteStringCounter)
}

// MinimockAsByteStringDone returns true if the count of the AsByteString invocations corresponds
// the number of defined expectations
func (m *DigestHolderMock) MinimockAsByteStringDone() bool {
	for _, e := range m.AsByteStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsByteStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsByteString != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		return false
	}
	return true
}

// MinimockAsByteStringInspect logs each unmet expectation
func (m *DigestHolderMock) MinimockAsByteStringInspect() {
	for _, e := range m.AsByteStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DigestHolderMock.AsByteString")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsByteStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		m.t.Error("Expected call to DigestHolderMock.AsByteString")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsByteString != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		m.t.Error("Expected call to DigestHolderMock.AsByteString")
	}
}

type mDigestHolderMockAsBytes struct {
	mock               *DigestHolderMock
	defaultExpectation *DigestHolderMockAsBytesExpectation
	expectations       []*DigestHolderMockAsBytesExpectation
}

// DigestHolderMockAsBytesExpectation specifies expectation struct of the DigestHolder.AsBytes
type DigestHolderMockAsBytesExpectation struct {
	mock *DigestHolderMock

	results *DigestHolderMockAsBytesResults
	Counter uint64
}

// DigestHolderMockAsBytesResults contains results of the DigestHolder.AsBytes
type DigestHolderMockAsBytesResults struct {
	ba1 []byte
}

// Expect sets up expected params for DigestHolder.AsBytes
func (mmAsBytes *mDigestHolderMockAsBytes) Expect() *mDigestHolderMockAsBytes {
	if mmAsBytes.mock.funcAsBytes != nil {
		mmAsBytes.mock.t.Fatalf("DigestHolderMock.AsBytes mock is already set by Set")
	}

	if mmAsBytes.defaultExpectation == nil {
		mmAsBytes.defaultExpectation = &DigestHolderMockAsBytesExpectation{}
	}

	return mmAsBytes
}

// Inspect accepts an inspector function that has same arguments as the DigestHolder.AsBytes
func (mmAsBytes *mDigestHolderMockAsBytes) Inspect(f func()) *mDigestHolderMockAsBytes {
	if mmAsBytes.mock.inspectFuncAsBytes != nil {
		mmAsBytes.mock.t.Fatalf("Inspect function is already set for DigestHolderMock.AsBytes")
	}

	mmAsBytes.mock.inspectFuncAsBytes = f

	return mmAsBytes
}

// Return sets up results that will be returned by DigestHolder.AsBytes
func (mmAsBytes *mDigestHolderMockAsBytes) Return(ba1 []byte) *DigestHolderMock {
	if mmAsBytes.mock.funcAsBytes != nil {
		mmAsBytes.mock.t.Fatalf("DigestHolderMock.AsBytes mock is already set by Set")
	}

	if mmAsBytes.defaultExpectation == nil {
		mmAsBytes.defaultExpectation = &DigestHolderMockAsBytesExpectation{mock: mmAsBytes.mock}
	}
	mmAsBytes.defaultExpectation.results = &DigestHolderMockAsBytesResults{ba1}
	return mmAsBytes.mock
}

//Set uses given function f to mock the DigestHolder.AsBytes method
func (mmAsBytes *mDigestHolderMockAsBytes) Set(f func() (ba1 []byte)) *DigestHolderMock {
	if mmAsBytes.defaultExpectation != nil {
		mmAsBytes.mock.t.Fatalf("Default expectation is already set for the DigestHolder.AsBytes method")
	}

	if len(mmAsBytes.expectations) > 0 {
		mmAsBytes.mock.t.Fatalf("Some expectations are already set for the DigestHolder.AsBytes method")
	}

	mmAsBytes.mock.funcAsBytes = f
	return mmAsBytes.mock
}

// AsBytes implements DigestHolder
func (mmAsBytes *DigestHolderMock) AsBytes() (ba1 []byte) {
	mm_atomic.AddUint64(&mmAsBytes.beforeAsBytesCounter, 1)
	defer mm_atomic.AddUint64(&mmAsBytes.afterAsBytesCounter, 1)

	if mmAsBytes.inspectFuncAsBytes != nil {
		mmAsBytes.inspectFuncAsBytes()
	}

	if mmAsBytes.AsBytesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAsBytes.AsBytesMock.defaultExpectation.Counter, 1)

		results := mmAsBytes.AsBytesMock.defaultExpectation.results
		if results == nil {
			mmAsBytes.t.Fatal("No results are set for the DigestHolderMock.AsBytes")
		}
		return (*results).ba1
	}
	if mmAsBytes.funcAsBytes != nil {
		return mmAsBytes.funcAsBytes()
	}
	mmAsBytes.t.Fatalf("Unexpected call to DigestHolderMock.AsBytes.")
	return
}

// AsBytesAfterCounter returns a count of finished DigestHolderMock.AsBytes invocations
func (mmAsBytes *DigestHolderMock) AsBytesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsBytes.afterAsBytesCounter)
}

// AsBytesBeforeCounter returns a count of DigestHolderMock.AsBytes invocations
func (mmAsBytes *DigestHolderMock) AsBytesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsBytes.beforeAsBytesCounter)
}

// MinimockAsBytesDone returns true if the count of the AsBytes invocations corresponds
// the number of defined expectations
func (m *DigestHolderMock) MinimockAsBytesDone() bool {
	for _, e := range m.AsBytesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsBytesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsBytesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsBytes != nil && mm_atomic.LoadUint64(&m.afterAsBytesCounter) < 1 {
		return false
	}
	return true
}

// MinimockAsBytesInspect logs each unmet expectation
func (m *DigestHolderMock) MinimockAsBytesInspect() {
	for _, e := range m.AsBytesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DigestHolderMock.AsBytes")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsBytesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsBytesCounter) < 1 {
		m.t.Error("Expected call to DigestHolderMock.AsBytes")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsBytes != nil && mm_atomic.LoadUint64(&m.afterAsBytesCounter) < 1 {
		m.t.Error("Expected call to DigestHolderMock.AsBytes")
	}
}

type mDigestHolderMockCopyOfDigest struct {
	mock               *DigestHolderMock
	defaultExpectation *DigestHolderMockCopyOfDigestExpectation
	expectations       []*DigestHolderMockCopyOfDigestExpectation
}

// DigestHolderMockCopyOfDigestExpectation specifies expectation struct of the DigestHolder.CopyOfDigest
type DigestHolderMockCopyOfDigestExpectation struct {
	mock *DigestHolderMock

	results *DigestHolderMockCopyOfDigestResults
	Counter uint64
}

// DigestHolderMockCopyOfDigestResults contains results of the DigestHolder.CopyOfDigest
type DigestHolderMockCopyOfDigestResults struct {
	d1 Digest
}

// Expect sets up expected params for DigestHolder.CopyOfDigest
func (mmCopyOfDigest *mDigestHolderMockCopyOfDigest) Expect() *mDigestHolderMockCopyOfDigest {
	if mmCopyOfDigest.mock.funcCopyOfDigest != nil {
		mmCopyOfDigest.mock.t.Fatalf("DigestHolderMock.CopyOfDigest mock is already set by Set")
	}

	if mmCopyOfDigest.defaultExpectation == nil {
		mmCopyOfDigest.defaultExpectation = &DigestHolderMockCopyOfDigestExpectation{}
	}

	return mmCopyOfDigest
}

// Inspect accepts an inspector function that has same arguments as the DigestHolder.CopyOfDigest
func (mmCopyOfDigest *mDigestHolderMockCopyOfDigest) Inspect(f func()) *mDigestHolderMockCopyOfDigest {
	if mmCopyOfDigest.mock.inspectFuncCopyOfDigest != nil {
		mmCopyOfDigest.mock.t.Fatalf("Inspect function is already set for DigestHolderMock.CopyOfDigest")
	}

	mmCopyOfDigest.mock.inspectFuncCopyOfDigest = f

	return mmCopyOfDigest
}

// Return sets up results that will be returned by DigestHolder.CopyOfDigest
func (mmCopyOfDigest *mDigestHolderMockCopyOfDigest) Return(d1 Digest) *DigestHolderMock {
	if mmCopyOfDigest.mock.funcCopyOfDigest != nil {
		mmCopyOfDigest.mock.t.Fatalf("DigestHolderMock.CopyOfDigest mock is already set by Set")
	}

	if mmCopyOfDigest.defaultExpectation == nil {
		mmCopyOfDigest.defaultExpectation = &DigestHolderMockCopyOfDigestExpectation{mock: mmCopyOfDigest.mock}
	}
	mmCopyOfDigest.defaultExpectation.results = &DigestHolderMockCopyOfDigestResults{d1}
	return mmCopyOfDigest.mock
}

//Set uses given function f to mock the DigestHolder.CopyOfDigest method
func (mmCopyOfDigest *mDigestHolderMockCopyOfDigest) Set(f func() (d1 Digest)) *DigestHolderMock {
	if mmCopyOfDigest.defaultExpectation != nil {
		mmCopyOfDigest.mock.t.Fatalf("Default expectation is already set for the DigestHolder.CopyOfDigest method")
	}

	if len(mmCopyOfDigest.expectations) > 0 {
		mmCopyOfDigest.mock.t.Fatalf("Some expectations are already set for the DigestHolder.CopyOfDigest method")
	}

	mmCopyOfDigest.mock.funcCopyOfDigest = f
	return mmCopyOfDigest.mock
}

// CopyOfDigest implements DigestHolder
func (mmCopyOfDigest *DigestHolderMock) CopyOfDigest() (d1 Digest) {
	mm_atomic.AddUint64(&mmCopyOfDigest.beforeCopyOfDigestCounter, 1)
	defer mm_atomic.AddUint64(&mmCopyOfDigest.afterCopyOfDigestCounter, 1)

	if mmCopyOfDigest.inspectFuncCopyOfDigest != nil {
		mmCopyOfDigest.inspectFuncCopyOfDigest()
	}

	if mmCopyOfDigest.CopyOfDigestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCopyOfDigest.CopyOfDigestMock.defaultExpectation.Counter, 1)

		results := mmCopyOfDigest.CopyOfDigestMock.defaultExpectation.results
		if results == nil {
			mmCopyOfDigest.t.Fatal("No results are set for the DigestHolderMock.CopyOfDigest")
		}
		return (*results).d1
	}
	if mmCopyOfDigest.funcCopyOfDigest != nil {
		return mmCopyOfDigest.funcCopyOfDigest()
	}
	mmCopyOfDigest.t.Fatalf("Unexpected call to DigestHolderMock.CopyOfDigest.")
	return
}

// CopyOfDigestAfterCounter returns a count of finished DigestHolderMock.CopyOfDigest invocations
func (mmCopyOfDigest *DigestHolderMock) CopyOfDigestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyOfDigest.afterCopyOfDigestCounter)
}

// CopyOfDigestBeforeCounter returns a count of DigestHolderMock.CopyOfDigest invocations
func (mmCopyOfDigest *DigestHolderMock) CopyOfDigestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyOfDigest.beforeCopyOfDigestCounter)
}

// MinimockCopyOfDigestDone returns true if the count of the CopyOfDigest invocations corresponds
// the number of defined expectations
func (m *DigestHolderMock) MinimockCopyOfDigestDone() bool {
	for _, e := range m.CopyOfDigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyOfDigestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyOfDigestCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyOfDigest != nil && mm_atomic.LoadUint64(&m.afterCopyOfDigestCounter) < 1 {
		return false
	}
	return true
}

// MinimockCopyOfDigestInspect logs each unmet expectation
func (m *DigestHolderMock) MinimockCopyOfDigestInspect() {
	for _, e := range m.CopyOfDigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DigestHolderMock.CopyOfDigest")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyOfDigestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyOfDigestCounter) < 1 {
		m.t.Error("Expected call to DigestHolderMock.CopyOfDigest")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyOfDigest != nil && mm_atomic.LoadUint64(&m.afterCopyOfDigestCounter) < 1 {
		m.t.Error("Expected call to DigestHolderMock.CopyOfDigest")
	}
}

type mDigestHolderMockEquals struct {
	mock               *DigestHolderMock
	defaultExpectation *DigestHolderMockEqualsExpectation
	expectations       []*DigestHolderMockEqualsExpectation

	callArgs []*DigestHolderMockEqualsParams
	mutex    sync.RWMutex
}

// DigestHolderMockEqualsExpectation specifies expectation struct of the DigestHolder.Equals
type DigestHolderMockEqualsExpectation struct {
	mock    *DigestHolderMock
	params  *DigestHolderMockEqualsParams
	results *DigestHolderMockEqualsResults
	Counter uint64
}

// DigestHolderMockEqualsParams contains parameters of the DigestHolder.Equals
type DigestHolderMockEqualsParams struct {
	other DigestHolder
}

// DigestHolderMockEqualsResults contains results of the DigestHolder.Equals
type DigestHolderMockEqualsResults struct {
	b1 bool
}

// Expect sets up expected params for DigestHolder.Equals
func (mmEquals *mDigestHolderMockEquals) Expect(other DigestHolder) *mDigestHolderMockEquals {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("DigestHolderMock.Equals mock is already set by Set")
	}

	if mmEquals.defaultExpectation == nil {
		mmEquals.defaultExpectation = &DigestHolderMockEqualsExpectation{}
	}

	mmEquals.defaultExpectation.params = &DigestHolderMockEqualsParams{other}
	for _, e := range mmEquals.expectations {
		if minimock.Equal(e.params, mmEquals.defaultExpectation.params) {
			mmEquals.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEquals.defaultExpectation.params)
		}
	}

	return mmEquals
}

// Inspect accepts an inspector function that has same arguments as the DigestHolder.Equals
func (mmEquals *mDigestHolderMockEquals) Inspect(f func(other DigestHolder)) *mDigestHolderMockEquals {
	if mmEquals.mock.inspectFuncEquals != nil {
		mmEquals.mock.t.Fatalf("Inspect function is already set for DigestHolderMock.Equals")
	}

	mmEquals.mock.inspectFuncEquals = f

	return mmEquals
}

// Return sets up results that will be returned by DigestHolder.Equals
func (mmEquals *mDigestHolderMockEquals) Return(b1 bool) *DigestHolderMock {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("DigestHolderMock.Equals mock is already set by Set")
	}

	if mmEquals.defaultExpectation == nil {
		mmEquals.defaultExpectation = &DigestHolderMockEqualsExpectation{mock: mmEquals.mock}
	}
	mmEquals.defaultExpectation.results = &DigestHolderMockEqualsResults{b1}
	return mmEquals.mock
}

//Set uses given function f to mock the DigestHolder.Equals method
func (mmEquals *mDigestHolderMockEquals) Set(f func(other DigestHolder) (b1 bool)) *DigestHolderMock {
	if mmEquals.defaultExpectation != nil {
		mmEquals.mock.t.Fatalf("Default expectation is already set for the DigestHolder.Equals method")
	}

	if len(mmEquals.expectations) > 0 {
		mmEquals.mock.t.Fatalf("Some expectations are already set for the DigestHolder.Equals method")
	}

	mmEquals.mock.funcEquals = f
	return mmEquals.mock
}

// When sets expectation for the DigestHolder.Equals which will trigger the result defined by the following
// Then helper
func (mmEquals *mDigestHolderMockEquals) When(other DigestHolder) *DigestHolderMockEqualsExpectation {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("DigestHolderMock.Equals mock is already set by Set")
	}

	expectation := &DigestHolderMockEqualsExpectation{
		mock:   mmEquals.mock,
		params: &DigestHolderMockEqualsParams{other},
	}
	mmEquals.expectations = append(mmEquals.expectations, expectation)
	return expectation
}

// Then sets up DigestHolder.Equals return parameters for the expectation previously defined by the When method
func (e *DigestHolderMockEqualsExpectation) Then(b1 bool) *DigestHolderMock {
	e.results = &DigestHolderMockEqualsResults{b1}
	return e.mock
}

// Equals implements DigestHolder
func (mmEquals *DigestHolderMock) Equals(other DigestHolder) (b1 bool) {
	mm_atomic.AddUint64(&mmEquals.beforeEqualsCounter, 1)
	defer mm_atomic.AddUint64(&mmEquals.afterEqualsCounter, 1)

	if mmEquals.inspectFuncEquals != nil {
		mmEquals.inspectFuncEquals(other)
	}

	params := &DigestHolderMockEqualsParams{other}

	// Record call args
	mmEquals.EqualsMock.mutex.Lock()
	mmEquals.EqualsMock.callArgs = append(mmEquals.EqualsMock.callArgs, params)
	mmEquals.EqualsMock.mutex.Unlock()

	for _, e := range mmEquals.EqualsMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmEquals.EqualsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEquals.EqualsMock.defaultExpectation.Counter, 1)
		want := mmEquals.EqualsMock.defaultExpectation.params
		got := DigestHolderMockEqualsParams{other}
		if want != nil && !minimock.Equal(*want, got) {
			mmEquals.t.Errorf("DigestHolderMock.Equals got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmEquals.EqualsMock.defaultExpectation.results
		if results == nil {
			mmEquals.t.Fatal("No results are set for the DigestHolderMock.Equals")
		}
		return (*results).b1
	}
	if mmEquals.funcEquals != nil {
		return mmEquals.funcEquals(other)
	}
	mmEquals.t.Fatalf("Unexpected call to DigestHolderMock.Equals. %v", other)
	return
}

// EqualsAfterCounter returns a count of finished DigestHolderMock.Equals invocations
func (mmEquals *DigestHolderMock) EqualsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEquals.afterEqualsCounter)
}

// EqualsBeforeCounter returns a count of DigestHolderMock.Equals invocations
func (mmEquals *DigestHolderMock) EqualsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEquals.beforeEqualsCounter)
}

// Calls returns a list of arguments used in each call to DigestHolderMock.Equals.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEquals *mDigestHolderMockEquals) Calls() []*DigestHolderMockEqualsParams {
	mmEquals.mutex.RLock()

	argCopy := make([]*DigestHolderMockEqualsParams, len(mmEquals.callArgs))
	copy(argCopy, mmEquals.callArgs)

	mmEquals.mutex.RUnlock()

	return argCopy
}

// MinimockEqualsDone returns true if the count of the Equals invocations corresponds
// the number of defined expectations
func (m *DigestHolderMock) MinimockEqualsDone() bool {
	for _, e := range m.EqualsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EqualsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEquals != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		return false
	}
	return true
}

// MinimockEqualsInspect logs each unmet expectation
func (m *DigestHolderMock) MinimockEqualsInspect() {
	for _, e := range m.EqualsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DigestHolderMock.Equals with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EqualsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		if m.EqualsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DigestHolderMock.Equals")
		} else {
			m.t.Errorf("Expected call to DigestHolderMock.Equals with params: %#v", *m.EqualsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEquals != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		m.t.Error("Expected call to DigestHolderMock.Equals")
	}
}

type mDigestHolderMockFixedByteSize struct {
	mock               *DigestHolderMock
	defaultExpectation *DigestHolderMockFixedByteSizeExpectation
	expectations       []*DigestHolderMockFixedByteSizeExpectation
}

// DigestHolderMockFixedByteSizeExpectation specifies expectation struct of the DigestHolder.FixedByteSize
type DigestHolderMockFixedByteSizeExpectation struct {
	mock *DigestHolderMock

	results *DigestHolderMockFixedByteSizeResults
	Counter uint64
}

// DigestHolderMockFixedByteSizeResults contains results of the DigestHolder.FixedByteSize
type DigestHolderMockFixedByteSizeResults struct {
	i1 int
}

// Expect sets up expected params for DigestHolder.FixedByteSize
func (mmFixedByteSize *mDigestHolderMockFixedByteSize) Expect() *mDigestHolderMockFixedByteSize {
	if mmFixedByteSize.mock.funcFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("DigestHolderMock.FixedByteSize mock is already set by Set")
	}

	if mmFixedByteSize.defaultExpectation == nil {
		mmFixedByteSize.defaultExpectation = &DigestHolderMockFixedByteSizeExpectation{}
	}

	return mmFixedByteSize
}

// Inspect accepts an inspector function that has same arguments as the DigestHolder.FixedByteSize
func (mmFixedByteSize *mDigestHolderMockFixedByteSize) Inspect(f func()) *mDigestHolderMockFixedByteSize {
	if mmFixedByteSize.mock.inspectFuncFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("Inspect function is already set for DigestHolderMock.FixedByteSize")
	}

	mmFixedByteSize.mock.inspectFuncFixedByteSize = f

	return mmFixedByteSize
}

// Return sets up results that will be returned by DigestHolder.FixedByteSize
func (mmFixedByteSize *mDigestHolderMockFixedByteSize) Return(i1 int) *DigestHolderMock {
	if mmFixedByteSize.mock.funcFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("DigestHolderMock.FixedByteSize mock is already set by Set")
	}

	if mmFixedByteSize.defaultExpectation == nil {
		mmFixedByteSize.defaultExpectation = &DigestHolderMockFixedByteSizeExpectation{mock: mmFixedByteSize.mock}
	}
	mmFixedByteSize.defaultExpectation.results = &DigestHolderMockFixedByteSizeResults{i1}
	return mmFixedByteSize.mock
}

//Set uses given function f to mock the DigestHolder.FixedByteSize method
func (mmFixedByteSize *mDigestHolderMockFixedByteSize) Set(f func() (i1 int)) *DigestHolderMock {
	if mmFixedByteSize.defaultExpectation != nil {
		mmFixedByteSize.mock.t.Fatalf("Default expectation is already set for the DigestHolder.FixedByteSize method")
	}

	if len(mmFixedByteSize.expectations) > 0 {
		mmFixedByteSize.mock.t.Fatalf("Some expectations are already set for the DigestHolder.FixedByteSize method")
	}

	mmFixedByteSize.mock.funcFixedByteSize = f
	return mmFixedByteSize.mock
}

// FixedByteSize implements DigestHolder
func (mmFixedByteSize *DigestHolderMock) FixedByteSize() (i1 int) {
	mm_atomic.AddUint64(&mmFixedByteSize.beforeFixedByteSizeCounter, 1)
	defer mm_atomic.AddUint64(&mmFixedByteSize.afterFixedByteSizeCounter, 1)

	if mmFixedByteSize.inspectFuncFixedByteSize != nil {
		mmFixedByteSize.inspectFuncFixedByteSize()
	}

	if mmFixedByteSize.FixedByteSizeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFixedByteSize.FixedByteSizeMock.defaultExpectation.Counter, 1)

		results := mmFixedByteSize.FixedByteSizeMock.defaultExpectation.results
		if results == nil {
			mmFixedByteSize.t.Fatal("No results are set for the DigestHolderMock.FixedByteSize")
		}
		return (*results).i1
	}
	if mmFixedByteSize.funcFixedByteSize != nil {
		return mmFixedByteSize.funcFixedByteSize()
	}
	mmFixedByteSize.t.Fatalf("Unexpected call to DigestHolderMock.FixedByteSize.")
	return
}

// FixedByteSizeAfterCounter returns a count of finished DigestHolderMock.FixedByteSize invocations
func (mmFixedByteSize *DigestHolderMock) FixedByteSizeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFixedByteSize.afterFixedByteSizeCounter)
}

// FixedByteSizeBeforeCounter returns a count of DigestHolderMock.FixedByteSize invocations
func (mmFixedByteSize *DigestHolderMock) FixedByteSizeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFixedByteSize.beforeFixedByteSizeCounter)
}

// MinimockFixedByteSizeDone returns true if the count of the FixedByteSize invocations corresponds
// the number of defined expectations
func (m *DigestHolderMock) MinimockFixedByteSizeDone() bool {
	for _, e := range m.FixedByteSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FixedByteSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFixedByteSize != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		return false
	}
	return true
}

// MinimockFixedByteSizeInspect logs each unmet expectation
func (m *DigestHolderMock) MinimockFixedByteSizeInspect() {
	for _, e := range m.FixedByteSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DigestHolderMock.FixedByteSize")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FixedByteSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		m.t.Error("Expected call to DigestHolderMock.FixedByteSize")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFixedByteSize != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		m.t.Error("Expected call to DigestHolderMock.FixedByteSize")
	}
}

type mDigestHolderMockFoldToUint64 struct {
	mock               *DigestHolderMock
	defaultExpectation *DigestHolderMockFoldToUint64Expectation
	expectations       []*DigestHolderMockFoldToUint64Expectation
}

// DigestHolderMockFoldToUint64Expectation specifies expectation struct of the DigestHolder.FoldToUint64
type DigestHolderMockFoldToUint64Expectation struct {
	mock *DigestHolderMock

	results *DigestHolderMockFoldToUint64Results
	Counter uint64
}

// DigestHolderMockFoldToUint64Results contains results of the DigestHolder.FoldToUint64
type DigestHolderMockFoldToUint64Results struct {
	u1 uint64
}

// Expect sets up expected params for DigestHolder.FoldToUint64
func (mmFoldToUint64 *mDigestHolderMockFoldToUint64) Expect() *mDigestHolderMockFoldToUint64 {
	if mmFoldToUint64.mock.funcFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("DigestHolderMock.FoldToUint64 mock is already set by Set")
	}

	if mmFoldToUint64.defaultExpectation == nil {
		mmFoldToUint64.defaultExpectation = &DigestHolderMockFoldToUint64Expectation{}
	}

	return mmFoldToUint64
}

// Inspect accepts an inspector function that has same arguments as the DigestHolder.FoldToUint64
func (mmFoldToUint64 *mDigestHolderMockFoldToUint64) Inspect(f func()) *mDigestHolderMockFoldToUint64 {
	if mmFoldToUint64.mock.inspectFuncFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("Inspect function is already set for DigestHolderMock.FoldToUint64")
	}

	mmFoldToUint64.mock.inspectFuncFoldToUint64 = f

	return mmFoldToUint64
}

// Return sets up results that will be returned by DigestHolder.FoldToUint64
func (mmFoldToUint64 *mDigestHolderMockFoldToUint64) Return(u1 uint64) *DigestHolderMock {
	if mmFoldToUint64.mock.funcFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("DigestHolderMock.FoldToUint64 mock is already set by Set")
	}

	if mmFoldToUint64.defaultExpectation == nil {
		mmFoldToUint64.defaultExpectation = &DigestHolderMockFoldToUint64Expectation{mock: mmFoldToUint64.mock}
	}
	mmFoldToUint64.defaultExpectation.results = &DigestHolderMockFoldToUint64Results{u1}
	return mmFoldToUint64.mock
}

//Set uses given function f to mock the DigestHolder.FoldToUint64 method
func (mmFoldToUint64 *mDigestHolderMockFoldToUint64) Set(f func() (u1 uint64)) *DigestHolderMock {
	if mmFoldToUint64.defaultExpectation != nil {
		mmFoldToUint64.mock.t.Fatalf("Default expectation is already set for the DigestHolder.FoldToUint64 method")
	}

	if len(mmFoldToUint64.expectations) > 0 {
		mmFoldToUint64.mock.t.Fatalf("Some expectations are already set for the DigestHolder.FoldToUint64 method")
	}

	mmFoldToUint64.mock.funcFoldToUint64 = f
	return mmFoldToUint64.mock
}

// FoldToUint64 implements DigestHolder
func (mmFoldToUint64 *DigestHolderMock) FoldToUint64() (u1 uint64) {
	mm_atomic.AddUint64(&mmFoldToUint64.beforeFoldToUint64Counter, 1)
	defer mm_atomic.AddUint64(&mmFoldToUint64.afterFoldToUint64Counter, 1)

	if mmFoldToUint64.inspectFuncFoldToUint64 != nil {
		mmFoldToUint64.inspectFuncFoldToUint64()
	}

	if mmFoldToUint64.FoldToUint64Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFoldToUint64.FoldToUint64Mock.defaultExpectation.Counter, 1)

		results := mmFoldToUint64.FoldToUint64Mock.defaultExpectation.results
		if results == nil {
			mmFoldToUint64.t.Fatal("No results are set for the DigestHolderMock.FoldToUint64")
		}
		return (*results).u1
	}
	if mmFoldToUint64.funcFoldToUint64 != nil {
		return mmFoldToUint64.funcFoldToUint64()
	}
	mmFoldToUint64.t.Fatalf("Unexpected call to DigestHolderMock.FoldToUint64.")
	return
}

// FoldToUint64AfterCounter returns a count of finished DigestHolderMock.FoldToUint64 invocations
func (mmFoldToUint64 *DigestHolderMock) FoldToUint64AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFoldToUint64.afterFoldToUint64Counter)
}

// FoldToUint64BeforeCounter returns a count of DigestHolderMock.FoldToUint64 invocations
func (mmFoldToUint64 *DigestHolderMock) FoldToUint64BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFoldToUint64.beforeFoldToUint64Counter)
}

// MinimockFoldToUint64Done returns true if the count of the FoldToUint64 invocations corresponds
// the number of defined expectations
func (m *DigestHolderMock) MinimockFoldToUint64Done() bool {
	for _, e := range m.FoldToUint64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FoldToUint64Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFoldToUint64 != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		return false
	}
	return true
}

// MinimockFoldToUint64Inspect logs each unmet expectation
func (m *DigestHolderMock) MinimockFoldToUint64Inspect() {
	for _, e := range m.FoldToUint64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DigestHolderMock.FoldToUint64")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FoldToUint64Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		m.t.Error("Expected call to DigestHolderMock.FoldToUint64")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFoldToUint64 != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		m.t.Error("Expected call to DigestHolderMock.FoldToUint64")
	}
}

type mDigestHolderMockGetDigestMethod struct {
	mock               *DigestHolderMock
	defaultExpectation *DigestHolderMockGetDigestMethodExpectation
	expectations       []*DigestHolderMockGetDigestMethodExpectation
}

// DigestHolderMockGetDigestMethodExpectation specifies expectation struct of the DigestHolder.GetDigestMethod
type DigestHolderMockGetDigestMethodExpectation struct {
	mock *DigestHolderMock

	results *DigestHolderMockGetDigestMethodResults
	Counter uint64
}

// DigestHolderMockGetDigestMethodResults contains results of the DigestHolder.GetDigestMethod
type DigestHolderMockGetDigestMethodResults struct {
	d1 DigestMethod
}

// Expect sets up expected params for DigestHolder.GetDigestMethod
func (mmGetDigestMethod *mDigestHolderMockGetDigestMethod) Expect() *mDigestHolderMockGetDigestMethod {
	if mmGetDigestMethod.mock.funcGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("DigestHolderMock.GetDigestMethod mock is already set by Set")
	}

	if mmGetDigestMethod.defaultExpectation == nil {
		mmGetDigestMethod.defaultExpectation = &DigestHolderMockGetDigestMethodExpectation{}
	}

	return mmGetDigestMethod
}

// Inspect accepts an inspector function that has same arguments as the DigestHolder.GetDigestMethod
func (mmGetDigestMethod *mDigestHolderMockGetDigestMethod) Inspect(f func()) *mDigestHolderMockGetDigestMethod {
	if mmGetDigestMethod.mock.inspectFuncGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("Inspect function is already set for DigestHolderMock.GetDigestMethod")
	}

	mmGetDigestMethod.mock.inspectFuncGetDigestMethod = f

	return mmGetDigestMethod
}

// Return sets up results that will be returned by DigestHolder.GetDigestMethod
func (mmGetDigestMethod *mDigestHolderMockGetDigestMethod) Return(d1 DigestMethod) *DigestHolderMock {
	if mmGetDigestMethod.mock.funcGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("DigestHolderMock.GetDigestMethod mock is already set by Set")
	}

	if mmGetDigestMethod.defaultExpectation == nil {
		mmGetDigestMethod.defaultExpectation = &DigestHolderMockGetDigestMethodExpectation{mock: mmGetDigestMethod.mock}
	}
	mmGetDigestMethod.defaultExpectation.results = &DigestHolderMockGetDigestMethodResults{d1}
	return mmGetDigestMethod.mock
}

//Set uses given function f to mock the DigestHolder.GetDigestMethod method
func (mmGetDigestMethod *mDigestHolderMockGetDigestMethod) Set(f func() (d1 DigestMethod)) *DigestHolderMock {
	if mmGetDigestMethod.defaultExpectation != nil {
		mmGetDigestMethod.mock.t.Fatalf("Default expectation is already set for the DigestHolder.GetDigestMethod method")
	}

	if len(mmGetDigestMethod.expectations) > 0 {
		mmGetDigestMethod.mock.t.Fatalf("Some expectations are already set for the DigestHolder.GetDigestMethod method")
	}

	mmGetDigestMethod.mock.funcGetDigestMethod = f
	return mmGetDigestMethod.mock
}

// GetDigestMethod implements DigestHolder
func (mmGetDigestMethod *DigestHolderMock) GetDigestMethod() (d1 DigestMethod) {
	mm_atomic.AddUint64(&mmGetDigestMethod.beforeGetDigestMethodCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDigestMethod.afterGetDigestMethodCounter, 1)

	if mmGetDigestMethod.inspectFuncGetDigestMethod != nil {
		mmGetDigestMethod.inspectFuncGetDigestMethod()
	}

	if mmGetDigestMethod.GetDigestMethodMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDigestMethod.GetDigestMethodMock.defaultExpectation.Counter, 1)

		results := mmGetDigestMethod.GetDigestMethodMock.defaultExpectation.results
		if results == nil {
			mmGetDigestMethod.t.Fatal("No results are set for the DigestHolderMock.GetDigestMethod")
		}
		return (*results).d1
	}
	if mmGetDigestMethod.funcGetDigestMethod != nil {
		return mmGetDigestMethod.funcGetDigestMethod()
	}
	mmGetDigestMethod.t.Fatalf("Unexpected call to DigestHolderMock.GetDigestMethod.")
	return
}

// GetDigestMethodAfterCounter returns a count of finished DigestHolderMock.GetDigestMethod invocations
func (mmGetDigestMethod *DigestHolderMock) GetDigestMethodAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestMethod.afterGetDigestMethodCounter)
}

// GetDigestMethodBeforeCounter returns a count of DigestHolderMock.GetDigestMethod invocations
func (mmGetDigestMethod *DigestHolderMock) GetDigestMethodBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestMethod.beforeGetDigestMethodCounter)
}

// MinimockGetDigestMethodDone returns true if the count of the GetDigestMethod invocations corresponds
// the number of defined expectations
func (m *DigestHolderMock) MinimockGetDigestMethodDone() bool {
	for _, e := range m.GetDigestMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestMethod != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetDigestMethodInspect logs each unmet expectation
func (m *DigestHolderMock) MinimockGetDigestMethodInspect() {
	for _, e := range m.GetDigestMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DigestHolderMock.GetDigestMethod")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		m.t.Error("Expected call to DigestHolderMock.GetDigestMethod")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestMethod != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		m.t.Error("Expected call to DigestHolderMock.GetDigestMethod")
	}
}

type mDigestHolderMockRead struct {
	mock               *DigestHolderMock
	defaultExpectation *DigestHolderMockReadExpectation
	expectations       []*DigestHolderMockReadExpectation

	callArgs []*DigestHolderMockReadParams
	mutex    sync.RWMutex
}

// DigestHolderMockReadExpectation specifies expectation struct of the DigestHolder.Read
type DigestHolderMockReadExpectation struct {
	mock    *DigestHolderMock
	params  *DigestHolderMockReadParams
	results *DigestHolderMockReadResults
	Counter uint64
}

// DigestHolderMockReadParams contains parameters of the DigestHolder.Read
type DigestHolderMockReadParams struct {
	p []byte
}

// DigestHolderMockReadResults contains results of the DigestHolder.Read
type DigestHolderMockReadResults struct {
	n   int
	err error
}

// Expect sets up expected params for DigestHolder.Read
func (mmRead *mDigestHolderMockRead) Expect(p []byte) *mDigestHolderMockRead {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("DigestHolderMock.Read mock is already set by Set")
	}

	if mmRead.defaultExpectation == nil {
		mmRead.defaultExpectation = &DigestHolderMockReadExpectation{}
	}

	mmRead.defaultExpectation.params = &DigestHolderMockReadParams{p}
	for _, e := range mmRead.expectations {
		if minimock.Equal(e.params, mmRead.defaultExpectation.params) {
			mmRead.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRead.defaultExpectation.params)
		}
	}

	return mmRead
}

// Inspect accepts an inspector function that has same arguments as the DigestHolder.Read
func (mmRead *mDigestHolderMockRead) Inspect(f func(p []byte)) *mDigestHolderMockRead {
	if mmRead.mock.inspectFuncRead != nil {
		mmRead.mock.t.Fatalf("Inspect function is already set for DigestHolderMock.Read")
	}

	mmRead.mock.inspectFuncRead = f

	return mmRead
}

// Return sets up results that will be returned by DigestHolder.Read
func (mmRead *mDigestHolderMockRead) Return(n int, err error) *DigestHolderMock {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("DigestHolderMock.Read mock is already set by Set")
	}

	if mmRead.defaultExpectation == nil {
		mmRead.defaultExpectation = &DigestHolderMockReadExpectation{mock: mmRead.mock}
	}
	mmRead.defaultExpectation.results = &DigestHolderMockReadResults{n, err}
	return mmRead.mock
}

//Set uses given function f to mock the DigestHolder.Read method
func (mmRead *mDigestHolderMockRead) Set(f func(p []byte) (n int, err error)) *DigestHolderMock {
	if mmRead.defaultExpectation != nil {
		mmRead.mock.t.Fatalf("Default expectation is already set for the DigestHolder.Read method")
	}

	if len(mmRead.expectations) > 0 {
		mmRead.mock.t.Fatalf("Some expectations are already set for the DigestHolder.Read method")
	}

	mmRead.mock.funcRead = f
	return mmRead.mock
}

// When sets expectation for the DigestHolder.Read which will trigger the result defined by the following
// Then helper
func (mmRead *mDigestHolderMockRead) When(p []byte) *DigestHolderMockReadExpectation {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("DigestHolderMock.Read mock is already set by Set")
	}

	expectation := &DigestHolderMockReadExpectation{
		mock:   mmRead.mock,
		params: &DigestHolderMockReadParams{p},
	}
	mmRead.expectations = append(mmRead.expectations, expectation)
	return expectation
}

// Then sets up DigestHolder.Read return parameters for the expectation previously defined by the When method
func (e *DigestHolderMockReadExpectation) Then(n int, err error) *DigestHolderMock {
	e.results = &DigestHolderMockReadResults{n, err}
	return e.mock
}

// Read implements DigestHolder
func (mmRead *DigestHolderMock) Read(p []byte) (n int, err error) {
	mm_atomic.AddUint64(&mmRead.beforeReadCounter, 1)
	defer mm_atomic.AddUint64(&mmRead.afterReadCounter, 1)

	if mmRead.inspectFuncRead != nil {
		mmRead.inspectFuncRead(p)
	}

	params := &DigestHolderMockReadParams{p}

	// Record call args
	mmRead.ReadMock.mutex.Lock()
	mmRead.ReadMock.callArgs = append(mmRead.ReadMock.callArgs, params)
	mmRead.ReadMock.mutex.Unlock()

	for _, e := range mmRead.ReadMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmRead.ReadMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRead.ReadMock.defaultExpectation.Counter, 1)
		want := mmRead.ReadMock.defaultExpectation.params
		got := DigestHolderMockReadParams{p}
		if want != nil && !minimock.Equal(*want, got) {
			mmRead.t.Errorf("DigestHolderMock.Read got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmRead.ReadMock.defaultExpectation.results
		if results == nil {
			mmRead.t.Fatal("No results are set for the DigestHolderMock.Read")
		}
		return (*results).n, (*results).err
	}
	if mmRead.funcRead != nil {
		return mmRead.funcRead(p)
	}
	mmRead.t.Fatalf("Unexpected call to DigestHolderMock.Read. %v", p)
	return
}

// ReadAfterCounter returns a count of finished DigestHolderMock.Read invocations
func (mmRead *DigestHolderMock) ReadAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRead.afterReadCounter)
}

// ReadBeforeCounter returns a count of DigestHolderMock.Read invocations
func (mmRead *DigestHolderMock) ReadBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRead.beforeReadCounter)
}

// Calls returns a list of arguments used in each call to DigestHolderMock.Read.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRead *mDigestHolderMockRead) Calls() []*DigestHolderMockReadParams {
	mmRead.mutex.RLock()

	argCopy := make([]*DigestHolderMockReadParams, len(mmRead.callArgs))
	copy(argCopy, mmRead.callArgs)

	mmRead.mutex.RUnlock()

	return argCopy
}

// MinimockReadDone returns true if the count of the Read invocations corresponds
// the number of defined expectations
func (m *DigestHolderMock) MinimockReadDone() bool {
	for _, e := range m.ReadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRead != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		return false
	}
	return true
}

// MinimockReadInspect logs each unmet expectation
func (m *DigestHolderMock) MinimockReadInspect() {
	for _, e := range m.ReadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DigestHolderMock.Read with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		if m.ReadMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DigestHolderMock.Read")
		} else {
			m.t.Errorf("Expected call to DigestHolderMock.Read with params: %#v", *m.ReadMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRead != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		m.t.Error("Expected call to DigestHolderMock.Read")
	}
}

type mDigestHolderMockSignWith struct {
	mock               *DigestHolderMock
	defaultExpectation *DigestHolderMockSignWithExpectation
	expectations       []*DigestHolderMockSignWithExpectation

	callArgs []*DigestHolderMockSignWithParams
	mutex    sync.RWMutex
}

// DigestHolderMockSignWithExpectation specifies expectation struct of the DigestHolder.SignWith
type DigestHolderMockSignWithExpectation struct {
	mock    *DigestHolderMock
	params  *DigestHolderMockSignWithParams
	results *DigestHolderMockSignWithResults
	Counter uint64
}

// DigestHolderMockSignWithParams contains parameters of the DigestHolder.SignWith
type DigestHolderMockSignWithParams struct {
	signer DigestSigner
}

// DigestHolderMockSignWithResults contains results of the DigestHolder.SignWith
type DigestHolderMockSignWithResults struct {
	s1 SignedDigestHolder
}

// Expect sets up expected params for DigestHolder.SignWith
func (mmSignWith *mDigestHolderMockSignWith) Expect(signer DigestSigner) *mDigestHolderMockSignWith {
	if mmSignWith.mock.funcSignWith != nil {
		mmSignWith.mock.t.Fatalf("DigestHolderMock.SignWith mock is already set by Set")
	}

	if mmSignWith.defaultExpectation == nil {
		mmSignWith.defaultExpectation = &DigestHolderMockSignWithExpectation{}
	}

	mmSignWith.defaultExpectation.params = &DigestHolderMockSignWithParams{signer}
	for _, e := range mmSignWith.expectations {
		if minimock.Equal(e.params, mmSignWith.defaultExpectation.params) {
			mmSignWith.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSignWith.defaultExpectation.params)
		}
	}

	return mmSignWith
}

// Inspect accepts an inspector function that has same arguments as the DigestHolder.SignWith
func (mmSignWith *mDigestHolderMockSignWith) Inspect(f func(signer DigestSigner)) *mDigestHolderMockSignWith {
	if mmSignWith.mock.inspectFuncSignWith != nil {
		mmSignWith.mock.t.Fatalf("Inspect function is already set for DigestHolderMock.SignWith")
	}

	mmSignWith.mock.inspectFuncSignWith = f

	return mmSignWith
}

// Return sets up results that will be returned by DigestHolder.SignWith
func (mmSignWith *mDigestHolderMockSignWith) Return(s1 SignedDigestHolder) *DigestHolderMock {
	if mmSignWith.mock.funcSignWith != nil {
		mmSignWith.mock.t.Fatalf("DigestHolderMock.SignWith mock is already set by Set")
	}

	if mmSignWith.defaultExpectation == nil {
		mmSignWith.defaultExpectation = &DigestHolderMockSignWithExpectation{mock: mmSignWith.mock}
	}
	mmSignWith.defaultExpectation.results = &DigestHolderMockSignWithResults{s1}
	return mmSignWith.mock
}

//Set uses given function f to mock the DigestHolder.SignWith method
func (mmSignWith *mDigestHolderMockSignWith) Set(f func(signer DigestSigner) (s1 SignedDigestHolder)) *DigestHolderMock {
	if mmSignWith.defaultExpectation != nil {
		mmSignWith.mock.t.Fatalf("Default expectation is already set for the DigestHolder.SignWith method")
	}

	if len(mmSignWith.expectations) > 0 {
		mmSignWith.mock.t.Fatalf("Some expectations are already set for the DigestHolder.SignWith method")
	}

	mmSignWith.mock.funcSignWith = f
	return mmSignWith.mock
}

// When sets expectation for the DigestHolder.SignWith which will trigger the result defined by the following
// Then helper
func (mmSignWith *mDigestHolderMockSignWith) When(signer DigestSigner) *DigestHolderMockSignWithExpectation {
	if mmSignWith.mock.funcSignWith != nil {
		mmSignWith.mock.t.Fatalf("DigestHolderMock.SignWith mock is already set by Set")
	}

	expectation := &DigestHolderMockSignWithExpectation{
		mock:   mmSignWith.mock,
		params: &DigestHolderMockSignWithParams{signer},
	}
	mmSignWith.expectations = append(mmSignWith.expectations, expectation)
	return expectation
}

// Then sets up DigestHolder.SignWith return parameters for the expectation previously defined by the When method
func (e *DigestHolderMockSignWithExpectation) Then(s1 SignedDigestHolder) *DigestHolderMock {
	e.results = &DigestHolderMockSignWithResults{s1}
	return e.mock
}

// SignWith implements DigestHolder
func (mmSignWith *DigestHolderMock) SignWith(signer DigestSigner) (s1 SignedDigestHolder) {
	mm_atomic.AddUint64(&mmSignWith.beforeSignWithCounter, 1)
	defer mm_atomic.AddUint64(&mmSignWith.afterSignWithCounter, 1)

	if mmSignWith.inspectFuncSignWith != nil {
		mmSignWith.inspectFuncSignWith(signer)
	}

	params := &DigestHolderMockSignWithParams{signer}

	// Record call args
	mmSignWith.SignWithMock.mutex.Lock()
	mmSignWith.SignWithMock.callArgs = append(mmSignWith.SignWithMock.callArgs, params)
	mmSignWith.SignWithMock.mutex.Unlock()

	for _, e := range mmSignWith.SignWithMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmSignWith.SignWithMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSignWith.SignWithMock.defaultExpectation.Counter, 1)
		want := mmSignWith.SignWithMock.defaultExpectation.params
		got := DigestHolderMockSignWithParams{signer}
		if want != nil && !minimock.Equal(*want, got) {
			mmSignWith.t.Errorf("DigestHolderMock.SignWith got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmSignWith.SignWithMock.defaultExpectation.results
		if results == nil {
			mmSignWith.t.Fatal("No results are set for the DigestHolderMock.SignWith")
		}
		return (*results).s1
	}
	if mmSignWith.funcSignWith != nil {
		return mmSignWith.funcSignWith(signer)
	}
	mmSignWith.t.Fatalf("Unexpected call to DigestHolderMock.SignWith. %v", signer)
	return
}

// SignWithAfterCounter returns a count of finished DigestHolderMock.SignWith invocations
func (mmSignWith *DigestHolderMock) SignWithAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSignWith.afterSignWithCounter)
}

// SignWithBeforeCounter returns a count of DigestHolderMock.SignWith invocations
func (mmSignWith *DigestHolderMock) SignWithBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSignWith.beforeSignWithCounter)
}

// Calls returns a list of arguments used in each call to DigestHolderMock.SignWith.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSignWith *mDigestHolderMockSignWith) Calls() []*DigestHolderMockSignWithParams {
	mmSignWith.mutex.RLock()

	argCopy := make([]*DigestHolderMockSignWithParams, len(mmSignWith.callArgs))
	copy(argCopy, mmSignWith.callArgs)

	mmSignWith.mutex.RUnlock()

	return argCopy
}

// MinimockSignWithDone returns true if the count of the SignWith invocations corresponds
// the number of defined expectations
func (m *DigestHolderMock) MinimockSignWithDone() bool {
	for _, e := range m.SignWithMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SignWithMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSignWithCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSignWith != nil && mm_atomic.LoadUint64(&m.afterSignWithCounter) < 1 {
		return false
	}
	return true
}

// MinimockSignWithInspect logs each unmet expectation
func (m *DigestHolderMock) MinimockSignWithInspect() {
	for _, e := range m.SignWithMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DigestHolderMock.SignWith with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SignWithMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSignWithCounter) < 1 {
		if m.SignWithMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DigestHolderMock.SignWith")
		} else {
			m.t.Errorf("Expected call to DigestHolderMock.SignWith with params: %#v", *m.SignWithMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSignWith != nil && mm_atomic.LoadUint64(&m.afterSignWithCounter) < 1 {
		m.t.Error("Expected call to DigestHolderMock.SignWith")
	}
}

type mDigestHolderMockWriteTo struct {
	mock               *DigestHolderMock
	defaultExpectation *DigestHolderMockWriteToExpectation
	expectations       []*DigestHolderMockWriteToExpectation

	callArgs []*DigestHolderMockWriteToParams
	mutex    sync.RWMutex
}

// DigestHolderMockWriteToExpectation specifies expectation struct of the DigestHolder.WriteTo
type DigestHolderMockWriteToExpectation struct {
	mock    *DigestHolderMock
	params  *DigestHolderMockWriteToParams
	results *DigestHolderMockWriteToResults
	Counter uint64
}

// DigestHolderMockWriteToParams contains parameters of the DigestHolder.WriteTo
type DigestHolderMockWriteToParams struct {
	w io.Writer
}

// DigestHolderMockWriteToResults contains results of the DigestHolder.WriteTo
type DigestHolderMockWriteToResults struct {
	n   int64
	err error
}

// Expect sets up expected params for DigestHolder.WriteTo
func (mmWriteTo *mDigestHolderMockWriteTo) Expect(w io.Writer) *mDigestHolderMockWriteTo {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("DigestHolderMock.WriteTo mock is already set by Set")
	}

	if mmWriteTo.defaultExpectation == nil {
		mmWriteTo.defaultExpectation = &DigestHolderMockWriteToExpectation{}
	}

	mmWriteTo.defaultExpectation.params = &DigestHolderMockWriteToParams{w}
	for _, e := range mmWriteTo.expectations {
		if minimock.Equal(e.params, mmWriteTo.defaultExpectation.params) {
			mmWriteTo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWriteTo.defaultExpectation.params)
		}
	}

	return mmWriteTo
}

// Inspect accepts an inspector function that has same arguments as the DigestHolder.WriteTo
func (mmWriteTo *mDigestHolderMockWriteTo) Inspect(f func(w io.Writer)) *mDigestHolderMockWriteTo {
	if mmWriteTo.mock.inspectFuncWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("Inspect function is already set for DigestHolderMock.WriteTo")
	}

	mmWriteTo.mock.inspectFuncWriteTo = f

	return mmWriteTo
}

// Return sets up results that will be returned by DigestHolder.WriteTo
func (mmWriteTo *mDigestHolderMockWriteTo) Return(n int64, err error) *DigestHolderMock {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("DigestHolderMock.WriteTo mock is already set by Set")
	}

	if mmWriteTo.defaultExpectation == nil {
		mmWriteTo.defaultExpectation = &DigestHolderMockWriteToExpectation{mock: mmWriteTo.mock}
	}
	mmWriteTo.defaultExpectation.results = &DigestHolderMockWriteToResults{n, err}
	return mmWriteTo.mock
}

//Set uses given function f to mock the DigestHolder.WriteTo method
func (mmWriteTo *mDigestHolderMockWriteTo) Set(f func(w io.Writer) (n int64, err error)) *DigestHolderMock {
	if mmWriteTo.defaultExpectation != nil {
		mmWriteTo.mock.t.Fatalf("Default expectation is already set for the DigestHolder.WriteTo method")
	}

	if len(mmWriteTo.expectations) > 0 {
		mmWriteTo.mock.t.Fatalf("Some expectations are already set for the DigestHolder.WriteTo method")
	}

	mmWriteTo.mock.funcWriteTo = f
	return mmWriteTo.mock
}

// When sets expectation for the DigestHolder.WriteTo which will trigger the result defined by the following
// Then helper
func (mmWriteTo *mDigestHolderMockWriteTo) When(w io.Writer) *DigestHolderMockWriteToExpectation {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("DigestHolderMock.WriteTo mock is already set by Set")
	}

	expectation := &DigestHolderMockWriteToExpectation{
		mock:   mmWriteTo.mock,
		params: &DigestHolderMockWriteToParams{w},
	}
	mmWriteTo.expectations = append(mmWriteTo.expectations, expectation)
	return expectation
}

// Then sets up DigestHolder.WriteTo return parameters for the expectation previously defined by the When method
func (e *DigestHolderMockWriteToExpectation) Then(n int64, err error) *DigestHolderMock {
	e.results = &DigestHolderMockWriteToResults{n, err}
	return e.mock
}

// WriteTo implements DigestHolder
func (mmWriteTo *DigestHolderMock) WriteTo(w io.Writer) (n int64, err error) {
	mm_atomic.AddUint64(&mmWriteTo.beforeWriteToCounter, 1)
	defer mm_atomic.AddUint64(&mmWriteTo.afterWriteToCounter, 1)

	if mmWriteTo.inspectFuncWriteTo != nil {
		mmWriteTo.inspectFuncWriteTo(w)
	}

	params := &DigestHolderMockWriteToParams{w}

	// Record call args
	mmWriteTo.WriteToMock.mutex.Lock()
	mmWriteTo.WriteToMock.callArgs = append(mmWriteTo.WriteToMock.callArgs, params)
	mmWriteTo.WriteToMock.mutex.Unlock()

	for _, e := range mmWriteTo.WriteToMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmWriteTo.WriteToMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWriteTo.WriteToMock.defaultExpectation.Counter, 1)
		want := mmWriteTo.WriteToMock.defaultExpectation.params
		got := DigestHolderMockWriteToParams{w}
		if want != nil && !minimock.Equal(*want, got) {
			mmWriteTo.t.Errorf("DigestHolderMock.WriteTo got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmWriteTo.WriteToMock.defaultExpectation.results
		if results == nil {
			mmWriteTo.t.Fatal("No results are set for the DigestHolderMock.WriteTo")
		}
		return (*results).n, (*results).err
	}
	if mmWriteTo.funcWriteTo != nil {
		return mmWriteTo.funcWriteTo(w)
	}
	mmWriteTo.t.Fatalf("Unexpected call to DigestHolderMock.WriteTo. %v", w)
	return
}

// WriteToAfterCounter returns a count of finished DigestHolderMock.WriteTo invocations
func (mmWriteTo *DigestHolderMock) WriteToAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteTo.afterWriteToCounter)
}

// WriteToBeforeCounter returns a count of DigestHolderMock.WriteTo invocations
func (mmWriteTo *DigestHolderMock) WriteToBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteTo.beforeWriteToCounter)
}

// Calls returns a list of arguments used in each call to DigestHolderMock.WriteTo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWriteTo *mDigestHolderMockWriteTo) Calls() []*DigestHolderMockWriteToParams {
	mmWriteTo.mutex.RLock()

	argCopy := make([]*DigestHolderMockWriteToParams, len(mmWriteTo.callArgs))
	copy(argCopy, mmWriteTo.callArgs)

	mmWriteTo.mutex.RUnlock()

	return argCopy
}

// MinimockWriteToDone returns true if the count of the WriteTo invocations corresponds
// the number of defined expectations
func (m *DigestHolderMock) MinimockWriteToDone() bool {
	for _, e := range m.WriteToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteTo != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		return false
	}
	return true
}

// MinimockWriteToInspect logs each unmet expectation
func (m *DigestHolderMock) MinimockWriteToInspect() {
	for _, e := range m.WriteToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DigestHolderMock.WriteTo with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		if m.WriteToMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DigestHolderMock.WriteTo")
		} else {
			m.t.Errorf("Expected call to DigestHolderMock.WriteTo with params: %#v", *m.WriteToMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteTo != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		m.t.Error("Expected call to DigestHolderMock.WriteTo")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *DigestHolderMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAsByteStringInspect()

		m.MinimockAsBytesInspect()

		m.MinimockCopyOfDigestInspect()

		m.MinimockEqualsInspect()

		m.MinimockFixedByteSizeInspect()

		m.MinimockFoldToUint64Inspect()

		m.MinimockGetDigestMethodInspect()

		m.MinimockReadInspect()

		m.MinimockSignWithInspect()

		m.MinimockWriteToInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *DigestHolderMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *DigestHolderMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAsByteStringDone() &&
		m.MinimockAsBytesDone() &&
		m.MinimockCopyOfDigestDone() &&
		m.MinimockEqualsDone() &&
		m.MinimockFixedByteSizeDone() &&
		m.MinimockFoldToUint64Done() &&
		m.MinimockGetDigestMethodDone() &&
		m.MinimockReadDone() &&
		m.MinimockSignWithDone() &&
		m.MinimockWriteToDone()
}
