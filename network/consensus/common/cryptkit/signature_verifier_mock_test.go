package cryptkit

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
)

// SignatureVerifierMock implements SignatureVerifier
type SignatureVerifierMock struct {
	t minimock.Tester

	funcIsDigestMethodSupported          func(m DigestMethod) (b1 bool)
	inspectFuncIsDigestMethodSupported   func(m DigestMethod)
	afterIsDigestMethodSupportedCounter  uint64
	beforeIsDigestMethodSupportedCounter uint64
	IsDigestMethodSupportedMock          mSignatureVerifierMockIsDigestMethodSupported

	funcIsSignMethodSupported          func(m SignMethod) (b1 bool)
	inspectFuncIsSignMethodSupported   func(m SignMethod)
	afterIsSignMethodSupportedCounter  uint64
	beforeIsSignMethodSupportedCounter uint64
	IsSignMethodSupportedMock          mSignatureVerifierMockIsSignMethodSupported

	funcIsSignOfSignatureMethodSupported          func(m SignatureMethod) (b1 bool)
	inspectFuncIsSignOfSignatureMethodSupported   func(m SignatureMethod)
	afterIsSignOfSignatureMethodSupportedCounter  uint64
	beforeIsSignOfSignatureMethodSupportedCounter uint64
	IsSignOfSignatureMethodSupportedMock          mSignatureVerifierMockIsSignOfSignatureMethodSupported

	funcIsValidDataSignature          func(data io.Reader, signature SignatureHolder) (b1 bool)
	inspectFuncIsValidDataSignature   func(data io.Reader, signature SignatureHolder)
	afterIsValidDataSignatureCounter  uint64
	beforeIsValidDataSignatureCounter uint64
	IsValidDataSignatureMock          mSignatureVerifierMockIsValidDataSignature

	funcIsValidDigestSignature          func(digest DigestHolder, signature SignatureHolder) (b1 bool)
	inspectFuncIsValidDigestSignature   func(digest DigestHolder, signature SignatureHolder)
	afterIsValidDigestSignatureCounter  uint64
	beforeIsValidDigestSignatureCounter uint64
	IsValidDigestSignatureMock          mSignatureVerifierMockIsValidDigestSignature
}

// NewSignatureVerifierMock returns a mock for SignatureVerifier
func NewSignatureVerifierMock(t minimock.Tester) *SignatureVerifierMock {
	m := &SignatureVerifierMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.IsDigestMethodSupportedMock = mSignatureVerifierMockIsDigestMethodSupported{mock: m}
	m.IsDigestMethodSupportedMock.callArgs = []*SignatureVerifierMockIsDigestMethodSupportedParams{}

	m.IsSignMethodSupportedMock = mSignatureVerifierMockIsSignMethodSupported{mock: m}
	m.IsSignMethodSupportedMock.callArgs = []*SignatureVerifierMockIsSignMethodSupportedParams{}

	m.IsSignOfSignatureMethodSupportedMock = mSignatureVerifierMockIsSignOfSignatureMethodSupported{mock: m}
	m.IsSignOfSignatureMethodSupportedMock.callArgs = []*SignatureVerifierMockIsSignOfSignatureMethodSupportedParams{}

	m.IsValidDataSignatureMock = mSignatureVerifierMockIsValidDataSignature{mock: m}
	m.IsValidDataSignatureMock.callArgs = []*SignatureVerifierMockIsValidDataSignatureParams{}

	m.IsValidDigestSignatureMock = mSignatureVerifierMockIsValidDigestSignature{mock: m}
	m.IsValidDigestSignatureMock.callArgs = []*SignatureVerifierMockIsValidDigestSignatureParams{}

	return m
}

type mSignatureVerifierMockIsDigestMethodSupported struct {
	mock               *SignatureVerifierMock
	defaultExpectation *SignatureVerifierMockIsDigestMethodSupportedExpectation
	expectations       []*SignatureVerifierMockIsDigestMethodSupportedExpectation

	callArgs []*SignatureVerifierMockIsDigestMethodSupportedParams
	mutex    sync.RWMutex
}

// SignatureVerifierMockIsDigestMethodSupportedExpectation specifies expectation struct of the SignatureVerifier.IsDigestMethodSupported
type SignatureVerifierMockIsDigestMethodSupportedExpectation struct {
	mock    *SignatureVerifierMock
	params  *SignatureVerifierMockIsDigestMethodSupportedParams
	results *SignatureVerifierMockIsDigestMethodSupportedResults
	Counter uint64
}

// SignatureVerifierMockIsDigestMethodSupportedParams contains parameters of the SignatureVerifier.IsDigestMethodSupported
type SignatureVerifierMockIsDigestMethodSupportedParams struct {
	m DigestMethod
}

// SignatureVerifierMockIsDigestMethodSupportedResults contains results of the SignatureVerifier.IsDigestMethodSupported
type SignatureVerifierMockIsDigestMethodSupportedResults struct {
	b1 bool
}

// Expect sets up expected params for SignatureVerifier.IsDigestMethodSupported
func (mmIsDigestMethodSupported *mSignatureVerifierMockIsDigestMethodSupported) Expect(m DigestMethod) *mSignatureVerifierMockIsDigestMethodSupported {
	if mmIsDigestMethodSupported.mock.funcIsDigestMethodSupported != nil {
		mmIsDigestMethodSupported.mock.t.Fatalf("SignatureVerifierMock.IsDigestMethodSupported mock is already set by Set")
	}

	if mmIsDigestMethodSupported.defaultExpectation == nil {
		mmIsDigestMethodSupported.defaultExpectation = &SignatureVerifierMockIsDigestMethodSupportedExpectation{}
	}

	mmIsDigestMethodSupported.defaultExpectation.params = &SignatureVerifierMockIsDigestMethodSupportedParams{m}
	for _, e := range mmIsDigestMethodSupported.expectations {
		if minimock.Equal(e.params, mmIsDigestMethodSupported.defaultExpectation.params) {
			mmIsDigestMethodSupported.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsDigestMethodSupported.defaultExpectation.params)
		}
	}

	return mmIsDigestMethodSupported
}

// Inspect accepts an inspector function that has same arguments as the SignatureVerifier.IsDigestMethodSupported
func (mmIsDigestMethodSupported *mSignatureVerifierMockIsDigestMethodSupported) Inspect(f func(m DigestMethod)) *mSignatureVerifierMockIsDigestMethodSupported {
	if mmIsDigestMethodSupported.mock.inspectFuncIsDigestMethodSupported != nil {
		mmIsDigestMethodSupported.mock.t.Fatalf("Inspect function is already set for SignatureVerifierMock.IsDigestMethodSupported")
	}

	mmIsDigestMethodSupported.mock.inspectFuncIsDigestMethodSupported = f

	return mmIsDigestMethodSupported
}

// Return sets up results that will be returned by SignatureVerifier.IsDigestMethodSupported
func (mmIsDigestMethodSupported *mSignatureVerifierMockIsDigestMethodSupported) Return(b1 bool) *SignatureVerifierMock {
	if mmIsDigestMethodSupported.mock.funcIsDigestMethodSupported != nil {
		mmIsDigestMethodSupported.mock.t.Fatalf("SignatureVerifierMock.IsDigestMethodSupported mock is already set by Set")
	}

	if mmIsDigestMethodSupported.defaultExpectation == nil {
		mmIsDigestMethodSupported.defaultExpectation = &SignatureVerifierMockIsDigestMethodSupportedExpectation{mock: mmIsDigestMethodSupported.mock}
	}
	mmIsDigestMethodSupported.defaultExpectation.results = &SignatureVerifierMockIsDigestMethodSupportedResults{b1}
	return mmIsDigestMethodSupported.mock
}

//Set uses given function f to mock the SignatureVerifier.IsDigestMethodSupported method
func (mmIsDigestMethodSupported *mSignatureVerifierMockIsDigestMethodSupported) Set(f func(m DigestMethod) (b1 bool)) *SignatureVerifierMock {
	if mmIsDigestMethodSupported.defaultExpectation != nil {
		mmIsDigestMethodSupported.mock.t.Fatalf("Default expectation is already set for the SignatureVerifier.IsDigestMethodSupported method")
	}

	if len(mmIsDigestMethodSupported.expectations) > 0 {
		mmIsDigestMethodSupported.mock.t.Fatalf("Some expectations are already set for the SignatureVerifier.IsDigestMethodSupported method")
	}

	mmIsDigestMethodSupported.mock.funcIsDigestMethodSupported = f
	return mmIsDigestMethodSupported.mock
}

// When sets expectation for the SignatureVerifier.IsDigestMethodSupported which will trigger the result defined by the following
// Then helper
func (mmIsDigestMethodSupported *mSignatureVerifierMockIsDigestMethodSupported) When(m DigestMethod) *SignatureVerifierMockIsDigestMethodSupportedExpectation {
	if mmIsDigestMethodSupported.mock.funcIsDigestMethodSupported != nil {
		mmIsDigestMethodSupported.mock.t.Fatalf("SignatureVerifierMock.IsDigestMethodSupported mock is already set by Set")
	}

	expectation := &SignatureVerifierMockIsDigestMethodSupportedExpectation{
		mock:   mmIsDigestMethodSupported.mock,
		params: &SignatureVerifierMockIsDigestMethodSupportedParams{m},
	}
	mmIsDigestMethodSupported.expectations = append(mmIsDigestMethodSupported.expectations, expectation)
	return expectation
}

// Then sets up SignatureVerifier.IsDigestMethodSupported return parameters for the expectation previously defined by the When method
func (e *SignatureVerifierMockIsDigestMethodSupportedExpectation) Then(b1 bool) *SignatureVerifierMock {
	e.results = &SignatureVerifierMockIsDigestMethodSupportedResults{b1}
	return e.mock
}

// IsDigestMethodSupported implements SignatureVerifier
func (mmIsDigestMethodSupported *SignatureVerifierMock) IsDigestMethodSupported(m DigestMethod) (b1 bool) {
	mm_atomic.AddUint64(&mmIsDigestMethodSupported.beforeIsDigestMethodSupportedCounter, 1)
	defer mm_atomic.AddUint64(&mmIsDigestMethodSupported.afterIsDigestMethodSupportedCounter, 1)

	if mmIsDigestMethodSupported.inspectFuncIsDigestMethodSupported != nil {
		mmIsDigestMethodSupported.inspectFuncIsDigestMethodSupported(m)
	}

	params := &SignatureVerifierMockIsDigestMethodSupportedParams{m}

	// Record call args
	mmIsDigestMethodSupported.IsDigestMethodSupportedMock.mutex.Lock()
	mmIsDigestMethodSupported.IsDigestMethodSupportedMock.callArgs = append(mmIsDigestMethodSupported.IsDigestMethodSupportedMock.callArgs, params)
	mmIsDigestMethodSupported.IsDigestMethodSupportedMock.mutex.Unlock()

	for _, e := range mmIsDigestMethodSupported.IsDigestMethodSupportedMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmIsDigestMethodSupported.IsDigestMethodSupportedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsDigestMethodSupported.IsDigestMethodSupportedMock.defaultExpectation.Counter, 1)
		want := mmIsDigestMethodSupported.IsDigestMethodSupportedMock.defaultExpectation.params
		got := SignatureVerifierMockIsDigestMethodSupportedParams{m}
		if want != nil && !minimock.Equal(*want, got) {
			mmIsDigestMethodSupported.t.Errorf("SignatureVerifierMock.IsDigestMethodSupported got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmIsDigestMethodSupported.IsDigestMethodSupportedMock.defaultExpectation.results
		if results == nil {
			mmIsDigestMethodSupported.t.Fatal("No results are set for the SignatureVerifierMock.IsDigestMethodSupported")
		}
		return (*results).b1
	}
	if mmIsDigestMethodSupported.funcIsDigestMethodSupported != nil {
		return mmIsDigestMethodSupported.funcIsDigestMethodSupported(m)
	}
	mmIsDigestMethodSupported.t.Fatalf("Unexpected call to SignatureVerifierMock.IsDigestMethodSupported. %v", m)
	return
}

// IsDigestMethodSupportedAfterCounter returns a count of finished SignatureVerifierMock.IsDigestMethodSupported invocations
func (mmIsDigestMethodSupported *SignatureVerifierMock) IsDigestMethodSupportedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsDigestMethodSupported.afterIsDigestMethodSupportedCounter)
}

// IsDigestMethodSupportedBeforeCounter returns a count of SignatureVerifierMock.IsDigestMethodSupported invocations
func (mmIsDigestMethodSupported *SignatureVerifierMock) IsDigestMethodSupportedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsDigestMethodSupported.beforeIsDigestMethodSupportedCounter)
}

// Calls returns a list of arguments used in each call to SignatureVerifierMock.IsDigestMethodSupported.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsDigestMethodSupported *mSignatureVerifierMockIsDigestMethodSupported) Calls() []*SignatureVerifierMockIsDigestMethodSupportedParams {
	mmIsDigestMethodSupported.mutex.RLock()

	argCopy := make([]*SignatureVerifierMockIsDigestMethodSupportedParams, len(mmIsDigestMethodSupported.callArgs))
	copy(argCopy, mmIsDigestMethodSupported.callArgs)

	mmIsDigestMethodSupported.mutex.RUnlock()

	return argCopy
}

// MinimockIsDigestMethodSupportedDone returns true if the count of the IsDigestMethodSupported invocations corresponds
// the number of defined expectations
func (m *SignatureVerifierMock) MinimockIsDigestMethodSupportedDone() bool {
	for _, e := range m.IsDigestMethodSupportedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsDigestMethodSupportedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsDigestMethodSupportedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsDigestMethodSupported != nil && mm_atomic.LoadUint64(&m.afterIsDigestMethodSupportedCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsDigestMethodSupportedInspect logs each unmet expectation
func (m *SignatureVerifierMock) MinimockIsDigestMethodSupportedInspect() {
	for _, e := range m.IsDigestMethodSupportedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SignatureVerifierMock.IsDigestMethodSupported with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsDigestMethodSupportedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsDigestMethodSupportedCounter) < 1 {
		if m.IsDigestMethodSupportedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SignatureVerifierMock.IsDigestMethodSupported")
		} else {
			m.t.Errorf("Expected call to SignatureVerifierMock.IsDigestMethodSupported with params: %#v", *m.IsDigestMethodSupportedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsDigestMethodSupported != nil && mm_atomic.LoadUint64(&m.afterIsDigestMethodSupportedCounter) < 1 {
		m.t.Error("Expected call to SignatureVerifierMock.IsDigestMethodSupported")
	}
}

type mSignatureVerifierMockIsSignMethodSupported struct {
	mock               *SignatureVerifierMock
	defaultExpectation *SignatureVerifierMockIsSignMethodSupportedExpectation
	expectations       []*SignatureVerifierMockIsSignMethodSupportedExpectation

	callArgs []*SignatureVerifierMockIsSignMethodSupportedParams
	mutex    sync.RWMutex
}

// SignatureVerifierMockIsSignMethodSupportedExpectation specifies expectation struct of the SignatureVerifier.IsSignMethodSupported
type SignatureVerifierMockIsSignMethodSupportedExpectation struct {
	mock    *SignatureVerifierMock
	params  *SignatureVerifierMockIsSignMethodSupportedParams
	results *SignatureVerifierMockIsSignMethodSupportedResults
	Counter uint64
}

// SignatureVerifierMockIsSignMethodSupportedParams contains parameters of the SignatureVerifier.IsSignMethodSupported
type SignatureVerifierMockIsSignMethodSupportedParams struct {
	m SignMethod
}

// SignatureVerifierMockIsSignMethodSupportedResults contains results of the SignatureVerifier.IsSignMethodSupported
type SignatureVerifierMockIsSignMethodSupportedResults struct {
	b1 bool
}

// Expect sets up expected params for SignatureVerifier.IsSignMethodSupported
func (mmIsSignMethodSupported *mSignatureVerifierMockIsSignMethodSupported) Expect(m SignMethod) *mSignatureVerifierMockIsSignMethodSupported {
	if mmIsSignMethodSupported.mock.funcIsSignMethodSupported != nil {
		mmIsSignMethodSupported.mock.t.Fatalf("SignatureVerifierMock.IsSignMethodSupported mock is already set by Set")
	}

	if mmIsSignMethodSupported.defaultExpectation == nil {
		mmIsSignMethodSupported.defaultExpectation = &SignatureVerifierMockIsSignMethodSupportedExpectation{}
	}

	mmIsSignMethodSupported.defaultExpectation.params = &SignatureVerifierMockIsSignMethodSupportedParams{m}
	for _, e := range mmIsSignMethodSupported.expectations {
		if minimock.Equal(e.params, mmIsSignMethodSupported.defaultExpectation.params) {
			mmIsSignMethodSupported.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsSignMethodSupported.defaultExpectation.params)
		}
	}

	return mmIsSignMethodSupported
}

// Inspect accepts an inspector function that has same arguments as the SignatureVerifier.IsSignMethodSupported
func (mmIsSignMethodSupported *mSignatureVerifierMockIsSignMethodSupported) Inspect(f func(m SignMethod)) *mSignatureVerifierMockIsSignMethodSupported {
	if mmIsSignMethodSupported.mock.inspectFuncIsSignMethodSupported != nil {
		mmIsSignMethodSupported.mock.t.Fatalf("Inspect function is already set for SignatureVerifierMock.IsSignMethodSupported")
	}

	mmIsSignMethodSupported.mock.inspectFuncIsSignMethodSupported = f

	return mmIsSignMethodSupported
}

// Return sets up results that will be returned by SignatureVerifier.IsSignMethodSupported
func (mmIsSignMethodSupported *mSignatureVerifierMockIsSignMethodSupported) Return(b1 bool) *SignatureVerifierMock {
	if mmIsSignMethodSupported.mock.funcIsSignMethodSupported != nil {
		mmIsSignMethodSupported.mock.t.Fatalf("SignatureVerifierMock.IsSignMethodSupported mock is already set by Set")
	}

	if mmIsSignMethodSupported.defaultExpectation == nil {
		mmIsSignMethodSupported.defaultExpectation = &SignatureVerifierMockIsSignMethodSupportedExpectation{mock: mmIsSignMethodSupported.mock}
	}
	mmIsSignMethodSupported.defaultExpectation.results = &SignatureVerifierMockIsSignMethodSupportedResults{b1}
	return mmIsSignMethodSupported.mock
}

//Set uses given function f to mock the SignatureVerifier.IsSignMethodSupported method
func (mmIsSignMethodSupported *mSignatureVerifierMockIsSignMethodSupported) Set(f func(m SignMethod) (b1 bool)) *SignatureVerifierMock {
	if mmIsSignMethodSupported.defaultExpectation != nil {
		mmIsSignMethodSupported.mock.t.Fatalf("Default expectation is already set for the SignatureVerifier.IsSignMethodSupported method")
	}

	if len(mmIsSignMethodSupported.expectations) > 0 {
		mmIsSignMethodSupported.mock.t.Fatalf("Some expectations are already set for the SignatureVerifier.IsSignMethodSupported method")
	}

	mmIsSignMethodSupported.mock.funcIsSignMethodSupported = f
	return mmIsSignMethodSupported.mock
}

// When sets expectation for the SignatureVerifier.IsSignMethodSupported which will trigger the result defined by the following
// Then helper
func (mmIsSignMethodSupported *mSignatureVerifierMockIsSignMethodSupported) When(m SignMethod) *SignatureVerifierMockIsSignMethodSupportedExpectation {
	if mmIsSignMethodSupported.mock.funcIsSignMethodSupported != nil {
		mmIsSignMethodSupported.mock.t.Fatalf("SignatureVerifierMock.IsSignMethodSupported mock is already set by Set")
	}

	expectation := &SignatureVerifierMockIsSignMethodSupportedExpectation{
		mock:   mmIsSignMethodSupported.mock,
		params: &SignatureVerifierMockIsSignMethodSupportedParams{m},
	}
	mmIsSignMethodSupported.expectations = append(mmIsSignMethodSupported.expectations, expectation)
	return expectation
}

// Then sets up SignatureVerifier.IsSignMethodSupported return parameters for the expectation previously defined by the When method
func (e *SignatureVerifierMockIsSignMethodSupportedExpectation) Then(b1 bool) *SignatureVerifierMock {
	e.results = &SignatureVerifierMockIsSignMethodSupportedResults{b1}
	return e.mock
}

// IsSignMethodSupported implements SignatureVerifier
func (mmIsSignMethodSupported *SignatureVerifierMock) IsSignMethodSupported(m SignMethod) (b1 bool) {
	mm_atomic.AddUint64(&mmIsSignMethodSupported.beforeIsSignMethodSupportedCounter, 1)
	defer mm_atomic.AddUint64(&mmIsSignMethodSupported.afterIsSignMethodSupportedCounter, 1)

	if mmIsSignMethodSupported.inspectFuncIsSignMethodSupported != nil {
		mmIsSignMethodSupported.inspectFuncIsSignMethodSupported(m)
	}

	params := &SignatureVerifierMockIsSignMethodSupportedParams{m}

	// Record call args
	mmIsSignMethodSupported.IsSignMethodSupportedMock.mutex.Lock()
	mmIsSignMethodSupported.IsSignMethodSupportedMock.callArgs = append(mmIsSignMethodSupported.IsSignMethodSupportedMock.callArgs, params)
	mmIsSignMethodSupported.IsSignMethodSupportedMock.mutex.Unlock()

	for _, e := range mmIsSignMethodSupported.IsSignMethodSupportedMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmIsSignMethodSupported.IsSignMethodSupportedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsSignMethodSupported.IsSignMethodSupportedMock.defaultExpectation.Counter, 1)
		want := mmIsSignMethodSupported.IsSignMethodSupportedMock.defaultExpectation.params
		got := SignatureVerifierMockIsSignMethodSupportedParams{m}
		if want != nil && !minimock.Equal(*want, got) {
			mmIsSignMethodSupported.t.Errorf("SignatureVerifierMock.IsSignMethodSupported got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmIsSignMethodSupported.IsSignMethodSupportedMock.defaultExpectation.results
		if results == nil {
			mmIsSignMethodSupported.t.Fatal("No results are set for the SignatureVerifierMock.IsSignMethodSupported")
		}
		return (*results).b1
	}
	if mmIsSignMethodSupported.funcIsSignMethodSupported != nil {
		return mmIsSignMethodSupported.funcIsSignMethodSupported(m)
	}
	mmIsSignMethodSupported.t.Fatalf("Unexpected call to SignatureVerifierMock.IsSignMethodSupported. %v", m)
	return
}

// IsSignMethodSupportedAfterCounter returns a count of finished SignatureVerifierMock.IsSignMethodSupported invocations
func (mmIsSignMethodSupported *SignatureVerifierMock) IsSignMethodSupportedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsSignMethodSupported.afterIsSignMethodSupportedCounter)
}

// IsSignMethodSupportedBeforeCounter returns a count of SignatureVerifierMock.IsSignMethodSupported invocations
func (mmIsSignMethodSupported *SignatureVerifierMock) IsSignMethodSupportedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsSignMethodSupported.beforeIsSignMethodSupportedCounter)
}

// Calls returns a list of arguments used in each call to SignatureVerifierMock.IsSignMethodSupported.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsSignMethodSupported *mSignatureVerifierMockIsSignMethodSupported) Calls() []*SignatureVerifierMockIsSignMethodSupportedParams {
	mmIsSignMethodSupported.mutex.RLock()

	argCopy := make([]*SignatureVerifierMockIsSignMethodSupportedParams, len(mmIsSignMethodSupported.callArgs))
	copy(argCopy, mmIsSignMethodSupported.callArgs)

	mmIsSignMethodSupported.mutex.RUnlock()

	return argCopy
}

// MinimockIsSignMethodSupportedDone returns true if the count of the IsSignMethodSupported invocations corresponds
// the number of defined expectations
func (m *SignatureVerifierMock) MinimockIsSignMethodSupportedDone() bool {
	for _, e := range m.IsSignMethodSupportedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsSignMethodSupportedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsSignMethodSupportedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsSignMethodSupported != nil && mm_atomic.LoadUint64(&m.afterIsSignMethodSupportedCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsSignMethodSupportedInspect logs each unmet expectation
func (m *SignatureVerifierMock) MinimockIsSignMethodSupportedInspect() {
	for _, e := range m.IsSignMethodSupportedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SignatureVerifierMock.IsSignMethodSupported with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsSignMethodSupportedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsSignMethodSupportedCounter) < 1 {
		if m.IsSignMethodSupportedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SignatureVerifierMock.IsSignMethodSupported")
		} else {
			m.t.Errorf("Expected call to SignatureVerifierMock.IsSignMethodSupported with params: %#v", *m.IsSignMethodSupportedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsSignMethodSupported != nil && mm_atomic.LoadUint64(&m.afterIsSignMethodSupportedCounter) < 1 {
		m.t.Error("Expected call to SignatureVerifierMock.IsSignMethodSupported")
	}
}

type mSignatureVerifierMockIsSignOfSignatureMethodSupported struct {
	mock               *SignatureVerifierMock
	defaultExpectation *SignatureVerifierMockIsSignOfSignatureMethodSupportedExpectation
	expectations       []*SignatureVerifierMockIsSignOfSignatureMethodSupportedExpectation

	callArgs []*SignatureVerifierMockIsSignOfSignatureMethodSupportedParams
	mutex    sync.RWMutex
}

// SignatureVerifierMockIsSignOfSignatureMethodSupportedExpectation specifies expectation struct of the SignatureVerifier.IsSignOfSignatureMethodSupported
type SignatureVerifierMockIsSignOfSignatureMethodSupportedExpectation struct {
	mock    *SignatureVerifierMock
	params  *SignatureVerifierMockIsSignOfSignatureMethodSupportedParams
	results *SignatureVerifierMockIsSignOfSignatureMethodSupportedResults
	Counter uint64
}

// SignatureVerifierMockIsSignOfSignatureMethodSupportedParams contains parameters of the SignatureVerifier.IsSignOfSignatureMethodSupported
type SignatureVerifierMockIsSignOfSignatureMethodSupportedParams struct {
	m SignatureMethod
}

// SignatureVerifierMockIsSignOfSignatureMethodSupportedResults contains results of the SignatureVerifier.IsSignOfSignatureMethodSupported
type SignatureVerifierMockIsSignOfSignatureMethodSupportedResults struct {
	b1 bool
}

// Expect sets up expected params for SignatureVerifier.IsSignOfSignatureMethodSupported
func (mmIsSignOfSignatureMethodSupported *mSignatureVerifierMockIsSignOfSignatureMethodSupported) Expect(m SignatureMethod) *mSignatureVerifierMockIsSignOfSignatureMethodSupported {
	if mmIsSignOfSignatureMethodSupported.mock.funcIsSignOfSignatureMethodSupported != nil {
		mmIsSignOfSignatureMethodSupported.mock.t.Fatalf("SignatureVerifierMock.IsSignOfSignatureMethodSupported mock is already set by Set")
	}

	if mmIsSignOfSignatureMethodSupported.defaultExpectation == nil {
		mmIsSignOfSignatureMethodSupported.defaultExpectation = &SignatureVerifierMockIsSignOfSignatureMethodSupportedExpectation{}
	}

	mmIsSignOfSignatureMethodSupported.defaultExpectation.params = &SignatureVerifierMockIsSignOfSignatureMethodSupportedParams{m}
	for _, e := range mmIsSignOfSignatureMethodSupported.expectations {
		if minimock.Equal(e.params, mmIsSignOfSignatureMethodSupported.defaultExpectation.params) {
			mmIsSignOfSignatureMethodSupported.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsSignOfSignatureMethodSupported.defaultExpectation.params)
		}
	}

	return mmIsSignOfSignatureMethodSupported
}

// Inspect accepts an inspector function that has same arguments as the SignatureVerifier.IsSignOfSignatureMethodSupported
func (mmIsSignOfSignatureMethodSupported *mSignatureVerifierMockIsSignOfSignatureMethodSupported) Inspect(f func(m SignatureMethod)) *mSignatureVerifierMockIsSignOfSignatureMethodSupported {
	if mmIsSignOfSignatureMethodSupported.mock.inspectFuncIsSignOfSignatureMethodSupported != nil {
		mmIsSignOfSignatureMethodSupported.mock.t.Fatalf("Inspect function is already set for SignatureVerifierMock.IsSignOfSignatureMethodSupported")
	}

	mmIsSignOfSignatureMethodSupported.mock.inspectFuncIsSignOfSignatureMethodSupported = f

	return mmIsSignOfSignatureMethodSupported
}

// Return sets up results that will be returned by SignatureVerifier.IsSignOfSignatureMethodSupported
func (mmIsSignOfSignatureMethodSupported *mSignatureVerifierMockIsSignOfSignatureMethodSupported) Return(b1 bool) *SignatureVerifierMock {
	if mmIsSignOfSignatureMethodSupported.mock.funcIsSignOfSignatureMethodSupported != nil {
		mmIsSignOfSignatureMethodSupported.mock.t.Fatalf("SignatureVerifierMock.IsSignOfSignatureMethodSupported mock is already set by Set")
	}

	if mmIsSignOfSignatureMethodSupported.defaultExpectation == nil {
		mmIsSignOfSignatureMethodSupported.defaultExpectation = &SignatureVerifierMockIsSignOfSignatureMethodSupportedExpectation{mock: mmIsSignOfSignatureMethodSupported.mock}
	}
	mmIsSignOfSignatureMethodSupported.defaultExpectation.results = &SignatureVerifierMockIsSignOfSignatureMethodSupportedResults{b1}
	return mmIsSignOfSignatureMethodSupported.mock
}

//Set uses given function f to mock the SignatureVerifier.IsSignOfSignatureMethodSupported method
func (mmIsSignOfSignatureMethodSupported *mSignatureVerifierMockIsSignOfSignatureMethodSupported) Set(f func(m SignatureMethod) (b1 bool)) *SignatureVerifierMock {
	if mmIsSignOfSignatureMethodSupported.defaultExpectation != nil {
		mmIsSignOfSignatureMethodSupported.mock.t.Fatalf("Default expectation is already set for the SignatureVerifier.IsSignOfSignatureMethodSupported method")
	}

	if len(mmIsSignOfSignatureMethodSupported.expectations) > 0 {
		mmIsSignOfSignatureMethodSupported.mock.t.Fatalf("Some expectations are already set for the SignatureVerifier.IsSignOfSignatureMethodSupported method")
	}

	mmIsSignOfSignatureMethodSupported.mock.funcIsSignOfSignatureMethodSupported = f
	return mmIsSignOfSignatureMethodSupported.mock
}

// When sets expectation for the SignatureVerifier.IsSignOfSignatureMethodSupported which will trigger the result defined by the following
// Then helper
func (mmIsSignOfSignatureMethodSupported *mSignatureVerifierMockIsSignOfSignatureMethodSupported) When(m SignatureMethod) *SignatureVerifierMockIsSignOfSignatureMethodSupportedExpectation {
	if mmIsSignOfSignatureMethodSupported.mock.funcIsSignOfSignatureMethodSupported != nil {
		mmIsSignOfSignatureMethodSupported.mock.t.Fatalf("SignatureVerifierMock.IsSignOfSignatureMethodSupported mock is already set by Set")
	}

	expectation := &SignatureVerifierMockIsSignOfSignatureMethodSupportedExpectation{
		mock:   mmIsSignOfSignatureMethodSupported.mock,
		params: &SignatureVerifierMockIsSignOfSignatureMethodSupportedParams{m},
	}
	mmIsSignOfSignatureMethodSupported.expectations = append(mmIsSignOfSignatureMethodSupported.expectations, expectation)
	return expectation
}

// Then sets up SignatureVerifier.IsSignOfSignatureMethodSupported return parameters for the expectation previously defined by the When method
func (e *SignatureVerifierMockIsSignOfSignatureMethodSupportedExpectation) Then(b1 bool) *SignatureVerifierMock {
	e.results = &SignatureVerifierMockIsSignOfSignatureMethodSupportedResults{b1}
	return e.mock
}

// IsSignOfSignatureMethodSupported implements SignatureVerifier
func (mmIsSignOfSignatureMethodSupported *SignatureVerifierMock) IsSignOfSignatureMethodSupported(m SignatureMethod) (b1 bool) {
	mm_atomic.AddUint64(&mmIsSignOfSignatureMethodSupported.beforeIsSignOfSignatureMethodSupportedCounter, 1)
	defer mm_atomic.AddUint64(&mmIsSignOfSignatureMethodSupported.afterIsSignOfSignatureMethodSupportedCounter, 1)

	if mmIsSignOfSignatureMethodSupported.inspectFuncIsSignOfSignatureMethodSupported != nil {
		mmIsSignOfSignatureMethodSupported.inspectFuncIsSignOfSignatureMethodSupported(m)
	}

	params := &SignatureVerifierMockIsSignOfSignatureMethodSupportedParams{m}

	// Record call args
	mmIsSignOfSignatureMethodSupported.IsSignOfSignatureMethodSupportedMock.mutex.Lock()
	mmIsSignOfSignatureMethodSupported.IsSignOfSignatureMethodSupportedMock.callArgs = append(mmIsSignOfSignatureMethodSupported.IsSignOfSignatureMethodSupportedMock.callArgs, params)
	mmIsSignOfSignatureMethodSupported.IsSignOfSignatureMethodSupportedMock.mutex.Unlock()

	for _, e := range mmIsSignOfSignatureMethodSupported.IsSignOfSignatureMethodSupportedMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmIsSignOfSignatureMethodSupported.IsSignOfSignatureMethodSupportedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsSignOfSignatureMethodSupported.IsSignOfSignatureMethodSupportedMock.defaultExpectation.Counter, 1)
		want := mmIsSignOfSignatureMethodSupported.IsSignOfSignatureMethodSupportedMock.defaultExpectation.params
		got := SignatureVerifierMockIsSignOfSignatureMethodSupportedParams{m}
		if want != nil && !minimock.Equal(*want, got) {
			mmIsSignOfSignatureMethodSupported.t.Errorf("SignatureVerifierMock.IsSignOfSignatureMethodSupported got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmIsSignOfSignatureMethodSupported.IsSignOfSignatureMethodSupportedMock.defaultExpectation.results
		if results == nil {
			mmIsSignOfSignatureMethodSupported.t.Fatal("No results are set for the SignatureVerifierMock.IsSignOfSignatureMethodSupported")
		}
		return (*results).b1
	}
	if mmIsSignOfSignatureMethodSupported.funcIsSignOfSignatureMethodSupported != nil {
		return mmIsSignOfSignatureMethodSupported.funcIsSignOfSignatureMethodSupported(m)
	}
	mmIsSignOfSignatureMethodSupported.t.Fatalf("Unexpected call to SignatureVerifierMock.IsSignOfSignatureMethodSupported. %v", m)
	return
}

// IsSignOfSignatureMethodSupportedAfterCounter returns a count of finished SignatureVerifierMock.IsSignOfSignatureMethodSupported invocations
func (mmIsSignOfSignatureMethodSupported *SignatureVerifierMock) IsSignOfSignatureMethodSupportedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsSignOfSignatureMethodSupported.afterIsSignOfSignatureMethodSupportedCounter)
}

// IsSignOfSignatureMethodSupportedBeforeCounter returns a count of SignatureVerifierMock.IsSignOfSignatureMethodSupported invocations
func (mmIsSignOfSignatureMethodSupported *SignatureVerifierMock) IsSignOfSignatureMethodSupportedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsSignOfSignatureMethodSupported.beforeIsSignOfSignatureMethodSupportedCounter)
}

// Calls returns a list of arguments used in each call to SignatureVerifierMock.IsSignOfSignatureMethodSupported.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsSignOfSignatureMethodSupported *mSignatureVerifierMockIsSignOfSignatureMethodSupported) Calls() []*SignatureVerifierMockIsSignOfSignatureMethodSupportedParams {
	mmIsSignOfSignatureMethodSupported.mutex.RLock()

	argCopy := make([]*SignatureVerifierMockIsSignOfSignatureMethodSupportedParams, len(mmIsSignOfSignatureMethodSupported.callArgs))
	copy(argCopy, mmIsSignOfSignatureMethodSupported.callArgs)

	mmIsSignOfSignatureMethodSupported.mutex.RUnlock()

	return argCopy
}

// MinimockIsSignOfSignatureMethodSupportedDone returns true if the count of the IsSignOfSignatureMethodSupported invocations corresponds
// the number of defined expectations
func (m *SignatureVerifierMock) MinimockIsSignOfSignatureMethodSupportedDone() bool {
	for _, e := range m.IsSignOfSignatureMethodSupportedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsSignOfSignatureMethodSupportedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsSignOfSignatureMethodSupportedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsSignOfSignatureMethodSupported != nil && mm_atomic.LoadUint64(&m.afterIsSignOfSignatureMethodSupportedCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsSignOfSignatureMethodSupportedInspect logs each unmet expectation
func (m *SignatureVerifierMock) MinimockIsSignOfSignatureMethodSupportedInspect() {
	for _, e := range m.IsSignOfSignatureMethodSupportedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SignatureVerifierMock.IsSignOfSignatureMethodSupported with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsSignOfSignatureMethodSupportedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsSignOfSignatureMethodSupportedCounter) < 1 {
		if m.IsSignOfSignatureMethodSupportedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SignatureVerifierMock.IsSignOfSignatureMethodSupported")
		} else {
			m.t.Errorf("Expected call to SignatureVerifierMock.IsSignOfSignatureMethodSupported with params: %#v", *m.IsSignOfSignatureMethodSupportedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsSignOfSignatureMethodSupported != nil && mm_atomic.LoadUint64(&m.afterIsSignOfSignatureMethodSupportedCounter) < 1 {
		m.t.Error("Expected call to SignatureVerifierMock.IsSignOfSignatureMethodSupported")
	}
}

type mSignatureVerifierMockIsValidDataSignature struct {
	mock               *SignatureVerifierMock
	defaultExpectation *SignatureVerifierMockIsValidDataSignatureExpectation
	expectations       []*SignatureVerifierMockIsValidDataSignatureExpectation

	callArgs []*SignatureVerifierMockIsValidDataSignatureParams
	mutex    sync.RWMutex
}

// SignatureVerifierMockIsValidDataSignatureExpectation specifies expectation struct of the SignatureVerifier.IsValidDataSignature
type SignatureVerifierMockIsValidDataSignatureExpectation struct {
	mock    *SignatureVerifierMock
	params  *SignatureVerifierMockIsValidDataSignatureParams
	results *SignatureVerifierMockIsValidDataSignatureResults
	Counter uint64
}

// SignatureVerifierMockIsValidDataSignatureParams contains parameters of the SignatureVerifier.IsValidDataSignature
type SignatureVerifierMockIsValidDataSignatureParams struct {
	data      io.Reader
	signature SignatureHolder
}

// SignatureVerifierMockIsValidDataSignatureResults contains results of the SignatureVerifier.IsValidDataSignature
type SignatureVerifierMockIsValidDataSignatureResults struct {
	b1 bool
}

// Expect sets up expected params for SignatureVerifier.IsValidDataSignature
func (mmIsValidDataSignature *mSignatureVerifierMockIsValidDataSignature) Expect(data io.Reader, signature SignatureHolder) *mSignatureVerifierMockIsValidDataSignature {
	if mmIsValidDataSignature.mock.funcIsValidDataSignature != nil {
		mmIsValidDataSignature.mock.t.Fatalf("SignatureVerifierMock.IsValidDataSignature mock is already set by Set")
	}

	if mmIsValidDataSignature.defaultExpectation == nil {
		mmIsValidDataSignature.defaultExpectation = &SignatureVerifierMockIsValidDataSignatureExpectation{}
	}

	mmIsValidDataSignature.defaultExpectation.params = &SignatureVerifierMockIsValidDataSignatureParams{data, signature}
	for _, e := range mmIsValidDataSignature.expectations {
		if minimock.Equal(e.params, mmIsValidDataSignature.defaultExpectation.params) {
			mmIsValidDataSignature.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsValidDataSignature.defaultExpectation.params)
		}
	}

	return mmIsValidDataSignature
}

// Inspect accepts an inspector function that has same arguments as the SignatureVerifier.IsValidDataSignature
func (mmIsValidDataSignature *mSignatureVerifierMockIsValidDataSignature) Inspect(f func(data io.Reader, signature SignatureHolder)) *mSignatureVerifierMockIsValidDataSignature {
	if mmIsValidDataSignature.mock.inspectFuncIsValidDataSignature != nil {
		mmIsValidDataSignature.mock.t.Fatalf("Inspect function is already set for SignatureVerifierMock.IsValidDataSignature")
	}

	mmIsValidDataSignature.mock.inspectFuncIsValidDataSignature = f

	return mmIsValidDataSignature
}

// Return sets up results that will be returned by SignatureVerifier.IsValidDataSignature
func (mmIsValidDataSignature *mSignatureVerifierMockIsValidDataSignature) Return(b1 bool) *SignatureVerifierMock {
	if mmIsValidDataSignature.mock.funcIsValidDataSignature != nil {
		mmIsValidDataSignature.mock.t.Fatalf("SignatureVerifierMock.IsValidDataSignature mock is already set by Set")
	}

	if mmIsValidDataSignature.defaultExpectation == nil {
		mmIsValidDataSignature.defaultExpectation = &SignatureVerifierMockIsValidDataSignatureExpectation{mock: mmIsValidDataSignature.mock}
	}
	mmIsValidDataSignature.defaultExpectation.results = &SignatureVerifierMockIsValidDataSignatureResults{b1}
	return mmIsValidDataSignature.mock
}

//Set uses given function f to mock the SignatureVerifier.IsValidDataSignature method
func (mmIsValidDataSignature *mSignatureVerifierMockIsValidDataSignature) Set(f func(data io.Reader, signature SignatureHolder) (b1 bool)) *SignatureVerifierMock {
	if mmIsValidDataSignature.defaultExpectation != nil {
		mmIsValidDataSignature.mock.t.Fatalf("Default expectation is already set for the SignatureVerifier.IsValidDataSignature method")
	}

	if len(mmIsValidDataSignature.expectations) > 0 {
		mmIsValidDataSignature.mock.t.Fatalf("Some expectations are already set for the SignatureVerifier.IsValidDataSignature method")
	}

	mmIsValidDataSignature.mock.funcIsValidDataSignature = f
	return mmIsValidDataSignature.mock
}

// When sets expectation for the SignatureVerifier.IsValidDataSignature which will trigger the result defined by the following
// Then helper
func (mmIsValidDataSignature *mSignatureVerifierMockIsValidDataSignature) When(data io.Reader, signature SignatureHolder) *SignatureVerifierMockIsValidDataSignatureExpectation {
	if mmIsValidDataSignature.mock.funcIsValidDataSignature != nil {
		mmIsValidDataSignature.mock.t.Fatalf("SignatureVerifierMock.IsValidDataSignature mock is already set by Set")
	}

	expectation := &SignatureVerifierMockIsValidDataSignatureExpectation{
		mock:   mmIsValidDataSignature.mock,
		params: &SignatureVerifierMockIsValidDataSignatureParams{data, signature},
	}
	mmIsValidDataSignature.expectations = append(mmIsValidDataSignature.expectations, expectation)
	return expectation
}

// Then sets up SignatureVerifier.IsValidDataSignature return parameters for the expectation previously defined by the When method
func (e *SignatureVerifierMockIsValidDataSignatureExpectation) Then(b1 bool) *SignatureVerifierMock {
	e.results = &SignatureVerifierMockIsValidDataSignatureResults{b1}
	return e.mock
}

// IsValidDataSignature implements SignatureVerifier
func (mmIsValidDataSignature *SignatureVerifierMock) IsValidDataSignature(data io.Reader, signature SignatureHolder) (b1 bool) {
	mm_atomic.AddUint64(&mmIsValidDataSignature.beforeIsValidDataSignatureCounter, 1)
	defer mm_atomic.AddUint64(&mmIsValidDataSignature.afterIsValidDataSignatureCounter, 1)

	if mmIsValidDataSignature.inspectFuncIsValidDataSignature != nil {
		mmIsValidDataSignature.inspectFuncIsValidDataSignature(data, signature)
	}

	params := &SignatureVerifierMockIsValidDataSignatureParams{data, signature}

	// Record call args
	mmIsValidDataSignature.IsValidDataSignatureMock.mutex.Lock()
	mmIsValidDataSignature.IsValidDataSignatureMock.callArgs = append(mmIsValidDataSignature.IsValidDataSignatureMock.callArgs, params)
	mmIsValidDataSignature.IsValidDataSignatureMock.mutex.Unlock()

	for _, e := range mmIsValidDataSignature.IsValidDataSignatureMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmIsValidDataSignature.IsValidDataSignatureMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsValidDataSignature.IsValidDataSignatureMock.defaultExpectation.Counter, 1)
		want := mmIsValidDataSignature.IsValidDataSignatureMock.defaultExpectation.params
		got := SignatureVerifierMockIsValidDataSignatureParams{data, signature}
		if want != nil && !minimock.Equal(*want, got) {
			mmIsValidDataSignature.t.Errorf("SignatureVerifierMock.IsValidDataSignature got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmIsValidDataSignature.IsValidDataSignatureMock.defaultExpectation.results
		if results == nil {
			mmIsValidDataSignature.t.Fatal("No results are set for the SignatureVerifierMock.IsValidDataSignature")
		}
		return (*results).b1
	}
	if mmIsValidDataSignature.funcIsValidDataSignature != nil {
		return mmIsValidDataSignature.funcIsValidDataSignature(data, signature)
	}
	mmIsValidDataSignature.t.Fatalf("Unexpected call to SignatureVerifierMock.IsValidDataSignature. %v %v", data, signature)
	return
}

// IsValidDataSignatureAfterCounter returns a count of finished SignatureVerifierMock.IsValidDataSignature invocations
func (mmIsValidDataSignature *SignatureVerifierMock) IsValidDataSignatureAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsValidDataSignature.afterIsValidDataSignatureCounter)
}

// IsValidDataSignatureBeforeCounter returns a count of SignatureVerifierMock.IsValidDataSignature invocations
func (mmIsValidDataSignature *SignatureVerifierMock) IsValidDataSignatureBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsValidDataSignature.beforeIsValidDataSignatureCounter)
}

// Calls returns a list of arguments used in each call to SignatureVerifierMock.IsValidDataSignature.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsValidDataSignature *mSignatureVerifierMockIsValidDataSignature) Calls() []*SignatureVerifierMockIsValidDataSignatureParams {
	mmIsValidDataSignature.mutex.RLock()

	argCopy := make([]*SignatureVerifierMockIsValidDataSignatureParams, len(mmIsValidDataSignature.callArgs))
	copy(argCopy, mmIsValidDataSignature.callArgs)

	mmIsValidDataSignature.mutex.RUnlock()

	return argCopy
}

// MinimockIsValidDataSignatureDone returns true if the count of the IsValidDataSignature invocations corresponds
// the number of defined expectations
func (m *SignatureVerifierMock) MinimockIsValidDataSignatureDone() bool {
	for _, e := range m.IsValidDataSignatureMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsValidDataSignatureMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsValidDataSignatureCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsValidDataSignature != nil && mm_atomic.LoadUint64(&m.afterIsValidDataSignatureCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsValidDataSignatureInspect logs each unmet expectation
func (m *SignatureVerifierMock) MinimockIsValidDataSignatureInspect() {
	for _, e := range m.IsValidDataSignatureMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SignatureVerifierMock.IsValidDataSignature with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsValidDataSignatureMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsValidDataSignatureCounter) < 1 {
		if m.IsValidDataSignatureMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SignatureVerifierMock.IsValidDataSignature")
		} else {
			m.t.Errorf("Expected call to SignatureVerifierMock.IsValidDataSignature with params: %#v", *m.IsValidDataSignatureMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsValidDataSignature != nil && mm_atomic.LoadUint64(&m.afterIsValidDataSignatureCounter) < 1 {
		m.t.Error("Expected call to SignatureVerifierMock.IsValidDataSignature")
	}
}

type mSignatureVerifierMockIsValidDigestSignature struct {
	mock               *SignatureVerifierMock
	defaultExpectation *SignatureVerifierMockIsValidDigestSignatureExpectation
	expectations       []*SignatureVerifierMockIsValidDigestSignatureExpectation

	callArgs []*SignatureVerifierMockIsValidDigestSignatureParams
	mutex    sync.RWMutex
}

// SignatureVerifierMockIsValidDigestSignatureExpectation specifies expectation struct of the SignatureVerifier.IsValidDigestSignature
type SignatureVerifierMockIsValidDigestSignatureExpectation struct {
	mock    *SignatureVerifierMock
	params  *SignatureVerifierMockIsValidDigestSignatureParams
	results *SignatureVerifierMockIsValidDigestSignatureResults
	Counter uint64
}

// SignatureVerifierMockIsValidDigestSignatureParams contains parameters of the SignatureVerifier.IsValidDigestSignature
type SignatureVerifierMockIsValidDigestSignatureParams struct {
	digest    DigestHolder
	signature SignatureHolder
}

// SignatureVerifierMockIsValidDigestSignatureResults contains results of the SignatureVerifier.IsValidDigestSignature
type SignatureVerifierMockIsValidDigestSignatureResults struct {
	b1 bool
}

// Expect sets up expected params for SignatureVerifier.IsValidDigestSignature
func (mmIsValidDigestSignature *mSignatureVerifierMockIsValidDigestSignature) Expect(digest DigestHolder, signature SignatureHolder) *mSignatureVerifierMockIsValidDigestSignature {
	if mmIsValidDigestSignature.mock.funcIsValidDigestSignature != nil {
		mmIsValidDigestSignature.mock.t.Fatalf("SignatureVerifierMock.IsValidDigestSignature mock is already set by Set")
	}

	if mmIsValidDigestSignature.defaultExpectation == nil {
		mmIsValidDigestSignature.defaultExpectation = &SignatureVerifierMockIsValidDigestSignatureExpectation{}
	}

	mmIsValidDigestSignature.defaultExpectation.params = &SignatureVerifierMockIsValidDigestSignatureParams{digest, signature}
	for _, e := range mmIsValidDigestSignature.expectations {
		if minimock.Equal(e.params, mmIsValidDigestSignature.defaultExpectation.params) {
			mmIsValidDigestSignature.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsValidDigestSignature.defaultExpectation.params)
		}
	}

	return mmIsValidDigestSignature
}

// Inspect accepts an inspector function that has same arguments as the SignatureVerifier.IsValidDigestSignature
func (mmIsValidDigestSignature *mSignatureVerifierMockIsValidDigestSignature) Inspect(f func(digest DigestHolder, signature SignatureHolder)) *mSignatureVerifierMockIsValidDigestSignature {
	if mmIsValidDigestSignature.mock.inspectFuncIsValidDigestSignature != nil {
		mmIsValidDigestSignature.mock.t.Fatalf("Inspect function is already set for SignatureVerifierMock.IsValidDigestSignature")
	}

	mmIsValidDigestSignature.mock.inspectFuncIsValidDigestSignature = f

	return mmIsValidDigestSignature
}

// Return sets up results that will be returned by SignatureVerifier.IsValidDigestSignature
func (mmIsValidDigestSignature *mSignatureVerifierMockIsValidDigestSignature) Return(b1 bool) *SignatureVerifierMock {
	if mmIsValidDigestSignature.mock.funcIsValidDigestSignature != nil {
		mmIsValidDigestSignature.mock.t.Fatalf("SignatureVerifierMock.IsValidDigestSignature mock is already set by Set")
	}

	if mmIsValidDigestSignature.defaultExpectation == nil {
		mmIsValidDigestSignature.defaultExpectation = &SignatureVerifierMockIsValidDigestSignatureExpectation{mock: mmIsValidDigestSignature.mock}
	}
	mmIsValidDigestSignature.defaultExpectation.results = &SignatureVerifierMockIsValidDigestSignatureResults{b1}
	return mmIsValidDigestSignature.mock
}

//Set uses given function f to mock the SignatureVerifier.IsValidDigestSignature method
func (mmIsValidDigestSignature *mSignatureVerifierMockIsValidDigestSignature) Set(f func(digest DigestHolder, signature SignatureHolder) (b1 bool)) *SignatureVerifierMock {
	if mmIsValidDigestSignature.defaultExpectation != nil {
		mmIsValidDigestSignature.mock.t.Fatalf("Default expectation is already set for the SignatureVerifier.IsValidDigestSignature method")
	}

	if len(mmIsValidDigestSignature.expectations) > 0 {
		mmIsValidDigestSignature.mock.t.Fatalf("Some expectations are already set for the SignatureVerifier.IsValidDigestSignature method")
	}

	mmIsValidDigestSignature.mock.funcIsValidDigestSignature = f
	return mmIsValidDigestSignature.mock
}

// When sets expectation for the SignatureVerifier.IsValidDigestSignature which will trigger the result defined by the following
// Then helper
func (mmIsValidDigestSignature *mSignatureVerifierMockIsValidDigestSignature) When(digest DigestHolder, signature SignatureHolder) *SignatureVerifierMockIsValidDigestSignatureExpectation {
	if mmIsValidDigestSignature.mock.funcIsValidDigestSignature != nil {
		mmIsValidDigestSignature.mock.t.Fatalf("SignatureVerifierMock.IsValidDigestSignature mock is already set by Set")
	}

	expectation := &SignatureVerifierMockIsValidDigestSignatureExpectation{
		mock:   mmIsValidDigestSignature.mock,
		params: &SignatureVerifierMockIsValidDigestSignatureParams{digest, signature},
	}
	mmIsValidDigestSignature.expectations = append(mmIsValidDigestSignature.expectations, expectation)
	return expectation
}

// Then sets up SignatureVerifier.IsValidDigestSignature return parameters for the expectation previously defined by the When method
func (e *SignatureVerifierMockIsValidDigestSignatureExpectation) Then(b1 bool) *SignatureVerifierMock {
	e.results = &SignatureVerifierMockIsValidDigestSignatureResults{b1}
	return e.mock
}

// IsValidDigestSignature implements SignatureVerifier
func (mmIsValidDigestSignature *SignatureVerifierMock) IsValidDigestSignature(digest DigestHolder, signature SignatureHolder) (b1 bool) {
	mm_atomic.AddUint64(&mmIsValidDigestSignature.beforeIsValidDigestSignatureCounter, 1)
	defer mm_atomic.AddUint64(&mmIsValidDigestSignature.afterIsValidDigestSignatureCounter, 1)

	if mmIsValidDigestSignature.inspectFuncIsValidDigestSignature != nil {
		mmIsValidDigestSignature.inspectFuncIsValidDigestSignature(digest, signature)
	}

	params := &SignatureVerifierMockIsValidDigestSignatureParams{digest, signature}

	// Record call args
	mmIsValidDigestSignature.IsValidDigestSignatureMock.mutex.Lock()
	mmIsValidDigestSignature.IsValidDigestSignatureMock.callArgs = append(mmIsValidDigestSignature.IsValidDigestSignatureMock.callArgs, params)
	mmIsValidDigestSignature.IsValidDigestSignatureMock.mutex.Unlock()

	for _, e := range mmIsValidDigestSignature.IsValidDigestSignatureMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmIsValidDigestSignature.IsValidDigestSignatureMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsValidDigestSignature.IsValidDigestSignatureMock.defaultExpectation.Counter, 1)
		want := mmIsValidDigestSignature.IsValidDigestSignatureMock.defaultExpectation.params
		got := SignatureVerifierMockIsValidDigestSignatureParams{digest, signature}
		if want != nil && !minimock.Equal(*want, got) {
			mmIsValidDigestSignature.t.Errorf("SignatureVerifierMock.IsValidDigestSignature got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmIsValidDigestSignature.IsValidDigestSignatureMock.defaultExpectation.results
		if results == nil {
			mmIsValidDigestSignature.t.Fatal("No results are set for the SignatureVerifierMock.IsValidDigestSignature")
		}
		return (*results).b1
	}
	if mmIsValidDigestSignature.funcIsValidDigestSignature != nil {
		return mmIsValidDigestSignature.funcIsValidDigestSignature(digest, signature)
	}
	mmIsValidDigestSignature.t.Fatalf("Unexpected call to SignatureVerifierMock.IsValidDigestSignature. %v %v", digest, signature)
	return
}

// IsValidDigestSignatureAfterCounter returns a count of finished SignatureVerifierMock.IsValidDigestSignature invocations
func (mmIsValidDigestSignature *SignatureVerifierMock) IsValidDigestSignatureAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsValidDigestSignature.afterIsValidDigestSignatureCounter)
}

// IsValidDigestSignatureBeforeCounter returns a count of SignatureVerifierMock.IsValidDigestSignature invocations
func (mmIsValidDigestSignature *SignatureVerifierMock) IsValidDigestSignatureBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsValidDigestSignature.beforeIsValidDigestSignatureCounter)
}

// Calls returns a list of arguments used in each call to SignatureVerifierMock.IsValidDigestSignature.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsValidDigestSignature *mSignatureVerifierMockIsValidDigestSignature) Calls() []*SignatureVerifierMockIsValidDigestSignatureParams {
	mmIsValidDigestSignature.mutex.RLock()

	argCopy := make([]*SignatureVerifierMockIsValidDigestSignatureParams, len(mmIsValidDigestSignature.callArgs))
	copy(argCopy, mmIsValidDigestSignature.callArgs)

	mmIsValidDigestSignature.mutex.RUnlock()

	return argCopy
}

// MinimockIsValidDigestSignatureDone returns true if the count of the IsValidDigestSignature invocations corresponds
// the number of defined expectations
func (m *SignatureVerifierMock) MinimockIsValidDigestSignatureDone() bool {
	for _, e := range m.IsValidDigestSignatureMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsValidDigestSignatureMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsValidDigestSignatureCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsValidDigestSignature != nil && mm_atomic.LoadUint64(&m.afterIsValidDigestSignatureCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsValidDigestSignatureInspect logs each unmet expectation
func (m *SignatureVerifierMock) MinimockIsValidDigestSignatureInspect() {
	for _, e := range m.IsValidDigestSignatureMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SignatureVerifierMock.IsValidDigestSignature with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsValidDigestSignatureMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsValidDigestSignatureCounter) < 1 {
		if m.IsValidDigestSignatureMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SignatureVerifierMock.IsValidDigestSignature")
		} else {
			m.t.Errorf("Expected call to SignatureVerifierMock.IsValidDigestSignature with params: %#v", *m.IsValidDigestSignatureMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsValidDigestSignature != nil && mm_atomic.LoadUint64(&m.afterIsValidDigestSignatureCounter) < 1 {
		m.t.Error("Expected call to SignatureVerifierMock.IsValidDigestSignature")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SignatureVerifierMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockIsDigestMethodSupportedInspect()

		m.MinimockIsSignMethodSupportedInspect()

		m.MinimockIsSignOfSignatureMethodSupportedInspect()

		m.MinimockIsValidDataSignatureInspect()

		m.MinimockIsValidDigestSignatureInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SignatureVerifierMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SignatureVerifierMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockIsDigestMethodSupportedDone() &&
		m.MinimockIsSignMethodSupportedDone() &&
		m.MinimockIsSignOfSignatureMethodSupportedDone() &&
		m.MinimockIsValidDataSignatureDone() &&
		m.MinimockIsValidDigestSignatureDone()
}
