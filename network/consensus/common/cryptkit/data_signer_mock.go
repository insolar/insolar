package cryptkit

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// DataSignerMock implements DataSigner
type DataSignerMock struct {
	t minimock.Tester

	funcGetDigestMethod          func() (d1 DigestMethod)
	inspectFuncGetDigestMethod   func()
	afterGetDigestMethodCounter  uint64
	beforeGetDigestMethodCounter uint64
	GetDigestMethodMock          mDataSignerMockGetDigestMethod

	funcGetDigestOf          func(reader io.Reader) (d1 Digest)
	inspectFuncGetDigestOf   func(reader io.Reader)
	afterGetDigestOfCounter  uint64
	beforeGetDigestOfCounter uint64
	GetDigestOfMock          mDataSignerMockGetDigestOf

	funcGetSignMethod          func() (s1 SignMethod)
	inspectFuncGetSignMethod   func()
	afterGetSignMethodCounter  uint64
	beforeGetSignMethodCounter uint64
	GetSignMethodMock          mDataSignerMockGetSignMethod

	funcGetSignatureMethod          func() (s1 SignatureMethod)
	inspectFuncGetSignatureMethod   func()
	afterGetSignatureMethodCounter  uint64
	beforeGetSignatureMethodCounter uint64
	GetSignatureMethodMock          mDataSignerMockGetSignatureMethod

	funcSignData          func(reader io.Reader) (s1 SignedDigest)
	inspectFuncSignData   func(reader io.Reader)
	afterSignDataCounter  uint64
	beforeSignDataCounter uint64
	SignDataMock          mDataSignerMockSignData

	funcSignDigest          func(digest Digest) (s1 Signature)
	inspectFuncSignDigest   func(digest Digest)
	afterSignDigestCounter  uint64
	beforeSignDigestCounter uint64
	SignDigestMock          mDataSignerMockSignDigest
}

// NewDataSignerMock returns a mock for DataSigner
func NewDataSignerMock(t minimock.Tester) *DataSignerMock {
	m := &DataSignerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetDigestMethodMock = mDataSignerMockGetDigestMethod{mock: m}

	m.GetDigestOfMock = mDataSignerMockGetDigestOf{mock: m}
	m.GetDigestOfMock.callArgs = []*DataSignerMockGetDigestOfParams{}

	m.GetSignMethodMock = mDataSignerMockGetSignMethod{mock: m}

	m.GetSignatureMethodMock = mDataSignerMockGetSignatureMethod{mock: m}

	m.SignDataMock = mDataSignerMockSignData{mock: m}
	m.SignDataMock.callArgs = []*DataSignerMockSignDataParams{}

	m.SignDigestMock = mDataSignerMockSignDigest{mock: m}
	m.SignDigestMock.callArgs = []*DataSignerMockSignDigestParams{}

	return m
}

type mDataSignerMockGetDigestMethod struct {
	mock               *DataSignerMock
	defaultExpectation *DataSignerMockGetDigestMethodExpectation
	expectations       []*DataSignerMockGetDigestMethodExpectation
}

// DataSignerMockGetDigestMethodExpectation specifies expectation struct of the DataSigner.GetDigestMethod
type DataSignerMockGetDigestMethodExpectation struct {
	mock *DataSignerMock

	results *DataSignerMockGetDigestMethodResults
	Counter uint64
}

// DataSignerMockGetDigestMethodResults contains results of the DataSigner.GetDigestMethod
type DataSignerMockGetDigestMethodResults struct {
	d1 DigestMethod
}

// Expect sets up expected params for DataSigner.GetDigestMethod
func (mmGetDigestMethod *mDataSignerMockGetDigestMethod) Expect() *mDataSignerMockGetDigestMethod {
	if mmGetDigestMethod.mock.funcGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("DataSignerMock.GetDigestMethod mock is already set by Set")
	}

	if mmGetDigestMethod.defaultExpectation == nil {
		mmGetDigestMethod.defaultExpectation = &DataSignerMockGetDigestMethodExpectation{}
	}

	return mmGetDigestMethod
}

// Inspect accepts an inspector function that has same arguments as the DataSigner.GetDigestMethod
func (mmGetDigestMethod *mDataSignerMockGetDigestMethod) Inspect(f func()) *mDataSignerMockGetDigestMethod {
	if mmGetDigestMethod.mock.inspectFuncGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("Inspect function is already set for DataSignerMock.GetDigestMethod")
	}

	mmGetDigestMethod.mock.inspectFuncGetDigestMethod = f

	return mmGetDigestMethod
}

// Return sets up results that will be returned by DataSigner.GetDigestMethod
func (mmGetDigestMethod *mDataSignerMockGetDigestMethod) Return(d1 DigestMethod) *DataSignerMock {
	if mmGetDigestMethod.mock.funcGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("DataSignerMock.GetDigestMethod mock is already set by Set")
	}

	if mmGetDigestMethod.defaultExpectation == nil {
		mmGetDigestMethod.defaultExpectation = &DataSignerMockGetDigestMethodExpectation{mock: mmGetDigestMethod.mock}
	}
	mmGetDigestMethod.defaultExpectation.results = &DataSignerMockGetDigestMethodResults{d1}
	return mmGetDigestMethod.mock
}

//Set uses given function f to mock the DataSigner.GetDigestMethod method
func (mmGetDigestMethod *mDataSignerMockGetDigestMethod) Set(f func() (d1 DigestMethod)) *DataSignerMock {
	if mmGetDigestMethod.defaultExpectation != nil {
		mmGetDigestMethod.mock.t.Fatalf("Default expectation is already set for the DataSigner.GetDigestMethod method")
	}

	if len(mmGetDigestMethod.expectations) > 0 {
		mmGetDigestMethod.mock.t.Fatalf("Some expectations are already set for the DataSigner.GetDigestMethod method")
	}

	mmGetDigestMethod.mock.funcGetDigestMethod = f
	return mmGetDigestMethod.mock
}

// GetDigestMethod implements DataSigner
func (mmGetDigestMethod *DataSignerMock) GetDigestMethod() (d1 DigestMethod) {
	mm_atomic.AddUint64(&mmGetDigestMethod.beforeGetDigestMethodCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDigestMethod.afterGetDigestMethodCounter, 1)

	if mmGetDigestMethod.inspectFuncGetDigestMethod != nil {
		mmGetDigestMethod.inspectFuncGetDigestMethod()
	}

	if mmGetDigestMethod.GetDigestMethodMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDigestMethod.GetDigestMethodMock.defaultExpectation.Counter, 1)

		mm_results := mmGetDigestMethod.GetDigestMethodMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDigestMethod.t.Fatal("No results are set for the DataSignerMock.GetDigestMethod")
		}
		return (*mm_results).d1
	}
	if mmGetDigestMethod.funcGetDigestMethod != nil {
		return mmGetDigestMethod.funcGetDigestMethod()
	}
	mmGetDigestMethod.t.Fatalf("Unexpected call to DataSignerMock.GetDigestMethod.")
	return
}

// GetDigestMethodAfterCounter returns a count of finished DataSignerMock.GetDigestMethod invocations
func (mmGetDigestMethod *DataSignerMock) GetDigestMethodAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestMethod.afterGetDigestMethodCounter)
}

// GetDigestMethodBeforeCounter returns a count of DataSignerMock.GetDigestMethod invocations
func (mmGetDigestMethod *DataSignerMock) GetDigestMethodBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestMethod.beforeGetDigestMethodCounter)
}

// MinimockGetDigestMethodDone returns true if the count of the GetDigestMethod invocations corresponds
// the number of defined expectations
func (m *DataSignerMock) MinimockGetDigestMethodDone() bool {
	for _, e := range m.GetDigestMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestMethod != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetDigestMethodInspect logs each unmet expectation
func (m *DataSignerMock) MinimockGetDigestMethodInspect() {
	for _, e := range m.GetDigestMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DataSignerMock.GetDigestMethod")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		m.t.Error("Expected call to DataSignerMock.GetDigestMethod")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestMethod != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		m.t.Error("Expected call to DataSignerMock.GetDigestMethod")
	}
}

type mDataSignerMockGetDigestOf struct {
	mock               *DataSignerMock
	defaultExpectation *DataSignerMockGetDigestOfExpectation
	expectations       []*DataSignerMockGetDigestOfExpectation

	callArgs []*DataSignerMockGetDigestOfParams
	mutex    sync.RWMutex
}

// DataSignerMockGetDigestOfExpectation specifies expectation struct of the DataSigner.GetDigestOf
type DataSignerMockGetDigestOfExpectation struct {
	mock    *DataSignerMock
	params  *DataSignerMockGetDigestOfParams
	results *DataSignerMockGetDigestOfResults
	Counter uint64
}

// DataSignerMockGetDigestOfParams contains parameters of the DataSigner.GetDigestOf
type DataSignerMockGetDigestOfParams struct {
	reader io.Reader
}

// DataSignerMockGetDigestOfResults contains results of the DataSigner.GetDigestOf
type DataSignerMockGetDigestOfResults struct {
	d1 Digest
}

// Expect sets up expected params for DataSigner.GetDigestOf
func (mmGetDigestOf *mDataSignerMockGetDigestOf) Expect(reader io.Reader) *mDataSignerMockGetDigestOf {
	if mmGetDigestOf.mock.funcGetDigestOf != nil {
		mmGetDigestOf.mock.t.Fatalf("DataSignerMock.GetDigestOf mock is already set by Set")
	}

	if mmGetDigestOf.defaultExpectation == nil {
		mmGetDigestOf.defaultExpectation = &DataSignerMockGetDigestOfExpectation{}
	}

	mmGetDigestOf.defaultExpectation.params = &DataSignerMockGetDigestOfParams{reader}
	for _, e := range mmGetDigestOf.expectations {
		if minimock.Equal(e.params, mmGetDigestOf.defaultExpectation.params) {
			mmGetDigestOf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetDigestOf.defaultExpectation.params)
		}
	}

	return mmGetDigestOf
}

// Inspect accepts an inspector function that has same arguments as the DataSigner.GetDigestOf
func (mmGetDigestOf *mDataSignerMockGetDigestOf) Inspect(f func(reader io.Reader)) *mDataSignerMockGetDigestOf {
	if mmGetDigestOf.mock.inspectFuncGetDigestOf != nil {
		mmGetDigestOf.mock.t.Fatalf("Inspect function is already set for DataSignerMock.GetDigestOf")
	}

	mmGetDigestOf.mock.inspectFuncGetDigestOf = f

	return mmGetDigestOf
}

// Return sets up results that will be returned by DataSigner.GetDigestOf
func (mmGetDigestOf *mDataSignerMockGetDigestOf) Return(d1 Digest) *DataSignerMock {
	if mmGetDigestOf.mock.funcGetDigestOf != nil {
		mmGetDigestOf.mock.t.Fatalf("DataSignerMock.GetDigestOf mock is already set by Set")
	}

	if mmGetDigestOf.defaultExpectation == nil {
		mmGetDigestOf.defaultExpectation = &DataSignerMockGetDigestOfExpectation{mock: mmGetDigestOf.mock}
	}
	mmGetDigestOf.defaultExpectation.results = &DataSignerMockGetDigestOfResults{d1}
	return mmGetDigestOf.mock
}

//Set uses given function f to mock the DataSigner.GetDigestOf method
func (mmGetDigestOf *mDataSignerMockGetDigestOf) Set(f func(reader io.Reader) (d1 Digest)) *DataSignerMock {
	if mmGetDigestOf.defaultExpectation != nil {
		mmGetDigestOf.mock.t.Fatalf("Default expectation is already set for the DataSigner.GetDigestOf method")
	}

	if len(mmGetDigestOf.expectations) > 0 {
		mmGetDigestOf.mock.t.Fatalf("Some expectations are already set for the DataSigner.GetDigestOf method")
	}

	mmGetDigestOf.mock.funcGetDigestOf = f
	return mmGetDigestOf.mock
}

// When sets expectation for the DataSigner.GetDigestOf which will trigger the result defined by the following
// Then helper
func (mmGetDigestOf *mDataSignerMockGetDigestOf) When(reader io.Reader) *DataSignerMockGetDigestOfExpectation {
	if mmGetDigestOf.mock.funcGetDigestOf != nil {
		mmGetDigestOf.mock.t.Fatalf("DataSignerMock.GetDigestOf mock is already set by Set")
	}

	expectation := &DataSignerMockGetDigestOfExpectation{
		mock:   mmGetDigestOf.mock,
		params: &DataSignerMockGetDigestOfParams{reader},
	}
	mmGetDigestOf.expectations = append(mmGetDigestOf.expectations, expectation)
	return expectation
}

// Then sets up DataSigner.GetDigestOf return parameters for the expectation previously defined by the When method
func (e *DataSignerMockGetDigestOfExpectation) Then(d1 Digest) *DataSignerMock {
	e.results = &DataSignerMockGetDigestOfResults{d1}
	return e.mock
}

// GetDigestOf implements DataSigner
func (mmGetDigestOf *DataSignerMock) GetDigestOf(reader io.Reader) (d1 Digest) {
	mm_atomic.AddUint64(&mmGetDigestOf.beforeGetDigestOfCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDigestOf.afterGetDigestOfCounter, 1)

	if mmGetDigestOf.inspectFuncGetDigestOf != nil {
		mmGetDigestOf.inspectFuncGetDigestOf(reader)
	}

	mm_params := &DataSignerMockGetDigestOfParams{reader}

	// Record call args
	mmGetDigestOf.GetDigestOfMock.mutex.Lock()
	mmGetDigestOf.GetDigestOfMock.callArgs = append(mmGetDigestOf.GetDigestOfMock.callArgs, mm_params)
	mmGetDigestOf.GetDigestOfMock.mutex.Unlock()

	for _, e := range mmGetDigestOf.GetDigestOfMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.d1
		}
	}

	if mmGetDigestOf.GetDigestOfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDigestOf.GetDigestOfMock.defaultExpectation.Counter, 1)
		mm_want := mmGetDigestOf.GetDigestOfMock.defaultExpectation.params
		mm_got := DataSignerMockGetDigestOfParams{reader}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetDigestOf.t.Errorf("DataSignerMock.GetDigestOf got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetDigestOf.GetDigestOfMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDigestOf.t.Fatal("No results are set for the DataSignerMock.GetDigestOf")
		}
		return (*mm_results).d1
	}
	if mmGetDigestOf.funcGetDigestOf != nil {
		return mmGetDigestOf.funcGetDigestOf(reader)
	}
	mmGetDigestOf.t.Fatalf("Unexpected call to DataSignerMock.GetDigestOf. %v", reader)
	return
}

// GetDigestOfAfterCounter returns a count of finished DataSignerMock.GetDigestOf invocations
func (mmGetDigestOf *DataSignerMock) GetDigestOfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestOf.afterGetDigestOfCounter)
}

// GetDigestOfBeforeCounter returns a count of DataSignerMock.GetDigestOf invocations
func (mmGetDigestOf *DataSignerMock) GetDigestOfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestOf.beforeGetDigestOfCounter)
}

// Calls returns a list of arguments used in each call to DataSignerMock.GetDigestOf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetDigestOf *mDataSignerMockGetDigestOf) Calls() []*DataSignerMockGetDigestOfParams {
	mmGetDigestOf.mutex.RLock()

	argCopy := make([]*DataSignerMockGetDigestOfParams, len(mmGetDigestOf.callArgs))
	copy(argCopy, mmGetDigestOf.callArgs)

	mmGetDigestOf.mutex.RUnlock()

	return argCopy
}

// MinimockGetDigestOfDone returns true if the count of the GetDigestOf invocations corresponds
// the number of defined expectations
func (m *DataSignerMock) MinimockGetDigestOfDone() bool {
	for _, e := range m.GetDigestOfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestOfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestOfCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestOf != nil && mm_atomic.LoadUint64(&m.afterGetDigestOfCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetDigestOfInspect logs each unmet expectation
func (m *DataSignerMock) MinimockGetDigestOfInspect() {
	for _, e := range m.GetDigestOfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DataSignerMock.GetDigestOf with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestOfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestOfCounter) < 1 {
		if m.GetDigestOfMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DataSignerMock.GetDigestOf")
		} else {
			m.t.Errorf("Expected call to DataSignerMock.GetDigestOf with params: %#v", *m.GetDigestOfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestOf != nil && mm_atomic.LoadUint64(&m.afterGetDigestOfCounter) < 1 {
		m.t.Error("Expected call to DataSignerMock.GetDigestOf")
	}
}

type mDataSignerMockGetSignMethod struct {
	mock               *DataSignerMock
	defaultExpectation *DataSignerMockGetSignMethodExpectation
	expectations       []*DataSignerMockGetSignMethodExpectation
}

// DataSignerMockGetSignMethodExpectation specifies expectation struct of the DataSigner.GetSignMethod
type DataSignerMockGetSignMethodExpectation struct {
	mock *DataSignerMock

	results *DataSignerMockGetSignMethodResults
	Counter uint64
}

// DataSignerMockGetSignMethodResults contains results of the DataSigner.GetSignMethod
type DataSignerMockGetSignMethodResults struct {
	s1 SignMethod
}

// Expect sets up expected params for DataSigner.GetSignMethod
func (mmGetSignMethod *mDataSignerMockGetSignMethod) Expect() *mDataSignerMockGetSignMethod {
	if mmGetSignMethod.mock.funcGetSignMethod != nil {
		mmGetSignMethod.mock.t.Fatalf("DataSignerMock.GetSignMethod mock is already set by Set")
	}

	if mmGetSignMethod.defaultExpectation == nil {
		mmGetSignMethod.defaultExpectation = &DataSignerMockGetSignMethodExpectation{}
	}

	return mmGetSignMethod
}

// Inspect accepts an inspector function that has same arguments as the DataSigner.GetSignMethod
func (mmGetSignMethod *mDataSignerMockGetSignMethod) Inspect(f func()) *mDataSignerMockGetSignMethod {
	if mmGetSignMethod.mock.inspectFuncGetSignMethod != nil {
		mmGetSignMethod.mock.t.Fatalf("Inspect function is already set for DataSignerMock.GetSignMethod")
	}

	mmGetSignMethod.mock.inspectFuncGetSignMethod = f

	return mmGetSignMethod
}

// Return sets up results that will be returned by DataSigner.GetSignMethod
func (mmGetSignMethod *mDataSignerMockGetSignMethod) Return(s1 SignMethod) *DataSignerMock {
	if mmGetSignMethod.mock.funcGetSignMethod != nil {
		mmGetSignMethod.mock.t.Fatalf("DataSignerMock.GetSignMethod mock is already set by Set")
	}

	if mmGetSignMethod.defaultExpectation == nil {
		mmGetSignMethod.defaultExpectation = &DataSignerMockGetSignMethodExpectation{mock: mmGetSignMethod.mock}
	}
	mmGetSignMethod.defaultExpectation.results = &DataSignerMockGetSignMethodResults{s1}
	return mmGetSignMethod.mock
}

//Set uses given function f to mock the DataSigner.GetSignMethod method
func (mmGetSignMethod *mDataSignerMockGetSignMethod) Set(f func() (s1 SignMethod)) *DataSignerMock {
	if mmGetSignMethod.defaultExpectation != nil {
		mmGetSignMethod.mock.t.Fatalf("Default expectation is already set for the DataSigner.GetSignMethod method")
	}

	if len(mmGetSignMethod.expectations) > 0 {
		mmGetSignMethod.mock.t.Fatalf("Some expectations are already set for the DataSigner.GetSignMethod method")
	}

	mmGetSignMethod.mock.funcGetSignMethod = f
	return mmGetSignMethod.mock
}

// GetSignMethod implements DataSigner
func (mmGetSignMethod *DataSignerMock) GetSignMethod() (s1 SignMethod) {
	mm_atomic.AddUint64(&mmGetSignMethod.beforeGetSignMethodCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSignMethod.afterGetSignMethodCounter, 1)

	if mmGetSignMethod.inspectFuncGetSignMethod != nil {
		mmGetSignMethod.inspectFuncGetSignMethod()
	}

	if mmGetSignMethod.GetSignMethodMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSignMethod.GetSignMethodMock.defaultExpectation.Counter, 1)

		mm_results := mmGetSignMethod.GetSignMethodMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSignMethod.t.Fatal("No results are set for the DataSignerMock.GetSignMethod")
		}
		return (*mm_results).s1
	}
	if mmGetSignMethod.funcGetSignMethod != nil {
		return mmGetSignMethod.funcGetSignMethod()
	}
	mmGetSignMethod.t.Fatalf("Unexpected call to DataSignerMock.GetSignMethod.")
	return
}

// GetSignMethodAfterCounter returns a count of finished DataSignerMock.GetSignMethod invocations
func (mmGetSignMethod *DataSignerMock) GetSignMethodAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSignMethod.afterGetSignMethodCounter)
}

// GetSignMethodBeforeCounter returns a count of DataSignerMock.GetSignMethod invocations
func (mmGetSignMethod *DataSignerMock) GetSignMethodBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSignMethod.beforeGetSignMethodCounter)
}

// MinimockGetSignMethodDone returns true if the count of the GetSignMethod invocations corresponds
// the number of defined expectations
func (m *DataSignerMock) MinimockGetSignMethodDone() bool {
	for _, e := range m.GetSignMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSignMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSignMethodCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSignMethod != nil && mm_atomic.LoadUint64(&m.afterGetSignMethodCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSignMethodInspect logs each unmet expectation
func (m *DataSignerMock) MinimockGetSignMethodInspect() {
	for _, e := range m.GetSignMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DataSignerMock.GetSignMethod")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSignMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSignMethodCounter) < 1 {
		m.t.Error("Expected call to DataSignerMock.GetSignMethod")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSignMethod != nil && mm_atomic.LoadUint64(&m.afterGetSignMethodCounter) < 1 {
		m.t.Error("Expected call to DataSignerMock.GetSignMethod")
	}
}

type mDataSignerMockGetSignatureMethod struct {
	mock               *DataSignerMock
	defaultExpectation *DataSignerMockGetSignatureMethodExpectation
	expectations       []*DataSignerMockGetSignatureMethodExpectation
}

// DataSignerMockGetSignatureMethodExpectation specifies expectation struct of the DataSigner.GetSignatureMethod
type DataSignerMockGetSignatureMethodExpectation struct {
	mock *DataSignerMock

	results *DataSignerMockGetSignatureMethodResults
	Counter uint64
}

// DataSignerMockGetSignatureMethodResults contains results of the DataSigner.GetSignatureMethod
type DataSignerMockGetSignatureMethodResults struct {
	s1 SignatureMethod
}

// Expect sets up expected params for DataSigner.GetSignatureMethod
func (mmGetSignatureMethod *mDataSignerMockGetSignatureMethod) Expect() *mDataSignerMockGetSignatureMethod {
	if mmGetSignatureMethod.mock.funcGetSignatureMethod != nil {
		mmGetSignatureMethod.mock.t.Fatalf("DataSignerMock.GetSignatureMethod mock is already set by Set")
	}

	if mmGetSignatureMethod.defaultExpectation == nil {
		mmGetSignatureMethod.defaultExpectation = &DataSignerMockGetSignatureMethodExpectation{}
	}

	return mmGetSignatureMethod
}

// Inspect accepts an inspector function that has same arguments as the DataSigner.GetSignatureMethod
func (mmGetSignatureMethod *mDataSignerMockGetSignatureMethod) Inspect(f func()) *mDataSignerMockGetSignatureMethod {
	if mmGetSignatureMethod.mock.inspectFuncGetSignatureMethod != nil {
		mmGetSignatureMethod.mock.t.Fatalf("Inspect function is already set for DataSignerMock.GetSignatureMethod")
	}

	mmGetSignatureMethod.mock.inspectFuncGetSignatureMethod = f

	return mmGetSignatureMethod
}

// Return sets up results that will be returned by DataSigner.GetSignatureMethod
func (mmGetSignatureMethod *mDataSignerMockGetSignatureMethod) Return(s1 SignatureMethod) *DataSignerMock {
	if mmGetSignatureMethod.mock.funcGetSignatureMethod != nil {
		mmGetSignatureMethod.mock.t.Fatalf("DataSignerMock.GetSignatureMethod mock is already set by Set")
	}

	if mmGetSignatureMethod.defaultExpectation == nil {
		mmGetSignatureMethod.defaultExpectation = &DataSignerMockGetSignatureMethodExpectation{mock: mmGetSignatureMethod.mock}
	}
	mmGetSignatureMethod.defaultExpectation.results = &DataSignerMockGetSignatureMethodResults{s1}
	return mmGetSignatureMethod.mock
}

//Set uses given function f to mock the DataSigner.GetSignatureMethod method
func (mmGetSignatureMethod *mDataSignerMockGetSignatureMethod) Set(f func() (s1 SignatureMethod)) *DataSignerMock {
	if mmGetSignatureMethod.defaultExpectation != nil {
		mmGetSignatureMethod.mock.t.Fatalf("Default expectation is already set for the DataSigner.GetSignatureMethod method")
	}

	if len(mmGetSignatureMethod.expectations) > 0 {
		mmGetSignatureMethod.mock.t.Fatalf("Some expectations are already set for the DataSigner.GetSignatureMethod method")
	}

	mmGetSignatureMethod.mock.funcGetSignatureMethod = f
	return mmGetSignatureMethod.mock
}

// GetSignatureMethod implements DataSigner
func (mmGetSignatureMethod *DataSignerMock) GetSignatureMethod() (s1 SignatureMethod) {
	mm_atomic.AddUint64(&mmGetSignatureMethod.beforeGetSignatureMethodCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSignatureMethod.afterGetSignatureMethodCounter, 1)

	if mmGetSignatureMethod.inspectFuncGetSignatureMethod != nil {
		mmGetSignatureMethod.inspectFuncGetSignatureMethod()
	}

	if mmGetSignatureMethod.GetSignatureMethodMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSignatureMethod.GetSignatureMethodMock.defaultExpectation.Counter, 1)

		mm_results := mmGetSignatureMethod.GetSignatureMethodMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSignatureMethod.t.Fatal("No results are set for the DataSignerMock.GetSignatureMethod")
		}
		return (*mm_results).s1
	}
	if mmGetSignatureMethod.funcGetSignatureMethod != nil {
		return mmGetSignatureMethod.funcGetSignatureMethod()
	}
	mmGetSignatureMethod.t.Fatalf("Unexpected call to DataSignerMock.GetSignatureMethod.")
	return
}

// GetSignatureMethodAfterCounter returns a count of finished DataSignerMock.GetSignatureMethod invocations
func (mmGetSignatureMethod *DataSignerMock) GetSignatureMethodAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSignatureMethod.afterGetSignatureMethodCounter)
}

// GetSignatureMethodBeforeCounter returns a count of DataSignerMock.GetSignatureMethod invocations
func (mmGetSignatureMethod *DataSignerMock) GetSignatureMethodBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSignatureMethod.beforeGetSignatureMethodCounter)
}

// MinimockGetSignatureMethodDone returns true if the count of the GetSignatureMethod invocations corresponds
// the number of defined expectations
func (m *DataSignerMock) MinimockGetSignatureMethodDone() bool {
	for _, e := range m.GetSignatureMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSignatureMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSignatureMethodCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSignatureMethod != nil && mm_atomic.LoadUint64(&m.afterGetSignatureMethodCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSignatureMethodInspect logs each unmet expectation
func (m *DataSignerMock) MinimockGetSignatureMethodInspect() {
	for _, e := range m.GetSignatureMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DataSignerMock.GetSignatureMethod")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSignatureMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSignatureMethodCounter) < 1 {
		m.t.Error("Expected call to DataSignerMock.GetSignatureMethod")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSignatureMethod != nil && mm_atomic.LoadUint64(&m.afterGetSignatureMethodCounter) < 1 {
		m.t.Error("Expected call to DataSignerMock.GetSignatureMethod")
	}
}

type mDataSignerMockSignData struct {
	mock               *DataSignerMock
	defaultExpectation *DataSignerMockSignDataExpectation
	expectations       []*DataSignerMockSignDataExpectation

	callArgs []*DataSignerMockSignDataParams
	mutex    sync.RWMutex
}

// DataSignerMockSignDataExpectation specifies expectation struct of the DataSigner.SignData
type DataSignerMockSignDataExpectation struct {
	mock    *DataSignerMock
	params  *DataSignerMockSignDataParams
	results *DataSignerMockSignDataResults
	Counter uint64
}

// DataSignerMockSignDataParams contains parameters of the DataSigner.SignData
type DataSignerMockSignDataParams struct {
	reader io.Reader
}

// DataSignerMockSignDataResults contains results of the DataSigner.SignData
type DataSignerMockSignDataResults struct {
	s1 SignedDigest
}

// Expect sets up expected params for DataSigner.SignData
func (mmSignData *mDataSignerMockSignData) Expect(reader io.Reader) *mDataSignerMockSignData {
	if mmSignData.mock.funcSignData != nil {
		mmSignData.mock.t.Fatalf("DataSignerMock.SignData mock is already set by Set")
	}

	if mmSignData.defaultExpectation == nil {
		mmSignData.defaultExpectation = &DataSignerMockSignDataExpectation{}
	}

	mmSignData.defaultExpectation.params = &DataSignerMockSignDataParams{reader}
	for _, e := range mmSignData.expectations {
		if minimock.Equal(e.params, mmSignData.defaultExpectation.params) {
			mmSignData.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSignData.defaultExpectation.params)
		}
	}

	return mmSignData
}

// Inspect accepts an inspector function that has same arguments as the DataSigner.SignData
func (mmSignData *mDataSignerMockSignData) Inspect(f func(reader io.Reader)) *mDataSignerMockSignData {
	if mmSignData.mock.inspectFuncSignData != nil {
		mmSignData.mock.t.Fatalf("Inspect function is already set for DataSignerMock.SignData")
	}

	mmSignData.mock.inspectFuncSignData = f

	return mmSignData
}

// Return sets up results that will be returned by DataSigner.SignData
func (mmSignData *mDataSignerMockSignData) Return(s1 SignedDigest) *DataSignerMock {
	if mmSignData.mock.funcSignData != nil {
		mmSignData.mock.t.Fatalf("DataSignerMock.SignData mock is already set by Set")
	}

	if mmSignData.defaultExpectation == nil {
		mmSignData.defaultExpectation = &DataSignerMockSignDataExpectation{mock: mmSignData.mock}
	}
	mmSignData.defaultExpectation.results = &DataSignerMockSignDataResults{s1}
	return mmSignData.mock
}

//Set uses given function f to mock the DataSigner.SignData method
func (mmSignData *mDataSignerMockSignData) Set(f func(reader io.Reader) (s1 SignedDigest)) *DataSignerMock {
	if mmSignData.defaultExpectation != nil {
		mmSignData.mock.t.Fatalf("Default expectation is already set for the DataSigner.SignData method")
	}

	if len(mmSignData.expectations) > 0 {
		mmSignData.mock.t.Fatalf("Some expectations are already set for the DataSigner.SignData method")
	}

	mmSignData.mock.funcSignData = f
	return mmSignData.mock
}

// When sets expectation for the DataSigner.SignData which will trigger the result defined by the following
// Then helper
func (mmSignData *mDataSignerMockSignData) When(reader io.Reader) *DataSignerMockSignDataExpectation {
	if mmSignData.mock.funcSignData != nil {
		mmSignData.mock.t.Fatalf("DataSignerMock.SignData mock is already set by Set")
	}

	expectation := &DataSignerMockSignDataExpectation{
		mock:   mmSignData.mock,
		params: &DataSignerMockSignDataParams{reader},
	}
	mmSignData.expectations = append(mmSignData.expectations, expectation)
	return expectation
}

// Then sets up DataSigner.SignData return parameters for the expectation previously defined by the When method
func (e *DataSignerMockSignDataExpectation) Then(s1 SignedDigest) *DataSignerMock {
	e.results = &DataSignerMockSignDataResults{s1}
	return e.mock
}

// SignData implements DataSigner
func (mmSignData *DataSignerMock) SignData(reader io.Reader) (s1 SignedDigest) {
	mm_atomic.AddUint64(&mmSignData.beforeSignDataCounter, 1)
	defer mm_atomic.AddUint64(&mmSignData.afterSignDataCounter, 1)

	if mmSignData.inspectFuncSignData != nil {
		mmSignData.inspectFuncSignData(reader)
	}

	mm_params := &DataSignerMockSignDataParams{reader}

	// Record call args
	mmSignData.SignDataMock.mutex.Lock()
	mmSignData.SignDataMock.callArgs = append(mmSignData.SignDataMock.callArgs, mm_params)
	mmSignData.SignDataMock.mutex.Unlock()

	for _, e := range mmSignData.SignDataMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmSignData.SignDataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSignData.SignDataMock.defaultExpectation.Counter, 1)
		mm_want := mmSignData.SignDataMock.defaultExpectation.params
		mm_got := DataSignerMockSignDataParams{reader}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSignData.t.Errorf("DataSignerMock.SignData got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSignData.SignDataMock.defaultExpectation.results
		if mm_results == nil {
			mmSignData.t.Fatal("No results are set for the DataSignerMock.SignData")
		}
		return (*mm_results).s1
	}
	if mmSignData.funcSignData != nil {
		return mmSignData.funcSignData(reader)
	}
	mmSignData.t.Fatalf("Unexpected call to DataSignerMock.SignData. %v", reader)
	return
}

// SignDataAfterCounter returns a count of finished DataSignerMock.SignData invocations
func (mmSignData *DataSignerMock) SignDataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSignData.afterSignDataCounter)
}

// SignDataBeforeCounter returns a count of DataSignerMock.SignData invocations
func (mmSignData *DataSignerMock) SignDataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSignData.beforeSignDataCounter)
}

// Calls returns a list of arguments used in each call to DataSignerMock.SignData.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSignData *mDataSignerMockSignData) Calls() []*DataSignerMockSignDataParams {
	mmSignData.mutex.RLock()

	argCopy := make([]*DataSignerMockSignDataParams, len(mmSignData.callArgs))
	copy(argCopy, mmSignData.callArgs)

	mmSignData.mutex.RUnlock()

	return argCopy
}

// MinimockSignDataDone returns true if the count of the SignData invocations corresponds
// the number of defined expectations
func (m *DataSignerMock) MinimockSignDataDone() bool {
	for _, e := range m.SignDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SignDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSignDataCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSignData != nil && mm_atomic.LoadUint64(&m.afterSignDataCounter) < 1 {
		return false
	}
	return true
}

// MinimockSignDataInspect logs each unmet expectation
func (m *DataSignerMock) MinimockSignDataInspect() {
	for _, e := range m.SignDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DataSignerMock.SignData with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SignDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSignDataCounter) < 1 {
		if m.SignDataMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DataSignerMock.SignData")
		} else {
			m.t.Errorf("Expected call to DataSignerMock.SignData with params: %#v", *m.SignDataMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSignData != nil && mm_atomic.LoadUint64(&m.afterSignDataCounter) < 1 {
		m.t.Error("Expected call to DataSignerMock.SignData")
	}
}

type mDataSignerMockSignDigest struct {
	mock               *DataSignerMock
	defaultExpectation *DataSignerMockSignDigestExpectation
	expectations       []*DataSignerMockSignDigestExpectation

	callArgs []*DataSignerMockSignDigestParams
	mutex    sync.RWMutex
}

// DataSignerMockSignDigestExpectation specifies expectation struct of the DataSigner.SignDigest
type DataSignerMockSignDigestExpectation struct {
	mock    *DataSignerMock
	params  *DataSignerMockSignDigestParams
	results *DataSignerMockSignDigestResults
	Counter uint64
}

// DataSignerMockSignDigestParams contains parameters of the DataSigner.SignDigest
type DataSignerMockSignDigestParams struct {
	digest Digest
}

// DataSignerMockSignDigestResults contains results of the DataSigner.SignDigest
type DataSignerMockSignDigestResults struct {
	s1 Signature
}

// Expect sets up expected params for DataSigner.SignDigest
func (mmSignDigest *mDataSignerMockSignDigest) Expect(digest Digest) *mDataSignerMockSignDigest {
	if mmSignDigest.mock.funcSignDigest != nil {
		mmSignDigest.mock.t.Fatalf("DataSignerMock.SignDigest mock is already set by Set")
	}

	if mmSignDigest.defaultExpectation == nil {
		mmSignDigest.defaultExpectation = &DataSignerMockSignDigestExpectation{}
	}

	mmSignDigest.defaultExpectation.params = &DataSignerMockSignDigestParams{digest}
	for _, e := range mmSignDigest.expectations {
		if minimock.Equal(e.params, mmSignDigest.defaultExpectation.params) {
			mmSignDigest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSignDigest.defaultExpectation.params)
		}
	}

	return mmSignDigest
}

// Inspect accepts an inspector function that has same arguments as the DataSigner.SignDigest
func (mmSignDigest *mDataSignerMockSignDigest) Inspect(f func(digest Digest)) *mDataSignerMockSignDigest {
	if mmSignDigest.mock.inspectFuncSignDigest != nil {
		mmSignDigest.mock.t.Fatalf("Inspect function is already set for DataSignerMock.SignDigest")
	}

	mmSignDigest.mock.inspectFuncSignDigest = f

	return mmSignDigest
}

// Return sets up results that will be returned by DataSigner.SignDigest
func (mmSignDigest *mDataSignerMockSignDigest) Return(s1 Signature) *DataSignerMock {
	if mmSignDigest.mock.funcSignDigest != nil {
		mmSignDigest.mock.t.Fatalf("DataSignerMock.SignDigest mock is already set by Set")
	}

	if mmSignDigest.defaultExpectation == nil {
		mmSignDigest.defaultExpectation = &DataSignerMockSignDigestExpectation{mock: mmSignDigest.mock}
	}
	mmSignDigest.defaultExpectation.results = &DataSignerMockSignDigestResults{s1}
	return mmSignDigest.mock
}

//Set uses given function f to mock the DataSigner.SignDigest method
func (mmSignDigest *mDataSignerMockSignDigest) Set(f func(digest Digest) (s1 Signature)) *DataSignerMock {
	if mmSignDigest.defaultExpectation != nil {
		mmSignDigest.mock.t.Fatalf("Default expectation is already set for the DataSigner.SignDigest method")
	}

	if len(mmSignDigest.expectations) > 0 {
		mmSignDigest.mock.t.Fatalf("Some expectations are already set for the DataSigner.SignDigest method")
	}

	mmSignDigest.mock.funcSignDigest = f
	return mmSignDigest.mock
}

// When sets expectation for the DataSigner.SignDigest which will trigger the result defined by the following
// Then helper
func (mmSignDigest *mDataSignerMockSignDigest) When(digest Digest) *DataSignerMockSignDigestExpectation {
	if mmSignDigest.mock.funcSignDigest != nil {
		mmSignDigest.mock.t.Fatalf("DataSignerMock.SignDigest mock is already set by Set")
	}

	expectation := &DataSignerMockSignDigestExpectation{
		mock:   mmSignDigest.mock,
		params: &DataSignerMockSignDigestParams{digest},
	}
	mmSignDigest.expectations = append(mmSignDigest.expectations, expectation)
	return expectation
}

// Then sets up DataSigner.SignDigest return parameters for the expectation previously defined by the When method
func (e *DataSignerMockSignDigestExpectation) Then(s1 Signature) *DataSignerMock {
	e.results = &DataSignerMockSignDigestResults{s1}
	return e.mock
}

// SignDigest implements DataSigner
func (mmSignDigest *DataSignerMock) SignDigest(digest Digest) (s1 Signature) {
	mm_atomic.AddUint64(&mmSignDigest.beforeSignDigestCounter, 1)
	defer mm_atomic.AddUint64(&mmSignDigest.afterSignDigestCounter, 1)

	if mmSignDigest.inspectFuncSignDigest != nil {
		mmSignDigest.inspectFuncSignDigest(digest)
	}

	mm_params := &DataSignerMockSignDigestParams{digest}

	// Record call args
	mmSignDigest.SignDigestMock.mutex.Lock()
	mmSignDigest.SignDigestMock.callArgs = append(mmSignDigest.SignDigestMock.callArgs, mm_params)
	mmSignDigest.SignDigestMock.mutex.Unlock()

	for _, e := range mmSignDigest.SignDigestMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmSignDigest.SignDigestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSignDigest.SignDigestMock.defaultExpectation.Counter, 1)
		mm_want := mmSignDigest.SignDigestMock.defaultExpectation.params
		mm_got := DataSignerMockSignDigestParams{digest}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSignDigest.t.Errorf("DataSignerMock.SignDigest got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSignDigest.SignDigestMock.defaultExpectation.results
		if mm_results == nil {
			mmSignDigest.t.Fatal("No results are set for the DataSignerMock.SignDigest")
		}
		return (*mm_results).s1
	}
	if mmSignDigest.funcSignDigest != nil {
		return mmSignDigest.funcSignDigest(digest)
	}
	mmSignDigest.t.Fatalf("Unexpected call to DataSignerMock.SignDigest. %v", digest)
	return
}

// SignDigestAfterCounter returns a count of finished DataSignerMock.SignDigest invocations
func (mmSignDigest *DataSignerMock) SignDigestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSignDigest.afterSignDigestCounter)
}

// SignDigestBeforeCounter returns a count of DataSignerMock.SignDigest invocations
func (mmSignDigest *DataSignerMock) SignDigestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSignDigest.beforeSignDigestCounter)
}

// Calls returns a list of arguments used in each call to DataSignerMock.SignDigest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSignDigest *mDataSignerMockSignDigest) Calls() []*DataSignerMockSignDigestParams {
	mmSignDigest.mutex.RLock()

	argCopy := make([]*DataSignerMockSignDigestParams, len(mmSignDigest.callArgs))
	copy(argCopy, mmSignDigest.callArgs)

	mmSignDigest.mutex.RUnlock()

	return argCopy
}

// MinimockSignDigestDone returns true if the count of the SignDigest invocations corresponds
// the number of defined expectations
func (m *DataSignerMock) MinimockSignDigestDone() bool {
	for _, e := range m.SignDigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SignDigestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSignDigestCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSignDigest != nil && mm_atomic.LoadUint64(&m.afterSignDigestCounter) < 1 {
		return false
	}
	return true
}

// MinimockSignDigestInspect logs each unmet expectation
func (m *DataSignerMock) MinimockSignDigestInspect() {
	for _, e := range m.SignDigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DataSignerMock.SignDigest with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SignDigestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSignDigestCounter) < 1 {
		if m.SignDigestMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DataSignerMock.SignDigest")
		} else {
			m.t.Errorf("Expected call to DataSignerMock.SignDigest with params: %#v", *m.SignDigestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSignDigest != nil && mm_atomic.LoadUint64(&m.afterSignDigestCounter) < 1 {
		m.t.Error("Expected call to DataSignerMock.SignDigest")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *DataSignerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetDigestMethodInspect()

		m.MinimockGetDigestOfInspect()

		m.MinimockGetSignMethodInspect()

		m.MinimockGetSignatureMethodInspect()

		m.MinimockSignDataInspect()

		m.MinimockSignDigestInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *DataSignerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *DataSignerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetDigestMethodDone() &&
		m.MinimockGetDigestOfDone() &&
		m.MinimockGetSignMethodDone() &&
		m.MinimockGetSignatureMethodDone() &&
		m.MinimockSignDataDone() &&
		m.MinimockSignDigestDone()
}
