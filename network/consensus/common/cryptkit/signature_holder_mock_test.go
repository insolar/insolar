package cryptkit

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/longbits"
)

// SignatureHolderMock implements SignatureHolder
type SignatureHolderMock struct {
	t minimock.Tester

	funcAsByteString          func() (b1 longbits.ByteString)
	inspectFuncAsByteString   func()
	afterAsByteStringCounter  uint64
	beforeAsByteStringCounter uint64
	AsByteStringMock          mSignatureHolderMockAsByteString

	funcAsBytes          func() (ba1 []byte)
	inspectFuncAsBytes   func()
	afterAsBytesCounter  uint64
	beforeAsBytesCounter uint64
	AsBytesMock          mSignatureHolderMockAsBytes

	funcCopyOfSignature          func() (s1 Signature)
	inspectFuncCopyOfSignature   func()
	afterCopyOfSignatureCounter  uint64
	beforeCopyOfSignatureCounter uint64
	CopyOfSignatureMock          mSignatureHolderMockCopyOfSignature

	funcEquals          func(other SignatureHolder) (b1 bool)
	inspectFuncEquals   func(other SignatureHolder)
	afterEqualsCounter  uint64
	beforeEqualsCounter uint64
	EqualsMock          mSignatureHolderMockEquals

	funcFixedByteSize          func() (i1 int)
	inspectFuncFixedByteSize   func()
	afterFixedByteSizeCounter  uint64
	beforeFixedByteSizeCounter uint64
	FixedByteSizeMock          mSignatureHolderMockFixedByteSize

	funcFoldToUint64          func() (u1 uint64)
	inspectFuncFoldToUint64   func()
	afterFoldToUint64Counter  uint64
	beforeFoldToUint64Counter uint64
	FoldToUint64Mock          mSignatureHolderMockFoldToUint64

	funcGetSignatureMethod          func() (s1 SignatureMethod)
	inspectFuncGetSignatureMethod   func()
	afterGetSignatureMethodCounter  uint64
	beforeGetSignatureMethodCounter uint64
	GetSignatureMethodMock          mSignatureHolderMockGetSignatureMethod

	funcRead          func(p []byte) (n int, err error)
	inspectFuncRead   func(p []byte)
	afterReadCounter  uint64
	beforeReadCounter uint64
	ReadMock          mSignatureHolderMockRead

	funcWriteTo          func(w io.Writer) (n int64, err error)
	inspectFuncWriteTo   func(w io.Writer)
	afterWriteToCounter  uint64
	beforeWriteToCounter uint64
	WriteToMock          mSignatureHolderMockWriteTo
}

// NewSignatureHolderMock returns a mock for SignatureHolder
func NewSignatureHolderMock(t minimock.Tester) *SignatureHolderMock {
	m := &SignatureHolderMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AsByteStringMock = mSignatureHolderMockAsByteString{mock: m}

	m.AsBytesMock = mSignatureHolderMockAsBytes{mock: m}

	m.CopyOfSignatureMock = mSignatureHolderMockCopyOfSignature{mock: m}

	m.EqualsMock = mSignatureHolderMockEquals{mock: m}
	m.EqualsMock.callArgs = []*SignatureHolderMockEqualsParams{}

	m.FixedByteSizeMock = mSignatureHolderMockFixedByteSize{mock: m}

	m.FoldToUint64Mock = mSignatureHolderMockFoldToUint64{mock: m}

	m.GetSignatureMethodMock = mSignatureHolderMockGetSignatureMethod{mock: m}

	m.ReadMock = mSignatureHolderMockRead{mock: m}
	m.ReadMock.callArgs = []*SignatureHolderMockReadParams{}

	m.WriteToMock = mSignatureHolderMockWriteTo{mock: m}
	m.WriteToMock.callArgs = []*SignatureHolderMockWriteToParams{}

	return m
}

type mSignatureHolderMockAsByteString struct {
	mock               *SignatureHolderMock
	defaultExpectation *SignatureHolderMockAsByteStringExpectation
	expectations       []*SignatureHolderMockAsByteStringExpectation
}

// SignatureHolderMockAsByteStringExpectation specifies expectation struct of the SignatureHolder.AsByteString
type SignatureHolderMockAsByteStringExpectation struct {
	mock *SignatureHolderMock

	results *SignatureHolderMockAsByteStringResults
	Counter uint64
}

// SignatureHolderMockAsByteStringResults contains results of the SignatureHolder.AsByteString
type SignatureHolderMockAsByteStringResults struct {
	b1 longbits.ByteString
}

// Expect sets up expected params for SignatureHolder.AsByteString
func (mmAsByteString *mSignatureHolderMockAsByteString) Expect() *mSignatureHolderMockAsByteString {
	if mmAsByteString.mock.funcAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("SignatureHolderMock.AsByteString mock is already set by Set")
	}

	if mmAsByteString.defaultExpectation == nil {
		mmAsByteString.defaultExpectation = &SignatureHolderMockAsByteStringExpectation{}
	}

	return mmAsByteString
}

// Inspect accepts an inspector function that has same arguments as the SignatureHolder.AsByteString
func (mmAsByteString *mSignatureHolderMockAsByteString) Inspect(f func()) *mSignatureHolderMockAsByteString {
	if mmAsByteString.mock.inspectFuncAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("Inspect function is already set for SignatureHolderMock.AsByteString")
	}

	mmAsByteString.mock.inspectFuncAsByteString = f

	return mmAsByteString
}

// Return sets up results that will be returned by SignatureHolder.AsByteString
func (mmAsByteString *mSignatureHolderMockAsByteString) Return(b1 longbits.ByteString) *SignatureHolderMock {
	if mmAsByteString.mock.funcAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("SignatureHolderMock.AsByteString mock is already set by Set")
	}

	if mmAsByteString.defaultExpectation == nil {
		mmAsByteString.defaultExpectation = &SignatureHolderMockAsByteStringExpectation{mock: mmAsByteString.mock}
	}
	mmAsByteString.defaultExpectation.results = &SignatureHolderMockAsByteStringResults{b1}
	return mmAsByteString.mock
}

//Set uses given function f to mock the SignatureHolder.AsByteString method
func (mmAsByteString *mSignatureHolderMockAsByteString) Set(f func() (b1 longbits.ByteString)) *SignatureHolderMock {
	if mmAsByteString.defaultExpectation != nil {
		mmAsByteString.mock.t.Fatalf("Default expectation is already set for the SignatureHolder.AsByteString method")
	}

	if len(mmAsByteString.expectations) > 0 {
		mmAsByteString.mock.t.Fatalf("Some expectations are already set for the SignatureHolder.AsByteString method")
	}

	mmAsByteString.mock.funcAsByteString = f
	return mmAsByteString.mock
}

// AsByteString implements SignatureHolder
func (mmAsByteString *SignatureHolderMock) AsByteString() (b1 longbits.ByteString) {
	mm_atomic.AddUint64(&mmAsByteString.beforeAsByteStringCounter, 1)
	defer mm_atomic.AddUint64(&mmAsByteString.afterAsByteStringCounter, 1)

	if mmAsByteString.inspectFuncAsByteString != nil {
		mmAsByteString.inspectFuncAsByteString()
	}

	if mmAsByteString.AsByteStringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAsByteString.AsByteStringMock.defaultExpectation.Counter, 1)

		results := mmAsByteString.AsByteStringMock.defaultExpectation.results
		if results == nil {
			mmAsByteString.t.Fatal("No results are set for the SignatureHolderMock.AsByteString")
		}
		return (*results).b1
	}
	if mmAsByteString.funcAsByteString != nil {
		return mmAsByteString.funcAsByteString()
	}
	mmAsByteString.t.Fatalf("Unexpected call to SignatureHolderMock.AsByteString.")
	return
}

// AsByteStringAfterCounter returns a count of finished SignatureHolderMock.AsByteString invocations
func (mmAsByteString *SignatureHolderMock) AsByteStringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsByteString.afterAsByteStringCounter)
}

// AsByteStringBeforeCounter returns a count of SignatureHolderMock.AsByteString invocations
func (mmAsByteString *SignatureHolderMock) AsByteStringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsByteString.beforeAsByteStringCounter)
}

// MinimockAsByteStringDone returns true if the count of the AsByteString invocations corresponds
// the number of defined expectations
func (m *SignatureHolderMock) MinimockAsByteStringDone() bool {
	for _, e := range m.AsByteStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsByteStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsByteString != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		return false
	}
	return true
}

// MinimockAsByteStringInspect logs each unmet expectation
func (m *SignatureHolderMock) MinimockAsByteStringInspect() {
	for _, e := range m.AsByteStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SignatureHolderMock.AsByteString")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsByteStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		m.t.Error("Expected call to SignatureHolderMock.AsByteString")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsByteString != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		m.t.Error("Expected call to SignatureHolderMock.AsByteString")
	}
}

type mSignatureHolderMockAsBytes struct {
	mock               *SignatureHolderMock
	defaultExpectation *SignatureHolderMockAsBytesExpectation
	expectations       []*SignatureHolderMockAsBytesExpectation
}

// SignatureHolderMockAsBytesExpectation specifies expectation struct of the SignatureHolder.AsBytes
type SignatureHolderMockAsBytesExpectation struct {
	mock *SignatureHolderMock

	results *SignatureHolderMockAsBytesResults
	Counter uint64
}

// SignatureHolderMockAsBytesResults contains results of the SignatureHolder.AsBytes
type SignatureHolderMockAsBytesResults struct {
	ba1 []byte
}

// Expect sets up expected params for SignatureHolder.AsBytes
func (mmAsBytes *mSignatureHolderMockAsBytes) Expect() *mSignatureHolderMockAsBytes {
	if mmAsBytes.mock.funcAsBytes != nil {
		mmAsBytes.mock.t.Fatalf("SignatureHolderMock.AsBytes mock is already set by Set")
	}

	if mmAsBytes.defaultExpectation == nil {
		mmAsBytes.defaultExpectation = &SignatureHolderMockAsBytesExpectation{}
	}

	return mmAsBytes
}

// Inspect accepts an inspector function that has same arguments as the SignatureHolder.AsBytes
func (mmAsBytes *mSignatureHolderMockAsBytes) Inspect(f func()) *mSignatureHolderMockAsBytes {
	if mmAsBytes.mock.inspectFuncAsBytes != nil {
		mmAsBytes.mock.t.Fatalf("Inspect function is already set for SignatureHolderMock.AsBytes")
	}

	mmAsBytes.mock.inspectFuncAsBytes = f

	return mmAsBytes
}

// Return sets up results that will be returned by SignatureHolder.AsBytes
func (mmAsBytes *mSignatureHolderMockAsBytes) Return(ba1 []byte) *SignatureHolderMock {
	if mmAsBytes.mock.funcAsBytes != nil {
		mmAsBytes.mock.t.Fatalf("SignatureHolderMock.AsBytes mock is already set by Set")
	}

	if mmAsBytes.defaultExpectation == nil {
		mmAsBytes.defaultExpectation = &SignatureHolderMockAsBytesExpectation{mock: mmAsBytes.mock}
	}
	mmAsBytes.defaultExpectation.results = &SignatureHolderMockAsBytesResults{ba1}
	return mmAsBytes.mock
}

//Set uses given function f to mock the SignatureHolder.AsBytes method
func (mmAsBytes *mSignatureHolderMockAsBytes) Set(f func() (ba1 []byte)) *SignatureHolderMock {
	if mmAsBytes.defaultExpectation != nil {
		mmAsBytes.mock.t.Fatalf("Default expectation is already set for the SignatureHolder.AsBytes method")
	}

	if len(mmAsBytes.expectations) > 0 {
		mmAsBytes.mock.t.Fatalf("Some expectations are already set for the SignatureHolder.AsBytes method")
	}

	mmAsBytes.mock.funcAsBytes = f
	return mmAsBytes.mock
}

// AsBytes implements SignatureHolder
func (mmAsBytes *SignatureHolderMock) AsBytes() (ba1 []byte) {
	mm_atomic.AddUint64(&mmAsBytes.beforeAsBytesCounter, 1)
	defer mm_atomic.AddUint64(&mmAsBytes.afterAsBytesCounter, 1)

	if mmAsBytes.inspectFuncAsBytes != nil {
		mmAsBytes.inspectFuncAsBytes()
	}

	if mmAsBytes.AsBytesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAsBytes.AsBytesMock.defaultExpectation.Counter, 1)

		results := mmAsBytes.AsBytesMock.defaultExpectation.results
		if results == nil {
			mmAsBytes.t.Fatal("No results are set for the SignatureHolderMock.AsBytes")
		}
		return (*results).ba1
	}
	if mmAsBytes.funcAsBytes != nil {
		return mmAsBytes.funcAsBytes()
	}
	mmAsBytes.t.Fatalf("Unexpected call to SignatureHolderMock.AsBytes.")
	return
}

// AsBytesAfterCounter returns a count of finished SignatureHolderMock.AsBytes invocations
func (mmAsBytes *SignatureHolderMock) AsBytesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsBytes.afterAsBytesCounter)
}

// AsBytesBeforeCounter returns a count of SignatureHolderMock.AsBytes invocations
func (mmAsBytes *SignatureHolderMock) AsBytesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsBytes.beforeAsBytesCounter)
}

// MinimockAsBytesDone returns true if the count of the AsBytes invocations corresponds
// the number of defined expectations
func (m *SignatureHolderMock) MinimockAsBytesDone() bool {
	for _, e := range m.AsBytesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsBytesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsBytesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsBytes != nil && mm_atomic.LoadUint64(&m.afterAsBytesCounter) < 1 {
		return false
	}
	return true
}

// MinimockAsBytesInspect logs each unmet expectation
func (m *SignatureHolderMock) MinimockAsBytesInspect() {
	for _, e := range m.AsBytesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SignatureHolderMock.AsBytes")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsBytesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsBytesCounter) < 1 {
		m.t.Error("Expected call to SignatureHolderMock.AsBytes")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsBytes != nil && mm_atomic.LoadUint64(&m.afterAsBytesCounter) < 1 {
		m.t.Error("Expected call to SignatureHolderMock.AsBytes")
	}
}

type mSignatureHolderMockCopyOfSignature struct {
	mock               *SignatureHolderMock
	defaultExpectation *SignatureHolderMockCopyOfSignatureExpectation
	expectations       []*SignatureHolderMockCopyOfSignatureExpectation
}

// SignatureHolderMockCopyOfSignatureExpectation specifies expectation struct of the SignatureHolder.CopyOfSignature
type SignatureHolderMockCopyOfSignatureExpectation struct {
	mock *SignatureHolderMock

	results *SignatureHolderMockCopyOfSignatureResults
	Counter uint64
}

// SignatureHolderMockCopyOfSignatureResults contains results of the SignatureHolder.CopyOfSignature
type SignatureHolderMockCopyOfSignatureResults struct {
	s1 Signature
}

// Expect sets up expected params for SignatureHolder.CopyOfSignature
func (mmCopyOfSignature *mSignatureHolderMockCopyOfSignature) Expect() *mSignatureHolderMockCopyOfSignature {
	if mmCopyOfSignature.mock.funcCopyOfSignature != nil {
		mmCopyOfSignature.mock.t.Fatalf("SignatureHolderMock.CopyOfSignature mock is already set by Set")
	}

	if mmCopyOfSignature.defaultExpectation == nil {
		mmCopyOfSignature.defaultExpectation = &SignatureHolderMockCopyOfSignatureExpectation{}
	}

	return mmCopyOfSignature
}

// Inspect accepts an inspector function that has same arguments as the SignatureHolder.CopyOfSignature
func (mmCopyOfSignature *mSignatureHolderMockCopyOfSignature) Inspect(f func()) *mSignatureHolderMockCopyOfSignature {
	if mmCopyOfSignature.mock.inspectFuncCopyOfSignature != nil {
		mmCopyOfSignature.mock.t.Fatalf("Inspect function is already set for SignatureHolderMock.CopyOfSignature")
	}

	mmCopyOfSignature.mock.inspectFuncCopyOfSignature = f

	return mmCopyOfSignature
}

// Return sets up results that will be returned by SignatureHolder.CopyOfSignature
func (mmCopyOfSignature *mSignatureHolderMockCopyOfSignature) Return(s1 Signature) *SignatureHolderMock {
	if mmCopyOfSignature.mock.funcCopyOfSignature != nil {
		mmCopyOfSignature.mock.t.Fatalf("SignatureHolderMock.CopyOfSignature mock is already set by Set")
	}

	if mmCopyOfSignature.defaultExpectation == nil {
		mmCopyOfSignature.defaultExpectation = &SignatureHolderMockCopyOfSignatureExpectation{mock: mmCopyOfSignature.mock}
	}
	mmCopyOfSignature.defaultExpectation.results = &SignatureHolderMockCopyOfSignatureResults{s1}
	return mmCopyOfSignature.mock
}

//Set uses given function f to mock the SignatureHolder.CopyOfSignature method
func (mmCopyOfSignature *mSignatureHolderMockCopyOfSignature) Set(f func() (s1 Signature)) *SignatureHolderMock {
	if mmCopyOfSignature.defaultExpectation != nil {
		mmCopyOfSignature.mock.t.Fatalf("Default expectation is already set for the SignatureHolder.CopyOfSignature method")
	}

	if len(mmCopyOfSignature.expectations) > 0 {
		mmCopyOfSignature.mock.t.Fatalf("Some expectations are already set for the SignatureHolder.CopyOfSignature method")
	}

	mmCopyOfSignature.mock.funcCopyOfSignature = f
	return mmCopyOfSignature.mock
}

// CopyOfSignature implements SignatureHolder
func (mmCopyOfSignature *SignatureHolderMock) CopyOfSignature() (s1 Signature) {
	mm_atomic.AddUint64(&mmCopyOfSignature.beforeCopyOfSignatureCounter, 1)
	defer mm_atomic.AddUint64(&mmCopyOfSignature.afterCopyOfSignatureCounter, 1)

	if mmCopyOfSignature.inspectFuncCopyOfSignature != nil {
		mmCopyOfSignature.inspectFuncCopyOfSignature()
	}

	if mmCopyOfSignature.CopyOfSignatureMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCopyOfSignature.CopyOfSignatureMock.defaultExpectation.Counter, 1)

		results := mmCopyOfSignature.CopyOfSignatureMock.defaultExpectation.results
		if results == nil {
			mmCopyOfSignature.t.Fatal("No results are set for the SignatureHolderMock.CopyOfSignature")
		}
		return (*results).s1
	}
	if mmCopyOfSignature.funcCopyOfSignature != nil {
		return mmCopyOfSignature.funcCopyOfSignature()
	}
	mmCopyOfSignature.t.Fatalf("Unexpected call to SignatureHolderMock.CopyOfSignature.")
	return
}

// CopyOfSignatureAfterCounter returns a count of finished SignatureHolderMock.CopyOfSignature invocations
func (mmCopyOfSignature *SignatureHolderMock) CopyOfSignatureAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyOfSignature.afterCopyOfSignatureCounter)
}

// CopyOfSignatureBeforeCounter returns a count of SignatureHolderMock.CopyOfSignature invocations
func (mmCopyOfSignature *SignatureHolderMock) CopyOfSignatureBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyOfSignature.beforeCopyOfSignatureCounter)
}

// MinimockCopyOfSignatureDone returns true if the count of the CopyOfSignature invocations corresponds
// the number of defined expectations
func (m *SignatureHolderMock) MinimockCopyOfSignatureDone() bool {
	for _, e := range m.CopyOfSignatureMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyOfSignatureMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyOfSignatureCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyOfSignature != nil && mm_atomic.LoadUint64(&m.afterCopyOfSignatureCounter) < 1 {
		return false
	}
	return true
}

// MinimockCopyOfSignatureInspect logs each unmet expectation
func (m *SignatureHolderMock) MinimockCopyOfSignatureInspect() {
	for _, e := range m.CopyOfSignatureMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SignatureHolderMock.CopyOfSignature")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyOfSignatureMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyOfSignatureCounter) < 1 {
		m.t.Error("Expected call to SignatureHolderMock.CopyOfSignature")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyOfSignature != nil && mm_atomic.LoadUint64(&m.afterCopyOfSignatureCounter) < 1 {
		m.t.Error("Expected call to SignatureHolderMock.CopyOfSignature")
	}
}

type mSignatureHolderMockEquals struct {
	mock               *SignatureHolderMock
	defaultExpectation *SignatureHolderMockEqualsExpectation
	expectations       []*SignatureHolderMockEqualsExpectation

	callArgs []*SignatureHolderMockEqualsParams
	mutex    sync.RWMutex
}

// SignatureHolderMockEqualsExpectation specifies expectation struct of the SignatureHolder.Equals
type SignatureHolderMockEqualsExpectation struct {
	mock    *SignatureHolderMock
	params  *SignatureHolderMockEqualsParams
	results *SignatureHolderMockEqualsResults
	Counter uint64
}

// SignatureHolderMockEqualsParams contains parameters of the SignatureHolder.Equals
type SignatureHolderMockEqualsParams struct {
	other SignatureHolder
}

// SignatureHolderMockEqualsResults contains results of the SignatureHolder.Equals
type SignatureHolderMockEqualsResults struct {
	b1 bool
}

// Expect sets up expected params for SignatureHolder.Equals
func (mmEquals *mSignatureHolderMockEquals) Expect(other SignatureHolder) *mSignatureHolderMockEquals {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("SignatureHolderMock.Equals mock is already set by Set")
	}

	if mmEquals.defaultExpectation == nil {
		mmEquals.defaultExpectation = &SignatureHolderMockEqualsExpectation{}
	}

	mmEquals.defaultExpectation.params = &SignatureHolderMockEqualsParams{other}
	for _, e := range mmEquals.expectations {
		if minimock.Equal(e.params, mmEquals.defaultExpectation.params) {
			mmEquals.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEquals.defaultExpectation.params)
		}
	}

	return mmEquals
}

// Inspect accepts an inspector function that has same arguments as the SignatureHolder.Equals
func (mmEquals *mSignatureHolderMockEquals) Inspect(f func(other SignatureHolder)) *mSignatureHolderMockEquals {
	if mmEquals.mock.inspectFuncEquals != nil {
		mmEquals.mock.t.Fatalf("Inspect function is already set for SignatureHolderMock.Equals")
	}

	mmEquals.mock.inspectFuncEquals = f

	return mmEquals
}

// Return sets up results that will be returned by SignatureHolder.Equals
func (mmEquals *mSignatureHolderMockEquals) Return(b1 bool) *SignatureHolderMock {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("SignatureHolderMock.Equals mock is already set by Set")
	}

	if mmEquals.defaultExpectation == nil {
		mmEquals.defaultExpectation = &SignatureHolderMockEqualsExpectation{mock: mmEquals.mock}
	}
	mmEquals.defaultExpectation.results = &SignatureHolderMockEqualsResults{b1}
	return mmEquals.mock
}

//Set uses given function f to mock the SignatureHolder.Equals method
func (mmEquals *mSignatureHolderMockEquals) Set(f func(other SignatureHolder) (b1 bool)) *SignatureHolderMock {
	if mmEquals.defaultExpectation != nil {
		mmEquals.mock.t.Fatalf("Default expectation is already set for the SignatureHolder.Equals method")
	}

	if len(mmEquals.expectations) > 0 {
		mmEquals.mock.t.Fatalf("Some expectations are already set for the SignatureHolder.Equals method")
	}

	mmEquals.mock.funcEquals = f
	return mmEquals.mock
}

// When sets expectation for the SignatureHolder.Equals which will trigger the result defined by the following
// Then helper
func (mmEquals *mSignatureHolderMockEquals) When(other SignatureHolder) *SignatureHolderMockEqualsExpectation {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("SignatureHolderMock.Equals mock is already set by Set")
	}

	expectation := &SignatureHolderMockEqualsExpectation{
		mock:   mmEquals.mock,
		params: &SignatureHolderMockEqualsParams{other},
	}
	mmEquals.expectations = append(mmEquals.expectations, expectation)
	return expectation
}

// Then sets up SignatureHolder.Equals return parameters for the expectation previously defined by the When method
func (e *SignatureHolderMockEqualsExpectation) Then(b1 bool) *SignatureHolderMock {
	e.results = &SignatureHolderMockEqualsResults{b1}
	return e.mock
}

// Equals implements SignatureHolder
func (mmEquals *SignatureHolderMock) Equals(other SignatureHolder) (b1 bool) {
	mm_atomic.AddUint64(&mmEquals.beforeEqualsCounter, 1)
	defer mm_atomic.AddUint64(&mmEquals.afterEqualsCounter, 1)

	if mmEquals.inspectFuncEquals != nil {
		mmEquals.inspectFuncEquals(other)
	}

	params := &SignatureHolderMockEqualsParams{other}

	// Record call args
	mmEquals.EqualsMock.mutex.Lock()
	mmEquals.EqualsMock.callArgs = append(mmEquals.EqualsMock.callArgs, params)
	mmEquals.EqualsMock.mutex.Unlock()

	for _, e := range mmEquals.EqualsMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmEquals.EqualsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEquals.EqualsMock.defaultExpectation.Counter, 1)
		want := mmEquals.EqualsMock.defaultExpectation.params
		got := SignatureHolderMockEqualsParams{other}
		if want != nil && !minimock.Equal(*want, got) {
			mmEquals.t.Errorf("SignatureHolderMock.Equals got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmEquals.EqualsMock.defaultExpectation.results
		if results == nil {
			mmEquals.t.Fatal("No results are set for the SignatureHolderMock.Equals")
		}
		return (*results).b1
	}
	if mmEquals.funcEquals != nil {
		return mmEquals.funcEquals(other)
	}
	mmEquals.t.Fatalf("Unexpected call to SignatureHolderMock.Equals. %v", other)
	return
}

// EqualsAfterCounter returns a count of finished SignatureHolderMock.Equals invocations
func (mmEquals *SignatureHolderMock) EqualsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEquals.afterEqualsCounter)
}

// EqualsBeforeCounter returns a count of SignatureHolderMock.Equals invocations
func (mmEquals *SignatureHolderMock) EqualsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEquals.beforeEqualsCounter)
}

// Calls returns a list of arguments used in each call to SignatureHolderMock.Equals.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEquals *mSignatureHolderMockEquals) Calls() []*SignatureHolderMockEqualsParams {
	mmEquals.mutex.RLock()

	argCopy := make([]*SignatureHolderMockEqualsParams, len(mmEquals.callArgs))
	copy(argCopy, mmEquals.callArgs)

	mmEquals.mutex.RUnlock()

	return argCopy
}

// MinimockEqualsDone returns true if the count of the Equals invocations corresponds
// the number of defined expectations
func (m *SignatureHolderMock) MinimockEqualsDone() bool {
	for _, e := range m.EqualsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EqualsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEquals != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		return false
	}
	return true
}

// MinimockEqualsInspect logs each unmet expectation
func (m *SignatureHolderMock) MinimockEqualsInspect() {
	for _, e := range m.EqualsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SignatureHolderMock.Equals with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EqualsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		if m.EqualsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SignatureHolderMock.Equals")
		} else {
			m.t.Errorf("Expected call to SignatureHolderMock.Equals with params: %#v", *m.EqualsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEquals != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		m.t.Error("Expected call to SignatureHolderMock.Equals")
	}
}

type mSignatureHolderMockFixedByteSize struct {
	mock               *SignatureHolderMock
	defaultExpectation *SignatureHolderMockFixedByteSizeExpectation
	expectations       []*SignatureHolderMockFixedByteSizeExpectation
}

// SignatureHolderMockFixedByteSizeExpectation specifies expectation struct of the SignatureHolder.FixedByteSize
type SignatureHolderMockFixedByteSizeExpectation struct {
	mock *SignatureHolderMock

	results *SignatureHolderMockFixedByteSizeResults
	Counter uint64
}

// SignatureHolderMockFixedByteSizeResults contains results of the SignatureHolder.FixedByteSize
type SignatureHolderMockFixedByteSizeResults struct {
	i1 int
}

// Expect sets up expected params for SignatureHolder.FixedByteSize
func (mmFixedByteSize *mSignatureHolderMockFixedByteSize) Expect() *mSignatureHolderMockFixedByteSize {
	if mmFixedByteSize.mock.funcFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("SignatureHolderMock.FixedByteSize mock is already set by Set")
	}

	if mmFixedByteSize.defaultExpectation == nil {
		mmFixedByteSize.defaultExpectation = &SignatureHolderMockFixedByteSizeExpectation{}
	}

	return mmFixedByteSize
}

// Inspect accepts an inspector function that has same arguments as the SignatureHolder.FixedByteSize
func (mmFixedByteSize *mSignatureHolderMockFixedByteSize) Inspect(f func()) *mSignatureHolderMockFixedByteSize {
	if mmFixedByteSize.mock.inspectFuncFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("Inspect function is already set for SignatureHolderMock.FixedByteSize")
	}

	mmFixedByteSize.mock.inspectFuncFixedByteSize = f

	return mmFixedByteSize
}

// Return sets up results that will be returned by SignatureHolder.FixedByteSize
func (mmFixedByteSize *mSignatureHolderMockFixedByteSize) Return(i1 int) *SignatureHolderMock {
	if mmFixedByteSize.mock.funcFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("SignatureHolderMock.FixedByteSize mock is already set by Set")
	}

	if mmFixedByteSize.defaultExpectation == nil {
		mmFixedByteSize.defaultExpectation = &SignatureHolderMockFixedByteSizeExpectation{mock: mmFixedByteSize.mock}
	}
	mmFixedByteSize.defaultExpectation.results = &SignatureHolderMockFixedByteSizeResults{i1}
	return mmFixedByteSize.mock
}

//Set uses given function f to mock the SignatureHolder.FixedByteSize method
func (mmFixedByteSize *mSignatureHolderMockFixedByteSize) Set(f func() (i1 int)) *SignatureHolderMock {
	if mmFixedByteSize.defaultExpectation != nil {
		mmFixedByteSize.mock.t.Fatalf("Default expectation is already set for the SignatureHolder.FixedByteSize method")
	}

	if len(mmFixedByteSize.expectations) > 0 {
		mmFixedByteSize.mock.t.Fatalf("Some expectations are already set for the SignatureHolder.FixedByteSize method")
	}

	mmFixedByteSize.mock.funcFixedByteSize = f
	return mmFixedByteSize.mock
}

// FixedByteSize implements SignatureHolder
func (mmFixedByteSize *SignatureHolderMock) FixedByteSize() (i1 int) {
	mm_atomic.AddUint64(&mmFixedByteSize.beforeFixedByteSizeCounter, 1)
	defer mm_atomic.AddUint64(&mmFixedByteSize.afterFixedByteSizeCounter, 1)

	if mmFixedByteSize.inspectFuncFixedByteSize != nil {
		mmFixedByteSize.inspectFuncFixedByteSize()
	}

	if mmFixedByteSize.FixedByteSizeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFixedByteSize.FixedByteSizeMock.defaultExpectation.Counter, 1)

		results := mmFixedByteSize.FixedByteSizeMock.defaultExpectation.results
		if results == nil {
			mmFixedByteSize.t.Fatal("No results are set for the SignatureHolderMock.FixedByteSize")
		}
		return (*results).i1
	}
	if mmFixedByteSize.funcFixedByteSize != nil {
		return mmFixedByteSize.funcFixedByteSize()
	}
	mmFixedByteSize.t.Fatalf("Unexpected call to SignatureHolderMock.FixedByteSize.")
	return
}

// FixedByteSizeAfterCounter returns a count of finished SignatureHolderMock.FixedByteSize invocations
func (mmFixedByteSize *SignatureHolderMock) FixedByteSizeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFixedByteSize.afterFixedByteSizeCounter)
}

// FixedByteSizeBeforeCounter returns a count of SignatureHolderMock.FixedByteSize invocations
func (mmFixedByteSize *SignatureHolderMock) FixedByteSizeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFixedByteSize.beforeFixedByteSizeCounter)
}

// MinimockFixedByteSizeDone returns true if the count of the FixedByteSize invocations corresponds
// the number of defined expectations
func (m *SignatureHolderMock) MinimockFixedByteSizeDone() bool {
	for _, e := range m.FixedByteSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FixedByteSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFixedByteSize != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		return false
	}
	return true
}

// MinimockFixedByteSizeInspect logs each unmet expectation
func (m *SignatureHolderMock) MinimockFixedByteSizeInspect() {
	for _, e := range m.FixedByteSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SignatureHolderMock.FixedByteSize")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FixedByteSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		m.t.Error("Expected call to SignatureHolderMock.FixedByteSize")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFixedByteSize != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		m.t.Error("Expected call to SignatureHolderMock.FixedByteSize")
	}
}

type mSignatureHolderMockFoldToUint64 struct {
	mock               *SignatureHolderMock
	defaultExpectation *SignatureHolderMockFoldToUint64Expectation
	expectations       []*SignatureHolderMockFoldToUint64Expectation
}

// SignatureHolderMockFoldToUint64Expectation specifies expectation struct of the SignatureHolder.FoldToUint64
type SignatureHolderMockFoldToUint64Expectation struct {
	mock *SignatureHolderMock

	results *SignatureHolderMockFoldToUint64Results
	Counter uint64
}

// SignatureHolderMockFoldToUint64Results contains results of the SignatureHolder.FoldToUint64
type SignatureHolderMockFoldToUint64Results struct {
	u1 uint64
}

// Expect sets up expected params for SignatureHolder.FoldToUint64
func (mmFoldToUint64 *mSignatureHolderMockFoldToUint64) Expect() *mSignatureHolderMockFoldToUint64 {
	if mmFoldToUint64.mock.funcFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("SignatureHolderMock.FoldToUint64 mock is already set by Set")
	}

	if mmFoldToUint64.defaultExpectation == nil {
		mmFoldToUint64.defaultExpectation = &SignatureHolderMockFoldToUint64Expectation{}
	}

	return mmFoldToUint64
}

// Inspect accepts an inspector function that has same arguments as the SignatureHolder.FoldToUint64
func (mmFoldToUint64 *mSignatureHolderMockFoldToUint64) Inspect(f func()) *mSignatureHolderMockFoldToUint64 {
	if mmFoldToUint64.mock.inspectFuncFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("Inspect function is already set for SignatureHolderMock.FoldToUint64")
	}

	mmFoldToUint64.mock.inspectFuncFoldToUint64 = f

	return mmFoldToUint64
}

// Return sets up results that will be returned by SignatureHolder.FoldToUint64
func (mmFoldToUint64 *mSignatureHolderMockFoldToUint64) Return(u1 uint64) *SignatureHolderMock {
	if mmFoldToUint64.mock.funcFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("SignatureHolderMock.FoldToUint64 mock is already set by Set")
	}

	if mmFoldToUint64.defaultExpectation == nil {
		mmFoldToUint64.defaultExpectation = &SignatureHolderMockFoldToUint64Expectation{mock: mmFoldToUint64.mock}
	}
	mmFoldToUint64.defaultExpectation.results = &SignatureHolderMockFoldToUint64Results{u1}
	return mmFoldToUint64.mock
}

//Set uses given function f to mock the SignatureHolder.FoldToUint64 method
func (mmFoldToUint64 *mSignatureHolderMockFoldToUint64) Set(f func() (u1 uint64)) *SignatureHolderMock {
	if mmFoldToUint64.defaultExpectation != nil {
		mmFoldToUint64.mock.t.Fatalf("Default expectation is already set for the SignatureHolder.FoldToUint64 method")
	}

	if len(mmFoldToUint64.expectations) > 0 {
		mmFoldToUint64.mock.t.Fatalf("Some expectations are already set for the SignatureHolder.FoldToUint64 method")
	}

	mmFoldToUint64.mock.funcFoldToUint64 = f
	return mmFoldToUint64.mock
}

// FoldToUint64 implements SignatureHolder
func (mmFoldToUint64 *SignatureHolderMock) FoldToUint64() (u1 uint64) {
	mm_atomic.AddUint64(&mmFoldToUint64.beforeFoldToUint64Counter, 1)
	defer mm_atomic.AddUint64(&mmFoldToUint64.afterFoldToUint64Counter, 1)

	if mmFoldToUint64.inspectFuncFoldToUint64 != nil {
		mmFoldToUint64.inspectFuncFoldToUint64()
	}

	if mmFoldToUint64.FoldToUint64Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFoldToUint64.FoldToUint64Mock.defaultExpectation.Counter, 1)

		results := mmFoldToUint64.FoldToUint64Mock.defaultExpectation.results
		if results == nil {
			mmFoldToUint64.t.Fatal("No results are set for the SignatureHolderMock.FoldToUint64")
		}
		return (*results).u1
	}
	if mmFoldToUint64.funcFoldToUint64 != nil {
		return mmFoldToUint64.funcFoldToUint64()
	}
	mmFoldToUint64.t.Fatalf("Unexpected call to SignatureHolderMock.FoldToUint64.")
	return
}

// FoldToUint64AfterCounter returns a count of finished SignatureHolderMock.FoldToUint64 invocations
func (mmFoldToUint64 *SignatureHolderMock) FoldToUint64AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFoldToUint64.afterFoldToUint64Counter)
}

// FoldToUint64BeforeCounter returns a count of SignatureHolderMock.FoldToUint64 invocations
func (mmFoldToUint64 *SignatureHolderMock) FoldToUint64BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFoldToUint64.beforeFoldToUint64Counter)
}

// MinimockFoldToUint64Done returns true if the count of the FoldToUint64 invocations corresponds
// the number of defined expectations
func (m *SignatureHolderMock) MinimockFoldToUint64Done() bool {
	for _, e := range m.FoldToUint64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FoldToUint64Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFoldToUint64 != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		return false
	}
	return true
}

// MinimockFoldToUint64Inspect logs each unmet expectation
func (m *SignatureHolderMock) MinimockFoldToUint64Inspect() {
	for _, e := range m.FoldToUint64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SignatureHolderMock.FoldToUint64")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FoldToUint64Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		m.t.Error("Expected call to SignatureHolderMock.FoldToUint64")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFoldToUint64 != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		m.t.Error("Expected call to SignatureHolderMock.FoldToUint64")
	}
}

type mSignatureHolderMockGetSignatureMethod struct {
	mock               *SignatureHolderMock
	defaultExpectation *SignatureHolderMockGetSignatureMethodExpectation
	expectations       []*SignatureHolderMockGetSignatureMethodExpectation
}

// SignatureHolderMockGetSignatureMethodExpectation specifies expectation struct of the SignatureHolder.GetSignatureMethod
type SignatureHolderMockGetSignatureMethodExpectation struct {
	mock *SignatureHolderMock

	results *SignatureHolderMockGetSignatureMethodResults
	Counter uint64
}

// SignatureHolderMockGetSignatureMethodResults contains results of the SignatureHolder.GetSignatureMethod
type SignatureHolderMockGetSignatureMethodResults struct {
	s1 SignatureMethod
}

// Expect sets up expected params for SignatureHolder.GetSignatureMethod
func (mmGetSignatureMethod *mSignatureHolderMockGetSignatureMethod) Expect() *mSignatureHolderMockGetSignatureMethod {
	if mmGetSignatureMethod.mock.funcGetSignatureMethod != nil {
		mmGetSignatureMethod.mock.t.Fatalf("SignatureHolderMock.GetSignatureMethod mock is already set by Set")
	}

	if mmGetSignatureMethod.defaultExpectation == nil {
		mmGetSignatureMethod.defaultExpectation = &SignatureHolderMockGetSignatureMethodExpectation{}
	}

	return mmGetSignatureMethod
}

// Inspect accepts an inspector function that has same arguments as the SignatureHolder.GetSignatureMethod
func (mmGetSignatureMethod *mSignatureHolderMockGetSignatureMethod) Inspect(f func()) *mSignatureHolderMockGetSignatureMethod {
	if mmGetSignatureMethod.mock.inspectFuncGetSignatureMethod != nil {
		mmGetSignatureMethod.mock.t.Fatalf("Inspect function is already set for SignatureHolderMock.GetSignatureMethod")
	}

	mmGetSignatureMethod.mock.inspectFuncGetSignatureMethod = f

	return mmGetSignatureMethod
}

// Return sets up results that will be returned by SignatureHolder.GetSignatureMethod
func (mmGetSignatureMethod *mSignatureHolderMockGetSignatureMethod) Return(s1 SignatureMethod) *SignatureHolderMock {
	if mmGetSignatureMethod.mock.funcGetSignatureMethod != nil {
		mmGetSignatureMethod.mock.t.Fatalf("SignatureHolderMock.GetSignatureMethod mock is already set by Set")
	}

	if mmGetSignatureMethod.defaultExpectation == nil {
		mmGetSignatureMethod.defaultExpectation = &SignatureHolderMockGetSignatureMethodExpectation{mock: mmGetSignatureMethod.mock}
	}
	mmGetSignatureMethod.defaultExpectation.results = &SignatureHolderMockGetSignatureMethodResults{s1}
	return mmGetSignatureMethod.mock
}

//Set uses given function f to mock the SignatureHolder.GetSignatureMethod method
func (mmGetSignatureMethod *mSignatureHolderMockGetSignatureMethod) Set(f func() (s1 SignatureMethod)) *SignatureHolderMock {
	if mmGetSignatureMethod.defaultExpectation != nil {
		mmGetSignatureMethod.mock.t.Fatalf("Default expectation is already set for the SignatureHolder.GetSignatureMethod method")
	}

	if len(mmGetSignatureMethod.expectations) > 0 {
		mmGetSignatureMethod.mock.t.Fatalf("Some expectations are already set for the SignatureHolder.GetSignatureMethod method")
	}

	mmGetSignatureMethod.mock.funcGetSignatureMethod = f
	return mmGetSignatureMethod.mock
}

// GetSignatureMethod implements SignatureHolder
func (mmGetSignatureMethod *SignatureHolderMock) GetSignatureMethod() (s1 SignatureMethod) {
	mm_atomic.AddUint64(&mmGetSignatureMethod.beforeGetSignatureMethodCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSignatureMethod.afterGetSignatureMethodCounter, 1)

	if mmGetSignatureMethod.inspectFuncGetSignatureMethod != nil {
		mmGetSignatureMethod.inspectFuncGetSignatureMethod()
	}

	if mmGetSignatureMethod.GetSignatureMethodMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSignatureMethod.GetSignatureMethodMock.defaultExpectation.Counter, 1)

		results := mmGetSignatureMethod.GetSignatureMethodMock.defaultExpectation.results
		if results == nil {
			mmGetSignatureMethod.t.Fatal("No results are set for the SignatureHolderMock.GetSignatureMethod")
		}
		return (*results).s1
	}
	if mmGetSignatureMethod.funcGetSignatureMethod != nil {
		return mmGetSignatureMethod.funcGetSignatureMethod()
	}
	mmGetSignatureMethod.t.Fatalf("Unexpected call to SignatureHolderMock.GetSignatureMethod.")
	return
}

// GetSignatureMethodAfterCounter returns a count of finished SignatureHolderMock.GetSignatureMethod invocations
func (mmGetSignatureMethod *SignatureHolderMock) GetSignatureMethodAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSignatureMethod.afterGetSignatureMethodCounter)
}

// GetSignatureMethodBeforeCounter returns a count of SignatureHolderMock.GetSignatureMethod invocations
func (mmGetSignatureMethod *SignatureHolderMock) GetSignatureMethodBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSignatureMethod.beforeGetSignatureMethodCounter)
}

// MinimockGetSignatureMethodDone returns true if the count of the GetSignatureMethod invocations corresponds
// the number of defined expectations
func (m *SignatureHolderMock) MinimockGetSignatureMethodDone() bool {
	for _, e := range m.GetSignatureMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSignatureMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSignatureMethodCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSignatureMethod != nil && mm_atomic.LoadUint64(&m.afterGetSignatureMethodCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSignatureMethodInspect logs each unmet expectation
func (m *SignatureHolderMock) MinimockGetSignatureMethodInspect() {
	for _, e := range m.GetSignatureMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SignatureHolderMock.GetSignatureMethod")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSignatureMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSignatureMethodCounter) < 1 {
		m.t.Error("Expected call to SignatureHolderMock.GetSignatureMethod")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSignatureMethod != nil && mm_atomic.LoadUint64(&m.afterGetSignatureMethodCounter) < 1 {
		m.t.Error("Expected call to SignatureHolderMock.GetSignatureMethod")
	}
}

type mSignatureHolderMockRead struct {
	mock               *SignatureHolderMock
	defaultExpectation *SignatureHolderMockReadExpectation
	expectations       []*SignatureHolderMockReadExpectation

	callArgs []*SignatureHolderMockReadParams
	mutex    sync.RWMutex
}

// SignatureHolderMockReadExpectation specifies expectation struct of the SignatureHolder.Read
type SignatureHolderMockReadExpectation struct {
	mock    *SignatureHolderMock
	params  *SignatureHolderMockReadParams
	results *SignatureHolderMockReadResults
	Counter uint64
}

// SignatureHolderMockReadParams contains parameters of the SignatureHolder.Read
type SignatureHolderMockReadParams struct {
	p []byte
}

// SignatureHolderMockReadResults contains results of the SignatureHolder.Read
type SignatureHolderMockReadResults struct {
	n   int
	err error
}

// Expect sets up expected params for SignatureHolder.Read
func (mmRead *mSignatureHolderMockRead) Expect(p []byte) *mSignatureHolderMockRead {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("SignatureHolderMock.Read mock is already set by Set")
	}

	if mmRead.defaultExpectation == nil {
		mmRead.defaultExpectation = &SignatureHolderMockReadExpectation{}
	}

	mmRead.defaultExpectation.params = &SignatureHolderMockReadParams{p}
	for _, e := range mmRead.expectations {
		if minimock.Equal(e.params, mmRead.defaultExpectation.params) {
			mmRead.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRead.defaultExpectation.params)
		}
	}

	return mmRead
}

// Inspect accepts an inspector function that has same arguments as the SignatureHolder.Read
func (mmRead *mSignatureHolderMockRead) Inspect(f func(p []byte)) *mSignatureHolderMockRead {
	if mmRead.mock.inspectFuncRead != nil {
		mmRead.mock.t.Fatalf("Inspect function is already set for SignatureHolderMock.Read")
	}

	mmRead.mock.inspectFuncRead = f

	return mmRead
}

// Return sets up results that will be returned by SignatureHolder.Read
func (mmRead *mSignatureHolderMockRead) Return(n int, err error) *SignatureHolderMock {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("SignatureHolderMock.Read mock is already set by Set")
	}

	if mmRead.defaultExpectation == nil {
		mmRead.defaultExpectation = &SignatureHolderMockReadExpectation{mock: mmRead.mock}
	}
	mmRead.defaultExpectation.results = &SignatureHolderMockReadResults{n, err}
	return mmRead.mock
}

//Set uses given function f to mock the SignatureHolder.Read method
func (mmRead *mSignatureHolderMockRead) Set(f func(p []byte) (n int, err error)) *SignatureHolderMock {
	if mmRead.defaultExpectation != nil {
		mmRead.mock.t.Fatalf("Default expectation is already set for the SignatureHolder.Read method")
	}

	if len(mmRead.expectations) > 0 {
		mmRead.mock.t.Fatalf("Some expectations are already set for the SignatureHolder.Read method")
	}

	mmRead.mock.funcRead = f
	return mmRead.mock
}

// When sets expectation for the SignatureHolder.Read which will trigger the result defined by the following
// Then helper
func (mmRead *mSignatureHolderMockRead) When(p []byte) *SignatureHolderMockReadExpectation {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("SignatureHolderMock.Read mock is already set by Set")
	}

	expectation := &SignatureHolderMockReadExpectation{
		mock:   mmRead.mock,
		params: &SignatureHolderMockReadParams{p},
	}
	mmRead.expectations = append(mmRead.expectations, expectation)
	return expectation
}

// Then sets up SignatureHolder.Read return parameters for the expectation previously defined by the When method
func (e *SignatureHolderMockReadExpectation) Then(n int, err error) *SignatureHolderMock {
	e.results = &SignatureHolderMockReadResults{n, err}
	return e.mock
}

// Read implements SignatureHolder
func (mmRead *SignatureHolderMock) Read(p []byte) (n int, err error) {
	mm_atomic.AddUint64(&mmRead.beforeReadCounter, 1)
	defer mm_atomic.AddUint64(&mmRead.afterReadCounter, 1)

	if mmRead.inspectFuncRead != nil {
		mmRead.inspectFuncRead(p)
	}

	params := &SignatureHolderMockReadParams{p}

	// Record call args
	mmRead.ReadMock.mutex.Lock()
	mmRead.ReadMock.callArgs = append(mmRead.ReadMock.callArgs, params)
	mmRead.ReadMock.mutex.Unlock()

	for _, e := range mmRead.ReadMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmRead.ReadMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRead.ReadMock.defaultExpectation.Counter, 1)
		want := mmRead.ReadMock.defaultExpectation.params
		got := SignatureHolderMockReadParams{p}
		if want != nil && !minimock.Equal(*want, got) {
			mmRead.t.Errorf("SignatureHolderMock.Read got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmRead.ReadMock.defaultExpectation.results
		if results == nil {
			mmRead.t.Fatal("No results are set for the SignatureHolderMock.Read")
		}
		return (*results).n, (*results).err
	}
	if mmRead.funcRead != nil {
		return mmRead.funcRead(p)
	}
	mmRead.t.Fatalf("Unexpected call to SignatureHolderMock.Read. %v", p)
	return
}

// ReadAfterCounter returns a count of finished SignatureHolderMock.Read invocations
func (mmRead *SignatureHolderMock) ReadAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRead.afterReadCounter)
}

// ReadBeforeCounter returns a count of SignatureHolderMock.Read invocations
func (mmRead *SignatureHolderMock) ReadBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRead.beforeReadCounter)
}

// Calls returns a list of arguments used in each call to SignatureHolderMock.Read.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRead *mSignatureHolderMockRead) Calls() []*SignatureHolderMockReadParams {
	mmRead.mutex.RLock()

	argCopy := make([]*SignatureHolderMockReadParams, len(mmRead.callArgs))
	copy(argCopy, mmRead.callArgs)

	mmRead.mutex.RUnlock()

	return argCopy
}

// MinimockReadDone returns true if the count of the Read invocations corresponds
// the number of defined expectations
func (m *SignatureHolderMock) MinimockReadDone() bool {
	for _, e := range m.ReadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRead != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		return false
	}
	return true
}

// MinimockReadInspect logs each unmet expectation
func (m *SignatureHolderMock) MinimockReadInspect() {
	for _, e := range m.ReadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SignatureHolderMock.Read with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		if m.ReadMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SignatureHolderMock.Read")
		} else {
			m.t.Errorf("Expected call to SignatureHolderMock.Read with params: %#v", *m.ReadMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRead != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		m.t.Error("Expected call to SignatureHolderMock.Read")
	}
}

type mSignatureHolderMockWriteTo struct {
	mock               *SignatureHolderMock
	defaultExpectation *SignatureHolderMockWriteToExpectation
	expectations       []*SignatureHolderMockWriteToExpectation

	callArgs []*SignatureHolderMockWriteToParams
	mutex    sync.RWMutex
}

// SignatureHolderMockWriteToExpectation specifies expectation struct of the SignatureHolder.WriteTo
type SignatureHolderMockWriteToExpectation struct {
	mock    *SignatureHolderMock
	params  *SignatureHolderMockWriteToParams
	results *SignatureHolderMockWriteToResults
	Counter uint64
}

// SignatureHolderMockWriteToParams contains parameters of the SignatureHolder.WriteTo
type SignatureHolderMockWriteToParams struct {
	w io.Writer
}

// SignatureHolderMockWriteToResults contains results of the SignatureHolder.WriteTo
type SignatureHolderMockWriteToResults struct {
	n   int64
	err error
}

// Expect sets up expected params for SignatureHolder.WriteTo
func (mmWriteTo *mSignatureHolderMockWriteTo) Expect(w io.Writer) *mSignatureHolderMockWriteTo {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("SignatureHolderMock.WriteTo mock is already set by Set")
	}

	if mmWriteTo.defaultExpectation == nil {
		mmWriteTo.defaultExpectation = &SignatureHolderMockWriteToExpectation{}
	}

	mmWriteTo.defaultExpectation.params = &SignatureHolderMockWriteToParams{w}
	for _, e := range mmWriteTo.expectations {
		if minimock.Equal(e.params, mmWriteTo.defaultExpectation.params) {
			mmWriteTo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWriteTo.defaultExpectation.params)
		}
	}

	return mmWriteTo
}

// Inspect accepts an inspector function that has same arguments as the SignatureHolder.WriteTo
func (mmWriteTo *mSignatureHolderMockWriteTo) Inspect(f func(w io.Writer)) *mSignatureHolderMockWriteTo {
	if mmWriteTo.mock.inspectFuncWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("Inspect function is already set for SignatureHolderMock.WriteTo")
	}

	mmWriteTo.mock.inspectFuncWriteTo = f

	return mmWriteTo
}

// Return sets up results that will be returned by SignatureHolder.WriteTo
func (mmWriteTo *mSignatureHolderMockWriteTo) Return(n int64, err error) *SignatureHolderMock {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("SignatureHolderMock.WriteTo mock is already set by Set")
	}

	if mmWriteTo.defaultExpectation == nil {
		mmWriteTo.defaultExpectation = &SignatureHolderMockWriteToExpectation{mock: mmWriteTo.mock}
	}
	mmWriteTo.defaultExpectation.results = &SignatureHolderMockWriteToResults{n, err}
	return mmWriteTo.mock
}

//Set uses given function f to mock the SignatureHolder.WriteTo method
func (mmWriteTo *mSignatureHolderMockWriteTo) Set(f func(w io.Writer) (n int64, err error)) *SignatureHolderMock {
	if mmWriteTo.defaultExpectation != nil {
		mmWriteTo.mock.t.Fatalf("Default expectation is already set for the SignatureHolder.WriteTo method")
	}

	if len(mmWriteTo.expectations) > 0 {
		mmWriteTo.mock.t.Fatalf("Some expectations are already set for the SignatureHolder.WriteTo method")
	}

	mmWriteTo.mock.funcWriteTo = f
	return mmWriteTo.mock
}

// When sets expectation for the SignatureHolder.WriteTo which will trigger the result defined by the following
// Then helper
func (mmWriteTo *mSignatureHolderMockWriteTo) When(w io.Writer) *SignatureHolderMockWriteToExpectation {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("SignatureHolderMock.WriteTo mock is already set by Set")
	}

	expectation := &SignatureHolderMockWriteToExpectation{
		mock:   mmWriteTo.mock,
		params: &SignatureHolderMockWriteToParams{w},
	}
	mmWriteTo.expectations = append(mmWriteTo.expectations, expectation)
	return expectation
}

// Then sets up SignatureHolder.WriteTo return parameters for the expectation previously defined by the When method
func (e *SignatureHolderMockWriteToExpectation) Then(n int64, err error) *SignatureHolderMock {
	e.results = &SignatureHolderMockWriteToResults{n, err}
	return e.mock
}

// WriteTo implements SignatureHolder
func (mmWriteTo *SignatureHolderMock) WriteTo(w io.Writer) (n int64, err error) {
	mm_atomic.AddUint64(&mmWriteTo.beforeWriteToCounter, 1)
	defer mm_atomic.AddUint64(&mmWriteTo.afterWriteToCounter, 1)

	if mmWriteTo.inspectFuncWriteTo != nil {
		mmWriteTo.inspectFuncWriteTo(w)
	}

	params := &SignatureHolderMockWriteToParams{w}

	// Record call args
	mmWriteTo.WriteToMock.mutex.Lock()
	mmWriteTo.WriteToMock.callArgs = append(mmWriteTo.WriteToMock.callArgs, params)
	mmWriteTo.WriteToMock.mutex.Unlock()

	for _, e := range mmWriteTo.WriteToMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmWriteTo.WriteToMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWriteTo.WriteToMock.defaultExpectation.Counter, 1)
		want := mmWriteTo.WriteToMock.defaultExpectation.params
		got := SignatureHolderMockWriteToParams{w}
		if want != nil && !minimock.Equal(*want, got) {
			mmWriteTo.t.Errorf("SignatureHolderMock.WriteTo got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmWriteTo.WriteToMock.defaultExpectation.results
		if results == nil {
			mmWriteTo.t.Fatal("No results are set for the SignatureHolderMock.WriteTo")
		}
		return (*results).n, (*results).err
	}
	if mmWriteTo.funcWriteTo != nil {
		return mmWriteTo.funcWriteTo(w)
	}
	mmWriteTo.t.Fatalf("Unexpected call to SignatureHolderMock.WriteTo. %v", w)
	return
}

// WriteToAfterCounter returns a count of finished SignatureHolderMock.WriteTo invocations
func (mmWriteTo *SignatureHolderMock) WriteToAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteTo.afterWriteToCounter)
}

// WriteToBeforeCounter returns a count of SignatureHolderMock.WriteTo invocations
func (mmWriteTo *SignatureHolderMock) WriteToBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteTo.beforeWriteToCounter)
}

// Calls returns a list of arguments used in each call to SignatureHolderMock.WriteTo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWriteTo *mSignatureHolderMockWriteTo) Calls() []*SignatureHolderMockWriteToParams {
	mmWriteTo.mutex.RLock()

	argCopy := make([]*SignatureHolderMockWriteToParams, len(mmWriteTo.callArgs))
	copy(argCopy, mmWriteTo.callArgs)

	mmWriteTo.mutex.RUnlock()

	return argCopy
}

// MinimockWriteToDone returns true if the count of the WriteTo invocations corresponds
// the number of defined expectations
func (m *SignatureHolderMock) MinimockWriteToDone() bool {
	for _, e := range m.WriteToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteTo != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		return false
	}
	return true
}

// MinimockWriteToInspect logs each unmet expectation
func (m *SignatureHolderMock) MinimockWriteToInspect() {
	for _, e := range m.WriteToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SignatureHolderMock.WriteTo with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		if m.WriteToMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SignatureHolderMock.WriteTo")
		} else {
			m.t.Errorf("Expected call to SignatureHolderMock.WriteTo with params: %#v", *m.WriteToMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteTo != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		m.t.Error("Expected call to SignatureHolderMock.WriteTo")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SignatureHolderMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAsByteStringInspect()

		m.MinimockAsBytesInspect()

		m.MinimockCopyOfSignatureInspect()

		m.MinimockEqualsInspect()

		m.MinimockFixedByteSizeInspect()

		m.MinimockFoldToUint64Inspect()

		m.MinimockGetSignatureMethodInspect()

		m.MinimockReadInspect()

		m.MinimockWriteToInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SignatureHolderMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SignatureHolderMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAsByteStringDone() &&
		m.MinimockAsBytesDone() &&
		m.MinimockCopyOfSignatureDone() &&
		m.MinimockEqualsDone() &&
		m.MinimockFixedByteSizeDone() &&
		m.MinimockFoldToUint64Done() &&
		m.MinimockGetSignatureMethodDone() &&
		m.MinimockReadDone() &&
		m.MinimockWriteToDone()
}
