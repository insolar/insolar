package cryptkit

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/longbits"
)

// SignatureKeyHolderMock implements SignatureKeyHolder
type SignatureKeyHolderMock struct {
	t minimock.Tester

	funcAsByteString          func() (b1 longbits.ByteString)
	inspectFuncAsByteString   func()
	afterAsByteStringCounter  uint64
	beforeAsByteStringCounter uint64
	AsByteStringMock          mSignatureKeyHolderMockAsByteString

	funcAsBytes          func() (ba1 []byte)
	inspectFuncAsBytes   func()
	afterAsBytesCounter  uint64
	beforeAsBytesCounter uint64
	AsBytesMock          mSignatureKeyHolderMockAsBytes

	funcEquals          func(other SignatureKeyHolder) (b1 bool)
	inspectFuncEquals   func(other SignatureKeyHolder)
	afterEqualsCounter  uint64
	beforeEqualsCounter uint64
	EqualsMock          mSignatureKeyHolderMockEquals

	funcFixedByteSize          func() (i1 int)
	inspectFuncFixedByteSize   func()
	afterFixedByteSizeCounter  uint64
	beforeFixedByteSizeCounter uint64
	FixedByteSizeMock          mSignatureKeyHolderMockFixedByteSize

	funcFoldToUint64          func() (u1 uint64)
	inspectFuncFoldToUint64   func()
	afterFoldToUint64Counter  uint64
	beforeFoldToUint64Counter uint64
	FoldToUint64Mock          mSignatureKeyHolderMockFoldToUint64

	funcGetSignMethod          func() (s1 SignMethod)
	inspectFuncGetSignMethod   func()
	afterGetSignMethodCounter  uint64
	beforeGetSignMethodCounter uint64
	GetSignMethodMock          mSignatureKeyHolderMockGetSignMethod

	funcGetSignatureKeyMethod          func() (s1 SignatureMethod)
	inspectFuncGetSignatureKeyMethod   func()
	afterGetSignatureKeyMethodCounter  uint64
	beforeGetSignatureKeyMethodCounter uint64
	GetSignatureKeyMethodMock          mSignatureKeyHolderMockGetSignatureKeyMethod

	funcGetSignatureKeyType          func() (s1 SignatureKeyType)
	inspectFuncGetSignatureKeyType   func()
	afterGetSignatureKeyTypeCounter  uint64
	beforeGetSignatureKeyTypeCounter uint64
	GetSignatureKeyTypeMock          mSignatureKeyHolderMockGetSignatureKeyType

	funcRead          func(p []byte) (n int, err error)
	inspectFuncRead   func(p []byte)
	afterReadCounter  uint64
	beforeReadCounter uint64
	ReadMock          mSignatureKeyHolderMockRead

	funcWriteTo          func(w io.Writer) (n int64, err error)
	inspectFuncWriteTo   func(w io.Writer)
	afterWriteToCounter  uint64
	beforeWriteToCounter uint64
	WriteToMock          mSignatureKeyHolderMockWriteTo
}

// NewSignatureKeyHolderMock returns a mock for SignatureKeyHolder
func NewSignatureKeyHolderMock(t minimock.Tester) *SignatureKeyHolderMock {
	m := &SignatureKeyHolderMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AsByteStringMock = mSignatureKeyHolderMockAsByteString{mock: m}

	m.AsBytesMock = mSignatureKeyHolderMockAsBytes{mock: m}

	m.EqualsMock = mSignatureKeyHolderMockEquals{mock: m}
	m.EqualsMock.callArgs = []*SignatureKeyHolderMockEqualsParams{}

	m.FixedByteSizeMock = mSignatureKeyHolderMockFixedByteSize{mock: m}

	m.FoldToUint64Mock = mSignatureKeyHolderMockFoldToUint64{mock: m}

	m.GetSignMethodMock = mSignatureKeyHolderMockGetSignMethod{mock: m}

	m.GetSignatureKeyMethodMock = mSignatureKeyHolderMockGetSignatureKeyMethod{mock: m}

	m.GetSignatureKeyTypeMock = mSignatureKeyHolderMockGetSignatureKeyType{mock: m}

	m.ReadMock = mSignatureKeyHolderMockRead{mock: m}
	m.ReadMock.callArgs = []*SignatureKeyHolderMockReadParams{}

	m.WriteToMock = mSignatureKeyHolderMockWriteTo{mock: m}
	m.WriteToMock.callArgs = []*SignatureKeyHolderMockWriteToParams{}

	return m
}

type mSignatureKeyHolderMockAsByteString struct {
	mock               *SignatureKeyHolderMock
	defaultExpectation *SignatureKeyHolderMockAsByteStringExpectation
	expectations       []*SignatureKeyHolderMockAsByteStringExpectation
}

// SignatureKeyHolderMockAsByteStringExpectation specifies expectation struct of the SignatureKeyHolder.AsByteString
type SignatureKeyHolderMockAsByteStringExpectation struct {
	mock *SignatureKeyHolderMock

	results *SignatureKeyHolderMockAsByteStringResults
	Counter uint64
}

// SignatureKeyHolderMockAsByteStringResults contains results of the SignatureKeyHolder.AsByteString
type SignatureKeyHolderMockAsByteStringResults struct {
	b1 longbits.ByteString
}

// Expect sets up expected params for SignatureKeyHolder.AsByteString
func (mmAsByteString *mSignatureKeyHolderMockAsByteString) Expect() *mSignatureKeyHolderMockAsByteString {
	if mmAsByteString.mock.funcAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("SignatureKeyHolderMock.AsByteString mock is already set by Set")
	}

	if mmAsByteString.defaultExpectation == nil {
		mmAsByteString.defaultExpectation = &SignatureKeyHolderMockAsByteStringExpectation{}
	}

	return mmAsByteString
}

// Inspect accepts an inspector function that has same arguments as the SignatureKeyHolder.AsByteString
func (mmAsByteString *mSignatureKeyHolderMockAsByteString) Inspect(f func()) *mSignatureKeyHolderMockAsByteString {
	if mmAsByteString.mock.inspectFuncAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("Inspect function is already set for SignatureKeyHolderMock.AsByteString")
	}

	mmAsByteString.mock.inspectFuncAsByteString = f

	return mmAsByteString
}

// Return sets up results that will be returned by SignatureKeyHolder.AsByteString
func (mmAsByteString *mSignatureKeyHolderMockAsByteString) Return(b1 longbits.ByteString) *SignatureKeyHolderMock {
	if mmAsByteString.mock.funcAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("SignatureKeyHolderMock.AsByteString mock is already set by Set")
	}

	if mmAsByteString.defaultExpectation == nil {
		mmAsByteString.defaultExpectation = &SignatureKeyHolderMockAsByteStringExpectation{mock: mmAsByteString.mock}
	}
	mmAsByteString.defaultExpectation.results = &SignatureKeyHolderMockAsByteStringResults{b1}
	return mmAsByteString.mock
}

//Set uses given function f to mock the SignatureKeyHolder.AsByteString method
func (mmAsByteString *mSignatureKeyHolderMockAsByteString) Set(f func() (b1 longbits.ByteString)) *SignatureKeyHolderMock {
	if mmAsByteString.defaultExpectation != nil {
		mmAsByteString.mock.t.Fatalf("Default expectation is already set for the SignatureKeyHolder.AsByteString method")
	}

	if len(mmAsByteString.expectations) > 0 {
		mmAsByteString.mock.t.Fatalf("Some expectations are already set for the SignatureKeyHolder.AsByteString method")
	}

	mmAsByteString.mock.funcAsByteString = f
	return mmAsByteString.mock
}

// AsByteString implements SignatureKeyHolder
func (mmAsByteString *SignatureKeyHolderMock) AsByteString() (b1 longbits.ByteString) {
	mm_atomic.AddUint64(&mmAsByteString.beforeAsByteStringCounter, 1)
	defer mm_atomic.AddUint64(&mmAsByteString.afterAsByteStringCounter, 1)

	if mmAsByteString.inspectFuncAsByteString != nil {
		mmAsByteString.inspectFuncAsByteString()
	}

	if mmAsByteString.AsByteStringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAsByteString.AsByteStringMock.defaultExpectation.Counter, 1)

		results := mmAsByteString.AsByteStringMock.defaultExpectation.results
		if results == nil {
			mmAsByteString.t.Fatal("No results are set for the SignatureKeyHolderMock.AsByteString")
		}
		return (*results).b1
	}
	if mmAsByteString.funcAsByteString != nil {
		return mmAsByteString.funcAsByteString()
	}
	mmAsByteString.t.Fatalf("Unexpected call to SignatureKeyHolderMock.AsByteString.")
	return
}

// AsByteStringAfterCounter returns a count of finished SignatureKeyHolderMock.AsByteString invocations
func (mmAsByteString *SignatureKeyHolderMock) AsByteStringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsByteString.afterAsByteStringCounter)
}

// AsByteStringBeforeCounter returns a count of SignatureKeyHolderMock.AsByteString invocations
func (mmAsByteString *SignatureKeyHolderMock) AsByteStringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsByteString.beforeAsByteStringCounter)
}

// MinimockAsByteStringDone returns true if the count of the AsByteString invocations corresponds
// the number of defined expectations
func (m *SignatureKeyHolderMock) MinimockAsByteStringDone() bool {
	for _, e := range m.AsByteStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsByteStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsByteString != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		return false
	}
	return true
}

// MinimockAsByteStringInspect logs each unmet expectation
func (m *SignatureKeyHolderMock) MinimockAsByteStringInspect() {
	for _, e := range m.AsByteStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SignatureKeyHolderMock.AsByteString")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsByteStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		m.t.Error("Expected call to SignatureKeyHolderMock.AsByteString")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsByteString != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		m.t.Error("Expected call to SignatureKeyHolderMock.AsByteString")
	}
}

type mSignatureKeyHolderMockAsBytes struct {
	mock               *SignatureKeyHolderMock
	defaultExpectation *SignatureKeyHolderMockAsBytesExpectation
	expectations       []*SignatureKeyHolderMockAsBytesExpectation
}

// SignatureKeyHolderMockAsBytesExpectation specifies expectation struct of the SignatureKeyHolder.AsBytes
type SignatureKeyHolderMockAsBytesExpectation struct {
	mock *SignatureKeyHolderMock

	results *SignatureKeyHolderMockAsBytesResults
	Counter uint64
}

// SignatureKeyHolderMockAsBytesResults contains results of the SignatureKeyHolder.AsBytes
type SignatureKeyHolderMockAsBytesResults struct {
	ba1 []byte
}

// Expect sets up expected params for SignatureKeyHolder.AsBytes
func (mmAsBytes *mSignatureKeyHolderMockAsBytes) Expect() *mSignatureKeyHolderMockAsBytes {
	if mmAsBytes.mock.funcAsBytes != nil {
		mmAsBytes.mock.t.Fatalf("SignatureKeyHolderMock.AsBytes mock is already set by Set")
	}

	if mmAsBytes.defaultExpectation == nil {
		mmAsBytes.defaultExpectation = &SignatureKeyHolderMockAsBytesExpectation{}
	}

	return mmAsBytes
}

// Inspect accepts an inspector function that has same arguments as the SignatureKeyHolder.AsBytes
func (mmAsBytes *mSignatureKeyHolderMockAsBytes) Inspect(f func()) *mSignatureKeyHolderMockAsBytes {
	if mmAsBytes.mock.inspectFuncAsBytes != nil {
		mmAsBytes.mock.t.Fatalf("Inspect function is already set for SignatureKeyHolderMock.AsBytes")
	}

	mmAsBytes.mock.inspectFuncAsBytes = f

	return mmAsBytes
}

// Return sets up results that will be returned by SignatureKeyHolder.AsBytes
func (mmAsBytes *mSignatureKeyHolderMockAsBytes) Return(ba1 []byte) *SignatureKeyHolderMock {
	if mmAsBytes.mock.funcAsBytes != nil {
		mmAsBytes.mock.t.Fatalf("SignatureKeyHolderMock.AsBytes mock is already set by Set")
	}

	if mmAsBytes.defaultExpectation == nil {
		mmAsBytes.defaultExpectation = &SignatureKeyHolderMockAsBytesExpectation{mock: mmAsBytes.mock}
	}
	mmAsBytes.defaultExpectation.results = &SignatureKeyHolderMockAsBytesResults{ba1}
	return mmAsBytes.mock
}

//Set uses given function f to mock the SignatureKeyHolder.AsBytes method
func (mmAsBytes *mSignatureKeyHolderMockAsBytes) Set(f func() (ba1 []byte)) *SignatureKeyHolderMock {
	if mmAsBytes.defaultExpectation != nil {
		mmAsBytes.mock.t.Fatalf("Default expectation is already set for the SignatureKeyHolder.AsBytes method")
	}

	if len(mmAsBytes.expectations) > 0 {
		mmAsBytes.mock.t.Fatalf("Some expectations are already set for the SignatureKeyHolder.AsBytes method")
	}

	mmAsBytes.mock.funcAsBytes = f
	return mmAsBytes.mock
}

// AsBytes implements SignatureKeyHolder
func (mmAsBytes *SignatureKeyHolderMock) AsBytes() (ba1 []byte) {
	mm_atomic.AddUint64(&mmAsBytes.beforeAsBytesCounter, 1)
	defer mm_atomic.AddUint64(&mmAsBytes.afterAsBytesCounter, 1)

	if mmAsBytes.inspectFuncAsBytes != nil {
		mmAsBytes.inspectFuncAsBytes()
	}

	if mmAsBytes.AsBytesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAsBytes.AsBytesMock.defaultExpectation.Counter, 1)

		results := mmAsBytes.AsBytesMock.defaultExpectation.results
		if results == nil {
			mmAsBytes.t.Fatal("No results are set for the SignatureKeyHolderMock.AsBytes")
		}
		return (*results).ba1
	}
	if mmAsBytes.funcAsBytes != nil {
		return mmAsBytes.funcAsBytes()
	}
	mmAsBytes.t.Fatalf("Unexpected call to SignatureKeyHolderMock.AsBytes.")
	return
}

// AsBytesAfterCounter returns a count of finished SignatureKeyHolderMock.AsBytes invocations
func (mmAsBytes *SignatureKeyHolderMock) AsBytesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsBytes.afterAsBytesCounter)
}

// AsBytesBeforeCounter returns a count of SignatureKeyHolderMock.AsBytes invocations
func (mmAsBytes *SignatureKeyHolderMock) AsBytesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsBytes.beforeAsBytesCounter)
}

// MinimockAsBytesDone returns true if the count of the AsBytes invocations corresponds
// the number of defined expectations
func (m *SignatureKeyHolderMock) MinimockAsBytesDone() bool {
	for _, e := range m.AsBytesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsBytesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsBytesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsBytes != nil && mm_atomic.LoadUint64(&m.afterAsBytesCounter) < 1 {
		return false
	}
	return true
}

// MinimockAsBytesInspect logs each unmet expectation
func (m *SignatureKeyHolderMock) MinimockAsBytesInspect() {
	for _, e := range m.AsBytesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SignatureKeyHolderMock.AsBytes")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsBytesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsBytesCounter) < 1 {
		m.t.Error("Expected call to SignatureKeyHolderMock.AsBytes")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsBytes != nil && mm_atomic.LoadUint64(&m.afterAsBytesCounter) < 1 {
		m.t.Error("Expected call to SignatureKeyHolderMock.AsBytes")
	}
}

type mSignatureKeyHolderMockEquals struct {
	mock               *SignatureKeyHolderMock
	defaultExpectation *SignatureKeyHolderMockEqualsExpectation
	expectations       []*SignatureKeyHolderMockEqualsExpectation

	callArgs []*SignatureKeyHolderMockEqualsParams
	mutex    sync.RWMutex
}

// SignatureKeyHolderMockEqualsExpectation specifies expectation struct of the SignatureKeyHolder.Equals
type SignatureKeyHolderMockEqualsExpectation struct {
	mock    *SignatureKeyHolderMock
	params  *SignatureKeyHolderMockEqualsParams
	results *SignatureKeyHolderMockEqualsResults
	Counter uint64
}

// SignatureKeyHolderMockEqualsParams contains parameters of the SignatureKeyHolder.Equals
type SignatureKeyHolderMockEqualsParams struct {
	other SignatureKeyHolder
}

// SignatureKeyHolderMockEqualsResults contains results of the SignatureKeyHolder.Equals
type SignatureKeyHolderMockEqualsResults struct {
	b1 bool
}

// Expect sets up expected params for SignatureKeyHolder.Equals
func (mmEquals *mSignatureKeyHolderMockEquals) Expect(other SignatureKeyHolder) *mSignatureKeyHolderMockEquals {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("SignatureKeyHolderMock.Equals mock is already set by Set")
	}

	if mmEquals.defaultExpectation == nil {
		mmEquals.defaultExpectation = &SignatureKeyHolderMockEqualsExpectation{}
	}

	mmEquals.defaultExpectation.params = &SignatureKeyHolderMockEqualsParams{other}
	for _, e := range mmEquals.expectations {
		if minimock.Equal(e.params, mmEquals.defaultExpectation.params) {
			mmEquals.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEquals.defaultExpectation.params)
		}
	}

	return mmEquals
}

// Inspect accepts an inspector function that has same arguments as the SignatureKeyHolder.Equals
func (mmEquals *mSignatureKeyHolderMockEquals) Inspect(f func(other SignatureKeyHolder)) *mSignatureKeyHolderMockEquals {
	if mmEquals.mock.inspectFuncEquals != nil {
		mmEquals.mock.t.Fatalf("Inspect function is already set for SignatureKeyHolderMock.Equals")
	}

	mmEquals.mock.inspectFuncEquals = f

	return mmEquals
}

// Return sets up results that will be returned by SignatureKeyHolder.Equals
func (mmEquals *mSignatureKeyHolderMockEquals) Return(b1 bool) *SignatureKeyHolderMock {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("SignatureKeyHolderMock.Equals mock is already set by Set")
	}

	if mmEquals.defaultExpectation == nil {
		mmEquals.defaultExpectation = &SignatureKeyHolderMockEqualsExpectation{mock: mmEquals.mock}
	}
	mmEquals.defaultExpectation.results = &SignatureKeyHolderMockEqualsResults{b1}
	return mmEquals.mock
}

//Set uses given function f to mock the SignatureKeyHolder.Equals method
func (mmEquals *mSignatureKeyHolderMockEquals) Set(f func(other SignatureKeyHolder) (b1 bool)) *SignatureKeyHolderMock {
	if mmEquals.defaultExpectation != nil {
		mmEquals.mock.t.Fatalf("Default expectation is already set for the SignatureKeyHolder.Equals method")
	}

	if len(mmEquals.expectations) > 0 {
		mmEquals.mock.t.Fatalf("Some expectations are already set for the SignatureKeyHolder.Equals method")
	}

	mmEquals.mock.funcEquals = f
	return mmEquals.mock
}

// When sets expectation for the SignatureKeyHolder.Equals which will trigger the result defined by the following
// Then helper
func (mmEquals *mSignatureKeyHolderMockEquals) When(other SignatureKeyHolder) *SignatureKeyHolderMockEqualsExpectation {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("SignatureKeyHolderMock.Equals mock is already set by Set")
	}

	expectation := &SignatureKeyHolderMockEqualsExpectation{
		mock:   mmEquals.mock,
		params: &SignatureKeyHolderMockEqualsParams{other},
	}
	mmEquals.expectations = append(mmEquals.expectations, expectation)
	return expectation
}

// Then sets up SignatureKeyHolder.Equals return parameters for the expectation previously defined by the When method
func (e *SignatureKeyHolderMockEqualsExpectation) Then(b1 bool) *SignatureKeyHolderMock {
	e.results = &SignatureKeyHolderMockEqualsResults{b1}
	return e.mock
}

// Equals implements SignatureKeyHolder
func (mmEquals *SignatureKeyHolderMock) Equals(other SignatureKeyHolder) (b1 bool) {
	mm_atomic.AddUint64(&mmEquals.beforeEqualsCounter, 1)
	defer mm_atomic.AddUint64(&mmEquals.afterEqualsCounter, 1)

	if mmEquals.inspectFuncEquals != nil {
		mmEquals.inspectFuncEquals(other)
	}

	params := &SignatureKeyHolderMockEqualsParams{other}

	// Record call args
	mmEquals.EqualsMock.mutex.Lock()
	mmEquals.EqualsMock.callArgs = append(mmEquals.EqualsMock.callArgs, params)
	mmEquals.EqualsMock.mutex.Unlock()

	for _, e := range mmEquals.EqualsMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmEquals.EqualsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEquals.EqualsMock.defaultExpectation.Counter, 1)
		want := mmEquals.EqualsMock.defaultExpectation.params
		got := SignatureKeyHolderMockEqualsParams{other}
		if want != nil && !minimock.Equal(*want, got) {
			mmEquals.t.Errorf("SignatureKeyHolderMock.Equals got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmEquals.EqualsMock.defaultExpectation.results
		if results == nil {
			mmEquals.t.Fatal("No results are set for the SignatureKeyHolderMock.Equals")
		}
		return (*results).b1
	}
	if mmEquals.funcEquals != nil {
		return mmEquals.funcEquals(other)
	}
	mmEquals.t.Fatalf("Unexpected call to SignatureKeyHolderMock.Equals. %v", other)
	return
}

// EqualsAfterCounter returns a count of finished SignatureKeyHolderMock.Equals invocations
func (mmEquals *SignatureKeyHolderMock) EqualsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEquals.afterEqualsCounter)
}

// EqualsBeforeCounter returns a count of SignatureKeyHolderMock.Equals invocations
func (mmEquals *SignatureKeyHolderMock) EqualsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEquals.beforeEqualsCounter)
}

// Calls returns a list of arguments used in each call to SignatureKeyHolderMock.Equals.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEquals *mSignatureKeyHolderMockEquals) Calls() []*SignatureKeyHolderMockEqualsParams {
	mmEquals.mutex.RLock()

	argCopy := make([]*SignatureKeyHolderMockEqualsParams, len(mmEquals.callArgs))
	copy(argCopy, mmEquals.callArgs)

	mmEquals.mutex.RUnlock()

	return argCopy
}

// MinimockEqualsDone returns true if the count of the Equals invocations corresponds
// the number of defined expectations
func (m *SignatureKeyHolderMock) MinimockEqualsDone() bool {
	for _, e := range m.EqualsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EqualsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEquals != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		return false
	}
	return true
}

// MinimockEqualsInspect logs each unmet expectation
func (m *SignatureKeyHolderMock) MinimockEqualsInspect() {
	for _, e := range m.EqualsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SignatureKeyHolderMock.Equals with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EqualsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		if m.EqualsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SignatureKeyHolderMock.Equals")
		} else {
			m.t.Errorf("Expected call to SignatureKeyHolderMock.Equals with params: %#v", *m.EqualsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEquals != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		m.t.Error("Expected call to SignatureKeyHolderMock.Equals")
	}
}

type mSignatureKeyHolderMockFixedByteSize struct {
	mock               *SignatureKeyHolderMock
	defaultExpectation *SignatureKeyHolderMockFixedByteSizeExpectation
	expectations       []*SignatureKeyHolderMockFixedByteSizeExpectation
}

// SignatureKeyHolderMockFixedByteSizeExpectation specifies expectation struct of the SignatureKeyHolder.FixedByteSize
type SignatureKeyHolderMockFixedByteSizeExpectation struct {
	mock *SignatureKeyHolderMock

	results *SignatureKeyHolderMockFixedByteSizeResults
	Counter uint64
}

// SignatureKeyHolderMockFixedByteSizeResults contains results of the SignatureKeyHolder.FixedByteSize
type SignatureKeyHolderMockFixedByteSizeResults struct {
	i1 int
}

// Expect sets up expected params for SignatureKeyHolder.FixedByteSize
func (mmFixedByteSize *mSignatureKeyHolderMockFixedByteSize) Expect() *mSignatureKeyHolderMockFixedByteSize {
	if mmFixedByteSize.mock.funcFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("SignatureKeyHolderMock.FixedByteSize mock is already set by Set")
	}

	if mmFixedByteSize.defaultExpectation == nil {
		mmFixedByteSize.defaultExpectation = &SignatureKeyHolderMockFixedByteSizeExpectation{}
	}

	return mmFixedByteSize
}

// Inspect accepts an inspector function that has same arguments as the SignatureKeyHolder.FixedByteSize
func (mmFixedByteSize *mSignatureKeyHolderMockFixedByteSize) Inspect(f func()) *mSignatureKeyHolderMockFixedByteSize {
	if mmFixedByteSize.mock.inspectFuncFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("Inspect function is already set for SignatureKeyHolderMock.FixedByteSize")
	}

	mmFixedByteSize.mock.inspectFuncFixedByteSize = f

	return mmFixedByteSize
}

// Return sets up results that will be returned by SignatureKeyHolder.FixedByteSize
func (mmFixedByteSize *mSignatureKeyHolderMockFixedByteSize) Return(i1 int) *SignatureKeyHolderMock {
	if mmFixedByteSize.mock.funcFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("SignatureKeyHolderMock.FixedByteSize mock is already set by Set")
	}

	if mmFixedByteSize.defaultExpectation == nil {
		mmFixedByteSize.defaultExpectation = &SignatureKeyHolderMockFixedByteSizeExpectation{mock: mmFixedByteSize.mock}
	}
	mmFixedByteSize.defaultExpectation.results = &SignatureKeyHolderMockFixedByteSizeResults{i1}
	return mmFixedByteSize.mock
}

//Set uses given function f to mock the SignatureKeyHolder.FixedByteSize method
func (mmFixedByteSize *mSignatureKeyHolderMockFixedByteSize) Set(f func() (i1 int)) *SignatureKeyHolderMock {
	if mmFixedByteSize.defaultExpectation != nil {
		mmFixedByteSize.mock.t.Fatalf("Default expectation is already set for the SignatureKeyHolder.FixedByteSize method")
	}

	if len(mmFixedByteSize.expectations) > 0 {
		mmFixedByteSize.mock.t.Fatalf("Some expectations are already set for the SignatureKeyHolder.FixedByteSize method")
	}

	mmFixedByteSize.mock.funcFixedByteSize = f
	return mmFixedByteSize.mock
}

// FixedByteSize implements SignatureKeyHolder
func (mmFixedByteSize *SignatureKeyHolderMock) FixedByteSize() (i1 int) {
	mm_atomic.AddUint64(&mmFixedByteSize.beforeFixedByteSizeCounter, 1)
	defer mm_atomic.AddUint64(&mmFixedByteSize.afterFixedByteSizeCounter, 1)

	if mmFixedByteSize.inspectFuncFixedByteSize != nil {
		mmFixedByteSize.inspectFuncFixedByteSize()
	}

	if mmFixedByteSize.FixedByteSizeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFixedByteSize.FixedByteSizeMock.defaultExpectation.Counter, 1)

		results := mmFixedByteSize.FixedByteSizeMock.defaultExpectation.results
		if results == nil {
			mmFixedByteSize.t.Fatal("No results are set for the SignatureKeyHolderMock.FixedByteSize")
		}
		return (*results).i1
	}
	if mmFixedByteSize.funcFixedByteSize != nil {
		return mmFixedByteSize.funcFixedByteSize()
	}
	mmFixedByteSize.t.Fatalf("Unexpected call to SignatureKeyHolderMock.FixedByteSize.")
	return
}

// FixedByteSizeAfterCounter returns a count of finished SignatureKeyHolderMock.FixedByteSize invocations
func (mmFixedByteSize *SignatureKeyHolderMock) FixedByteSizeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFixedByteSize.afterFixedByteSizeCounter)
}

// FixedByteSizeBeforeCounter returns a count of SignatureKeyHolderMock.FixedByteSize invocations
func (mmFixedByteSize *SignatureKeyHolderMock) FixedByteSizeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFixedByteSize.beforeFixedByteSizeCounter)
}

// MinimockFixedByteSizeDone returns true if the count of the FixedByteSize invocations corresponds
// the number of defined expectations
func (m *SignatureKeyHolderMock) MinimockFixedByteSizeDone() bool {
	for _, e := range m.FixedByteSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FixedByteSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFixedByteSize != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		return false
	}
	return true
}

// MinimockFixedByteSizeInspect logs each unmet expectation
func (m *SignatureKeyHolderMock) MinimockFixedByteSizeInspect() {
	for _, e := range m.FixedByteSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SignatureKeyHolderMock.FixedByteSize")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FixedByteSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		m.t.Error("Expected call to SignatureKeyHolderMock.FixedByteSize")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFixedByteSize != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		m.t.Error("Expected call to SignatureKeyHolderMock.FixedByteSize")
	}
}

type mSignatureKeyHolderMockFoldToUint64 struct {
	mock               *SignatureKeyHolderMock
	defaultExpectation *SignatureKeyHolderMockFoldToUint64Expectation
	expectations       []*SignatureKeyHolderMockFoldToUint64Expectation
}

// SignatureKeyHolderMockFoldToUint64Expectation specifies expectation struct of the SignatureKeyHolder.FoldToUint64
type SignatureKeyHolderMockFoldToUint64Expectation struct {
	mock *SignatureKeyHolderMock

	results *SignatureKeyHolderMockFoldToUint64Results
	Counter uint64
}

// SignatureKeyHolderMockFoldToUint64Results contains results of the SignatureKeyHolder.FoldToUint64
type SignatureKeyHolderMockFoldToUint64Results struct {
	u1 uint64
}

// Expect sets up expected params for SignatureKeyHolder.FoldToUint64
func (mmFoldToUint64 *mSignatureKeyHolderMockFoldToUint64) Expect() *mSignatureKeyHolderMockFoldToUint64 {
	if mmFoldToUint64.mock.funcFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("SignatureKeyHolderMock.FoldToUint64 mock is already set by Set")
	}

	if mmFoldToUint64.defaultExpectation == nil {
		mmFoldToUint64.defaultExpectation = &SignatureKeyHolderMockFoldToUint64Expectation{}
	}

	return mmFoldToUint64
}

// Inspect accepts an inspector function that has same arguments as the SignatureKeyHolder.FoldToUint64
func (mmFoldToUint64 *mSignatureKeyHolderMockFoldToUint64) Inspect(f func()) *mSignatureKeyHolderMockFoldToUint64 {
	if mmFoldToUint64.mock.inspectFuncFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("Inspect function is already set for SignatureKeyHolderMock.FoldToUint64")
	}

	mmFoldToUint64.mock.inspectFuncFoldToUint64 = f

	return mmFoldToUint64
}

// Return sets up results that will be returned by SignatureKeyHolder.FoldToUint64
func (mmFoldToUint64 *mSignatureKeyHolderMockFoldToUint64) Return(u1 uint64) *SignatureKeyHolderMock {
	if mmFoldToUint64.mock.funcFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("SignatureKeyHolderMock.FoldToUint64 mock is already set by Set")
	}

	if mmFoldToUint64.defaultExpectation == nil {
		mmFoldToUint64.defaultExpectation = &SignatureKeyHolderMockFoldToUint64Expectation{mock: mmFoldToUint64.mock}
	}
	mmFoldToUint64.defaultExpectation.results = &SignatureKeyHolderMockFoldToUint64Results{u1}
	return mmFoldToUint64.mock
}

//Set uses given function f to mock the SignatureKeyHolder.FoldToUint64 method
func (mmFoldToUint64 *mSignatureKeyHolderMockFoldToUint64) Set(f func() (u1 uint64)) *SignatureKeyHolderMock {
	if mmFoldToUint64.defaultExpectation != nil {
		mmFoldToUint64.mock.t.Fatalf("Default expectation is already set for the SignatureKeyHolder.FoldToUint64 method")
	}

	if len(mmFoldToUint64.expectations) > 0 {
		mmFoldToUint64.mock.t.Fatalf("Some expectations are already set for the SignatureKeyHolder.FoldToUint64 method")
	}

	mmFoldToUint64.mock.funcFoldToUint64 = f
	return mmFoldToUint64.mock
}

// FoldToUint64 implements SignatureKeyHolder
func (mmFoldToUint64 *SignatureKeyHolderMock) FoldToUint64() (u1 uint64) {
	mm_atomic.AddUint64(&mmFoldToUint64.beforeFoldToUint64Counter, 1)
	defer mm_atomic.AddUint64(&mmFoldToUint64.afterFoldToUint64Counter, 1)

	if mmFoldToUint64.inspectFuncFoldToUint64 != nil {
		mmFoldToUint64.inspectFuncFoldToUint64()
	}

	if mmFoldToUint64.FoldToUint64Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFoldToUint64.FoldToUint64Mock.defaultExpectation.Counter, 1)

		results := mmFoldToUint64.FoldToUint64Mock.defaultExpectation.results
		if results == nil {
			mmFoldToUint64.t.Fatal("No results are set for the SignatureKeyHolderMock.FoldToUint64")
		}
		return (*results).u1
	}
	if mmFoldToUint64.funcFoldToUint64 != nil {
		return mmFoldToUint64.funcFoldToUint64()
	}
	mmFoldToUint64.t.Fatalf("Unexpected call to SignatureKeyHolderMock.FoldToUint64.")
	return
}

// FoldToUint64AfterCounter returns a count of finished SignatureKeyHolderMock.FoldToUint64 invocations
func (mmFoldToUint64 *SignatureKeyHolderMock) FoldToUint64AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFoldToUint64.afterFoldToUint64Counter)
}

// FoldToUint64BeforeCounter returns a count of SignatureKeyHolderMock.FoldToUint64 invocations
func (mmFoldToUint64 *SignatureKeyHolderMock) FoldToUint64BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFoldToUint64.beforeFoldToUint64Counter)
}

// MinimockFoldToUint64Done returns true if the count of the FoldToUint64 invocations corresponds
// the number of defined expectations
func (m *SignatureKeyHolderMock) MinimockFoldToUint64Done() bool {
	for _, e := range m.FoldToUint64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FoldToUint64Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFoldToUint64 != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		return false
	}
	return true
}

// MinimockFoldToUint64Inspect logs each unmet expectation
func (m *SignatureKeyHolderMock) MinimockFoldToUint64Inspect() {
	for _, e := range m.FoldToUint64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SignatureKeyHolderMock.FoldToUint64")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FoldToUint64Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		m.t.Error("Expected call to SignatureKeyHolderMock.FoldToUint64")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFoldToUint64 != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		m.t.Error("Expected call to SignatureKeyHolderMock.FoldToUint64")
	}
}

type mSignatureKeyHolderMockGetSignMethod struct {
	mock               *SignatureKeyHolderMock
	defaultExpectation *SignatureKeyHolderMockGetSignMethodExpectation
	expectations       []*SignatureKeyHolderMockGetSignMethodExpectation
}

// SignatureKeyHolderMockGetSignMethodExpectation specifies expectation struct of the SignatureKeyHolder.GetSignMethod
type SignatureKeyHolderMockGetSignMethodExpectation struct {
	mock *SignatureKeyHolderMock

	results *SignatureKeyHolderMockGetSignMethodResults
	Counter uint64
}

// SignatureKeyHolderMockGetSignMethodResults contains results of the SignatureKeyHolder.GetSignMethod
type SignatureKeyHolderMockGetSignMethodResults struct {
	s1 SignMethod
}

// Expect sets up expected params for SignatureKeyHolder.GetSignMethod
func (mmGetSignMethod *mSignatureKeyHolderMockGetSignMethod) Expect() *mSignatureKeyHolderMockGetSignMethod {
	if mmGetSignMethod.mock.funcGetSignMethod != nil {
		mmGetSignMethod.mock.t.Fatalf("SignatureKeyHolderMock.GetSignMethod mock is already set by Set")
	}

	if mmGetSignMethod.defaultExpectation == nil {
		mmGetSignMethod.defaultExpectation = &SignatureKeyHolderMockGetSignMethodExpectation{}
	}

	return mmGetSignMethod
}

// Inspect accepts an inspector function that has same arguments as the SignatureKeyHolder.GetSignMethod
func (mmGetSignMethod *mSignatureKeyHolderMockGetSignMethod) Inspect(f func()) *mSignatureKeyHolderMockGetSignMethod {
	if mmGetSignMethod.mock.inspectFuncGetSignMethod != nil {
		mmGetSignMethod.mock.t.Fatalf("Inspect function is already set for SignatureKeyHolderMock.GetSignMethod")
	}

	mmGetSignMethod.mock.inspectFuncGetSignMethod = f

	return mmGetSignMethod
}

// Return sets up results that will be returned by SignatureKeyHolder.GetSignMethod
func (mmGetSignMethod *mSignatureKeyHolderMockGetSignMethod) Return(s1 SignMethod) *SignatureKeyHolderMock {
	if mmGetSignMethod.mock.funcGetSignMethod != nil {
		mmGetSignMethod.mock.t.Fatalf("SignatureKeyHolderMock.GetSignMethod mock is already set by Set")
	}

	if mmGetSignMethod.defaultExpectation == nil {
		mmGetSignMethod.defaultExpectation = &SignatureKeyHolderMockGetSignMethodExpectation{mock: mmGetSignMethod.mock}
	}
	mmGetSignMethod.defaultExpectation.results = &SignatureKeyHolderMockGetSignMethodResults{s1}
	return mmGetSignMethod.mock
}

//Set uses given function f to mock the SignatureKeyHolder.GetSignMethod method
func (mmGetSignMethod *mSignatureKeyHolderMockGetSignMethod) Set(f func() (s1 SignMethod)) *SignatureKeyHolderMock {
	if mmGetSignMethod.defaultExpectation != nil {
		mmGetSignMethod.mock.t.Fatalf("Default expectation is already set for the SignatureKeyHolder.GetSignMethod method")
	}

	if len(mmGetSignMethod.expectations) > 0 {
		mmGetSignMethod.mock.t.Fatalf("Some expectations are already set for the SignatureKeyHolder.GetSignMethod method")
	}

	mmGetSignMethod.mock.funcGetSignMethod = f
	return mmGetSignMethod.mock
}

// GetSignMethod implements SignatureKeyHolder
func (mmGetSignMethod *SignatureKeyHolderMock) GetSignMethod() (s1 SignMethod) {
	mm_atomic.AddUint64(&mmGetSignMethod.beforeGetSignMethodCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSignMethod.afterGetSignMethodCounter, 1)

	if mmGetSignMethod.inspectFuncGetSignMethod != nil {
		mmGetSignMethod.inspectFuncGetSignMethod()
	}

	if mmGetSignMethod.GetSignMethodMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSignMethod.GetSignMethodMock.defaultExpectation.Counter, 1)

		results := mmGetSignMethod.GetSignMethodMock.defaultExpectation.results
		if results == nil {
			mmGetSignMethod.t.Fatal("No results are set for the SignatureKeyHolderMock.GetSignMethod")
		}
		return (*results).s1
	}
	if mmGetSignMethod.funcGetSignMethod != nil {
		return mmGetSignMethod.funcGetSignMethod()
	}
	mmGetSignMethod.t.Fatalf("Unexpected call to SignatureKeyHolderMock.GetSignMethod.")
	return
}

// GetSignMethodAfterCounter returns a count of finished SignatureKeyHolderMock.GetSignMethod invocations
func (mmGetSignMethod *SignatureKeyHolderMock) GetSignMethodAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSignMethod.afterGetSignMethodCounter)
}

// GetSignMethodBeforeCounter returns a count of SignatureKeyHolderMock.GetSignMethod invocations
func (mmGetSignMethod *SignatureKeyHolderMock) GetSignMethodBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSignMethod.beforeGetSignMethodCounter)
}

// MinimockGetSignMethodDone returns true if the count of the GetSignMethod invocations corresponds
// the number of defined expectations
func (m *SignatureKeyHolderMock) MinimockGetSignMethodDone() bool {
	for _, e := range m.GetSignMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSignMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSignMethodCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSignMethod != nil && mm_atomic.LoadUint64(&m.afterGetSignMethodCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSignMethodInspect logs each unmet expectation
func (m *SignatureKeyHolderMock) MinimockGetSignMethodInspect() {
	for _, e := range m.GetSignMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SignatureKeyHolderMock.GetSignMethod")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSignMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSignMethodCounter) < 1 {
		m.t.Error("Expected call to SignatureKeyHolderMock.GetSignMethod")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSignMethod != nil && mm_atomic.LoadUint64(&m.afterGetSignMethodCounter) < 1 {
		m.t.Error("Expected call to SignatureKeyHolderMock.GetSignMethod")
	}
}

type mSignatureKeyHolderMockGetSignatureKeyMethod struct {
	mock               *SignatureKeyHolderMock
	defaultExpectation *SignatureKeyHolderMockGetSignatureKeyMethodExpectation
	expectations       []*SignatureKeyHolderMockGetSignatureKeyMethodExpectation
}

// SignatureKeyHolderMockGetSignatureKeyMethodExpectation specifies expectation struct of the SignatureKeyHolder.GetSignatureKeyMethod
type SignatureKeyHolderMockGetSignatureKeyMethodExpectation struct {
	mock *SignatureKeyHolderMock

	results *SignatureKeyHolderMockGetSignatureKeyMethodResults
	Counter uint64
}

// SignatureKeyHolderMockGetSignatureKeyMethodResults contains results of the SignatureKeyHolder.GetSignatureKeyMethod
type SignatureKeyHolderMockGetSignatureKeyMethodResults struct {
	s1 SignatureMethod
}

// Expect sets up expected params for SignatureKeyHolder.GetSignatureKeyMethod
func (mmGetSignatureKeyMethod *mSignatureKeyHolderMockGetSignatureKeyMethod) Expect() *mSignatureKeyHolderMockGetSignatureKeyMethod {
	if mmGetSignatureKeyMethod.mock.funcGetSignatureKeyMethod != nil {
		mmGetSignatureKeyMethod.mock.t.Fatalf("SignatureKeyHolderMock.GetSignatureKeyMethod mock is already set by Set")
	}

	if mmGetSignatureKeyMethod.defaultExpectation == nil {
		mmGetSignatureKeyMethod.defaultExpectation = &SignatureKeyHolderMockGetSignatureKeyMethodExpectation{}
	}

	return mmGetSignatureKeyMethod
}

// Inspect accepts an inspector function that has same arguments as the SignatureKeyHolder.GetSignatureKeyMethod
func (mmGetSignatureKeyMethod *mSignatureKeyHolderMockGetSignatureKeyMethod) Inspect(f func()) *mSignatureKeyHolderMockGetSignatureKeyMethod {
	if mmGetSignatureKeyMethod.mock.inspectFuncGetSignatureKeyMethod != nil {
		mmGetSignatureKeyMethod.mock.t.Fatalf("Inspect function is already set for SignatureKeyHolderMock.GetSignatureKeyMethod")
	}

	mmGetSignatureKeyMethod.mock.inspectFuncGetSignatureKeyMethod = f

	return mmGetSignatureKeyMethod
}

// Return sets up results that will be returned by SignatureKeyHolder.GetSignatureKeyMethod
func (mmGetSignatureKeyMethod *mSignatureKeyHolderMockGetSignatureKeyMethod) Return(s1 SignatureMethod) *SignatureKeyHolderMock {
	if mmGetSignatureKeyMethod.mock.funcGetSignatureKeyMethod != nil {
		mmGetSignatureKeyMethod.mock.t.Fatalf("SignatureKeyHolderMock.GetSignatureKeyMethod mock is already set by Set")
	}

	if mmGetSignatureKeyMethod.defaultExpectation == nil {
		mmGetSignatureKeyMethod.defaultExpectation = &SignatureKeyHolderMockGetSignatureKeyMethodExpectation{mock: mmGetSignatureKeyMethod.mock}
	}
	mmGetSignatureKeyMethod.defaultExpectation.results = &SignatureKeyHolderMockGetSignatureKeyMethodResults{s1}
	return mmGetSignatureKeyMethod.mock
}

//Set uses given function f to mock the SignatureKeyHolder.GetSignatureKeyMethod method
func (mmGetSignatureKeyMethod *mSignatureKeyHolderMockGetSignatureKeyMethod) Set(f func() (s1 SignatureMethod)) *SignatureKeyHolderMock {
	if mmGetSignatureKeyMethod.defaultExpectation != nil {
		mmGetSignatureKeyMethod.mock.t.Fatalf("Default expectation is already set for the SignatureKeyHolder.GetSignatureKeyMethod method")
	}

	if len(mmGetSignatureKeyMethod.expectations) > 0 {
		mmGetSignatureKeyMethod.mock.t.Fatalf("Some expectations are already set for the SignatureKeyHolder.GetSignatureKeyMethod method")
	}

	mmGetSignatureKeyMethod.mock.funcGetSignatureKeyMethod = f
	return mmGetSignatureKeyMethod.mock
}

// GetSignatureKeyMethod implements SignatureKeyHolder
func (mmGetSignatureKeyMethod *SignatureKeyHolderMock) GetSignatureKeyMethod() (s1 SignatureMethod) {
	mm_atomic.AddUint64(&mmGetSignatureKeyMethod.beforeGetSignatureKeyMethodCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSignatureKeyMethod.afterGetSignatureKeyMethodCounter, 1)

	if mmGetSignatureKeyMethod.inspectFuncGetSignatureKeyMethod != nil {
		mmGetSignatureKeyMethod.inspectFuncGetSignatureKeyMethod()
	}

	if mmGetSignatureKeyMethod.GetSignatureKeyMethodMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSignatureKeyMethod.GetSignatureKeyMethodMock.defaultExpectation.Counter, 1)

		results := mmGetSignatureKeyMethod.GetSignatureKeyMethodMock.defaultExpectation.results
		if results == nil {
			mmGetSignatureKeyMethod.t.Fatal("No results are set for the SignatureKeyHolderMock.GetSignatureKeyMethod")
		}
		return (*results).s1
	}
	if mmGetSignatureKeyMethod.funcGetSignatureKeyMethod != nil {
		return mmGetSignatureKeyMethod.funcGetSignatureKeyMethod()
	}
	mmGetSignatureKeyMethod.t.Fatalf("Unexpected call to SignatureKeyHolderMock.GetSignatureKeyMethod.")
	return
}

// GetSignatureKeyMethodAfterCounter returns a count of finished SignatureKeyHolderMock.GetSignatureKeyMethod invocations
func (mmGetSignatureKeyMethod *SignatureKeyHolderMock) GetSignatureKeyMethodAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSignatureKeyMethod.afterGetSignatureKeyMethodCounter)
}

// GetSignatureKeyMethodBeforeCounter returns a count of SignatureKeyHolderMock.GetSignatureKeyMethod invocations
func (mmGetSignatureKeyMethod *SignatureKeyHolderMock) GetSignatureKeyMethodBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSignatureKeyMethod.beforeGetSignatureKeyMethodCounter)
}

// MinimockGetSignatureKeyMethodDone returns true if the count of the GetSignatureKeyMethod invocations corresponds
// the number of defined expectations
func (m *SignatureKeyHolderMock) MinimockGetSignatureKeyMethodDone() bool {
	for _, e := range m.GetSignatureKeyMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSignatureKeyMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSignatureKeyMethodCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSignatureKeyMethod != nil && mm_atomic.LoadUint64(&m.afterGetSignatureKeyMethodCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSignatureKeyMethodInspect logs each unmet expectation
func (m *SignatureKeyHolderMock) MinimockGetSignatureKeyMethodInspect() {
	for _, e := range m.GetSignatureKeyMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SignatureKeyHolderMock.GetSignatureKeyMethod")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSignatureKeyMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSignatureKeyMethodCounter) < 1 {
		m.t.Error("Expected call to SignatureKeyHolderMock.GetSignatureKeyMethod")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSignatureKeyMethod != nil && mm_atomic.LoadUint64(&m.afterGetSignatureKeyMethodCounter) < 1 {
		m.t.Error("Expected call to SignatureKeyHolderMock.GetSignatureKeyMethod")
	}
}

type mSignatureKeyHolderMockGetSignatureKeyType struct {
	mock               *SignatureKeyHolderMock
	defaultExpectation *SignatureKeyHolderMockGetSignatureKeyTypeExpectation
	expectations       []*SignatureKeyHolderMockGetSignatureKeyTypeExpectation
}

// SignatureKeyHolderMockGetSignatureKeyTypeExpectation specifies expectation struct of the SignatureKeyHolder.GetSignatureKeyType
type SignatureKeyHolderMockGetSignatureKeyTypeExpectation struct {
	mock *SignatureKeyHolderMock

	results *SignatureKeyHolderMockGetSignatureKeyTypeResults
	Counter uint64
}

// SignatureKeyHolderMockGetSignatureKeyTypeResults contains results of the SignatureKeyHolder.GetSignatureKeyType
type SignatureKeyHolderMockGetSignatureKeyTypeResults struct {
	s1 SignatureKeyType
}

// Expect sets up expected params for SignatureKeyHolder.GetSignatureKeyType
func (mmGetSignatureKeyType *mSignatureKeyHolderMockGetSignatureKeyType) Expect() *mSignatureKeyHolderMockGetSignatureKeyType {
	if mmGetSignatureKeyType.mock.funcGetSignatureKeyType != nil {
		mmGetSignatureKeyType.mock.t.Fatalf("SignatureKeyHolderMock.GetSignatureKeyType mock is already set by Set")
	}

	if mmGetSignatureKeyType.defaultExpectation == nil {
		mmGetSignatureKeyType.defaultExpectation = &SignatureKeyHolderMockGetSignatureKeyTypeExpectation{}
	}

	return mmGetSignatureKeyType
}

// Inspect accepts an inspector function that has same arguments as the SignatureKeyHolder.GetSignatureKeyType
func (mmGetSignatureKeyType *mSignatureKeyHolderMockGetSignatureKeyType) Inspect(f func()) *mSignatureKeyHolderMockGetSignatureKeyType {
	if mmGetSignatureKeyType.mock.inspectFuncGetSignatureKeyType != nil {
		mmGetSignatureKeyType.mock.t.Fatalf("Inspect function is already set for SignatureKeyHolderMock.GetSignatureKeyType")
	}

	mmGetSignatureKeyType.mock.inspectFuncGetSignatureKeyType = f

	return mmGetSignatureKeyType
}

// Return sets up results that will be returned by SignatureKeyHolder.GetSignatureKeyType
func (mmGetSignatureKeyType *mSignatureKeyHolderMockGetSignatureKeyType) Return(s1 SignatureKeyType) *SignatureKeyHolderMock {
	if mmGetSignatureKeyType.mock.funcGetSignatureKeyType != nil {
		mmGetSignatureKeyType.mock.t.Fatalf("SignatureKeyHolderMock.GetSignatureKeyType mock is already set by Set")
	}

	if mmGetSignatureKeyType.defaultExpectation == nil {
		mmGetSignatureKeyType.defaultExpectation = &SignatureKeyHolderMockGetSignatureKeyTypeExpectation{mock: mmGetSignatureKeyType.mock}
	}
	mmGetSignatureKeyType.defaultExpectation.results = &SignatureKeyHolderMockGetSignatureKeyTypeResults{s1}
	return mmGetSignatureKeyType.mock
}

//Set uses given function f to mock the SignatureKeyHolder.GetSignatureKeyType method
func (mmGetSignatureKeyType *mSignatureKeyHolderMockGetSignatureKeyType) Set(f func() (s1 SignatureKeyType)) *SignatureKeyHolderMock {
	if mmGetSignatureKeyType.defaultExpectation != nil {
		mmGetSignatureKeyType.mock.t.Fatalf("Default expectation is already set for the SignatureKeyHolder.GetSignatureKeyType method")
	}

	if len(mmGetSignatureKeyType.expectations) > 0 {
		mmGetSignatureKeyType.mock.t.Fatalf("Some expectations are already set for the SignatureKeyHolder.GetSignatureKeyType method")
	}

	mmGetSignatureKeyType.mock.funcGetSignatureKeyType = f
	return mmGetSignatureKeyType.mock
}

// GetSignatureKeyType implements SignatureKeyHolder
func (mmGetSignatureKeyType *SignatureKeyHolderMock) GetSignatureKeyType() (s1 SignatureKeyType) {
	mm_atomic.AddUint64(&mmGetSignatureKeyType.beforeGetSignatureKeyTypeCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSignatureKeyType.afterGetSignatureKeyTypeCounter, 1)

	if mmGetSignatureKeyType.inspectFuncGetSignatureKeyType != nil {
		mmGetSignatureKeyType.inspectFuncGetSignatureKeyType()
	}

	if mmGetSignatureKeyType.GetSignatureKeyTypeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSignatureKeyType.GetSignatureKeyTypeMock.defaultExpectation.Counter, 1)

		results := mmGetSignatureKeyType.GetSignatureKeyTypeMock.defaultExpectation.results
		if results == nil {
			mmGetSignatureKeyType.t.Fatal("No results are set for the SignatureKeyHolderMock.GetSignatureKeyType")
		}
		return (*results).s1
	}
	if mmGetSignatureKeyType.funcGetSignatureKeyType != nil {
		return mmGetSignatureKeyType.funcGetSignatureKeyType()
	}
	mmGetSignatureKeyType.t.Fatalf("Unexpected call to SignatureKeyHolderMock.GetSignatureKeyType.")
	return
}

// GetSignatureKeyTypeAfterCounter returns a count of finished SignatureKeyHolderMock.GetSignatureKeyType invocations
func (mmGetSignatureKeyType *SignatureKeyHolderMock) GetSignatureKeyTypeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSignatureKeyType.afterGetSignatureKeyTypeCounter)
}

// GetSignatureKeyTypeBeforeCounter returns a count of SignatureKeyHolderMock.GetSignatureKeyType invocations
func (mmGetSignatureKeyType *SignatureKeyHolderMock) GetSignatureKeyTypeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSignatureKeyType.beforeGetSignatureKeyTypeCounter)
}

// MinimockGetSignatureKeyTypeDone returns true if the count of the GetSignatureKeyType invocations corresponds
// the number of defined expectations
func (m *SignatureKeyHolderMock) MinimockGetSignatureKeyTypeDone() bool {
	for _, e := range m.GetSignatureKeyTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSignatureKeyTypeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSignatureKeyTypeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSignatureKeyType != nil && mm_atomic.LoadUint64(&m.afterGetSignatureKeyTypeCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSignatureKeyTypeInspect logs each unmet expectation
func (m *SignatureKeyHolderMock) MinimockGetSignatureKeyTypeInspect() {
	for _, e := range m.GetSignatureKeyTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SignatureKeyHolderMock.GetSignatureKeyType")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSignatureKeyTypeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSignatureKeyTypeCounter) < 1 {
		m.t.Error("Expected call to SignatureKeyHolderMock.GetSignatureKeyType")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSignatureKeyType != nil && mm_atomic.LoadUint64(&m.afterGetSignatureKeyTypeCounter) < 1 {
		m.t.Error("Expected call to SignatureKeyHolderMock.GetSignatureKeyType")
	}
}

type mSignatureKeyHolderMockRead struct {
	mock               *SignatureKeyHolderMock
	defaultExpectation *SignatureKeyHolderMockReadExpectation
	expectations       []*SignatureKeyHolderMockReadExpectation

	callArgs []*SignatureKeyHolderMockReadParams
	mutex    sync.RWMutex
}

// SignatureKeyHolderMockReadExpectation specifies expectation struct of the SignatureKeyHolder.Read
type SignatureKeyHolderMockReadExpectation struct {
	mock    *SignatureKeyHolderMock
	params  *SignatureKeyHolderMockReadParams
	results *SignatureKeyHolderMockReadResults
	Counter uint64
}

// SignatureKeyHolderMockReadParams contains parameters of the SignatureKeyHolder.Read
type SignatureKeyHolderMockReadParams struct {
	p []byte
}

// SignatureKeyHolderMockReadResults contains results of the SignatureKeyHolder.Read
type SignatureKeyHolderMockReadResults struct {
	n   int
	err error
}

// Expect sets up expected params for SignatureKeyHolder.Read
func (mmRead *mSignatureKeyHolderMockRead) Expect(p []byte) *mSignatureKeyHolderMockRead {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("SignatureKeyHolderMock.Read mock is already set by Set")
	}

	if mmRead.defaultExpectation == nil {
		mmRead.defaultExpectation = &SignatureKeyHolderMockReadExpectation{}
	}

	mmRead.defaultExpectation.params = &SignatureKeyHolderMockReadParams{p}
	for _, e := range mmRead.expectations {
		if minimock.Equal(e.params, mmRead.defaultExpectation.params) {
			mmRead.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRead.defaultExpectation.params)
		}
	}

	return mmRead
}

// Inspect accepts an inspector function that has same arguments as the SignatureKeyHolder.Read
func (mmRead *mSignatureKeyHolderMockRead) Inspect(f func(p []byte)) *mSignatureKeyHolderMockRead {
	if mmRead.mock.inspectFuncRead != nil {
		mmRead.mock.t.Fatalf("Inspect function is already set for SignatureKeyHolderMock.Read")
	}

	mmRead.mock.inspectFuncRead = f

	return mmRead
}

// Return sets up results that will be returned by SignatureKeyHolder.Read
func (mmRead *mSignatureKeyHolderMockRead) Return(n int, err error) *SignatureKeyHolderMock {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("SignatureKeyHolderMock.Read mock is already set by Set")
	}

	if mmRead.defaultExpectation == nil {
		mmRead.defaultExpectation = &SignatureKeyHolderMockReadExpectation{mock: mmRead.mock}
	}
	mmRead.defaultExpectation.results = &SignatureKeyHolderMockReadResults{n, err}
	return mmRead.mock
}

//Set uses given function f to mock the SignatureKeyHolder.Read method
func (mmRead *mSignatureKeyHolderMockRead) Set(f func(p []byte) (n int, err error)) *SignatureKeyHolderMock {
	if mmRead.defaultExpectation != nil {
		mmRead.mock.t.Fatalf("Default expectation is already set for the SignatureKeyHolder.Read method")
	}

	if len(mmRead.expectations) > 0 {
		mmRead.mock.t.Fatalf("Some expectations are already set for the SignatureKeyHolder.Read method")
	}

	mmRead.mock.funcRead = f
	return mmRead.mock
}

// When sets expectation for the SignatureKeyHolder.Read which will trigger the result defined by the following
// Then helper
func (mmRead *mSignatureKeyHolderMockRead) When(p []byte) *SignatureKeyHolderMockReadExpectation {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("SignatureKeyHolderMock.Read mock is already set by Set")
	}

	expectation := &SignatureKeyHolderMockReadExpectation{
		mock:   mmRead.mock,
		params: &SignatureKeyHolderMockReadParams{p},
	}
	mmRead.expectations = append(mmRead.expectations, expectation)
	return expectation
}

// Then sets up SignatureKeyHolder.Read return parameters for the expectation previously defined by the When method
func (e *SignatureKeyHolderMockReadExpectation) Then(n int, err error) *SignatureKeyHolderMock {
	e.results = &SignatureKeyHolderMockReadResults{n, err}
	return e.mock
}

// Read implements SignatureKeyHolder
func (mmRead *SignatureKeyHolderMock) Read(p []byte) (n int, err error) {
	mm_atomic.AddUint64(&mmRead.beforeReadCounter, 1)
	defer mm_atomic.AddUint64(&mmRead.afterReadCounter, 1)

	if mmRead.inspectFuncRead != nil {
		mmRead.inspectFuncRead(p)
	}

	params := &SignatureKeyHolderMockReadParams{p}

	// Record call args
	mmRead.ReadMock.mutex.Lock()
	mmRead.ReadMock.callArgs = append(mmRead.ReadMock.callArgs, params)
	mmRead.ReadMock.mutex.Unlock()

	for _, e := range mmRead.ReadMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmRead.ReadMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRead.ReadMock.defaultExpectation.Counter, 1)
		want := mmRead.ReadMock.defaultExpectation.params
		got := SignatureKeyHolderMockReadParams{p}
		if want != nil && !minimock.Equal(*want, got) {
			mmRead.t.Errorf("SignatureKeyHolderMock.Read got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmRead.ReadMock.defaultExpectation.results
		if results == nil {
			mmRead.t.Fatal("No results are set for the SignatureKeyHolderMock.Read")
		}
		return (*results).n, (*results).err
	}
	if mmRead.funcRead != nil {
		return mmRead.funcRead(p)
	}
	mmRead.t.Fatalf("Unexpected call to SignatureKeyHolderMock.Read. %v", p)
	return
}

// ReadAfterCounter returns a count of finished SignatureKeyHolderMock.Read invocations
func (mmRead *SignatureKeyHolderMock) ReadAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRead.afterReadCounter)
}

// ReadBeforeCounter returns a count of SignatureKeyHolderMock.Read invocations
func (mmRead *SignatureKeyHolderMock) ReadBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRead.beforeReadCounter)
}

// Calls returns a list of arguments used in each call to SignatureKeyHolderMock.Read.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRead *mSignatureKeyHolderMockRead) Calls() []*SignatureKeyHolderMockReadParams {
	mmRead.mutex.RLock()

	argCopy := make([]*SignatureKeyHolderMockReadParams, len(mmRead.callArgs))
	copy(argCopy, mmRead.callArgs)

	mmRead.mutex.RUnlock()

	return argCopy
}

// MinimockReadDone returns true if the count of the Read invocations corresponds
// the number of defined expectations
func (m *SignatureKeyHolderMock) MinimockReadDone() bool {
	for _, e := range m.ReadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRead != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		return false
	}
	return true
}

// MinimockReadInspect logs each unmet expectation
func (m *SignatureKeyHolderMock) MinimockReadInspect() {
	for _, e := range m.ReadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SignatureKeyHolderMock.Read with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		if m.ReadMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SignatureKeyHolderMock.Read")
		} else {
			m.t.Errorf("Expected call to SignatureKeyHolderMock.Read with params: %#v", *m.ReadMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRead != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		m.t.Error("Expected call to SignatureKeyHolderMock.Read")
	}
}

type mSignatureKeyHolderMockWriteTo struct {
	mock               *SignatureKeyHolderMock
	defaultExpectation *SignatureKeyHolderMockWriteToExpectation
	expectations       []*SignatureKeyHolderMockWriteToExpectation

	callArgs []*SignatureKeyHolderMockWriteToParams
	mutex    sync.RWMutex
}

// SignatureKeyHolderMockWriteToExpectation specifies expectation struct of the SignatureKeyHolder.WriteTo
type SignatureKeyHolderMockWriteToExpectation struct {
	mock    *SignatureKeyHolderMock
	params  *SignatureKeyHolderMockWriteToParams
	results *SignatureKeyHolderMockWriteToResults
	Counter uint64
}

// SignatureKeyHolderMockWriteToParams contains parameters of the SignatureKeyHolder.WriteTo
type SignatureKeyHolderMockWriteToParams struct {
	w io.Writer
}

// SignatureKeyHolderMockWriteToResults contains results of the SignatureKeyHolder.WriteTo
type SignatureKeyHolderMockWriteToResults struct {
	n   int64
	err error
}

// Expect sets up expected params for SignatureKeyHolder.WriteTo
func (mmWriteTo *mSignatureKeyHolderMockWriteTo) Expect(w io.Writer) *mSignatureKeyHolderMockWriteTo {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("SignatureKeyHolderMock.WriteTo mock is already set by Set")
	}

	if mmWriteTo.defaultExpectation == nil {
		mmWriteTo.defaultExpectation = &SignatureKeyHolderMockWriteToExpectation{}
	}

	mmWriteTo.defaultExpectation.params = &SignatureKeyHolderMockWriteToParams{w}
	for _, e := range mmWriteTo.expectations {
		if minimock.Equal(e.params, mmWriteTo.defaultExpectation.params) {
			mmWriteTo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWriteTo.defaultExpectation.params)
		}
	}

	return mmWriteTo
}

// Inspect accepts an inspector function that has same arguments as the SignatureKeyHolder.WriteTo
func (mmWriteTo *mSignatureKeyHolderMockWriteTo) Inspect(f func(w io.Writer)) *mSignatureKeyHolderMockWriteTo {
	if mmWriteTo.mock.inspectFuncWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("Inspect function is already set for SignatureKeyHolderMock.WriteTo")
	}

	mmWriteTo.mock.inspectFuncWriteTo = f

	return mmWriteTo
}

// Return sets up results that will be returned by SignatureKeyHolder.WriteTo
func (mmWriteTo *mSignatureKeyHolderMockWriteTo) Return(n int64, err error) *SignatureKeyHolderMock {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("SignatureKeyHolderMock.WriteTo mock is already set by Set")
	}

	if mmWriteTo.defaultExpectation == nil {
		mmWriteTo.defaultExpectation = &SignatureKeyHolderMockWriteToExpectation{mock: mmWriteTo.mock}
	}
	mmWriteTo.defaultExpectation.results = &SignatureKeyHolderMockWriteToResults{n, err}
	return mmWriteTo.mock
}

//Set uses given function f to mock the SignatureKeyHolder.WriteTo method
func (mmWriteTo *mSignatureKeyHolderMockWriteTo) Set(f func(w io.Writer) (n int64, err error)) *SignatureKeyHolderMock {
	if mmWriteTo.defaultExpectation != nil {
		mmWriteTo.mock.t.Fatalf("Default expectation is already set for the SignatureKeyHolder.WriteTo method")
	}

	if len(mmWriteTo.expectations) > 0 {
		mmWriteTo.mock.t.Fatalf("Some expectations are already set for the SignatureKeyHolder.WriteTo method")
	}

	mmWriteTo.mock.funcWriteTo = f
	return mmWriteTo.mock
}

// When sets expectation for the SignatureKeyHolder.WriteTo which will trigger the result defined by the following
// Then helper
func (mmWriteTo *mSignatureKeyHolderMockWriteTo) When(w io.Writer) *SignatureKeyHolderMockWriteToExpectation {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("SignatureKeyHolderMock.WriteTo mock is already set by Set")
	}

	expectation := &SignatureKeyHolderMockWriteToExpectation{
		mock:   mmWriteTo.mock,
		params: &SignatureKeyHolderMockWriteToParams{w},
	}
	mmWriteTo.expectations = append(mmWriteTo.expectations, expectation)
	return expectation
}

// Then sets up SignatureKeyHolder.WriteTo return parameters for the expectation previously defined by the When method
func (e *SignatureKeyHolderMockWriteToExpectation) Then(n int64, err error) *SignatureKeyHolderMock {
	e.results = &SignatureKeyHolderMockWriteToResults{n, err}
	return e.mock
}

// WriteTo implements SignatureKeyHolder
func (mmWriteTo *SignatureKeyHolderMock) WriteTo(w io.Writer) (n int64, err error) {
	mm_atomic.AddUint64(&mmWriteTo.beforeWriteToCounter, 1)
	defer mm_atomic.AddUint64(&mmWriteTo.afterWriteToCounter, 1)

	if mmWriteTo.inspectFuncWriteTo != nil {
		mmWriteTo.inspectFuncWriteTo(w)
	}

	params := &SignatureKeyHolderMockWriteToParams{w}

	// Record call args
	mmWriteTo.WriteToMock.mutex.Lock()
	mmWriteTo.WriteToMock.callArgs = append(mmWriteTo.WriteToMock.callArgs, params)
	mmWriteTo.WriteToMock.mutex.Unlock()

	for _, e := range mmWriteTo.WriteToMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmWriteTo.WriteToMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWriteTo.WriteToMock.defaultExpectation.Counter, 1)
		want := mmWriteTo.WriteToMock.defaultExpectation.params
		got := SignatureKeyHolderMockWriteToParams{w}
		if want != nil && !minimock.Equal(*want, got) {
			mmWriteTo.t.Errorf("SignatureKeyHolderMock.WriteTo got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmWriteTo.WriteToMock.defaultExpectation.results
		if results == nil {
			mmWriteTo.t.Fatal("No results are set for the SignatureKeyHolderMock.WriteTo")
		}
		return (*results).n, (*results).err
	}
	if mmWriteTo.funcWriteTo != nil {
		return mmWriteTo.funcWriteTo(w)
	}
	mmWriteTo.t.Fatalf("Unexpected call to SignatureKeyHolderMock.WriteTo. %v", w)
	return
}

// WriteToAfterCounter returns a count of finished SignatureKeyHolderMock.WriteTo invocations
func (mmWriteTo *SignatureKeyHolderMock) WriteToAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteTo.afterWriteToCounter)
}

// WriteToBeforeCounter returns a count of SignatureKeyHolderMock.WriteTo invocations
func (mmWriteTo *SignatureKeyHolderMock) WriteToBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteTo.beforeWriteToCounter)
}

// Calls returns a list of arguments used in each call to SignatureKeyHolderMock.WriteTo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWriteTo *mSignatureKeyHolderMockWriteTo) Calls() []*SignatureKeyHolderMockWriteToParams {
	mmWriteTo.mutex.RLock()

	argCopy := make([]*SignatureKeyHolderMockWriteToParams, len(mmWriteTo.callArgs))
	copy(argCopy, mmWriteTo.callArgs)

	mmWriteTo.mutex.RUnlock()

	return argCopy
}

// MinimockWriteToDone returns true if the count of the WriteTo invocations corresponds
// the number of defined expectations
func (m *SignatureKeyHolderMock) MinimockWriteToDone() bool {
	for _, e := range m.WriteToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteTo != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		return false
	}
	return true
}

// MinimockWriteToInspect logs each unmet expectation
func (m *SignatureKeyHolderMock) MinimockWriteToInspect() {
	for _, e := range m.WriteToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SignatureKeyHolderMock.WriteTo with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		if m.WriteToMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SignatureKeyHolderMock.WriteTo")
		} else {
			m.t.Errorf("Expected call to SignatureKeyHolderMock.WriteTo with params: %#v", *m.WriteToMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteTo != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		m.t.Error("Expected call to SignatureKeyHolderMock.WriteTo")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SignatureKeyHolderMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAsByteStringInspect()

		m.MinimockAsBytesInspect()

		m.MinimockEqualsInspect()

		m.MinimockFixedByteSizeInspect()

		m.MinimockFoldToUint64Inspect()

		m.MinimockGetSignMethodInspect()

		m.MinimockGetSignatureKeyMethodInspect()

		m.MinimockGetSignatureKeyTypeInspect()

		m.MinimockReadInspect()

		m.MinimockWriteToInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SignatureKeyHolderMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SignatureKeyHolderMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAsByteStringDone() &&
		m.MinimockAsBytesDone() &&
		m.MinimockEqualsDone() &&
		m.MinimockFixedByteSizeDone() &&
		m.MinimockFoldToUint64Done() &&
		m.MinimockGetSignMethodDone() &&
		m.MinimockGetSignatureKeyMethodDone() &&
		m.MinimockGetSignatureKeyTypeDone() &&
		m.MinimockReadDone() &&
		m.MinimockWriteToDone()
}
