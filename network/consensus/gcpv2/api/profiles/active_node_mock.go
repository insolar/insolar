package profiles

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/insolar/insolar"
	"github.com/insolar/insolar/network/consensus/common/cryptkit"
	"github.com/insolar/insolar/network/consensus/gcpv2/api/member"
)

// ActiveNodeMock implements ActiveNode
type ActiveNodeMock struct {
	t minimock.Tester

	funcCanIntroduceJoiner          func() (b1 bool)
	inspectFuncCanIntroduceJoiner   func()
	afterCanIntroduceJoinerCounter  uint64
	beforeCanIntroduceJoinerCounter uint64
	CanIntroduceJoinerMock          mActiveNodeMockCanIntroduceJoiner

	funcGetDeclaredPower          func() (p1 member.Power)
	inspectFuncGetDeclaredPower   func()
	afterGetDeclaredPowerCounter  uint64
	beforeGetDeclaredPowerCounter uint64
	GetDeclaredPowerMock          mActiveNodeMockGetDeclaredPower

	funcGetIndex          func() (i1 member.Index)
	inspectFuncGetIndex   func()
	afterGetIndexCounter  uint64
	beforeGetIndexCounter uint64
	GetIndexMock          mActiveNodeMockGetIndex

	funcGetNodeID          func() (s1 insolar.ShortNodeID)
	inspectFuncGetNodeID   func()
	afterGetNodeIDCounter  uint64
	beforeGetNodeIDCounter uint64
	GetNodeIDMock          mActiveNodeMockGetNodeID

	funcGetOpMode          func() (o1 member.OpMode)
	inspectFuncGetOpMode   func()
	afterGetOpModeCounter  uint64
	beforeGetOpModeCounter uint64
	GetOpModeMock          mActiveNodeMockGetOpMode

	funcGetSignatureVerifier          func() (s1 cryptkit.SignatureVerifier)
	inspectFuncGetSignatureVerifier   func()
	afterGetSignatureVerifierCounter  uint64
	beforeGetSignatureVerifierCounter uint64
	GetSignatureVerifierMock          mActiveNodeMockGetSignatureVerifier

	funcGetStatic          func() (s1 StaticProfile)
	inspectFuncGetStatic   func()
	afterGetStaticCounter  uint64
	beforeGetStaticCounter uint64
	GetStaticMock          mActiveNodeMockGetStatic

	funcHasFullProfile          func() (b1 bool)
	inspectFuncHasFullProfile   func()
	afterHasFullProfileCounter  uint64
	beforeHasFullProfileCounter uint64
	HasFullProfileMock          mActiveNodeMockHasFullProfile

	funcIsJoiner          func() (b1 bool)
	inspectFuncIsJoiner   func()
	afterIsJoinerCounter  uint64
	beforeIsJoinerCounter uint64
	IsJoinerMock          mActiveNodeMockIsJoiner

	funcIsPowered          func() (b1 bool)
	inspectFuncIsPowered   func()
	afterIsPoweredCounter  uint64
	beforeIsPoweredCounter uint64
	IsPoweredMock          mActiveNodeMockIsPowered

	funcIsStateful          func() (b1 bool)
	inspectFuncIsStateful   func()
	afterIsStatefulCounter  uint64
	beforeIsStatefulCounter uint64
	IsStatefulMock          mActiveNodeMockIsStateful

	funcIsVoter          func() (b1 bool)
	inspectFuncIsVoter   func()
	afterIsVoterCounter  uint64
	beforeIsVoterCounter uint64
	IsVoterMock          mActiveNodeMockIsVoter
}

// NewActiveNodeMock returns a mock for ActiveNode
func NewActiveNodeMock(t minimock.Tester) *ActiveNodeMock {
	m := &ActiveNodeMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CanIntroduceJoinerMock = mActiveNodeMockCanIntroduceJoiner{mock: m}

	m.GetDeclaredPowerMock = mActiveNodeMockGetDeclaredPower{mock: m}

	m.GetIndexMock = mActiveNodeMockGetIndex{mock: m}

	m.GetNodeIDMock = mActiveNodeMockGetNodeID{mock: m}

	m.GetOpModeMock = mActiveNodeMockGetOpMode{mock: m}

	m.GetSignatureVerifierMock = mActiveNodeMockGetSignatureVerifier{mock: m}

	m.GetStaticMock = mActiveNodeMockGetStatic{mock: m}

	m.HasFullProfileMock = mActiveNodeMockHasFullProfile{mock: m}

	m.IsJoinerMock = mActiveNodeMockIsJoiner{mock: m}

	m.IsPoweredMock = mActiveNodeMockIsPowered{mock: m}

	m.IsStatefulMock = mActiveNodeMockIsStateful{mock: m}

	m.IsVoterMock = mActiveNodeMockIsVoter{mock: m}

	return m
}

type mActiveNodeMockCanIntroduceJoiner struct {
	mock               *ActiveNodeMock
	defaultExpectation *ActiveNodeMockCanIntroduceJoinerExpectation
	expectations       []*ActiveNodeMockCanIntroduceJoinerExpectation
}

// ActiveNodeMockCanIntroduceJoinerExpectation specifies expectation struct of the ActiveNode.CanIntroduceJoiner
type ActiveNodeMockCanIntroduceJoinerExpectation struct {
	mock *ActiveNodeMock

	results *ActiveNodeMockCanIntroduceJoinerResults
	Counter uint64
}

// ActiveNodeMockCanIntroduceJoinerResults contains results of the ActiveNode.CanIntroduceJoiner
type ActiveNodeMockCanIntroduceJoinerResults struct {
	b1 bool
}

// Expect sets up expected params for ActiveNode.CanIntroduceJoiner
func (mmCanIntroduceJoiner *mActiveNodeMockCanIntroduceJoiner) Expect() *mActiveNodeMockCanIntroduceJoiner {
	if mmCanIntroduceJoiner.mock.funcCanIntroduceJoiner != nil {
		mmCanIntroduceJoiner.mock.t.Fatalf("ActiveNodeMock.CanIntroduceJoiner mock is already set by Set")
	}

	if mmCanIntroduceJoiner.defaultExpectation == nil {
		mmCanIntroduceJoiner.defaultExpectation = &ActiveNodeMockCanIntroduceJoinerExpectation{}
	}

	return mmCanIntroduceJoiner
}

// Inspect accepts an inspector function that has same arguments as the ActiveNode.CanIntroduceJoiner
func (mmCanIntroduceJoiner *mActiveNodeMockCanIntroduceJoiner) Inspect(f func()) *mActiveNodeMockCanIntroduceJoiner {
	if mmCanIntroduceJoiner.mock.inspectFuncCanIntroduceJoiner != nil {
		mmCanIntroduceJoiner.mock.t.Fatalf("Inspect function is already set for ActiveNodeMock.CanIntroduceJoiner")
	}

	mmCanIntroduceJoiner.mock.inspectFuncCanIntroduceJoiner = f

	return mmCanIntroduceJoiner
}

// Return sets up results that will be returned by ActiveNode.CanIntroduceJoiner
func (mmCanIntroduceJoiner *mActiveNodeMockCanIntroduceJoiner) Return(b1 bool) *ActiveNodeMock {
	if mmCanIntroduceJoiner.mock.funcCanIntroduceJoiner != nil {
		mmCanIntroduceJoiner.mock.t.Fatalf("ActiveNodeMock.CanIntroduceJoiner mock is already set by Set")
	}

	if mmCanIntroduceJoiner.defaultExpectation == nil {
		mmCanIntroduceJoiner.defaultExpectation = &ActiveNodeMockCanIntroduceJoinerExpectation{mock: mmCanIntroduceJoiner.mock}
	}
	mmCanIntroduceJoiner.defaultExpectation.results = &ActiveNodeMockCanIntroduceJoinerResults{b1}
	return mmCanIntroduceJoiner.mock
}

//Set uses given function f to mock the ActiveNode.CanIntroduceJoiner method
func (mmCanIntroduceJoiner *mActiveNodeMockCanIntroduceJoiner) Set(f func() (b1 bool)) *ActiveNodeMock {
	if mmCanIntroduceJoiner.defaultExpectation != nil {
		mmCanIntroduceJoiner.mock.t.Fatalf("Default expectation is already set for the ActiveNode.CanIntroduceJoiner method")
	}

	if len(mmCanIntroduceJoiner.expectations) > 0 {
		mmCanIntroduceJoiner.mock.t.Fatalf("Some expectations are already set for the ActiveNode.CanIntroduceJoiner method")
	}

	mmCanIntroduceJoiner.mock.funcCanIntroduceJoiner = f
	return mmCanIntroduceJoiner.mock
}

// CanIntroduceJoiner implements ActiveNode
func (mmCanIntroduceJoiner *ActiveNodeMock) CanIntroduceJoiner() (b1 bool) {
	mm_atomic.AddUint64(&mmCanIntroduceJoiner.beforeCanIntroduceJoinerCounter, 1)
	defer mm_atomic.AddUint64(&mmCanIntroduceJoiner.afterCanIntroduceJoinerCounter, 1)

	if mmCanIntroduceJoiner.inspectFuncCanIntroduceJoiner != nil {
		mmCanIntroduceJoiner.inspectFuncCanIntroduceJoiner()
	}

	if mmCanIntroduceJoiner.CanIntroduceJoinerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCanIntroduceJoiner.CanIntroduceJoinerMock.defaultExpectation.Counter, 1)

		mm_results := mmCanIntroduceJoiner.CanIntroduceJoinerMock.defaultExpectation.results
		if mm_results == nil {
			mmCanIntroduceJoiner.t.Fatal("No results are set for the ActiveNodeMock.CanIntroduceJoiner")
		}
		return (*mm_results).b1
	}
	if mmCanIntroduceJoiner.funcCanIntroduceJoiner != nil {
		return mmCanIntroduceJoiner.funcCanIntroduceJoiner()
	}
	mmCanIntroduceJoiner.t.Fatalf("Unexpected call to ActiveNodeMock.CanIntroduceJoiner.")
	return
}

// CanIntroduceJoinerAfterCounter returns a count of finished ActiveNodeMock.CanIntroduceJoiner invocations
func (mmCanIntroduceJoiner *ActiveNodeMock) CanIntroduceJoinerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCanIntroduceJoiner.afterCanIntroduceJoinerCounter)
}

// CanIntroduceJoinerBeforeCounter returns a count of ActiveNodeMock.CanIntroduceJoiner invocations
func (mmCanIntroduceJoiner *ActiveNodeMock) CanIntroduceJoinerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCanIntroduceJoiner.beforeCanIntroduceJoinerCounter)
}

// MinimockCanIntroduceJoinerDone returns true if the count of the CanIntroduceJoiner invocations corresponds
// the number of defined expectations
func (m *ActiveNodeMock) MinimockCanIntroduceJoinerDone() bool {
	for _, e := range m.CanIntroduceJoinerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CanIntroduceJoinerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCanIntroduceJoinerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCanIntroduceJoiner != nil && mm_atomic.LoadUint64(&m.afterCanIntroduceJoinerCounter) < 1 {
		return false
	}
	return true
}

// MinimockCanIntroduceJoinerInspect logs each unmet expectation
func (m *ActiveNodeMock) MinimockCanIntroduceJoinerInspect() {
	for _, e := range m.CanIntroduceJoinerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ActiveNodeMock.CanIntroduceJoiner")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CanIntroduceJoinerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCanIntroduceJoinerCounter) < 1 {
		m.t.Error("Expected call to ActiveNodeMock.CanIntroduceJoiner")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCanIntroduceJoiner != nil && mm_atomic.LoadUint64(&m.afterCanIntroduceJoinerCounter) < 1 {
		m.t.Error("Expected call to ActiveNodeMock.CanIntroduceJoiner")
	}
}

type mActiveNodeMockGetDeclaredPower struct {
	mock               *ActiveNodeMock
	defaultExpectation *ActiveNodeMockGetDeclaredPowerExpectation
	expectations       []*ActiveNodeMockGetDeclaredPowerExpectation
}

// ActiveNodeMockGetDeclaredPowerExpectation specifies expectation struct of the ActiveNode.GetDeclaredPower
type ActiveNodeMockGetDeclaredPowerExpectation struct {
	mock *ActiveNodeMock

	results *ActiveNodeMockGetDeclaredPowerResults
	Counter uint64
}

// ActiveNodeMockGetDeclaredPowerResults contains results of the ActiveNode.GetDeclaredPower
type ActiveNodeMockGetDeclaredPowerResults struct {
	p1 member.Power
}

// Expect sets up expected params for ActiveNode.GetDeclaredPower
func (mmGetDeclaredPower *mActiveNodeMockGetDeclaredPower) Expect() *mActiveNodeMockGetDeclaredPower {
	if mmGetDeclaredPower.mock.funcGetDeclaredPower != nil {
		mmGetDeclaredPower.mock.t.Fatalf("ActiveNodeMock.GetDeclaredPower mock is already set by Set")
	}

	if mmGetDeclaredPower.defaultExpectation == nil {
		mmGetDeclaredPower.defaultExpectation = &ActiveNodeMockGetDeclaredPowerExpectation{}
	}

	return mmGetDeclaredPower
}

// Inspect accepts an inspector function that has same arguments as the ActiveNode.GetDeclaredPower
func (mmGetDeclaredPower *mActiveNodeMockGetDeclaredPower) Inspect(f func()) *mActiveNodeMockGetDeclaredPower {
	if mmGetDeclaredPower.mock.inspectFuncGetDeclaredPower != nil {
		mmGetDeclaredPower.mock.t.Fatalf("Inspect function is already set for ActiveNodeMock.GetDeclaredPower")
	}

	mmGetDeclaredPower.mock.inspectFuncGetDeclaredPower = f

	return mmGetDeclaredPower
}

// Return sets up results that will be returned by ActiveNode.GetDeclaredPower
func (mmGetDeclaredPower *mActiveNodeMockGetDeclaredPower) Return(p1 member.Power) *ActiveNodeMock {
	if mmGetDeclaredPower.mock.funcGetDeclaredPower != nil {
		mmGetDeclaredPower.mock.t.Fatalf("ActiveNodeMock.GetDeclaredPower mock is already set by Set")
	}

	if mmGetDeclaredPower.defaultExpectation == nil {
		mmGetDeclaredPower.defaultExpectation = &ActiveNodeMockGetDeclaredPowerExpectation{mock: mmGetDeclaredPower.mock}
	}
	mmGetDeclaredPower.defaultExpectation.results = &ActiveNodeMockGetDeclaredPowerResults{p1}
	return mmGetDeclaredPower.mock
}

//Set uses given function f to mock the ActiveNode.GetDeclaredPower method
func (mmGetDeclaredPower *mActiveNodeMockGetDeclaredPower) Set(f func() (p1 member.Power)) *ActiveNodeMock {
	if mmGetDeclaredPower.defaultExpectation != nil {
		mmGetDeclaredPower.mock.t.Fatalf("Default expectation is already set for the ActiveNode.GetDeclaredPower method")
	}

	if len(mmGetDeclaredPower.expectations) > 0 {
		mmGetDeclaredPower.mock.t.Fatalf("Some expectations are already set for the ActiveNode.GetDeclaredPower method")
	}

	mmGetDeclaredPower.mock.funcGetDeclaredPower = f
	return mmGetDeclaredPower.mock
}

// GetDeclaredPower implements ActiveNode
func (mmGetDeclaredPower *ActiveNodeMock) GetDeclaredPower() (p1 member.Power) {
	mm_atomic.AddUint64(&mmGetDeclaredPower.beforeGetDeclaredPowerCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDeclaredPower.afterGetDeclaredPowerCounter, 1)

	if mmGetDeclaredPower.inspectFuncGetDeclaredPower != nil {
		mmGetDeclaredPower.inspectFuncGetDeclaredPower()
	}

	if mmGetDeclaredPower.GetDeclaredPowerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDeclaredPower.GetDeclaredPowerMock.defaultExpectation.Counter, 1)

		mm_results := mmGetDeclaredPower.GetDeclaredPowerMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDeclaredPower.t.Fatal("No results are set for the ActiveNodeMock.GetDeclaredPower")
		}
		return (*mm_results).p1
	}
	if mmGetDeclaredPower.funcGetDeclaredPower != nil {
		return mmGetDeclaredPower.funcGetDeclaredPower()
	}
	mmGetDeclaredPower.t.Fatalf("Unexpected call to ActiveNodeMock.GetDeclaredPower.")
	return
}

// GetDeclaredPowerAfterCounter returns a count of finished ActiveNodeMock.GetDeclaredPower invocations
func (mmGetDeclaredPower *ActiveNodeMock) GetDeclaredPowerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDeclaredPower.afterGetDeclaredPowerCounter)
}

// GetDeclaredPowerBeforeCounter returns a count of ActiveNodeMock.GetDeclaredPower invocations
func (mmGetDeclaredPower *ActiveNodeMock) GetDeclaredPowerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDeclaredPower.beforeGetDeclaredPowerCounter)
}

// MinimockGetDeclaredPowerDone returns true if the count of the GetDeclaredPower invocations corresponds
// the number of defined expectations
func (m *ActiveNodeMock) MinimockGetDeclaredPowerDone() bool {
	for _, e := range m.GetDeclaredPowerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDeclaredPowerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDeclaredPowerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDeclaredPower != nil && mm_atomic.LoadUint64(&m.afterGetDeclaredPowerCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetDeclaredPowerInspect logs each unmet expectation
func (m *ActiveNodeMock) MinimockGetDeclaredPowerInspect() {
	for _, e := range m.GetDeclaredPowerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ActiveNodeMock.GetDeclaredPower")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDeclaredPowerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDeclaredPowerCounter) < 1 {
		m.t.Error("Expected call to ActiveNodeMock.GetDeclaredPower")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDeclaredPower != nil && mm_atomic.LoadUint64(&m.afterGetDeclaredPowerCounter) < 1 {
		m.t.Error("Expected call to ActiveNodeMock.GetDeclaredPower")
	}
}

type mActiveNodeMockGetIndex struct {
	mock               *ActiveNodeMock
	defaultExpectation *ActiveNodeMockGetIndexExpectation
	expectations       []*ActiveNodeMockGetIndexExpectation
}

// ActiveNodeMockGetIndexExpectation specifies expectation struct of the ActiveNode.GetIndex
type ActiveNodeMockGetIndexExpectation struct {
	mock *ActiveNodeMock

	results *ActiveNodeMockGetIndexResults
	Counter uint64
}

// ActiveNodeMockGetIndexResults contains results of the ActiveNode.GetIndex
type ActiveNodeMockGetIndexResults struct {
	i1 member.Index
}

// Expect sets up expected params for ActiveNode.GetIndex
func (mmGetIndex *mActiveNodeMockGetIndex) Expect() *mActiveNodeMockGetIndex {
	if mmGetIndex.mock.funcGetIndex != nil {
		mmGetIndex.mock.t.Fatalf("ActiveNodeMock.GetIndex mock is already set by Set")
	}

	if mmGetIndex.defaultExpectation == nil {
		mmGetIndex.defaultExpectation = &ActiveNodeMockGetIndexExpectation{}
	}

	return mmGetIndex
}

// Inspect accepts an inspector function that has same arguments as the ActiveNode.GetIndex
func (mmGetIndex *mActiveNodeMockGetIndex) Inspect(f func()) *mActiveNodeMockGetIndex {
	if mmGetIndex.mock.inspectFuncGetIndex != nil {
		mmGetIndex.mock.t.Fatalf("Inspect function is already set for ActiveNodeMock.GetIndex")
	}

	mmGetIndex.mock.inspectFuncGetIndex = f

	return mmGetIndex
}

// Return sets up results that will be returned by ActiveNode.GetIndex
func (mmGetIndex *mActiveNodeMockGetIndex) Return(i1 member.Index) *ActiveNodeMock {
	if mmGetIndex.mock.funcGetIndex != nil {
		mmGetIndex.mock.t.Fatalf("ActiveNodeMock.GetIndex mock is already set by Set")
	}

	if mmGetIndex.defaultExpectation == nil {
		mmGetIndex.defaultExpectation = &ActiveNodeMockGetIndexExpectation{mock: mmGetIndex.mock}
	}
	mmGetIndex.defaultExpectation.results = &ActiveNodeMockGetIndexResults{i1}
	return mmGetIndex.mock
}

//Set uses given function f to mock the ActiveNode.GetIndex method
func (mmGetIndex *mActiveNodeMockGetIndex) Set(f func() (i1 member.Index)) *ActiveNodeMock {
	if mmGetIndex.defaultExpectation != nil {
		mmGetIndex.mock.t.Fatalf("Default expectation is already set for the ActiveNode.GetIndex method")
	}

	if len(mmGetIndex.expectations) > 0 {
		mmGetIndex.mock.t.Fatalf("Some expectations are already set for the ActiveNode.GetIndex method")
	}

	mmGetIndex.mock.funcGetIndex = f
	return mmGetIndex.mock
}

// GetIndex implements ActiveNode
func (mmGetIndex *ActiveNodeMock) GetIndex() (i1 member.Index) {
	mm_atomic.AddUint64(&mmGetIndex.beforeGetIndexCounter, 1)
	defer mm_atomic.AddUint64(&mmGetIndex.afterGetIndexCounter, 1)

	if mmGetIndex.inspectFuncGetIndex != nil {
		mmGetIndex.inspectFuncGetIndex()
	}

	if mmGetIndex.GetIndexMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetIndex.GetIndexMock.defaultExpectation.Counter, 1)

		mm_results := mmGetIndex.GetIndexMock.defaultExpectation.results
		if mm_results == nil {
			mmGetIndex.t.Fatal("No results are set for the ActiveNodeMock.GetIndex")
		}
		return (*mm_results).i1
	}
	if mmGetIndex.funcGetIndex != nil {
		return mmGetIndex.funcGetIndex()
	}
	mmGetIndex.t.Fatalf("Unexpected call to ActiveNodeMock.GetIndex.")
	return
}

// GetIndexAfterCounter returns a count of finished ActiveNodeMock.GetIndex invocations
func (mmGetIndex *ActiveNodeMock) GetIndexAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetIndex.afterGetIndexCounter)
}

// GetIndexBeforeCounter returns a count of ActiveNodeMock.GetIndex invocations
func (mmGetIndex *ActiveNodeMock) GetIndexBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetIndex.beforeGetIndexCounter)
}

// MinimockGetIndexDone returns true if the count of the GetIndex invocations corresponds
// the number of defined expectations
func (m *ActiveNodeMock) MinimockGetIndexDone() bool {
	for _, e := range m.GetIndexMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetIndexMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetIndexCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetIndex != nil && mm_atomic.LoadUint64(&m.afterGetIndexCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetIndexInspect logs each unmet expectation
func (m *ActiveNodeMock) MinimockGetIndexInspect() {
	for _, e := range m.GetIndexMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ActiveNodeMock.GetIndex")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetIndexMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetIndexCounter) < 1 {
		m.t.Error("Expected call to ActiveNodeMock.GetIndex")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetIndex != nil && mm_atomic.LoadUint64(&m.afterGetIndexCounter) < 1 {
		m.t.Error("Expected call to ActiveNodeMock.GetIndex")
	}
}

type mActiveNodeMockGetNodeID struct {
	mock               *ActiveNodeMock
	defaultExpectation *ActiveNodeMockGetNodeIDExpectation
	expectations       []*ActiveNodeMockGetNodeIDExpectation
}

// ActiveNodeMockGetNodeIDExpectation specifies expectation struct of the ActiveNode.GetNodeID
type ActiveNodeMockGetNodeIDExpectation struct {
	mock *ActiveNodeMock

	results *ActiveNodeMockGetNodeIDResults
	Counter uint64
}

// ActiveNodeMockGetNodeIDResults contains results of the ActiveNode.GetNodeID
type ActiveNodeMockGetNodeIDResults struct {
	s1 insolar.ShortNodeID
}

// Expect sets up expected params for ActiveNode.GetNodeID
func (mmGetNodeID *mActiveNodeMockGetNodeID) Expect() *mActiveNodeMockGetNodeID {
	if mmGetNodeID.mock.funcGetNodeID != nil {
		mmGetNodeID.mock.t.Fatalf("ActiveNodeMock.GetNodeID mock is already set by Set")
	}

	if mmGetNodeID.defaultExpectation == nil {
		mmGetNodeID.defaultExpectation = &ActiveNodeMockGetNodeIDExpectation{}
	}

	return mmGetNodeID
}

// Inspect accepts an inspector function that has same arguments as the ActiveNode.GetNodeID
func (mmGetNodeID *mActiveNodeMockGetNodeID) Inspect(f func()) *mActiveNodeMockGetNodeID {
	if mmGetNodeID.mock.inspectFuncGetNodeID != nil {
		mmGetNodeID.mock.t.Fatalf("Inspect function is already set for ActiveNodeMock.GetNodeID")
	}

	mmGetNodeID.mock.inspectFuncGetNodeID = f

	return mmGetNodeID
}

// Return sets up results that will be returned by ActiveNode.GetNodeID
func (mmGetNodeID *mActiveNodeMockGetNodeID) Return(s1 insolar.ShortNodeID) *ActiveNodeMock {
	if mmGetNodeID.mock.funcGetNodeID != nil {
		mmGetNodeID.mock.t.Fatalf("ActiveNodeMock.GetNodeID mock is already set by Set")
	}

	if mmGetNodeID.defaultExpectation == nil {
		mmGetNodeID.defaultExpectation = &ActiveNodeMockGetNodeIDExpectation{mock: mmGetNodeID.mock}
	}
	mmGetNodeID.defaultExpectation.results = &ActiveNodeMockGetNodeIDResults{s1}
	return mmGetNodeID.mock
}

//Set uses given function f to mock the ActiveNode.GetNodeID method
func (mmGetNodeID *mActiveNodeMockGetNodeID) Set(f func() (s1 insolar.ShortNodeID)) *ActiveNodeMock {
	if mmGetNodeID.defaultExpectation != nil {
		mmGetNodeID.mock.t.Fatalf("Default expectation is already set for the ActiveNode.GetNodeID method")
	}

	if len(mmGetNodeID.expectations) > 0 {
		mmGetNodeID.mock.t.Fatalf("Some expectations are already set for the ActiveNode.GetNodeID method")
	}

	mmGetNodeID.mock.funcGetNodeID = f
	return mmGetNodeID.mock
}

// GetNodeID implements ActiveNode
func (mmGetNodeID *ActiveNodeMock) GetNodeID() (s1 insolar.ShortNodeID) {
	mm_atomic.AddUint64(&mmGetNodeID.beforeGetNodeIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNodeID.afterGetNodeIDCounter, 1)

	if mmGetNodeID.inspectFuncGetNodeID != nil {
		mmGetNodeID.inspectFuncGetNodeID()
	}

	if mmGetNodeID.GetNodeIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNodeID.GetNodeIDMock.defaultExpectation.Counter, 1)

		mm_results := mmGetNodeID.GetNodeIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetNodeID.t.Fatal("No results are set for the ActiveNodeMock.GetNodeID")
		}
		return (*mm_results).s1
	}
	if mmGetNodeID.funcGetNodeID != nil {
		return mmGetNodeID.funcGetNodeID()
	}
	mmGetNodeID.t.Fatalf("Unexpected call to ActiveNodeMock.GetNodeID.")
	return
}

// GetNodeIDAfterCounter returns a count of finished ActiveNodeMock.GetNodeID invocations
func (mmGetNodeID *ActiveNodeMock) GetNodeIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNodeID.afterGetNodeIDCounter)
}

// GetNodeIDBeforeCounter returns a count of ActiveNodeMock.GetNodeID invocations
func (mmGetNodeID *ActiveNodeMock) GetNodeIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNodeID.beforeGetNodeIDCounter)
}

// MinimockGetNodeIDDone returns true if the count of the GetNodeID invocations corresponds
// the number of defined expectations
func (m *ActiveNodeMock) MinimockGetNodeIDDone() bool {
	for _, e := range m.GetNodeIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetNodeIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetNodeIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNodeID != nil && mm_atomic.LoadUint64(&m.afterGetNodeIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetNodeIDInspect logs each unmet expectation
func (m *ActiveNodeMock) MinimockGetNodeIDInspect() {
	for _, e := range m.GetNodeIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ActiveNodeMock.GetNodeID")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetNodeIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetNodeIDCounter) < 1 {
		m.t.Error("Expected call to ActiveNodeMock.GetNodeID")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNodeID != nil && mm_atomic.LoadUint64(&m.afterGetNodeIDCounter) < 1 {
		m.t.Error("Expected call to ActiveNodeMock.GetNodeID")
	}
}

type mActiveNodeMockGetOpMode struct {
	mock               *ActiveNodeMock
	defaultExpectation *ActiveNodeMockGetOpModeExpectation
	expectations       []*ActiveNodeMockGetOpModeExpectation
}

// ActiveNodeMockGetOpModeExpectation specifies expectation struct of the ActiveNode.GetOpMode
type ActiveNodeMockGetOpModeExpectation struct {
	mock *ActiveNodeMock

	results *ActiveNodeMockGetOpModeResults
	Counter uint64
}

// ActiveNodeMockGetOpModeResults contains results of the ActiveNode.GetOpMode
type ActiveNodeMockGetOpModeResults struct {
	o1 member.OpMode
}

// Expect sets up expected params for ActiveNode.GetOpMode
func (mmGetOpMode *mActiveNodeMockGetOpMode) Expect() *mActiveNodeMockGetOpMode {
	if mmGetOpMode.mock.funcGetOpMode != nil {
		mmGetOpMode.mock.t.Fatalf("ActiveNodeMock.GetOpMode mock is already set by Set")
	}

	if mmGetOpMode.defaultExpectation == nil {
		mmGetOpMode.defaultExpectation = &ActiveNodeMockGetOpModeExpectation{}
	}

	return mmGetOpMode
}

// Inspect accepts an inspector function that has same arguments as the ActiveNode.GetOpMode
func (mmGetOpMode *mActiveNodeMockGetOpMode) Inspect(f func()) *mActiveNodeMockGetOpMode {
	if mmGetOpMode.mock.inspectFuncGetOpMode != nil {
		mmGetOpMode.mock.t.Fatalf("Inspect function is already set for ActiveNodeMock.GetOpMode")
	}

	mmGetOpMode.mock.inspectFuncGetOpMode = f

	return mmGetOpMode
}

// Return sets up results that will be returned by ActiveNode.GetOpMode
func (mmGetOpMode *mActiveNodeMockGetOpMode) Return(o1 member.OpMode) *ActiveNodeMock {
	if mmGetOpMode.mock.funcGetOpMode != nil {
		mmGetOpMode.mock.t.Fatalf("ActiveNodeMock.GetOpMode mock is already set by Set")
	}

	if mmGetOpMode.defaultExpectation == nil {
		mmGetOpMode.defaultExpectation = &ActiveNodeMockGetOpModeExpectation{mock: mmGetOpMode.mock}
	}
	mmGetOpMode.defaultExpectation.results = &ActiveNodeMockGetOpModeResults{o1}
	return mmGetOpMode.mock
}

//Set uses given function f to mock the ActiveNode.GetOpMode method
func (mmGetOpMode *mActiveNodeMockGetOpMode) Set(f func() (o1 member.OpMode)) *ActiveNodeMock {
	if mmGetOpMode.defaultExpectation != nil {
		mmGetOpMode.mock.t.Fatalf("Default expectation is already set for the ActiveNode.GetOpMode method")
	}

	if len(mmGetOpMode.expectations) > 0 {
		mmGetOpMode.mock.t.Fatalf("Some expectations are already set for the ActiveNode.GetOpMode method")
	}

	mmGetOpMode.mock.funcGetOpMode = f
	return mmGetOpMode.mock
}

// GetOpMode implements ActiveNode
func (mmGetOpMode *ActiveNodeMock) GetOpMode() (o1 member.OpMode) {
	mm_atomic.AddUint64(&mmGetOpMode.beforeGetOpModeCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOpMode.afterGetOpModeCounter, 1)

	if mmGetOpMode.inspectFuncGetOpMode != nil {
		mmGetOpMode.inspectFuncGetOpMode()
	}

	if mmGetOpMode.GetOpModeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOpMode.GetOpModeMock.defaultExpectation.Counter, 1)

		mm_results := mmGetOpMode.GetOpModeMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOpMode.t.Fatal("No results are set for the ActiveNodeMock.GetOpMode")
		}
		return (*mm_results).o1
	}
	if mmGetOpMode.funcGetOpMode != nil {
		return mmGetOpMode.funcGetOpMode()
	}
	mmGetOpMode.t.Fatalf("Unexpected call to ActiveNodeMock.GetOpMode.")
	return
}

// GetOpModeAfterCounter returns a count of finished ActiveNodeMock.GetOpMode invocations
func (mmGetOpMode *ActiveNodeMock) GetOpModeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOpMode.afterGetOpModeCounter)
}

// GetOpModeBeforeCounter returns a count of ActiveNodeMock.GetOpMode invocations
func (mmGetOpMode *ActiveNodeMock) GetOpModeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOpMode.beforeGetOpModeCounter)
}

// MinimockGetOpModeDone returns true if the count of the GetOpMode invocations corresponds
// the number of defined expectations
func (m *ActiveNodeMock) MinimockGetOpModeDone() bool {
	for _, e := range m.GetOpModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOpModeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOpModeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOpMode != nil && mm_atomic.LoadUint64(&m.afterGetOpModeCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetOpModeInspect logs each unmet expectation
func (m *ActiveNodeMock) MinimockGetOpModeInspect() {
	for _, e := range m.GetOpModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ActiveNodeMock.GetOpMode")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOpModeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOpModeCounter) < 1 {
		m.t.Error("Expected call to ActiveNodeMock.GetOpMode")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOpMode != nil && mm_atomic.LoadUint64(&m.afterGetOpModeCounter) < 1 {
		m.t.Error("Expected call to ActiveNodeMock.GetOpMode")
	}
}

type mActiveNodeMockGetSignatureVerifier struct {
	mock               *ActiveNodeMock
	defaultExpectation *ActiveNodeMockGetSignatureVerifierExpectation
	expectations       []*ActiveNodeMockGetSignatureVerifierExpectation
}

// ActiveNodeMockGetSignatureVerifierExpectation specifies expectation struct of the ActiveNode.GetSignatureVerifier
type ActiveNodeMockGetSignatureVerifierExpectation struct {
	mock *ActiveNodeMock

	results *ActiveNodeMockGetSignatureVerifierResults
	Counter uint64
}

// ActiveNodeMockGetSignatureVerifierResults contains results of the ActiveNode.GetSignatureVerifier
type ActiveNodeMockGetSignatureVerifierResults struct {
	s1 cryptkit.SignatureVerifier
}

// Expect sets up expected params for ActiveNode.GetSignatureVerifier
func (mmGetSignatureVerifier *mActiveNodeMockGetSignatureVerifier) Expect() *mActiveNodeMockGetSignatureVerifier {
	if mmGetSignatureVerifier.mock.funcGetSignatureVerifier != nil {
		mmGetSignatureVerifier.mock.t.Fatalf("ActiveNodeMock.GetSignatureVerifier mock is already set by Set")
	}

	if mmGetSignatureVerifier.defaultExpectation == nil {
		mmGetSignatureVerifier.defaultExpectation = &ActiveNodeMockGetSignatureVerifierExpectation{}
	}

	return mmGetSignatureVerifier
}

// Inspect accepts an inspector function that has same arguments as the ActiveNode.GetSignatureVerifier
func (mmGetSignatureVerifier *mActiveNodeMockGetSignatureVerifier) Inspect(f func()) *mActiveNodeMockGetSignatureVerifier {
	if mmGetSignatureVerifier.mock.inspectFuncGetSignatureVerifier != nil {
		mmGetSignatureVerifier.mock.t.Fatalf("Inspect function is already set for ActiveNodeMock.GetSignatureVerifier")
	}

	mmGetSignatureVerifier.mock.inspectFuncGetSignatureVerifier = f

	return mmGetSignatureVerifier
}

// Return sets up results that will be returned by ActiveNode.GetSignatureVerifier
func (mmGetSignatureVerifier *mActiveNodeMockGetSignatureVerifier) Return(s1 cryptkit.SignatureVerifier) *ActiveNodeMock {
	if mmGetSignatureVerifier.mock.funcGetSignatureVerifier != nil {
		mmGetSignatureVerifier.mock.t.Fatalf("ActiveNodeMock.GetSignatureVerifier mock is already set by Set")
	}

	if mmGetSignatureVerifier.defaultExpectation == nil {
		mmGetSignatureVerifier.defaultExpectation = &ActiveNodeMockGetSignatureVerifierExpectation{mock: mmGetSignatureVerifier.mock}
	}
	mmGetSignatureVerifier.defaultExpectation.results = &ActiveNodeMockGetSignatureVerifierResults{s1}
	return mmGetSignatureVerifier.mock
}

//Set uses given function f to mock the ActiveNode.GetSignatureVerifier method
func (mmGetSignatureVerifier *mActiveNodeMockGetSignatureVerifier) Set(f func() (s1 cryptkit.SignatureVerifier)) *ActiveNodeMock {
	if mmGetSignatureVerifier.defaultExpectation != nil {
		mmGetSignatureVerifier.mock.t.Fatalf("Default expectation is already set for the ActiveNode.GetSignatureVerifier method")
	}

	if len(mmGetSignatureVerifier.expectations) > 0 {
		mmGetSignatureVerifier.mock.t.Fatalf("Some expectations are already set for the ActiveNode.GetSignatureVerifier method")
	}

	mmGetSignatureVerifier.mock.funcGetSignatureVerifier = f
	return mmGetSignatureVerifier.mock
}

// GetSignatureVerifier implements ActiveNode
func (mmGetSignatureVerifier *ActiveNodeMock) GetSignatureVerifier() (s1 cryptkit.SignatureVerifier) {
	mm_atomic.AddUint64(&mmGetSignatureVerifier.beforeGetSignatureVerifierCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSignatureVerifier.afterGetSignatureVerifierCounter, 1)

	if mmGetSignatureVerifier.inspectFuncGetSignatureVerifier != nil {
		mmGetSignatureVerifier.inspectFuncGetSignatureVerifier()
	}

	if mmGetSignatureVerifier.GetSignatureVerifierMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSignatureVerifier.GetSignatureVerifierMock.defaultExpectation.Counter, 1)

		mm_results := mmGetSignatureVerifier.GetSignatureVerifierMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSignatureVerifier.t.Fatal("No results are set for the ActiveNodeMock.GetSignatureVerifier")
		}
		return (*mm_results).s1
	}
	if mmGetSignatureVerifier.funcGetSignatureVerifier != nil {
		return mmGetSignatureVerifier.funcGetSignatureVerifier()
	}
	mmGetSignatureVerifier.t.Fatalf("Unexpected call to ActiveNodeMock.GetSignatureVerifier.")
	return
}

// GetSignatureVerifierAfterCounter returns a count of finished ActiveNodeMock.GetSignatureVerifier invocations
func (mmGetSignatureVerifier *ActiveNodeMock) GetSignatureVerifierAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSignatureVerifier.afterGetSignatureVerifierCounter)
}

// GetSignatureVerifierBeforeCounter returns a count of ActiveNodeMock.GetSignatureVerifier invocations
func (mmGetSignatureVerifier *ActiveNodeMock) GetSignatureVerifierBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSignatureVerifier.beforeGetSignatureVerifierCounter)
}

// MinimockGetSignatureVerifierDone returns true if the count of the GetSignatureVerifier invocations corresponds
// the number of defined expectations
func (m *ActiveNodeMock) MinimockGetSignatureVerifierDone() bool {
	for _, e := range m.GetSignatureVerifierMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSignatureVerifierMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSignatureVerifierCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSignatureVerifier != nil && mm_atomic.LoadUint64(&m.afterGetSignatureVerifierCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSignatureVerifierInspect logs each unmet expectation
func (m *ActiveNodeMock) MinimockGetSignatureVerifierInspect() {
	for _, e := range m.GetSignatureVerifierMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ActiveNodeMock.GetSignatureVerifier")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSignatureVerifierMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSignatureVerifierCounter) < 1 {
		m.t.Error("Expected call to ActiveNodeMock.GetSignatureVerifier")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSignatureVerifier != nil && mm_atomic.LoadUint64(&m.afterGetSignatureVerifierCounter) < 1 {
		m.t.Error("Expected call to ActiveNodeMock.GetSignatureVerifier")
	}
}

type mActiveNodeMockGetStatic struct {
	mock               *ActiveNodeMock
	defaultExpectation *ActiveNodeMockGetStaticExpectation
	expectations       []*ActiveNodeMockGetStaticExpectation
}

// ActiveNodeMockGetStaticExpectation specifies expectation struct of the ActiveNode.GetStatic
type ActiveNodeMockGetStaticExpectation struct {
	mock *ActiveNodeMock

	results *ActiveNodeMockGetStaticResults
	Counter uint64
}

// ActiveNodeMockGetStaticResults contains results of the ActiveNode.GetStatic
type ActiveNodeMockGetStaticResults struct {
	s1 StaticProfile
}

// Expect sets up expected params for ActiveNode.GetStatic
func (mmGetStatic *mActiveNodeMockGetStatic) Expect() *mActiveNodeMockGetStatic {
	if mmGetStatic.mock.funcGetStatic != nil {
		mmGetStatic.mock.t.Fatalf("ActiveNodeMock.GetStatic mock is already set by Set")
	}

	if mmGetStatic.defaultExpectation == nil {
		mmGetStatic.defaultExpectation = &ActiveNodeMockGetStaticExpectation{}
	}

	return mmGetStatic
}

// Inspect accepts an inspector function that has same arguments as the ActiveNode.GetStatic
func (mmGetStatic *mActiveNodeMockGetStatic) Inspect(f func()) *mActiveNodeMockGetStatic {
	if mmGetStatic.mock.inspectFuncGetStatic != nil {
		mmGetStatic.mock.t.Fatalf("Inspect function is already set for ActiveNodeMock.GetStatic")
	}

	mmGetStatic.mock.inspectFuncGetStatic = f

	return mmGetStatic
}

// Return sets up results that will be returned by ActiveNode.GetStatic
func (mmGetStatic *mActiveNodeMockGetStatic) Return(s1 StaticProfile) *ActiveNodeMock {
	if mmGetStatic.mock.funcGetStatic != nil {
		mmGetStatic.mock.t.Fatalf("ActiveNodeMock.GetStatic mock is already set by Set")
	}

	if mmGetStatic.defaultExpectation == nil {
		mmGetStatic.defaultExpectation = &ActiveNodeMockGetStaticExpectation{mock: mmGetStatic.mock}
	}
	mmGetStatic.defaultExpectation.results = &ActiveNodeMockGetStaticResults{s1}
	return mmGetStatic.mock
}

//Set uses given function f to mock the ActiveNode.GetStatic method
func (mmGetStatic *mActiveNodeMockGetStatic) Set(f func() (s1 StaticProfile)) *ActiveNodeMock {
	if mmGetStatic.defaultExpectation != nil {
		mmGetStatic.mock.t.Fatalf("Default expectation is already set for the ActiveNode.GetStatic method")
	}

	if len(mmGetStatic.expectations) > 0 {
		mmGetStatic.mock.t.Fatalf("Some expectations are already set for the ActiveNode.GetStatic method")
	}

	mmGetStatic.mock.funcGetStatic = f
	return mmGetStatic.mock
}

// GetStatic implements ActiveNode
func (mmGetStatic *ActiveNodeMock) GetStatic() (s1 StaticProfile) {
	mm_atomic.AddUint64(&mmGetStatic.beforeGetStaticCounter, 1)
	defer mm_atomic.AddUint64(&mmGetStatic.afterGetStaticCounter, 1)

	if mmGetStatic.inspectFuncGetStatic != nil {
		mmGetStatic.inspectFuncGetStatic()
	}

	if mmGetStatic.GetStaticMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetStatic.GetStaticMock.defaultExpectation.Counter, 1)

		mm_results := mmGetStatic.GetStaticMock.defaultExpectation.results
		if mm_results == nil {
			mmGetStatic.t.Fatal("No results are set for the ActiveNodeMock.GetStatic")
		}
		return (*mm_results).s1
	}
	if mmGetStatic.funcGetStatic != nil {
		return mmGetStatic.funcGetStatic()
	}
	mmGetStatic.t.Fatalf("Unexpected call to ActiveNodeMock.GetStatic.")
	return
}

// GetStaticAfterCounter returns a count of finished ActiveNodeMock.GetStatic invocations
func (mmGetStatic *ActiveNodeMock) GetStaticAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStatic.afterGetStaticCounter)
}

// GetStaticBeforeCounter returns a count of ActiveNodeMock.GetStatic invocations
func (mmGetStatic *ActiveNodeMock) GetStaticBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStatic.beforeGetStaticCounter)
}

// MinimockGetStaticDone returns true if the count of the GetStatic invocations corresponds
// the number of defined expectations
func (m *ActiveNodeMock) MinimockGetStaticDone() bool {
	for _, e := range m.GetStaticMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetStaticMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetStaticCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetStatic != nil && mm_atomic.LoadUint64(&m.afterGetStaticCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetStaticInspect logs each unmet expectation
func (m *ActiveNodeMock) MinimockGetStaticInspect() {
	for _, e := range m.GetStaticMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ActiveNodeMock.GetStatic")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetStaticMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetStaticCounter) < 1 {
		m.t.Error("Expected call to ActiveNodeMock.GetStatic")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetStatic != nil && mm_atomic.LoadUint64(&m.afterGetStaticCounter) < 1 {
		m.t.Error("Expected call to ActiveNodeMock.GetStatic")
	}
}

type mActiveNodeMockHasFullProfile struct {
	mock               *ActiveNodeMock
	defaultExpectation *ActiveNodeMockHasFullProfileExpectation
	expectations       []*ActiveNodeMockHasFullProfileExpectation
}

// ActiveNodeMockHasFullProfileExpectation specifies expectation struct of the ActiveNode.HasFullProfile
type ActiveNodeMockHasFullProfileExpectation struct {
	mock *ActiveNodeMock

	results *ActiveNodeMockHasFullProfileResults
	Counter uint64
}

// ActiveNodeMockHasFullProfileResults contains results of the ActiveNode.HasFullProfile
type ActiveNodeMockHasFullProfileResults struct {
	b1 bool
}

// Expect sets up expected params for ActiveNode.HasFullProfile
func (mmHasFullProfile *mActiveNodeMockHasFullProfile) Expect() *mActiveNodeMockHasFullProfile {
	if mmHasFullProfile.mock.funcHasFullProfile != nil {
		mmHasFullProfile.mock.t.Fatalf("ActiveNodeMock.HasFullProfile mock is already set by Set")
	}

	if mmHasFullProfile.defaultExpectation == nil {
		mmHasFullProfile.defaultExpectation = &ActiveNodeMockHasFullProfileExpectation{}
	}

	return mmHasFullProfile
}

// Inspect accepts an inspector function that has same arguments as the ActiveNode.HasFullProfile
func (mmHasFullProfile *mActiveNodeMockHasFullProfile) Inspect(f func()) *mActiveNodeMockHasFullProfile {
	if mmHasFullProfile.mock.inspectFuncHasFullProfile != nil {
		mmHasFullProfile.mock.t.Fatalf("Inspect function is already set for ActiveNodeMock.HasFullProfile")
	}

	mmHasFullProfile.mock.inspectFuncHasFullProfile = f

	return mmHasFullProfile
}

// Return sets up results that will be returned by ActiveNode.HasFullProfile
func (mmHasFullProfile *mActiveNodeMockHasFullProfile) Return(b1 bool) *ActiveNodeMock {
	if mmHasFullProfile.mock.funcHasFullProfile != nil {
		mmHasFullProfile.mock.t.Fatalf("ActiveNodeMock.HasFullProfile mock is already set by Set")
	}

	if mmHasFullProfile.defaultExpectation == nil {
		mmHasFullProfile.defaultExpectation = &ActiveNodeMockHasFullProfileExpectation{mock: mmHasFullProfile.mock}
	}
	mmHasFullProfile.defaultExpectation.results = &ActiveNodeMockHasFullProfileResults{b1}
	return mmHasFullProfile.mock
}

//Set uses given function f to mock the ActiveNode.HasFullProfile method
func (mmHasFullProfile *mActiveNodeMockHasFullProfile) Set(f func() (b1 bool)) *ActiveNodeMock {
	if mmHasFullProfile.defaultExpectation != nil {
		mmHasFullProfile.mock.t.Fatalf("Default expectation is already set for the ActiveNode.HasFullProfile method")
	}

	if len(mmHasFullProfile.expectations) > 0 {
		mmHasFullProfile.mock.t.Fatalf("Some expectations are already set for the ActiveNode.HasFullProfile method")
	}

	mmHasFullProfile.mock.funcHasFullProfile = f
	return mmHasFullProfile.mock
}

// HasFullProfile implements ActiveNode
func (mmHasFullProfile *ActiveNodeMock) HasFullProfile() (b1 bool) {
	mm_atomic.AddUint64(&mmHasFullProfile.beforeHasFullProfileCounter, 1)
	defer mm_atomic.AddUint64(&mmHasFullProfile.afterHasFullProfileCounter, 1)

	if mmHasFullProfile.inspectFuncHasFullProfile != nil {
		mmHasFullProfile.inspectFuncHasFullProfile()
	}

	if mmHasFullProfile.HasFullProfileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHasFullProfile.HasFullProfileMock.defaultExpectation.Counter, 1)

		mm_results := mmHasFullProfile.HasFullProfileMock.defaultExpectation.results
		if mm_results == nil {
			mmHasFullProfile.t.Fatal("No results are set for the ActiveNodeMock.HasFullProfile")
		}
		return (*mm_results).b1
	}
	if mmHasFullProfile.funcHasFullProfile != nil {
		return mmHasFullProfile.funcHasFullProfile()
	}
	mmHasFullProfile.t.Fatalf("Unexpected call to ActiveNodeMock.HasFullProfile.")
	return
}

// HasFullProfileAfterCounter returns a count of finished ActiveNodeMock.HasFullProfile invocations
func (mmHasFullProfile *ActiveNodeMock) HasFullProfileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHasFullProfile.afterHasFullProfileCounter)
}

// HasFullProfileBeforeCounter returns a count of ActiveNodeMock.HasFullProfile invocations
func (mmHasFullProfile *ActiveNodeMock) HasFullProfileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHasFullProfile.beforeHasFullProfileCounter)
}

// MinimockHasFullProfileDone returns true if the count of the HasFullProfile invocations corresponds
// the number of defined expectations
func (m *ActiveNodeMock) MinimockHasFullProfileDone() bool {
	for _, e := range m.HasFullProfileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HasFullProfileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHasFullProfileCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHasFullProfile != nil && mm_atomic.LoadUint64(&m.afterHasFullProfileCounter) < 1 {
		return false
	}
	return true
}

// MinimockHasFullProfileInspect logs each unmet expectation
func (m *ActiveNodeMock) MinimockHasFullProfileInspect() {
	for _, e := range m.HasFullProfileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ActiveNodeMock.HasFullProfile")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HasFullProfileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHasFullProfileCounter) < 1 {
		m.t.Error("Expected call to ActiveNodeMock.HasFullProfile")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHasFullProfile != nil && mm_atomic.LoadUint64(&m.afterHasFullProfileCounter) < 1 {
		m.t.Error("Expected call to ActiveNodeMock.HasFullProfile")
	}
}

type mActiveNodeMockIsJoiner struct {
	mock               *ActiveNodeMock
	defaultExpectation *ActiveNodeMockIsJoinerExpectation
	expectations       []*ActiveNodeMockIsJoinerExpectation
}

// ActiveNodeMockIsJoinerExpectation specifies expectation struct of the ActiveNode.IsJoiner
type ActiveNodeMockIsJoinerExpectation struct {
	mock *ActiveNodeMock

	results *ActiveNodeMockIsJoinerResults
	Counter uint64
}

// ActiveNodeMockIsJoinerResults contains results of the ActiveNode.IsJoiner
type ActiveNodeMockIsJoinerResults struct {
	b1 bool
}

// Expect sets up expected params for ActiveNode.IsJoiner
func (mmIsJoiner *mActiveNodeMockIsJoiner) Expect() *mActiveNodeMockIsJoiner {
	if mmIsJoiner.mock.funcIsJoiner != nil {
		mmIsJoiner.mock.t.Fatalf("ActiveNodeMock.IsJoiner mock is already set by Set")
	}

	if mmIsJoiner.defaultExpectation == nil {
		mmIsJoiner.defaultExpectation = &ActiveNodeMockIsJoinerExpectation{}
	}

	return mmIsJoiner
}

// Inspect accepts an inspector function that has same arguments as the ActiveNode.IsJoiner
func (mmIsJoiner *mActiveNodeMockIsJoiner) Inspect(f func()) *mActiveNodeMockIsJoiner {
	if mmIsJoiner.mock.inspectFuncIsJoiner != nil {
		mmIsJoiner.mock.t.Fatalf("Inspect function is already set for ActiveNodeMock.IsJoiner")
	}

	mmIsJoiner.mock.inspectFuncIsJoiner = f

	return mmIsJoiner
}

// Return sets up results that will be returned by ActiveNode.IsJoiner
func (mmIsJoiner *mActiveNodeMockIsJoiner) Return(b1 bool) *ActiveNodeMock {
	if mmIsJoiner.mock.funcIsJoiner != nil {
		mmIsJoiner.mock.t.Fatalf("ActiveNodeMock.IsJoiner mock is already set by Set")
	}

	if mmIsJoiner.defaultExpectation == nil {
		mmIsJoiner.defaultExpectation = &ActiveNodeMockIsJoinerExpectation{mock: mmIsJoiner.mock}
	}
	mmIsJoiner.defaultExpectation.results = &ActiveNodeMockIsJoinerResults{b1}
	return mmIsJoiner.mock
}

//Set uses given function f to mock the ActiveNode.IsJoiner method
func (mmIsJoiner *mActiveNodeMockIsJoiner) Set(f func() (b1 bool)) *ActiveNodeMock {
	if mmIsJoiner.defaultExpectation != nil {
		mmIsJoiner.mock.t.Fatalf("Default expectation is already set for the ActiveNode.IsJoiner method")
	}

	if len(mmIsJoiner.expectations) > 0 {
		mmIsJoiner.mock.t.Fatalf("Some expectations are already set for the ActiveNode.IsJoiner method")
	}

	mmIsJoiner.mock.funcIsJoiner = f
	return mmIsJoiner.mock
}

// IsJoiner implements ActiveNode
func (mmIsJoiner *ActiveNodeMock) IsJoiner() (b1 bool) {
	mm_atomic.AddUint64(&mmIsJoiner.beforeIsJoinerCounter, 1)
	defer mm_atomic.AddUint64(&mmIsJoiner.afterIsJoinerCounter, 1)

	if mmIsJoiner.inspectFuncIsJoiner != nil {
		mmIsJoiner.inspectFuncIsJoiner()
	}

	if mmIsJoiner.IsJoinerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsJoiner.IsJoinerMock.defaultExpectation.Counter, 1)

		mm_results := mmIsJoiner.IsJoinerMock.defaultExpectation.results
		if mm_results == nil {
			mmIsJoiner.t.Fatal("No results are set for the ActiveNodeMock.IsJoiner")
		}
		return (*mm_results).b1
	}
	if mmIsJoiner.funcIsJoiner != nil {
		return mmIsJoiner.funcIsJoiner()
	}
	mmIsJoiner.t.Fatalf("Unexpected call to ActiveNodeMock.IsJoiner.")
	return
}

// IsJoinerAfterCounter returns a count of finished ActiveNodeMock.IsJoiner invocations
func (mmIsJoiner *ActiveNodeMock) IsJoinerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsJoiner.afterIsJoinerCounter)
}

// IsJoinerBeforeCounter returns a count of ActiveNodeMock.IsJoiner invocations
func (mmIsJoiner *ActiveNodeMock) IsJoinerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsJoiner.beforeIsJoinerCounter)
}

// MinimockIsJoinerDone returns true if the count of the IsJoiner invocations corresponds
// the number of defined expectations
func (m *ActiveNodeMock) MinimockIsJoinerDone() bool {
	for _, e := range m.IsJoinerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsJoinerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsJoinerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsJoiner != nil && mm_atomic.LoadUint64(&m.afterIsJoinerCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsJoinerInspect logs each unmet expectation
func (m *ActiveNodeMock) MinimockIsJoinerInspect() {
	for _, e := range m.IsJoinerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ActiveNodeMock.IsJoiner")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsJoinerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsJoinerCounter) < 1 {
		m.t.Error("Expected call to ActiveNodeMock.IsJoiner")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsJoiner != nil && mm_atomic.LoadUint64(&m.afterIsJoinerCounter) < 1 {
		m.t.Error("Expected call to ActiveNodeMock.IsJoiner")
	}
}

type mActiveNodeMockIsPowered struct {
	mock               *ActiveNodeMock
	defaultExpectation *ActiveNodeMockIsPoweredExpectation
	expectations       []*ActiveNodeMockIsPoweredExpectation
}

// ActiveNodeMockIsPoweredExpectation specifies expectation struct of the ActiveNode.IsPowered
type ActiveNodeMockIsPoweredExpectation struct {
	mock *ActiveNodeMock

	results *ActiveNodeMockIsPoweredResults
	Counter uint64
}

// ActiveNodeMockIsPoweredResults contains results of the ActiveNode.IsPowered
type ActiveNodeMockIsPoweredResults struct {
	b1 bool
}

// Expect sets up expected params for ActiveNode.IsPowered
func (mmIsPowered *mActiveNodeMockIsPowered) Expect() *mActiveNodeMockIsPowered {
	if mmIsPowered.mock.funcIsPowered != nil {
		mmIsPowered.mock.t.Fatalf("ActiveNodeMock.IsPowered mock is already set by Set")
	}

	if mmIsPowered.defaultExpectation == nil {
		mmIsPowered.defaultExpectation = &ActiveNodeMockIsPoweredExpectation{}
	}

	return mmIsPowered
}

// Inspect accepts an inspector function that has same arguments as the ActiveNode.IsPowered
func (mmIsPowered *mActiveNodeMockIsPowered) Inspect(f func()) *mActiveNodeMockIsPowered {
	if mmIsPowered.mock.inspectFuncIsPowered != nil {
		mmIsPowered.mock.t.Fatalf("Inspect function is already set for ActiveNodeMock.IsPowered")
	}

	mmIsPowered.mock.inspectFuncIsPowered = f

	return mmIsPowered
}

// Return sets up results that will be returned by ActiveNode.IsPowered
func (mmIsPowered *mActiveNodeMockIsPowered) Return(b1 bool) *ActiveNodeMock {
	if mmIsPowered.mock.funcIsPowered != nil {
		mmIsPowered.mock.t.Fatalf("ActiveNodeMock.IsPowered mock is already set by Set")
	}

	if mmIsPowered.defaultExpectation == nil {
		mmIsPowered.defaultExpectation = &ActiveNodeMockIsPoweredExpectation{mock: mmIsPowered.mock}
	}
	mmIsPowered.defaultExpectation.results = &ActiveNodeMockIsPoweredResults{b1}
	return mmIsPowered.mock
}

//Set uses given function f to mock the ActiveNode.IsPowered method
func (mmIsPowered *mActiveNodeMockIsPowered) Set(f func() (b1 bool)) *ActiveNodeMock {
	if mmIsPowered.defaultExpectation != nil {
		mmIsPowered.mock.t.Fatalf("Default expectation is already set for the ActiveNode.IsPowered method")
	}

	if len(mmIsPowered.expectations) > 0 {
		mmIsPowered.mock.t.Fatalf("Some expectations are already set for the ActiveNode.IsPowered method")
	}

	mmIsPowered.mock.funcIsPowered = f
	return mmIsPowered.mock
}

// IsPowered implements ActiveNode
func (mmIsPowered *ActiveNodeMock) IsPowered() (b1 bool) {
	mm_atomic.AddUint64(&mmIsPowered.beforeIsPoweredCounter, 1)
	defer mm_atomic.AddUint64(&mmIsPowered.afterIsPoweredCounter, 1)

	if mmIsPowered.inspectFuncIsPowered != nil {
		mmIsPowered.inspectFuncIsPowered()
	}

	if mmIsPowered.IsPoweredMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsPowered.IsPoweredMock.defaultExpectation.Counter, 1)

		mm_results := mmIsPowered.IsPoweredMock.defaultExpectation.results
		if mm_results == nil {
			mmIsPowered.t.Fatal("No results are set for the ActiveNodeMock.IsPowered")
		}
		return (*mm_results).b1
	}
	if mmIsPowered.funcIsPowered != nil {
		return mmIsPowered.funcIsPowered()
	}
	mmIsPowered.t.Fatalf("Unexpected call to ActiveNodeMock.IsPowered.")
	return
}

// IsPoweredAfterCounter returns a count of finished ActiveNodeMock.IsPowered invocations
func (mmIsPowered *ActiveNodeMock) IsPoweredAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsPowered.afterIsPoweredCounter)
}

// IsPoweredBeforeCounter returns a count of ActiveNodeMock.IsPowered invocations
func (mmIsPowered *ActiveNodeMock) IsPoweredBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsPowered.beforeIsPoweredCounter)
}

// MinimockIsPoweredDone returns true if the count of the IsPowered invocations corresponds
// the number of defined expectations
func (m *ActiveNodeMock) MinimockIsPoweredDone() bool {
	for _, e := range m.IsPoweredMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsPoweredMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsPoweredCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsPowered != nil && mm_atomic.LoadUint64(&m.afterIsPoweredCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsPoweredInspect logs each unmet expectation
func (m *ActiveNodeMock) MinimockIsPoweredInspect() {
	for _, e := range m.IsPoweredMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ActiveNodeMock.IsPowered")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsPoweredMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsPoweredCounter) < 1 {
		m.t.Error("Expected call to ActiveNodeMock.IsPowered")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsPowered != nil && mm_atomic.LoadUint64(&m.afterIsPoweredCounter) < 1 {
		m.t.Error("Expected call to ActiveNodeMock.IsPowered")
	}
}

type mActiveNodeMockIsStateful struct {
	mock               *ActiveNodeMock
	defaultExpectation *ActiveNodeMockIsStatefulExpectation
	expectations       []*ActiveNodeMockIsStatefulExpectation
}

// ActiveNodeMockIsStatefulExpectation specifies expectation struct of the ActiveNode.IsStateful
type ActiveNodeMockIsStatefulExpectation struct {
	mock *ActiveNodeMock

	results *ActiveNodeMockIsStatefulResults
	Counter uint64
}

// ActiveNodeMockIsStatefulResults contains results of the ActiveNode.IsStateful
type ActiveNodeMockIsStatefulResults struct {
	b1 bool
}

// Expect sets up expected params for ActiveNode.IsStateful
func (mmIsStateful *mActiveNodeMockIsStateful) Expect() *mActiveNodeMockIsStateful {
	if mmIsStateful.mock.funcIsStateful != nil {
		mmIsStateful.mock.t.Fatalf("ActiveNodeMock.IsStateful mock is already set by Set")
	}

	if mmIsStateful.defaultExpectation == nil {
		mmIsStateful.defaultExpectation = &ActiveNodeMockIsStatefulExpectation{}
	}

	return mmIsStateful
}

// Inspect accepts an inspector function that has same arguments as the ActiveNode.IsStateful
func (mmIsStateful *mActiveNodeMockIsStateful) Inspect(f func()) *mActiveNodeMockIsStateful {
	if mmIsStateful.mock.inspectFuncIsStateful != nil {
		mmIsStateful.mock.t.Fatalf("Inspect function is already set for ActiveNodeMock.IsStateful")
	}

	mmIsStateful.mock.inspectFuncIsStateful = f

	return mmIsStateful
}

// Return sets up results that will be returned by ActiveNode.IsStateful
func (mmIsStateful *mActiveNodeMockIsStateful) Return(b1 bool) *ActiveNodeMock {
	if mmIsStateful.mock.funcIsStateful != nil {
		mmIsStateful.mock.t.Fatalf("ActiveNodeMock.IsStateful mock is already set by Set")
	}

	if mmIsStateful.defaultExpectation == nil {
		mmIsStateful.defaultExpectation = &ActiveNodeMockIsStatefulExpectation{mock: mmIsStateful.mock}
	}
	mmIsStateful.defaultExpectation.results = &ActiveNodeMockIsStatefulResults{b1}
	return mmIsStateful.mock
}

//Set uses given function f to mock the ActiveNode.IsStateful method
func (mmIsStateful *mActiveNodeMockIsStateful) Set(f func() (b1 bool)) *ActiveNodeMock {
	if mmIsStateful.defaultExpectation != nil {
		mmIsStateful.mock.t.Fatalf("Default expectation is already set for the ActiveNode.IsStateful method")
	}

	if len(mmIsStateful.expectations) > 0 {
		mmIsStateful.mock.t.Fatalf("Some expectations are already set for the ActiveNode.IsStateful method")
	}

	mmIsStateful.mock.funcIsStateful = f
	return mmIsStateful.mock
}

// IsStateful implements ActiveNode
func (mmIsStateful *ActiveNodeMock) IsStateful() (b1 bool) {
	mm_atomic.AddUint64(&mmIsStateful.beforeIsStatefulCounter, 1)
	defer mm_atomic.AddUint64(&mmIsStateful.afterIsStatefulCounter, 1)

	if mmIsStateful.inspectFuncIsStateful != nil {
		mmIsStateful.inspectFuncIsStateful()
	}

	if mmIsStateful.IsStatefulMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsStateful.IsStatefulMock.defaultExpectation.Counter, 1)

		mm_results := mmIsStateful.IsStatefulMock.defaultExpectation.results
		if mm_results == nil {
			mmIsStateful.t.Fatal("No results are set for the ActiveNodeMock.IsStateful")
		}
		return (*mm_results).b1
	}
	if mmIsStateful.funcIsStateful != nil {
		return mmIsStateful.funcIsStateful()
	}
	mmIsStateful.t.Fatalf("Unexpected call to ActiveNodeMock.IsStateful.")
	return
}

// IsStatefulAfterCounter returns a count of finished ActiveNodeMock.IsStateful invocations
func (mmIsStateful *ActiveNodeMock) IsStatefulAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsStateful.afterIsStatefulCounter)
}

// IsStatefulBeforeCounter returns a count of ActiveNodeMock.IsStateful invocations
func (mmIsStateful *ActiveNodeMock) IsStatefulBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsStateful.beforeIsStatefulCounter)
}

// MinimockIsStatefulDone returns true if the count of the IsStateful invocations corresponds
// the number of defined expectations
func (m *ActiveNodeMock) MinimockIsStatefulDone() bool {
	for _, e := range m.IsStatefulMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsStatefulMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsStatefulCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsStateful != nil && mm_atomic.LoadUint64(&m.afterIsStatefulCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsStatefulInspect logs each unmet expectation
func (m *ActiveNodeMock) MinimockIsStatefulInspect() {
	for _, e := range m.IsStatefulMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ActiveNodeMock.IsStateful")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsStatefulMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsStatefulCounter) < 1 {
		m.t.Error("Expected call to ActiveNodeMock.IsStateful")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsStateful != nil && mm_atomic.LoadUint64(&m.afterIsStatefulCounter) < 1 {
		m.t.Error("Expected call to ActiveNodeMock.IsStateful")
	}
}

type mActiveNodeMockIsVoter struct {
	mock               *ActiveNodeMock
	defaultExpectation *ActiveNodeMockIsVoterExpectation
	expectations       []*ActiveNodeMockIsVoterExpectation
}

// ActiveNodeMockIsVoterExpectation specifies expectation struct of the ActiveNode.IsVoter
type ActiveNodeMockIsVoterExpectation struct {
	mock *ActiveNodeMock

	results *ActiveNodeMockIsVoterResults
	Counter uint64
}

// ActiveNodeMockIsVoterResults contains results of the ActiveNode.IsVoter
type ActiveNodeMockIsVoterResults struct {
	b1 bool
}

// Expect sets up expected params for ActiveNode.IsVoter
func (mmIsVoter *mActiveNodeMockIsVoter) Expect() *mActiveNodeMockIsVoter {
	if mmIsVoter.mock.funcIsVoter != nil {
		mmIsVoter.mock.t.Fatalf("ActiveNodeMock.IsVoter mock is already set by Set")
	}

	if mmIsVoter.defaultExpectation == nil {
		mmIsVoter.defaultExpectation = &ActiveNodeMockIsVoterExpectation{}
	}

	return mmIsVoter
}

// Inspect accepts an inspector function that has same arguments as the ActiveNode.IsVoter
func (mmIsVoter *mActiveNodeMockIsVoter) Inspect(f func()) *mActiveNodeMockIsVoter {
	if mmIsVoter.mock.inspectFuncIsVoter != nil {
		mmIsVoter.mock.t.Fatalf("Inspect function is already set for ActiveNodeMock.IsVoter")
	}

	mmIsVoter.mock.inspectFuncIsVoter = f

	return mmIsVoter
}

// Return sets up results that will be returned by ActiveNode.IsVoter
func (mmIsVoter *mActiveNodeMockIsVoter) Return(b1 bool) *ActiveNodeMock {
	if mmIsVoter.mock.funcIsVoter != nil {
		mmIsVoter.mock.t.Fatalf("ActiveNodeMock.IsVoter mock is already set by Set")
	}

	if mmIsVoter.defaultExpectation == nil {
		mmIsVoter.defaultExpectation = &ActiveNodeMockIsVoterExpectation{mock: mmIsVoter.mock}
	}
	mmIsVoter.defaultExpectation.results = &ActiveNodeMockIsVoterResults{b1}
	return mmIsVoter.mock
}

//Set uses given function f to mock the ActiveNode.IsVoter method
func (mmIsVoter *mActiveNodeMockIsVoter) Set(f func() (b1 bool)) *ActiveNodeMock {
	if mmIsVoter.defaultExpectation != nil {
		mmIsVoter.mock.t.Fatalf("Default expectation is already set for the ActiveNode.IsVoter method")
	}

	if len(mmIsVoter.expectations) > 0 {
		mmIsVoter.mock.t.Fatalf("Some expectations are already set for the ActiveNode.IsVoter method")
	}

	mmIsVoter.mock.funcIsVoter = f
	return mmIsVoter.mock
}

// IsVoter implements ActiveNode
func (mmIsVoter *ActiveNodeMock) IsVoter() (b1 bool) {
	mm_atomic.AddUint64(&mmIsVoter.beforeIsVoterCounter, 1)
	defer mm_atomic.AddUint64(&mmIsVoter.afterIsVoterCounter, 1)

	if mmIsVoter.inspectFuncIsVoter != nil {
		mmIsVoter.inspectFuncIsVoter()
	}

	if mmIsVoter.IsVoterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsVoter.IsVoterMock.defaultExpectation.Counter, 1)

		mm_results := mmIsVoter.IsVoterMock.defaultExpectation.results
		if mm_results == nil {
			mmIsVoter.t.Fatal("No results are set for the ActiveNodeMock.IsVoter")
		}
		return (*mm_results).b1
	}
	if mmIsVoter.funcIsVoter != nil {
		return mmIsVoter.funcIsVoter()
	}
	mmIsVoter.t.Fatalf("Unexpected call to ActiveNodeMock.IsVoter.")
	return
}

// IsVoterAfterCounter returns a count of finished ActiveNodeMock.IsVoter invocations
func (mmIsVoter *ActiveNodeMock) IsVoterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsVoter.afterIsVoterCounter)
}

// IsVoterBeforeCounter returns a count of ActiveNodeMock.IsVoter invocations
func (mmIsVoter *ActiveNodeMock) IsVoterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsVoter.beforeIsVoterCounter)
}

// MinimockIsVoterDone returns true if the count of the IsVoter invocations corresponds
// the number of defined expectations
func (m *ActiveNodeMock) MinimockIsVoterDone() bool {
	for _, e := range m.IsVoterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsVoterMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsVoterCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsVoter != nil && mm_atomic.LoadUint64(&m.afterIsVoterCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsVoterInspect logs each unmet expectation
func (m *ActiveNodeMock) MinimockIsVoterInspect() {
	for _, e := range m.IsVoterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ActiveNodeMock.IsVoter")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsVoterMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsVoterCounter) < 1 {
		m.t.Error("Expected call to ActiveNodeMock.IsVoter")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsVoter != nil && mm_atomic.LoadUint64(&m.afterIsVoterCounter) < 1 {
		m.t.Error("Expected call to ActiveNodeMock.IsVoter")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ActiveNodeMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCanIntroduceJoinerInspect()

		m.MinimockGetDeclaredPowerInspect()

		m.MinimockGetIndexInspect()

		m.MinimockGetNodeIDInspect()

		m.MinimockGetOpModeInspect()

		m.MinimockGetSignatureVerifierInspect()

		m.MinimockGetStaticInspect()

		m.MinimockHasFullProfileInspect()

		m.MinimockIsJoinerInspect()

		m.MinimockIsPoweredInspect()

		m.MinimockIsStatefulInspect()

		m.MinimockIsVoterInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ActiveNodeMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ActiveNodeMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCanIntroduceJoinerDone() &&
		m.MinimockGetDeclaredPowerDone() &&
		m.MinimockGetIndexDone() &&
		m.MinimockGetNodeIDDone() &&
		m.MinimockGetOpModeDone() &&
		m.MinimockGetSignatureVerifierDone() &&
		m.MinimockGetStaticDone() &&
		m.MinimockHasFullProfileDone() &&
		m.MinimockIsJoinerDone() &&
		m.MinimockIsPoweredDone() &&
		m.MinimockIsStatefulDone() &&
		m.MinimockIsVoterDone()
}
