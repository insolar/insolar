package profiles

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/insolar"
	"github.com/insolar/insolar/network/consensus/common/cryptkit"
	"github.com/insolar/insolar/network/consensus/gcpv2/api/member"
)

// LocalNodeMock implements LocalNode
type LocalNodeMock struct {
	t minimock.Tester

	funcCanIntroduceJoiner          func() (b1 bool)
	inspectFuncCanIntroduceJoiner   func()
	afterCanIntroduceJoinerCounter  uint64
	beforeCanIntroduceJoinerCounter uint64
	CanIntroduceJoinerMock          mLocalNodeMockCanIntroduceJoiner

	funcGetDeclaredPower          func() (p1 member.Power)
	inspectFuncGetDeclaredPower   func()
	afterGetDeclaredPowerCounter  uint64
	beforeGetDeclaredPowerCounter uint64
	GetDeclaredPowerMock          mLocalNodeMockGetDeclaredPower

	funcGetIndex          func() (i1 member.Index)
	inspectFuncGetIndex   func()
	afterGetIndexCounter  uint64
	beforeGetIndexCounter uint64
	GetIndexMock          mLocalNodeMockGetIndex

	funcGetNodeID          func() (s1 insolar.ShortNodeID)
	inspectFuncGetNodeID   func()
	afterGetNodeIDCounter  uint64
	beforeGetNodeIDCounter uint64
	GetNodeIDMock          mLocalNodeMockGetNodeID

	funcGetOpMode          func() (o1 member.OpMode)
	inspectFuncGetOpMode   func()
	afterGetOpModeCounter  uint64
	beforeGetOpModeCounter uint64
	GetOpModeMock          mLocalNodeMockGetOpMode

	funcGetSignatureVerifier          func() (s1 cryptkit.SignatureVerifier)
	inspectFuncGetSignatureVerifier   func()
	afterGetSignatureVerifierCounter  uint64
	beforeGetSignatureVerifierCounter uint64
	GetSignatureVerifierMock          mLocalNodeMockGetSignatureVerifier

	funcGetStatic          func() (s1 StaticProfile)
	inspectFuncGetStatic   func()
	afterGetStaticCounter  uint64
	beforeGetStaticCounter uint64
	GetStaticMock          mLocalNodeMockGetStatic

	funcHasFullProfile          func() (b1 bool)
	inspectFuncHasFullProfile   func()
	afterHasFullProfileCounter  uint64
	beforeHasFullProfileCounter uint64
	HasFullProfileMock          mLocalNodeMockHasFullProfile

	funcIsJoiner          func() (b1 bool)
	inspectFuncIsJoiner   func()
	afterIsJoinerCounter  uint64
	beforeIsJoinerCounter uint64
	IsJoinerMock          mLocalNodeMockIsJoiner

	funcIsPowered          func() (b1 bool)
	inspectFuncIsPowered   func()
	afterIsPoweredCounter  uint64
	beforeIsPoweredCounter uint64
	IsPoweredMock          mLocalNodeMockIsPowered

	funcIsStateful          func() (b1 bool)
	inspectFuncIsStateful   func()
	afterIsStatefulCounter  uint64
	beforeIsStatefulCounter uint64
	IsStatefulMock          mLocalNodeMockIsStateful

	funcIsVoter          func() (b1 bool)
	inspectFuncIsVoter   func()
	afterIsVoterCounter  uint64
	beforeIsVoterCounter uint64
	IsVoterMock          mLocalNodeMockIsVoter

	funcLocalNodeProfile          func()
	inspectFuncLocalNodeProfile   func()
	afterLocalNodeProfileCounter  uint64
	beforeLocalNodeProfileCounter uint64
	LocalNodeProfileMock          mLocalNodeMockLocalNodeProfile
}

// NewLocalNodeMock returns a mock for LocalNode
func NewLocalNodeMock(t minimock.Tester) *LocalNodeMock {
	m := &LocalNodeMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CanIntroduceJoinerMock = mLocalNodeMockCanIntroduceJoiner{mock: m}

	m.GetDeclaredPowerMock = mLocalNodeMockGetDeclaredPower{mock: m}

	m.GetIndexMock = mLocalNodeMockGetIndex{mock: m}

	m.GetNodeIDMock = mLocalNodeMockGetNodeID{mock: m}

	m.GetOpModeMock = mLocalNodeMockGetOpMode{mock: m}

	m.GetSignatureVerifierMock = mLocalNodeMockGetSignatureVerifier{mock: m}

	m.GetStaticMock = mLocalNodeMockGetStatic{mock: m}

	m.HasFullProfileMock = mLocalNodeMockHasFullProfile{mock: m}

	m.IsJoinerMock = mLocalNodeMockIsJoiner{mock: m}

	m.IsPoweredMock = mLocalNodeMockIsPowered{mock: m}

	m.IsStatefulMock = mLocalNodeMockIsStateful{mock: m}

	m.IsVoterMock = mLocalNodeMockIsVoter{mock: m}

	m.LocalNodeProfileMock = mLocalNodeMockLocalNodeProfile{mock: m}

	return m
}

type mLocalNodeMockCanIntroduceJoiner struct {
	mock               *LocalNodeMock
	defaultExpectation *LocalNodeMockCanIntroduceJoinerExpectation
	expectations       []*LocalNodeMockCanIntroduceJoinerExpectation
}

// LocalNodeMockCanIntroduceJoinerExpectation specifies expectation struct of the LocalNode.CanIntroduceJoiner
type LocalNodeMockCanIntroduceJoinerExpectation struct {
	mock *LocalNodeMock

	results *LocalNodeMockCanIntroduceJoinerResults
	Counter uint64
}

// LocalNodeMockCanIntroduceJoinerResults contains results of the LocalNode.CanIntroduceJoiner
type LocalNodeMockCanIntroduceJoinerResults struct {
	b1 bool
}

// Expect sets up expected params for LocalNode.CanIntroduceJoiner
func (mmCanIntroduceJoiner *mLocalNodeMockCanIntroduceJoiner) Expect() *mLocalNodeMockCanIntroduceJoiner {
	if mmCanIntroduceJoiner.mock.funcCanIntroduceJoiner != nil {
		mmCanIntroduceJoiner.mock.t.Fatalf("LocalNodeMock.CanIntroduceJoiner mock is already set by Set")
	}

	if mmCanIntroduceJoiner.defaultExpectation == nil {
		mmCanIntroduceJoiner.defaultExpectation = &LocalNodeMockCanIntroduceJoinerExpectation{}
	}

	return mmCanIntroduceJoiner
}

// Inspect accepts an inspector function that has same arguments as the LocalNode.CanIntroduceJoiner
func (mmCanIntroduceJoiner *mLocalNodeMockCanIntroduceJoiner) Inspect(f func()) *mLocalNodeMockCanIntroduceJoiner {
	if mmCanIntroduceJoiner.mock.inspectFuncCanIntroduceJoiner != nil {
		mmCanIntroduceJoiner.mock.t.Fatalf("Inspect function is already set for LocalNodeMock.CanIntroduceJoiner")
	}

	mmCanIntroduceJoiner.mock.inspectFuncCanIntroduceJoiner = f

	return mmCanIntroduceJoiner
}

// Return sets up results that will be returned by LocalNode.CanIntroduceJoiner
func (mmCanIntroduceJoiner *mLocalNodeMockCanIntroduceJoiner) Return(b1 bool) *LocalNodeMock {
	if mmCanIntroduceJoiner.mock.funcCanIntroduceJoiner != nil {
		mmCanIntroduceJoiner.mock.t.Fatalf("LocalNodeMock.CanIntroduceJoiner mock is already set by Set")
	}

	if mmCanIntroduceJoiner.defaultExpectation == nil {
		mmCanIntroduceJoiner.defaultExpectation = &LocalNodeMockCanIntroduceJoinerExpectation{mock: mmCanIntroduceJoiner.mock}
	}
	mmCanIntroduceJoiner.defaultExpectation.results = &LocalNodeMockCanIntroduceJoinerResults{b1}
	return mmCanIntroduceJoiner.mock
}

//Set uses given function f to mock the LocalNode.CanIntroduceJoiner method
func (mmCanIntroduceJoiner *mLocalNodeMockCanIntroduceJoiner) Set(f func() (b1 bool)) *LocalNodeMock {
	if mmCanIntroduceJoiner.defaultExpectation != nil {
		mmCanIntroduceJoiner.mock.t.Fatalf("Default expectation is already set for the LocalNode.CanIntroduceJoiner method")
	}

	if len(mmCanIntroduceJoiner.expectations) > 0 {
		mmCanIntroduceJoiner.mock.t.Fatalf("Some expectations are already set for the LocalNode.CanIntroduceJoiner method")
	}

	mmCanIntroduceJoiner.mock.funcCanIntroduceJoiner = f
	return mmCanIntroduceJoiner.mock
}

// CanIntroduceJoiner implements LocalNode
func (mmCanIntroduceJoiner *LocalNodeMock) CanIntroduceJoiner() (b1 bool) {
	mm_atomic.AddUint64(&mmCanIntroduceJoiner.beforeCanIntroduceJoinerCounter, 1)
	defer mm_atomic.AddUint64(&mmCanIntroduceJoiner.afterCanIntroduceJoinerCounter, 1)

	if mmCanIntroduceJoiner.inspectFuncCanIntroduceJoiner != nil {
		mmCanIntroduceJoiner.inspectFuncCanIntroduceJoiner()
	}

	if mmCanIntroduceJoiner.CanIntroduceJoinerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCanIntroduceJoiner.CanIntroduceJoinerMock.defaultExpectation.Counter, 1)

		results := mmCanIntroduceJoiner.CanIntroduceJoinerMock.defaultExpectation.results
		if results == nil {
			mmCanIntroduceJoiner.t.Fatal("No results are set for the LocalNodeMock.CanIntroduceJoiner")
		}
		return (*results).b1
	}
	if mmCanIntroduceJoiner.funcCanIntroduceJoiner != nil {
		return mmCanIntroduceJoiner.funcCanIntroduceJoiner()
	}
	mmCanIntroduceJoiner.t.Fatalf("Unexpected call to LocalNodeMock.CanIntroduceJoiner.")
	return
}

// CanIntroduceJoinerAfterCounter returns a count of finished LocalNodeMock.CanIntroduceJoiner invocations
func (mmCanIntroduceJoiner *LocalNodeMock) CanIntroduceJoinerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCanIntroduceJoiner.afterCanIntroduceJoinerCounter)
}

// CanIntroduceJoinerBeforeCounter returns a count of LocalNodeMock.CanIntroduceJoiner invocations
func (mmCanIntroduceJoiner *LocalNodeMock) CanIntroduceJoinerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCanIntroduceJoiner.beforeCanIntroduceJoinerCounter)
}

// MinimockCanIntroduceJoinerDone returns true if the count of the CanIntroduceJoiner invocations corresponds
// the number of defined expectations
func (m *LocalNodeMock) MinimockCanIntroduceJoinerDone() bool {
	for _, e := range m.CanIntroduceJoinerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CanIntroduceJoinerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCanIntroduceJoinerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCanIntroduceJoiner != nil && mm_atomic.LoadUint64(&m.afterCanIntroduceJoinerCounter) < 1 {
		return false
	}
	return true
}

// MinimockCanIntroduceJoinerInspect logs each unmet expectation
func (m *LocalNodeMock) MinimockCanIntroduceJoinerInspect() {
	for _, e := range m.CanIntroduceJoinerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LocalNodeMock.CanIntroduceJoiner")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CanIntroduceJoinerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCanIntroduceJoinerCounter) < 1 {
		m.t.Error("Expected call to LocalNodeMock.CanIntroduceJoiner")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCanIntroduceJoiner != nil && mm_atomic.LoadUint64(&m.afterCanIntroduceJoinerCounter) < 1 {
		m.t.Error("Expected call to LocalNodeMock.CanIntroduceJoiner")
	}
}

type mLocalNodeMockGetDeclaredPower struct {
	mock               *LocalNodeMock
	defaultExpectation *LocalNodeMockGetDeclaredPowerExpectation
	expectations       []*LocalNodeMockGetDeclaredPowerExpectation
}

// LocalNodeMockGetDeclaredPowerExpectation specifies expectation struct of the LocalNode.GetDeclaredPower
type LocalNodeMockGetDeclaredPowerExpectation struct {
	mock *LocalNodeMock

	results *LocalNodeMockGetDeclaredPowerResults
	Counter uint64
}

// LocalNodeMockGetDeclaredPowerResults contains results of the LocalNode.GetDeclaredPower
type LocalNodeMockGetDeclaredPowerResults struct {
	p1 member.Power
}

// Expect sets up expected params for LocalNode.GetDeclaredPower
func (mmGetDeclaredPower *mLocalNodeMockGetDeclaredPower) Expect() *mLocalNodeMockGetDeclaredPower {
	if mmGetDeclaredPower.mock.funcGetDeclaredPower != nil {
		mmGetDeclaredPower.mock.t.Fatalf("LocalNodeMock.GetDeclaredPower mock is already set by Set")
	}

	if mmGetDeclaredPower.defaultExpectation == nil {
		mmGetDeclaredPower.defaultExpectation = &LocalNodeMockGetDeclaredPowerExpectation{}
	}

	return mmGetDeclaredPower
}

// Inspect accepts an inspector function that has same arguments as the LocalNode.GetDeclaredPower
func (mmGetDeclaredPower *mLocalNodeMockGetDeclaredPower) Inspect(f func()) *mLocalNodeMockGetDeclaredPower {
	if mmGetDeclaredPower.mock.inspectFuncGetDeclaredPower != nil {
		mmGetDeclaredPower.mock.t.Fatalf("Inspect function is already set for LocalNodeMock.GetDeclaredPower")
	}

	mmGetDeclaredPower.mock.inspectFuncGetDeclaredPower = f

	return mmGetDeclaredPower
}

// Return sets up results that will be returned by LocalNode.GetDeclaredPower
func (mmGetDeclaredPower *mLocalNodeMockGetDeclaredPower) Return(p1 member.Power) *LocalNodeMock {
	if mmGetDeclaredPower.mock.funcGetDeclaredPower != nil {
		mmGetDeclaredPower.mock.t.Fatalf("LocalNodeMock.GetDeclaredPower mock is already set by Set")
	}

	if mmGetDeclaredPower.defaultExpectation == nil {
		mmGetDeclaredPower.defaultExpectation = &LocalNodeMockGetDeclaredPowerExpectation{mock: mmGetDeclaredPower.mock}
	}
	mmGetDeclaredPower.defaultExpectation.results = &LocalNodeMockGetDeclaredPowerResults{p1}
	return mmGetDeclaredPower.mock
}

//Set uses given function f to mock the LocalNode.GetDeclaredPower method
func (mmGetDeclaredPower *mLocalNodeMockGetDeclaredPower) Set(f func() (p1 member.Power)) *LocalNodeMock {
	if mmGetDeclaredPower.defaultExpectation != nil {
		mmGetDeclaredPower.mock.t.Fatalf("Default expectation is already set for the LocalNode.GetDeclaredPower method")
	}

	if len(mmGetDeclaredPower.expectations) > 0 {
		mmGetDeclaredPower.mock.t.Fatalf("Some expectations are already set for the LocalNode.GetDeclaredPower method")
	}

	mmGetDeclaredPower.mock.funcGetDeclaredPower = f
	return mmGetDeclaredPower.mock
}

// GetDeclaredPower implements LocalNode
func (mmGetDeclaredPower *LocalNodeMock) GetDeclaredPower() (p1 member.Power) {
	mm_atomic.AddUint64(&mmGetDeclaredPower.beforeGetDeclaredPowerCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDeclaredPower.afterGetDeclaredPowerCounter, 1)

	if mmGetDeclaredPower.inspectFuncGetDeclaredPower != nil {
		mmGetDeclaredPower.inspectFuncGetDeclaredPower()
	}

	if mmGetDeclaredPower.GetDeclaredPowerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDeclaredPower.GetDeclaredPowerMock.defaultExpectation.Counter, 1)

		results := mmGetDeclaredPower.GetDeclaredPowerMock.defaultExpectation.results
		if results == nil {
			mmGetDeclaredPower.t.Fatal("No results are set for the LocalNodeMock.GetDeclaredPower")
		}
		return (*results).p1
	}
	if mmGetDeclaredPower.funcGetDeclaredPower != nil {
		return mmGetDeclaredPower.funcGetDeclaredPower()
	}
	mmGetDeclaredPower.t.Fatalf("Unexpected call to LocalNodeMock.GetDeclaredPower.")
	return
}

// GetDeclaredPowerAfterCounter returns a count of finished LocalNodeMock.GetDeclaredPower invocations
func (mmGetDeclaredPower *LocalNodeMock) GetDeclaredPowerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDeclaredPower.afterGetDeclaredPowerCounter)
}

// GetDeclaredPowerBeforeCounter returns a count of LocalNodeMock.GetDeclaredPower invocations
func (mmGetDeclaredPower *LocalNodeMock) GetDeclaredPowerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDeclaredPower.beforeGetDeclaredPowerCounter)
}

// MinimockGetDeclaredPowerDone returns true if the count of the GetDeclaredPower invocations corresponds
// the number of defined expectations
func (m *LocalNodeMock) MinimockGetDeclaredPowerDone() bool {
	for _, e := range m.GetDeclaredPowerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDeclaredPowerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDeclaredPowerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDeclaredPower != nil && mm_atomic.LoadUint64(&m.afterGetDeclaredPowerCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetDeclaredPowerInspect logs each unmet expectation
func (m *LocalNodeMock) MinimockGetDeclaredPowerInspect() {
	for _, e := range m.GetDeclaredPowerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LocalNodeMock.GetDeclaredPower")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDeclaredPowerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDeclaredPowerCounter) < 1 {
		m.t.Error("Expected call to LocalNodeMock.GetDeclaredPower")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDeclaredPower != nil && mm_atomic.LoadUint64(&m.afterGetDeclaredPowerCounter) < 1 {
		m.t.Error("Expected call to LocalNodeMock.GetDeclaredPower")
	}
}

type mLocalNodeMockGetIndex struct {
	mock               *LocalNodeMock
	defaultExpectation *LocalNodeMockGetIndexExpectation
	expectations       []*LocalNodeMockGetIndexExpectation
}

// LocalNodeMockGetIndexExpectation specifies expectation struct of the LocalNode.GetIndex
type LocalNodeMockGetIndexExpectation struct {
	mock *LocalNodeMock

	results *LocalNodeMockGetIndexResults
	Counter uint64
}

// LocalNodeMockGetIndexResults contains results of the LocalNode.GetIndex
type LocalNodeMockGetIndexResults struct {
	i1 member.Index
}

// Expect sets up expected params for LocalNode.GetIndex
func (mmGetIndex *mLocalNodeMockGetIndex) Expect() *mLocalNodeMockGetIndex {
	if mmGetIndex.mock.funcGetIndex != nil {
		mmGetIndex.mock.t.Fatalf("LocalNodeMock.GetIndex mock is already set by Set")
	}

	if mmGetIndex.defaultExpectation == nil {
		mmGetIndex.defaultExpectation = &LocalNodeMockGetIndexExpectation{}
	}

	return mmGetIndex
}

// Inspect accepts an inspector function that has same arguments as the LocalNode.GetIndex
func (mmGetIndex *mLocalNodeMockGetIndex) Inspect(f func()) *mLocalNodeMockGetIndex {
	if mmGetIndex.mock.inspectFuncGetIndex != nil {
		mmGetIndex.mock.t.Fatalf("Inspect function is already set for LocalNodeMock.GetIndex")
	}

	mmGetIndex.mock.inspectFuncGetIndex = f

	return mmGetIndex
}

// Return sets up results that will be returned by LocalNode.GetIndex
func (mmGetIndex *mLocalNodeMockGetIndex) Return(i1 member.Index) *LocalNodeMock {
	if mmGetIndex.mock.funcGetIndex != nil {
		mmGetIndex.mock.t.Fatalf("LocalNodeMock.GetIndex mock is already set by Set")
	}

	if mmGetIndex.defaultExpectation == nil {
		mmGetIndex.defaultExpectation = &LocalNodeMockGetIndexExpectation{mock: mmGetIndex.mock}
	}
	mmGetIndex.defaultExpectation.results = &LocalNodeMockGetIndexResults{i1}
	return mmGetIndex.mock
}

//Set uses given function f to mock the LocalNode.GetIndex method
func (mmGetIndex *mLocalNodeMockGetIndex) Set(f func() (i1 member.Index)) *LocalNodeMock {
	if mmGetIndex.defaultExpectation != nil {
		mmGetIndex.mock.t.Fatalf("Default expectation is already set for the LocalNode.GetIndex method")
	}

	if len(mmGetIndex.expectations) > 0 {
		mmGetIndex.mock.t.Fatalf("Some expectations are already set for the LocalNode.GetIndex method")
	}

	mmGetIndex.mock.funcGetIndex = f
	return mmGetIndex.mock
}

// GetIndex implements LocalNode
func (mmGetIndex *LocalNodeMock) GetIndex() (i1 member.Index) {
	mm_atomic.AddUint64(&mmGetIndex.beforeGetIndexCounter, 1)
	defer mm_atomic.AddUint64(&mmGetIndex.afterGetIndexCounter, 1)

	if mmGetIndex.inspectFuncGetIndex != nil {
		mmGetIndex.inspectFuncGetIndex()
	}

	if mmGetIndex.GetIndexMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetIndex.GetIndexMock.defaultExpectation.Counter, 1)

		results := mmGetIndex.GetIndexMock.defaultExpectation.results
		if results == nil {
			mmGetIndex.t.Fatal("No results are set for the LocalNodeMock.GetIndex")
		}
		return (*results).i1
	}
	if mmGetIndex.funcGetIndex != nil {
		return mmGetIndex.funcGetIndex()
	}
	mmGetIndex.t.Fatalf("Unexpected call to LocalNodeMock.GetIndex.")
	return
}

// GetIndexAfterCounter returns a count of finished LocalNodeMock.GetIndex invocations
func (mmGetIndex *LocalNodeMock) GetIndexAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetIndex.afterGetIndexCounter)
}

// GetIndexBeforeCounter returns a count of LocalNodeMock.GetIndex invocations
func (mmGetIndex *LocalNodeMock) GetIndexBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetIndex.beforeGetIndexCounter)
}

// MinimockGetIndexDone returns true if the count of the GetIndex invocations corresponds
// the number of defined expectations
func (m *LocalNodeMock) MinimockGetIndexDone() bool {
	for _, e := range m.GetIndexMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetIndexMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetIndexCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetIndex != nil && mm_atomic.LoadUint64(&m.afterGetIndexCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetIndexInspect logs each unmet expectation
func (m *LocalNodeMock) MinimockGetIndexInspect() {
	for _, e := range m.GetIndexMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LocalNodeMock.GetIndex")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetIndexMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetIndexCounter) < 1 {
		m.t.Error("Expected call to LocalNodeMock.GetIndex")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetIndex != nil && mm_atomic.LoadUint64(&m.afterGetIndexCounter) < 1 {
		m.t.Error("Expected call to LocalNodeMock.GetIndex")
	}
}

type mLocalNodeMockGetNodeID struct {
	mock               *LocalNodeMock
	defaultExpectation *LocalNodeMockGetNodeIDExpectation
	expectations       []*LocalNodeMockGetNodeIDExpectation
}

// LocalNodeMockGetNodeIDExpectation specifies expectation struct of the LocalNode.GetNodeID
type LocalNodeMockGetNodeIDExpectation struct {
	mock *LocalNodeMock

	results *LocalNodeMockGetNodeIDResults
	Counter uint64
}

// LocalNodeMockGetNodeIDResults contains results of the LocalNode.GetNodeID
type LocalNodeMockGetNodeIDResults struct {
	s1 insolar.ShortNodeID
}

// Expect sets up expected params for LocalNode.GetNodeID
func (mmGetNodeID *mLocalNodeMockGetNodeID) Expect() *mLocalNodeMockGetNodeID {
	if mmGetNodeID.mock.funcGetNodeID != nil {
		mmGetNodeID.mock.t.Fatalf("LocalNodeMock.GetNodeID mock is already set by Set")
	}

	if mmGetNodeID.defaultExpectation == nil {
		mmGetNodeID.defaultExpectation = &LocalNodeMockGetNodeIDExpectation{}
	}

	return mmGetNodeID
}

// Inspect accepts an inspector function that has same arguments as the LocalNode.GetNodeID
func (mmGetNodeID *mLocalNodeMockGetNodeID) Inspect(f func()) *mLocalNodeMockGetNodeID {
	if mmGetNodeID.mock.inspectFuncGetNodeID != nil {
		mmGetNodeID.mock.t.Fatalf("Inspect function is already set for LocalNodeMock.GetNodeID")
	}

	mmGetNodeID.mock.inspectFuncGetNodeID = f

	return mmGetNodeID
}

// Return sets up results that will be returned by LocalNode.GetNodeID
func (mmGetNodeID *mLocalNodeMockGetNodeID) Return(s1 insolar.ShortNodeID) *LocalNodeMock {
	if mmGetNodeID.mock.funcGetNodeID != nil {
		mmGetNodeID.mock.t.Fatalf("LocalNodeMock.GetNodeID mock is already set by Set")
	}

	if mmGetNodeID.defaultExpectation == nil {
		mmGetNodeID.defaultExpectation = &LocalNodeMockGetNodeIDExpectation{mock: mmGetNodeID.mock}
	}
	mmGetNodeID.defaultExpectation.results = &LocalNodeMockGetNodeIDResults{s1}
	return mmGetNodeID.mock
}

//Set uses given function f to mock the LocalNode.GetNodeID method
func (mmGetNodeID *mLocalNodeMockGetNodeID) Set(f func() (s1 insolar.ShortNodeID)) *LocalNodeMock {
	if mmGetNodeID.defaultExpectation != nil {
		mmGetNodeID.mock.t.Fatalf("Default expectation is already set for the LocalNode.GetNodeID method")
	}

	if len(mmGetNodeID.expectations) > 0 {
		mmGetNodeID.mock.t.Fatalf("Some expectations are already set for the LocalNode.GetNodeID method")
	}

	mmGetNodeID.mock.funcGetNodeID = f
	return mmGetNodeID.mock
}

// GetNodeID implements LocalNode
func (mmGetNodeID *LocalNodeMock) GetNodeID() (s1 insolar.ShortNodeID) {
	mm_atomic.AddUint64(&mmGetNodeID.beforeGetNodeIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNodeID.afterGetNodeIDCounter, 1)

	if mmGetNodeID.inspectFuncGetNodeID != nil {
		mmGetNodeID.inspectFuncGetNodeID()
	}

	if mmGetNodeID.GetNodeIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNodeID.GetNodeIDMock.defaultExpectation.Counter, 1)

		results := mmGetNodeID.GetNodeIDMock.defaultExpectation.results
		if results == nil {
			mmGetNodeID.t.Fatal("No results are set for the LocalNodeMock.GetNodeID")
		}
		return (*results).s1
	}
	if mmGetNodeID.funcGetNodeID != nil {
		return mmGetNodeID.funcGetNodeID()
	}
	mmGetNodeID.t.Fatalf("Unexpected call to LocalNodeMock.GetNodeID.")
	return
}

// GetNodeIDAfterCounter returns a count of finished LocalNodeMock.GetNodeID invocations
func (mmGetNodeID *LocalNodeMock) GetNodeIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNodeID.afterGetNodeIDCounter)
}

// GetNodeIDBeforeCounter returns a count of LocalNodeMock.GetNodeID invocations
func (mmGetNodeID *LocalNodeMock) GetNodeIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNodeID.beforeGetNodeIDCounter)
}

// MinimockGetNodeIDDone returns true if the count of the GetNodeID invocations corresponds
// the number of defined expectations
func (m *LocalNodeMock) MinimockGetNodeIDDone() bool {
	for _, e := range m.GetNodeIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetNodeIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetNodeIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNodeID != nil && mm_atomic.LoadUint64(&m.afterGetNodeIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetNodeIDInspect logs each unmet expectation
func (m *LocalNodeMock) MinimockGetNodeIDInspect() {
	for _, e := range m.GetNodeIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LocalNodeMock.GetNodeID")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetNodeIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetNodeIDCounter) < 1 {
		m.t.Error("Expected call to LocalNodeMock.GetNodeID")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNodeID != nil && mm_atomic.LoadUint64(&m.afterGetNodeIDCounter) < 1 {
		m.t.Error("Expected call to LocalNodeMock.GetNodeID")
	}
}

type mLocalNodeMockGetOpMode struct {
	mock               *LocalNodeMock
	defaultExpectation *LocalNodeMockGetOpModeExpectation
	expectations       []*LocalNodeMockGetOpModeExpectation
}

// LocalNodeMockGetOpModeExpectation specifies expectation struct of the LocalNode.GetOpMode
type LocalNodeMockGetOpModeExpectation struct {
	mock *LocalNodeMock

	results *LocalNodeMockGetOpModeResults
	Counter uint64
}

// LocalNodeMockGetOpModeResults contains results of the LocalNode.GetOpMode
type LocalNodeMockGetOpModeResults struct {
	o1 member.OpMode
}

// Expect sets up expected params for LocalNode.GetOpMode
func (mmGetOpMode *mLocalNodeMockGetOpMode) Expect() *mLocalNodeMockGetOpMode {
	if mmGetOpMode.mock.funcGetOpMode != nil {
		mmGetOpMode.mock.t.Fatalf("LocalNodeMock.GetOpMode mock is already set by Set")
	}

	if mmGetOpMode.defaultExpectation == nil {
		mmGetOpMode.defaultExpectation = &LocalNodeMockGetOpModeExpectation{}
	}

	return mmGetOpMode
}

// Inspect accepts an inspector function that has same arguments as the LocalNode.GetOpMode
func (mmGetOpMode *mLocalNodeMockGetOpMode) Inspect(f func()) *mLocalNodeMockGetOpMode {
	if mmGetOpMode.mock.inspectFuncGetOpMode != nil {
		mmGetOpMode.mock.t.Fatalf("Inspect function is already set for LocalNodeMock.GetOpMode")
	}

	mmGetOpMode.mock.inspectFuncGetOpMode = f

	return mmGetOpMode
}

// Return sets up results that will be returned by LocalNode.GetOpMode
func (mmGetOpMode *mLocalNodeMockGetOpMode) Return(o1 member.OpMode) *LocalNodeMock {
	if mmGetOpMode.mock.funcGetOpMode != nil {
		mmGetOpMode.mock.t.Fatalf("LocalNodeMock.GetOpMode mock is already set by Set")
	}

	if mmGetOpMode.defaultExpectation == nil {
		mmGetOpMode.defaultExpectation = &LocalNodeMockGetOpModeExpectation{mock: mmGetOpMode.mock}
	}
	mmGetOpMode.defaultExpectation.results = &LocalNodeMockGetOpModeResults{o1}
	return mmGetOpMode.mock
}

//Set uses given function f to mock the LocalNode.GetOpMode method
func (mmGetOpMode *mLocalNodeMockGetOpMode) Set(f func() (o1 member.OpMode)) *LocalNodeMock {
	if mmGetOpMode.defaultExpectation != nil {
		mmGetOpMode.mock.t.Fatalf("Default expectation is already set for the LocalNode.GetOpMode method")
	}

	if len(mmGetOpMode.expectations) > 0 {
		mmGetOpMode.mock.t.Fatalf("Some expectations are already set for the LocalNode.GetOpMode method")
	}

	mmGetOpMode.mock.funcGetOpMode = f
	return mmGetOpMode.mock
}

// GetOpMode implements LocalNode
func (mmGetOpMode *LocalNodeMock) GetOpMode() (o1 member.OpMode) {
	mm_atomic.AddUint64(&mmGetOpMode.beforeGetOpModeCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOpMode.afterGetOpModeCounter, 1)

	if mmGetOpMode.inspectFuncGetOpMode != nil {
		mmGetOpMode.inspectFuncGetOpMode()
	}

	if mmGetOpMode.GetOpModeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOpMode.GetOpModeMock.defaultExpectation.Counter, 1)

		results := mmGetOpMode.GetOpModeMock.defaultExpectation.results
		if results == nil {
			mmGetOpMode.t.Fatal("No results are set for the LocalNodeMock.GetOpMode")
		}
		return (*results).o1
	}
	if mmGetOpMode.funcGetOpMode != nil {
		return mmGetOpMode.funcGetOpMode()
	}
	mmGetOpMode.t.Fatalf("Unexpected call to LocalNodeMock.GetOpMode.")
	return
}

// GetOpModeAfterCounter returns a count of finished LocalNodeMock.GetOpMode invocations
func (mmGetOpMode *LocalNodeMock) GetOpModeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOpMode.afterGetOpModeCounter)
}

// GetOpModeBeforeCounter returns a count of LocalNodeMock.GetOpMode invocations
func (mmGetOpMode *LocalNodeMock) GetOpModeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOpMode.beforeGetOpModeCounter)
}

// MinimockGetOpModeDone returns true if the count of the GetOpMode invocations corresponds
// the number of defined expectations
func (m *LocalNodeMock) MinimockGetOpModeDone() bool {
	for _, e := range m.GetOpModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOpModeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOpModeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOpMode != nil && mm_atomic.LoadUint64(&m.afterGetOpModeCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetOpModeInspect logs each unmet expectation
func (m *LocalNodeMock) MinimockGetOpModeInspect() {
	for _, e := range m.GetOpModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LocalNodeMock.GetOpMode")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOpModeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOpModeCounter) < 1 {
		m.t.Error("Expected call to LocalNodeMock.GetOpMode")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOpMode != nil && mm_atomic.LoadUint64(&m.afterGetOpModeCounter) < 1 {
		m.t.Error("Expected call to LocalNodeMock.GetOpMode")
	}
}

type mLocalNodeMockGetSignatureVerifier struct {
	mock               *LocalNodeMock
	defaultExpectation *LocalNodeMockGetSignatureVerifierExpectation
	expectations       []*LocalNodeMockGetSignatureVerifierExpectation
}

// LocalNodeMockGetSignatureVerifierExpectation specifies expectation struct of the LocalNode.GetSignatureVerifier
type LocalNodeMockGetSignatureVerifierExpectation struct {
	mock *LocalNodeMock

	results *LocalNodeMockGetSignatureVerifierResults
	Counter uint64
}

// LocalNodeMockGetSignatureVerifierResults contains results of the LocalNode.GetSignatureVerifier
type LocalNodeMockGetSignatureVerifierResults struct {
	s1 cryptkit.SignatureVerifier
}

// Expect sets up expected params for LocalNode.GetSignatureVerifier
func (mmGetSignatureVerifier *mLocalNodeMockGetSignatureVerifier) Expect() *mLocalNodeMockGetSignatureVerifier {
	if mmGetSignatureVerifier.mock.funcGetSignatureVerifier != nil {
		mmGetSignatureVerifier.mock.t.Fatalf("LocalNodeMock.GetSignatureVerifier mock is already set by Set")
	}

	if mmGetSignatureVerifier.defaultExpectation == nil {
		mmGetSignatureVerifier.defaultExpectation = &LocalNodeMockGetSignatureVerifierExpectation{}
	}

	return mmGetSignatureVerifier
}

// Inspect accepts an inspector function that has same arguments as the LocalNode.GetSignatureVerifier
func (mmGetSignatureVerifier *mLocalNodeMockGetSignatureVerifier) Inspect(f func()) *mLocalNodeMockGetSignatureVerifier {
	if mmGetSignatureVerifier.mock.inspectFuncGetSignatureVerifier != nil {
		mmGetSignatureVerifier.mock.t.Fatalf("Inspect function is already set for LocalNodeMock.GetSignatureVerifier")
	}

	mmGetSignatureVerifier.mock.inspectFuncGetSignatureVerifier = f

	return mmGetSignatureVerifier
}

// Return sets up results that will be returned by LocalNode.GetSignatureVerifier
func (mmGetSignatureVerifier *mLocalNodeMockGetSignatureVerifier) Return(s1 cryptkit.SignatureVerifier) *LocalNodeMock {
	if mmGetSignatureVerifier.mock.funcGetSignatureVerifier != nil {
		mmGetSignatureVerifier.mock.t.Fatalf("LocalNodeMock.GetSignatureVerifier mock is already set by Set")
	}

	if mmGetSignatureVerifier.defaultExpectation == nil {
		mmGetSignatureVerifier.defaultExpectation = &LocalNodeMockGetSignatureVerifierExpectation{mock: mmGetSignatureVerifier.mock}
	}
	mmGetSignatureVerifier.defaultExpectation.results = &LocalNodeMockGetSignatureVerifierResults{s1}
	return mmGetSignatureVerifier.mock
}

//Set uses given function f to mock the LocalNode.GetSignatureVerifier method
func (mmGetSignatureVerifier *mLocalNodeMockGetSignatureVerifier) Set(f func() (s1 cryptkit.SignatureVerifier)) *LocalNodeMock {
	if mmGetSignatureVerifier.defaultExpectation != nil {
		mmGetSignatureVerifier.mock.t.Fatalf("Default expectation is already set for the LocalNode.GetSignatureVerifier method")
	}

	if len(mmGetSignatureVerifier.expectations) > 0 {
		mmGetSignatureVerifier.mock.t.Fatalf("Some expectations are already set for the LocalNode.GetSignatureVerifier method")
	}

	mmGetSignatureVerifier.mock.funcGetSignatureVerifier = f
	return mmGetSignatureVerifier.mock
}

// GetSignatureVerifier implements LocalNode
func (mmGetSignatureVerifier *LocalNodeMock) GetSignatureVerifier() (s1 cryptkit.SignatureVerifier) {
	mm_atomic.AddUint64(&mmGetSignatureVerifier.beforeGetSignatureVerifierCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSignatureVerifier.afterGetSignatureVerifierCounter, 1)

	if mmGetSignatureVerifier.inspectFuncGetSignatureVerifier != nil {
		mmGetSignatureVerifier.inspectFuncGetSignatureVerifier()
	}

	if mmGetSignatureVerifier.GetSignatureVerifierMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSignatureVerifier.GetSignatureVerifierMock.defaultExpectation.Counter, 1)

		results := mmGetSignatureVerifier.GetSignatureVerifierMock.defaultExpectation.results
		if results == nil {
			mmGetSignatureVerifier.t.Fatal("No results are set for the LocalNodeMock.GetSignatureVerifier")
		}
		return (*results).s1
	}
	if mmGetSignatureVerifier.funcGetSignatureVerifier != nil {
		return mmGetSignatureVerifier.funcGetSignatureVerifier()
	}
	mmGetSignatureVerifier.t.Fatalf("Unexpected call to LocalNodeMock.GetSignatureVerifier.")
	return
}

// GetSignatureVerifierAfterCounter returns a count of finished LocalNodeMock.GetSignatureVerifier invocations
func (mmGetSignatureVerifier *LocalNodeMock) GetSignatureVerifierAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSignatureVerifier.afterGetSignatureVerifierCounter)
}

// GetSignatureVerifierBeforeCounter returns a count of LocalNodeMock.GetSignatureVerifier invocations
func (mmGetSignatureVerifier *LocalNodeMock) GetSignatureVerifierBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSignatureVerifier.beforeGetSignatureVerifierCounter)
}

// MinimockGetSignatureVerifierDone returns true if the count of the GetSignatureVerifier invocations corresponds
// the number of defined expectations
func (m *LocalNodeMock) MinimockGetSignatureVerifierDone() bool {
	for _, e := range m.GetSignatureVerifierMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSignatureVerifierMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSignatureVerifierCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSignatureVerifier != nil && mm_atomic.LoadUint64(&m.afterGetSignatureVerifierCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSignatureVerifierInspect logs each unmet expectation
func (m *LocalNodeMock) MinimockGetSignatureVerifierInspect() {
	for _, e := range m.GetSignatureVerifierMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LocalNodeMock.GetSignatureVerifier")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSignatureVerifierMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSignatureVerifierCounter) < 1 {
		m.t.Error("Expected call to LocalNodeMock.GetSignatureVerifier")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSignatureVerifier != nil && mm_atomic.LoadUint64(&m.afterGetSignatureVerifierCounter) < 1 {
		m.t.Error("Expected call to LocalNodeMock.GetSignatureVerifier")
	}
}

type mLocalNodeMockGetStatic struct {
	mock               *LocalNodeMock
	defaultExpectation *LocalNodeMockGetStaticExpectation
	expectations       []*LocalNodeMockGetStaticExpectation
}

// LocalNodeMockGetStaticExpectation specifies expectation struct of the LocalNode.GetStatic
type LocalNodeMockGetStaticExpectation struct {
	mock *LocalNodeMock

	results *LocalNodeMockGetStaticResults
	Counter uint64
}

// LocalNodeMockGetStaticResults contains results of the LocalNode.GetStatic
type LocalNodeMockGetStaticResults struct {
	s1 StaticProfile
}

// Expect sets up expected params for LocalNode.GetStatic
func (mmGetStatic *mLocalNodeMockGetStatic) Expect() *mLocalNodeMockGetStatic {
	if mmGetStatic.mock.funcGetStatic != nil {
		mmGetStatic.mock.t.Fatalf("LocalNodeMock.GetStatic mock is already set by Set")
	}

	if mmGetStatic.defaultExpectation == nil {
		mmGetStatic.defaultExpectation = &LocalNodeMockGetStaticExpectation{}
	}

	return mmGetStatic
}

// Inspect accepts an inspector function that has same arguments as the LocalNode.GetStatic
func (mmGetStatic *mLocalNodeMockGetStatic) Inspect(f func()) *mLocalNodeMockGetStatic {
	if mmGetStatic.mock.inspectFuncGetStatic != nil {
		mmGetStatic.mock.t.Fatalf("Inspect function is already set for LocalNodeMock.GetStatic")
	}

	mmGetStatic.mock.inspectFuncGetStatic = f

	return mmGetStatic
}

// Return sets up results that will be returned by LocalNode.GetStatic
func (mmGetStatic *mLocalNodeMockGetStatic) Return(s1 StaticProfile) *LocalNodeMock {
	if mmGetStatic.mock.funcGetStatic != nil {
		mmGetStatic.mock.t.Fatalf("LocalNodeMock.GetStatic mock is already set by Set")
	}

	if mmGetStatic.defaultExpectation == nil {
		mmGetStatic.defaultExpectation = &LocalNodeMockGetStaticExpectation{mock: mmGetStatic.mock}
	}
	mmGetStatic.defaultExpectation.results = &LocalNodeMockGetStaticResults{s1}
	return mmGetStatic.mock
}

//Set uses given function f to mock the LocalNode.GetStatic method
func (mmGetStatic *mLocalNodeMockGetStatic) Set(f func() (s1 StaticProfile)) *LocalNodeMock {
	if mmGetStatic.defaultExpectation != nil {
		mmGetStatic.mock.t.Fatalf("Default expectation is already set for the LocalNode.GetStatic method")
	}

	if len(mmGetStatic.expectations) > 0 {
		mmGetStatic.mock.t.Fatalf("Some expectations are already set for the LocalNode.GetStatic method")
	}

	mmGetStatic.mock.funcGetStatic = f
	return mmGetStatic.mock
}

// GetStatic implements LocalNode
func (mmGetStatic *LocalNodeMock) GetStatic() (s1 StaticProfile) {
	mm_atomic.AddUint64(&mmGetStatic.beforeGetStaticCounter, 1)
	defer mm_atomic.AddUint64(&mmGetStatic.afterGetStaticCounter, 1)

	if mmGetStatic.inspectFuncGetStatic != nil {
		mmGetStatic.inspectFuncGetStatic()
	}

	if mmGetStatic.GetStaticMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetStatic.GetStaticMock.defaultExpectation.Counter, 1)

		results := mmGetStatic.GetStaticMock.defaultExpectation.results
		if results == nil {
			mmGetStatic.t.Fatal("No results are set for the LocalNodeMock.GetStatic")
		}
		return (*results).s1
	}
	if mmGetStatic.funcGetStatic != nil {
		return mmGetStatic.funcGetStatic()
	}
	mmGetStatic.t.Fatalf("Unexpected call to LocalNodeMock.GetStatic.")
	return
}

// GetStaticAfterCounter returns a count of finished LocalNodeMock.GetStatic invocations
func (mmGetStatic *LocalNodeMock) GetStaticAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStatic.afterGetStaticCounter)
}

// GetStaticBeforeCounter returns a count of LocalNodeMock.GetStatic invocations
func (mmGetStatic *LocalNodeMock) GetStaticBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStatic.beforeGetStaticCounter)
}

// MinimockGetStaticDone returns true if the count of the GetStatic invocations corresponds
// the number of defined expectations
func (m *LocalNodeMock) MinimockGetStaticDone() bool {
	for _, e := range m.GetStaticMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetStaticMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetStaticCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetStatic != nil && mm_atomic.LoadUint64(&m.afterGetStaticCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetStaticInspect logs each unmet expectation
func (m *LocalNodeMock) MinimockGetStaticInspect() {
	for _, e := range m.GetStaticMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LocalNodeMock.GetStatic")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetStaticMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetStaticCounter) < 1 {
		m.t.Error("Expected call to LocalNodeMock.GetStatic")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetStatic != nil && mm_atomic.LoadUint64(&m.afterGetStaticCounter) < 1 {
		m.t.Error("Expected call to LocalNodeMock.GetStatic")
	}
}

type mLocalNodeMockHasFullProfile struct {
	mock               *LocalNodeMock
	defaultExpectation *LocalNodeMockHasFullProfileExpectation
	expectations       []*LocalNodeMockHasFullProfileExpectation
}

// LocalNodeMockHasFullProfileExpectation specifies expectation struct of the LocalNode.HasFullProfile
type LocalNodeMockHasFullProfileExpectation struct {
	mock *LocalNodeMock

	results *LocalNodeMockHasFullProfileResults
	Counter uint64
}

// LocalNodeMockHasFullProfileResults contains results of the LocalNode.HasFullProfile
type LocalNodeMockHasFullProfileResults struct {
	b1 bool
}

// Expect sets up expected params for LocalNode.HasFullProfile
func (mmHasFullProfile *mLocalNodeMockHasFullProfile) Expect() *mLocalNodeMockHasFullProfile {
	if mmHasFullProfile.mock.funcHasFullProfile != nil {
		mmHasFullProfile.mock.t.Fatalf("LocalNodeMock.HasFullProfile mock is already set by Set")
	}

	if mmHasFullProfile.defaultExpectation == nil {
		mmHasFullProfile.defaultExpectation = &LocalNodeMockHasFullProfileExpectation{}
	}

	return mmHasFullProfile
}

// Inspect accepts an inspector function that has same arguments as the LocalNode.HasFullProfile
func (mmHasFullProfile *mLocalNodeMockHasFullProfile) Inspect(f func()) *mLocalNodeMockHasFullProfile {
	if mmHasFullProfile.mock.inspectFuncHasFullProfile != nil {
		mmHasFullProfile.mock.t.Fatalf("Inspect function is already set for LocalNodeMock.HasFullProfile")
	}

	mmHasFullProfile.mock.inspectFuncHasFullProfile = f

	return mmHasFullProfile
}

// Return sets up results that will be returned by LocalNode.HasFullProfile
func (mmHasFullProfile *mLocalNodeMockHasFullProfile) Return(b1 bool) *LocalNodeMock {
	if mmHasFullProfile.mock.funcHasFullProfile != nil {
		mmHasFullProfile.mock.t.Fatalf("LocalNodeMock.HasFullProfile mock is already set by Set")
	}

	if mmHasFullProfile.defaultExpectation == nil {
		mmHasFullProfile.defaultExpectation = &LocalNodeMockHasFullProfileExpectation{mock: mmHasFullProfile.mock}
	}
	mmHasFullProfile.defaultExpectation.results = &LocalNodeMockHasFullProfileResults{b1}
	return mmHasFullProfile.mock
}

//Set uses given function f to mock the LocalNode.HasFullProfile method
func (mmHasFullProfile *mLocalNodeMockHasFullProfile) Set(f func() (b1 bool)) *LocalNodeMock {
	if mmHasFullProfile.defaultExpectation != nil {
		mmHasFullProfile.mock.t.Fatalf("Default expectation is already set for the LocalNode.HasFullProfile method")
	}

	if len(mmHasFullProfile.expectations) > 0 {
		mmHasFullProfile.mock.t.Fatalf("Some expectations are already set for the LocalNode.HasFullProfile method")
	}

	mmHasFullProfile.mock.funcHasFullProfile = f
	return mmHasFullProfile.mock
}

// HasFullProfile implements LocalNode
func (mmHasFullProfile *LocalNodeMock) HasFullProfile() (b1 bool) {
	mm_atomic.AddUint64(&mmHasFullProfile.beforeHasFullProfileCounter, 1)
	defer mm_atomic.AddUint64(&mmHasFullProfile.afterHasFullProfileCounter, 1)

	if mmHasFullProfile.inspectFuncHasFullProfile != nil {
		mmHasFullProfile.inspectFuncHasFullProfile()
	}

	if mmHasFullProfile.HasFullProfileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHasFullProfile.HasFullProfileMock.defaultExpectation.Counter, 1)

		results := mmHasFullProfile.HasFullProfileMock.defaultExpectation.results
		if results == nil {
			mmHasFullProfile.t.Fatal("No results are set for the LocalNodeMock.HasFullProfile")
		}
		return (*results).b1
	}
	if mmHasFullProfile.funcHasFullProfile != nil {
		return mmHasFullProfile.funcHasFullProfile()
	}
	mmHasFullProfile.t.Fatalf("Unexpected call to LocalNodeMock.HasFullProfile.")
	return
}

// HasFullProfileAfterCounter returns a count of finished LocalNodeMock.HasFullProfile invocations
func (mmHasFullProfile *LocalNodeMock) HasFullProfileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHasFullProfile.afterHasFullProfileCounter)
}

// HasFullProfileBeforeCounter returns a count of LocalNodeMock.HasFullProfile invocations
func (mmHasFullProfile *LocalNodeMock) HasFullProfileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHasFullProfile.beforeHasFullProfileCounter)
}

// MinimockHasFullProfileDone returns true if the count of the HasFullProfile invocations corresponds
// the number of defined expectations
func (m *LocalNodeMock) MinimockHasFullProfileDone() bool {
	for _, e := range m.HasFullProfileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HasFullProfileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHasFullProfileCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHasFullProfile != nil && mm_atomic.LoadUint64(&m.afterHasFullProfileCounter) < 1 {
		return false
	}
	return true
}

// MinimockHasFullProfileInspect logs each unmet expectation
func (m *LocalNodeMock) MinimockHasFullProfileInspect() {
	for _, e := range m.HasFullProfileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LocalNodeMock.HasFullProfile")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HasFullProfileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHasFullProfileCounter) < 1 {
		m.t.Error("Expected call to LocalNodeMock.HasFullProfile")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHasFullProfile != nil && mm_atomic.LoadUint64(&m.afterHasFullProfileCounter) < 1 {
		m.t.Error("Expected call to LocalNodeMock.HasFullProfile")
	}
}

type mLocalNodeMockIsJoiner struct {
	mock               *LocalNodeMock
	defaultExpectation *LocalNodeMockIsJoinerExpectation
	expectations       []*LocalNodeMockIsJoinerExpectation
}

// LocalNodeMockIsJoinerExpectation specifies expectation struct of the LocalNode.IsJoiner
type LocalNodeMockIsJoinerExpectation struct {
	mock *LocalNodeMock

	results *LocalNodeMockIsJoinerResults
	Counter uint64
}

// LocalNodeMockIsJoinerResults contains results of the LocalNode.IsJoiner
type LocalNodeMockIsJoinerResults struct {
	b1 bool
}

// Expect sets up expected params for LocalNode.IsJoiner
func (mmIsJoiner *mLocalNodeMockIsJoiner) Expect() *mLocalNodeMockIsJoiner {
	if mmIsJoiner.mock.funcIsJoiner != nil {
		mmIsJoiner.mock.t.Fatalf("LocalNodeMock.IsJoiner mock is already set by Set")
	}

	if mmIsJoiner.defaultExpectation == nil {
		mmIsJoiner.defaultExpectation = &LocalNodeMockIsJoinerExpectation{}
	}

	return mmIsJoiner
}

// Inspect accepts an inspector function that has same arguments as the LocalNode.IsJoiner
func (mmIsJoiner *mLocalNodeMockIsJoiner) Inspect(f func()) *mLocalNodeMockIsJoiner {
	if mmIsJoiner.mock.inspectFuncIsJoiner != nil {
		mmIsJoiner.mock.t.Fatalf("Inspect function is already set for LocalNodeMock.IsJoiner")
	}

	mmIsJoiner.mock.inspectFuncIsJoiner = f

	return mmIsJoiner
}

// Return sets up results that will be returned by LocalNode.IsJoiner
func (mmIsJoiner *mLocalNodeMockIsJoiner) Return(b1 bool) *LocalNodeMock {
	if mmIsJoiner.mock.funcIsJoiner != nil {
		mmIsJoiner.mock.t.Fatalf("LocalNodeMock.IsJoiner mock is already set by Set")
	}

	if mmIsJoiner.defaultExpectation == nil {
		mmIsJoiner.defaultExpectation = &LocalNodeMockIsJoinerExpectation{mock: mmIsJoiner.mock}
	}
	mmIsJoiner.defaultExpectation.results = &LocalNodeMockIsJoinerResults{b1}
	return mmIsJoiner.mock
}

//Set uses given function f to mock the LocalNode.IsJoiner method
func (mmIsJoiner *mLocalNodeMockIsJoiner) Set(f func() (b1 bool)) *LocalNodeMock {
	if mmIsJoiner.defaultExpectation != nil {
		mmIsJoiner.mock.t.Fatalf("Default expectation is already set for the LocalNode.IsJoiner method")
	}

	if len(mmIsJoiner.expectations) > 0 {
		mmIsJoiner.mock.t.Fatalf("Some expectations are already set for the LocalNode.IsJoiner method")
	}

	mmIsJoiner.mock.funcIsJoiner = f
	return mmIsJoiner.mock
}

// IsJoiner implements LocalNode
func (mmIsJoiner *LocalNodeMock) IsJoiner() (b1 bool) {
	mm_atomic.AddUint64(&mmIsJoiner.beforeIsJoinerCounter, 1)
	defer mm_atomic.AddUint64(&mmIsJoiner.afterIsJoinerCounter, 1)

	if mmIsJoiner.inspectFuncIsJoiner != nil {
		mmIsJoiner.inspectFuncIsJoiner()
	}

	if mmIsJoiner.IsJoinerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsJoiner.IsJoinerMock.defaultExpectation.Counter, 1)

		results := mmIsJoiner.IsJoinerMock.defaultExpectation.results
		if results == nil {
			mmIsJoiner.t.Fatal("No results are set for the LocalNodeMock.IsJoiner")
		}
		return (*results).b1
	}
	if mmIsJoiner.funcIsJoiner != nil {
		return mmIsJoiner.funcIsJoiner()
	}
	mmIsJoiner.t.Fatalf("Unexpected call to LocalNodeMock.IsJoiner.")
	return
}

// IsJoinerAfterCounter returns a count of finished LocalNodeMock.IsJoiner invocations
func (mmIsJoiner *LocalNodeMock) IsJoinerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsJoiner.afterIsJoinerCounter)
}

// IsJoinerBeforeCounter returns a count of LocalNodeMock.IsJoiner invocations
func (mmIsJoiner *LocalNodeMock) IsJoinerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsJoiner.beforeIsJoinerCounter)
}

// MinimockIsJoinerDone returns true if the count of the IsJoiner invocations corresponds
// the number of defined expectations
func (m *LocalNodeMock) MinimockIsJoinerDone() bool {
	for _, e := range m.IsJoinerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsJoinerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsJoinerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsJoiner != nil && mm_atomic.LoadUint64(&m.afterIsJoinerCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsJoinerInspect logs each unmet expectation
func (m *LocalNodeMock) MinimockIsJoinerInspect() {
	for _, e := range m.IsJoinerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LocalNodeMock.IsJoiner")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsJoinerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsJoinerCounter) < 1 {
		m.t.Error("Expected call to LocalNodeMock.IsJoiner")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsJoiner != nil && mm_atomic.LoadUint64(&m.afterIsJoinerCounter) < 1 {
		m.t.Error("Expected call to LocalNodeMock.IsJoiner")
	}
}

type mLocalNodeMockIsPowered struct {
	mock               *LocalNodeMock
	defaultExpectation *LocalNodeMockIsPoweredExpectation
	expectations       []*LocalNodeMockIsPoweredExpectation
}

// LocalNodeMockIsPoweredExpectation specifies expectation struct of the LocalNode.IsPowered
type LocalNodeMockIsPoweredExpectation struct {
	mock *LocalNodeMock

	results *LocalNodeMockIsPoweredResults
	Counter uint64
}

// LocalNodeMockIsPoweredResults contains results of the LocalNode.IsPowered
type LocalNodeMockIsPoweredResults struct {
	b1 bool
}

// Expect sets up expected params for LocalNode.IsPowered
func (mmIsPowered *mLocalNodeMockIsPowered) Expect() *mLocalNodeMockIsPowered {
	if mmIsPowered.mock.funcIsPowered != nil {
		mmIsPowered.mock.t.Fatalf("LocalNodeMock.IsPowered mock is already set by Set")
	}

	if mmIsPowered.defaultExpectation == nil {
		mmIsPowered.defaultExpectation = &LocalNodeMockIsPoweredExpectation{}
	}

	return mmIsPowered
}

// Inspect accepts an inspector function that has same arguments as the LocalNode.IsPowered
func (mmIsPowered *mLocalNodeMockIsPowered) Inspect(f func()) *mLocalNodeMockIsPowered {
	if mmIsPowered.mock.inspectFuncIsPowered != nil {
		mmIsPowered.mock.t.Fatalf("Inspect function is already set for LocalNodeMock.IsPowered")
	}

	mmIsPowered.mock.inspectFuncIsPowered = f

	return mmIsPowered
}

// Return sets up results that will be returned by LocalNode.IsPowered
func (mmIsPowered *mLocalNodeMockIsPowered) Return(b1 bool) *LocalNodeMock {
	if mmIsPowered.mock.funcIsPowered != nil {
		mmIsPowered.mock.t.Fatalf("LocalNodeMock.IsPowered mock is already set by Set")
	}

	if mmIsPowered.defaultExpectation == nil {
		mmIsPowered.defaultExpectation = &LocalNodeMockIsPoweredExpectation{mock: mmIsPowered.mock}
	}
	mmIsPowered.defaultExpectation.results = &LocalNodeMockIsPoweredResults{b1}
	return mmIsPowered.mock
}

//Set uses given function f to mock the LocalNode.IsPowered method
func (mmIsPowered *mLocalNodeMockIsPowered) Set(f func() (b1 bool)) *LocalNodeMock {
	if mmIsPowered.defaultExpectation != nil {
		mmIsPowered.mock.t.Fatalf("Default expectation is already set for the LocalNode.IsPowered method")
	}

	if len(mmIsPowered.expectations) > 0 {
		mmIsPowered.mock.t.Fatalf("Some expectations are already set for the LocalNode.IsPowered method")
	}

	mmIsPowered.mock.funcIsPowered = f
	return mmIsPowered.mock
}

// IsPowered implements LocalNode
func (mmIsPowered *LocalNodeMock) IsPowered() (b1 bool) {
	mm_atomic.AddUint64(&mmIsPowered.beforeIsPoweredCounter, 1)
	defer mm_atomic.AddUint64(&mmIsPowered.afterIsPoweredCounter, 1)

	if mmIsPowered.inspectFuncIsPowered != nil {
		mmIsPowered.inspectFuncIsPowered()
	}

	if mmIsPowered.IsPoweredMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsPowered.IsPoweredMock.defaultExpectation.Counter, 1)

		results := mmIsPowered.IsPoweredMock.defaultExpectation.results
		if results == nil {
			mmIsPowered.t.Fatal("No results are set for the LocalNodeMock.IsPowered")
		}
		return (*results).b1
	}
	if mmIsPowered.funcIsPowered != nil {
		return mmIsPowered.funcIsPowered()
	}
	mmIsPowered.t.Fatalf("Unexpected call to LocalNodeMock.IsPowered.")
	return
}

// IsPoweredAfterCounter returns a count of finished LocalNodeMock.IsPowered invocations
func (mmIsPowered *LocalNodeMock) IsPoweredAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsPowered.afterIsPoweredCounter)
}

// IsPoweredBeforeCounter returns a count of LocalNodeMock.IsPowered invocations
func (mmIsPowered *LocalNodeMock) IsPoweredBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsPowered.beforeIsPoweredCounter)
}

// MinimockIsPoweredDone returns true if the count of the IsPowered invocations corresponds
// the number of defined expectations
func (m *LocalNodeMock) MinimockIsPoweredDone() bool {
	for _, e := range m.IsPoweredMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsPoweredMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsPoweredCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsPowered != nil && mm_atomic.LoadUint64(&m.afterIsPoweredCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsPoweredInspect logs each unmet expectation
func (m *LocalNodeMock) MinimockIsPoweredInspect() {
	for _, e := range m.IsPoweredMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LocalNodeMock.IsPowered")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsPoweredMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsPoweredCounter) < 1 {
		m.t.Error("Expected call to LocalNodeMock.IsPowered")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsPowered != nil && mm_atomic.LoadUint64(&m.afterIsPoweredCounter) < 1 {
		m.t.Error("Expected call to LocalNodeMock.IsPowered")
	}
}

type mLocalNodeMockIsStateful struct {
	mock               *LocalNodeMock
	defaultExpectation *LocalNodeMockIsStatefulExpectation
	expectations       []*LocalNodeMockIsStatefulExpectation
}

// LocalNodeMockIsStatefulExpectation specifies expectation struct of the LocalNode.IsStateful
type LocalNodeMockIsStatefulExpectation struct {
	mock *LocalNodeMock

	results *LocalNodeMockIsStatefulResults
	Counter uint64
}

// LocalNodeMockIsStatefulResults contains results of the LocalNode.IsStateful
type LocalNodeMockIsStatefulResults struct {
	b1 bool
}

// Expect sets up expected params for LocalNode.IsStateful
func (mmIsStateful *mLocalNodeMockIsStateful) Expect() *mLocalNodeMockIsStateful {
	if mmIsStateful.mock.funcIsStateful != nil {
		mmIsStateful.mock.t.Fatalf("LocalNodeMock.IsStateful mock is already set by Set")
	}

	if mmIsStateful.defaultExpectation == nil {
		mmIsStateful.defaultExpectation = &LocalNodeMockIsStatefulExpectation{}
	}

	return mmIsStateful
}

// Inspect accepts an inspector function that has same arguments as the LocalNode.IsStateful
func (mmIsStateful *mLocalNodeMockIsStateful) Inspect(f func()) *mLocalNodeMockIsStateful {
	if mmIsStateful.mock.inspectFuncIsStateful != nil {
		mmIsStateful.mock.t.Fatalf("Inspect function is already set for LocalNodeMock.IsStateful")
	}

	mmIsStateful.mock.inspectFuncIsStateful = f

	return mmIsStateful
}

// Return sets up results that will be returned by LocalNode.IsStateful
func (mmIsStateful *mLocalNodeMockIsStateful) Return(b1 bool) *LocalNodeMock {
	if mmIsStateful.mock.funcIsStateful != nil {
		mmIsStateful.mock.t.Fatalf("LocalNodeMock.IsStateful mock is already set by Set")
	}

	if mmIsStateful.defaultExpectation == nil {
		mmIsStateful.defaultExpectation = &LocalNodeMockIsStatefulExpectation{mock: mmIsStateful.mock}
	}
	mmIsStateful.defaultExpectation.results = &LocalNodeMockIsStatefulResults{b1}
	return mmIsStateful.mock
}

//Set uses given function f to mock the LocalNode.IsStateful method
func (mmIsStateful *mLocalNodeMockIsStateful) Set(f func() (b1 bool)) *LocalNodeMock {
	if mmIsStateful.defaultExpectation != nil {
		mmIsStateful.mock.t.Fatalf("Default expectation is already set for the LocalNode.IsStateful method")
	}

	if len(mmIsStateful.expectations) > 0 {
		mmIsStateful.mock.t.Fatalf("Some expectations are already set for the LocalNode.IsStateful method")
	}

	mmIsStateful.mock.funcIsStateful = f
	return mmIsStateful.mock
}

// IsStateful implements LocalNode
func (mmIsStateful *LocalNodeMock) IsStateful() (b1 bool) {
	mm_atomic.AddUint64(&mmIsStateful.beforeIsStatefulCounter, 1)
	defer mm_atomic.AddUint64(&mmIsStateful.afterIsStatefulCounter, 1)

	if mmIsStateful.inspectFuncIsStateful != nil {
		mmIsStateful.inspectFuncIsStateful()
	}

	if mmIsStateful.IsStatefulMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsStateful.IsStatefulMock.defaultExpectation.Counter, 1)

		results := mmIsStateful.IsStatefulMock.defaultExpectation.results
		if results == nil {
			mmIsStateful.t.Fatal("No results are set for the LocalNodeMock.IsStateful")
		}
		return (*results).b1
	}
	if mmIsStateful.funcIsStateful != nil {
		return mmIsStateful.funcIsStateful()
	}
	mmIsStateful.t.Fatalf("Unexpected call to LocalNodeMock.IsStateful.")
	return
}

// IsStatefulAfterCounter returns a count of finished LocalNodeMock.IsStateful invocations
func (mmIsStateful *LocalNodeMock) IsStatefulAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsStateful.afterIsStatefulCounter)
}

// IsStatefulBeforeCounter returns a count of LocalNodeMock.IsStateful invocations
func (mmIsStateful *LocalNodeMock) IsStatefulBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsStateful.beforeIsStatefulCounter)
}

// MinimockIsStatefulDone returns true if the count of the IsStateful invocations corresponds
// the number of defined expectations
func (m *LocalNodeMock) MinimockIsStatefulDone() bool {
	for _, e := range m.IsStatefulMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsStatefulMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsStatefulCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsStateful != nil && mm_atomic.LoadUint64(&m.afterIsStatefulCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsStatefulInspect logs each unmet expectation
func (m *LocalNodeMock) MinimockIsStatefulInspect() {
	for _, e := range m.IsStatefulMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LocalNodeMock.IsStateful")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsStatefulMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsStatefulCounter) < 1 {
		m.t.Error("Expected call to LocalNodeMock.IsStateful")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsStateful != nil && mm_atomic.LoadUint64(&m.afterIsStatefulCounter) < 1 {
		m.t.Error("Expected call to LocalNodeMock.IsStateful")
	}
}

type mLocalNodeMockIsVoter struct {
	mock               *LocalNodeMock
	defaultExpectation *LocalNodeMockIsVoterExpectation
	expectations       []*LocalNodeMockIsVoterExpectation
}

// LocalNodeMockIsVoterExpectation specifies expectation struct of the LocalNode.IsVoter
type LocalNodeMockIsVoterExpectation struct {
	mock *LocalNodeMock

	results *LocalNodeMockIsVoterResults
	Counter uint64
}

// LocalNodeMockIsVoterResults contains results of the LocalNode.IsVoter
type LocalNodeMockIsVoterResults struct {
	b1 bool
}

// Expect sets up expected params for LocalNode.IsVoter
func (mmIsVoter *mLocalNodeMockIsVoter) Expect() *mLocalNodeMockIsVoter {
	if mmIsVoter.mock.funcIsVoter != nil {
		mmIsVoter.mock.t.Fatalf("LocalNodeMock.IsVoter mock is already set by Set")
	}

	if mmIsVoter.defaultExpectation == nil {
		mmIsVoter.defaultExpectation = &LocalNodeMockIsVoterExpectation{}
	}

	return mmIsVoter
}

// Inspect accepts an inspector function that has same arguments as the LocalNode.IsVoter
func (mmIsVoter *mLocalNodeMockIsVoter) Inspect(f func()) *mLocalNodeMockIsVoter {
	if mmIsVoter.mock.inspectFuncIsVoter != nil {
		mmIsVoter.mock.t.Fatalf("Inspect function is already set for LocalNodeMock.IsVoter")
	}

	mmIsVoter.mock.inspectFuncIsVoter = f

	return mmIsVoter
}

// Return sets up results that will be returned by LocalNode.IsVoter
func (mmIsVoter *mLocalNodeMockIsVoter) Return(b1 bool) *LocalNodeMock {
	if mmIsVoter.mock.funcIsVoter != nil {
		mmIsVoter.mock.t.Fatalf("LocalNodeMock.IsVoter mock is already set by Set")
	}

	if mmIsVoter.defaultExpectation == nil {
		mmIsVoter.defaultExpectation = &LocalNodeMockIsVoterExpectation{mock: mmIsVoter.mock}
	}
	mmIsVoter.defaultExpectation.results = &LocalNodeMockIsVoterResults{b1}
	return mmIsVoter.mock
}

//Set uses given function f to mock the LocalNode.IsVoter method
func (mmIsVoter *mLocalNodeMockIsVoter) Set(f func() (b1 bool)) *LocalNodeMock {
	if mmIsVoter.defaultExpectation != nil {
		mmIsVoter.mock.t.Fatalf("Default expectation is already set for the LocalNode.IsVoter method")
	}

	if len(mmIsVoter.expectations) > 0 {
		mmIsVoter.mock.t.Fatalf("Some expectations are already set for the LocalNode.IsVoter method")
	}

	mmIsVoter.mock.funcIsVoter = f
	return mmIsVoter.mock
}

// IsVoter implements LocalNode
func (mmIsVoter *LocalNodeMock) IsVoter() (b1 bool) {
	mm_atomic.AddUint64(&mmIsVoter.beforeIsVoterCounter, 1)
	defer mm_atomic.AddUint64(&mmIsVoter.afterIsVoterCounter, 1)

	if mmIsVoter.inspectFuncIsVoter != nil {
		mmIsVoter.inspectFuncIsVoter()
	}

	if mmIsVoter.IsVoterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsVoter.IsVoterMock.defaultExpectation.Counter, 1)

		results := mmIsVoter.IsVoterMock.defaultExpectation.results
		if results == nil {
			mmIsVoter.t.Fatal("No results are set for the LocalNodeMock.IsVoter")
		}
		return (*results).b1
	}
	if mmIsVoter.funcIsVoter != nil {
		return mmIsVoter.funcIsVoter()
	}
	mmIsVoter.t.Fatalf("Unexpected call to LocalNodeMock.IsVoter.")
	return
}

// IsVoterAfterCounter returns a count of finished LocalNodeMock.IsVoter invocations
func (mmIsVoter *LocalNodeMock) IsVoterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsVoter.afterIsVoterCounter)
}

// IsVoterBeforeCounter returns a count of LocalNodeMock.IsVoter invocations
func (mmIsVoter *LocalNodeMock) IsVoterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsVoter.beforeIsVoterCounter)
}

// MinimockIsVoterDone returns true if the count of the IsVoter invocations corresponds
// the number of defined expectations
func (m *LocalNodeMock) MinimockIsVoterDone() bool {
	for _, e := range m.IsVoterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsVoterMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsVoterCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsVoter != nil && mm_atomic.LoadUint64(&m.afterIsVoterCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsVoterInspect logs each unmet expectation
func (m *LocalNodeMock) MinimockIsVoterInspect() {
	for _, e := range m.IsVoterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LocalNodeMock.IsVoter")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsVoterMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsVoterCounter) < 1 {
		m.t.Error("Expected call to LocalNodeMock.IsVoter")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsVoter != nil && mm_atomic.LoadUint64(&m.afterIsVoterCounter) < 1 {
		m.t.Error("Expected call to LocalNodeMock.IsVoter")
	}
}

type mLocalNodeMockLocalNodeProfile struct {
	mock               *LocalNodeMock
	defaultExpectation *LocalNodeMockLocalNodeProfileExpectation
	expectations       []*LocalNodeMockLocalNodeProfileExpectation
}

// LocalNodeMockLocalNodeProfileExpectation specifies expectation struct of the LocalNode.LocalNodeProfile
type LocalNodeMockLocalNodeProfileExpectation struct {
	mock *LocalNodeMock

	Counter uint64
}

// Expect sets up expected params for LocalNode.LocalNodeProfile
func (mmLocalNodeProfile *mLocalNodeMockLocalNodeProfile) Expect() *mLocalNodeMockLocalNodeProfile {
	if mmLocalNodeProfile.mock.funcLocalNodeProfile != nil {
		mmLocalNodeProfile.mock.t.Fatalf("LocalNodeMock.LocalNodeProfile mock is already set by Set")
	}

	if mmLocalNodeProfile.defaultExpectation == nil {
		mmLocalNodeProfile.defaultExpectation = &LocalNodeMockLocalNodeProfileExpectation{}
	}

	return mmLocalNodeProfile
}

// Inspect accepts an inspector function that has same arguments as the LocalNode.LocalNodeProfile
func (mmLocalNodeProfile *mLocalNodeMockLocalNodeProfile) Inspect(f func()) *mLocalNodeMockLocalNodeProfile {
	if mmLocalNodeProfile.mock.inspectFuncLocalNodeProfile != nil {
		mmLocalNodeProfile.mock.t.Fatalf("Inspect function is already set for LocalNodeMock.LocalNodeProfile")
	}

	mmLocalNodeProfile.mock.inspectFuncLocalNodeProfile = f

	return mmLocalNodeProfile
}

// Return sets up results that will be returned by LocalNode.LocalNodeProfile
func (mmLocalNodeProfile *mLocalNodeMockLocalNodeProfile) Return() *LocalNodeMock {
	if mmLocalNodeProfile.mock.funcLocalNodeProfile != nil {
		mmLocalNodeProfile.mock.t.Fatalf("LocalNodeMock.LocalNodeProfile mock is already set by Set")
	}

	if mmLocalNodeProfile.defaultExpectation == nil {
		mmLocalNodeProfile.defaultExpectation = &LocalNodeMockLocalNodeProfileExpectation{mock: mmLocalNodeProfile.mock}
	}

	return mmLocalNodeProfile.mock
}

//Set uses given function f to mock the LocalNode.LocalNodeProfile method
func (mmLocalNodeProfile *mLocalNodeMockLocalNodeProfile) Set(f func()) *LocalNodeMock {
	if mmLocalNodeProfile.defaultExpectation != nil {
		mmLocalNodeProfile.mock.t.Fatalf("Default expectation is already set for the LocalNode.LocalNodeProfile method")
	}

	if len(mmLocalNodeProfile.expectations) > 0 {
		mmLocalNodeProfile.mock.t.Fatalf("Some expectations are already set for the LocalNode.LocalNodeProfile method")
	}

	mmLocalNodeProfile.mock.funcLocalNodeProfile = f
	return mmLocalNodeProfile.mock
}

// LocalNodeProfile implements LocalNode
func (mmLocalNodeProfile *LocalNodeMock) LocalNodeProfile() {
	mm_atomic.AddUint64(&mmLocalNodeProfile.beforeLocalNodeProfileCounter, 1)
	defer mm_atomic.AddUint64(&mmLocalNodeProfile.afterLocalNodeProfileCounter, 1)

	if mmLocalNodeProfile.inspectFuncLocalNodeProfile != nil {
		mmLocalNodeProfile.inspectFuncLocalNodeProfile()
	}

	if mmLocalNodeProfile.LocalNodeProfileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLocalNodeProfile.LocalNodeProfileMock.defaultExpectation.Counter, 1)

		return

	}
	if mmLocalNodeProfile.funcLocalNodeProfile != nil {
		mmLocalNodeProfile.funcLocalNodeProfile()
		return
	}
	mmLocalNodeProfile.t.Fatalf("Unexpected call to LocalNodeMock.LocalNodeProfile.")

}

// LocalNodeProfileAfterCounter returns a count of finished LocalNodeMock.LocalNodeProfile invocations
func (mmLocalNodeProfile *LocalNodeMock) LocalNodeProfileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLocalNodeProfile.afterLocalNodeProfileCounter)
}

// LocalNodeProfileBeforeCounter returns a count of LocalNodeMock.LocalNodeProfile invocations
func (mmLocalNodeProfile *LocalNodeMock) LocalNodeProfileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLocalNodeProfile.beforeLocalNodeProfileCounter)
}

// MinimockLocalNodeProfileDone returns true if the count of the LocalNodeProfile invocations corresponds
// the number of defined expectations
func (m *LocalNodeMock) MinimockLocalNodeProfileDone() bool {
	for _, e := range m.LocalNodeProfileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LocalNodeProfileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLocalNodeProfileCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLocalNodeProfile != nil && mm_atomic.LoadUint64(&m.afterLocalNodeProfileCounter) < 1 {
		return false
	}
	return true
}

// MinimockLocalNodeProfileInspect logs each unmet expectation
func (m *LocalNodeMock) MinimockLocalNodeProfileInspect() {
	for _, e := range m.LocalNodeProfileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to LocalNodeMock.LocalNodeProfile")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LocalNodeProfileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLocalNodeProfileCounter) < 1 {
		m.t.Error("Expected call to LocalNodeMock.LocalNodeProfile")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLocalNodeProfile != nil && mm_atomic.LoadUint64(&m.afterLocalNodeProfileCounter) < 1 {
		m.t.Error("Expected call to LocalNodeMock.LocalNodeProfile")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LocalNodeMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCanIntroduceJoinerInspect()

		m.MinimockGetDeclaredPowerInspect()

		m.MinimockGetIndexInspect()

		m.MinimockGetNodeIDInspect()

		m.MinimockGetOpModeInspect()

		m.MinimockGetSignatureVerifierInspect()

		m.MinimockGetStaticInspect()

		m.MinimockHasFullProfileInspect()

		m.MinimockIsJoinerInspect()

		m.MinimockIsPoweredInspect()

		m.MinimockIsStatefulInspect()

		m.MinimockIsVoterInspect()

		m.MinimockLocalNodeProfileInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LocalNodeMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LocalNodeMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCanIntroduceJoinerDone() &&
		m.MinimockGetDeclaredPowerDone() &&
		m.MinimockGetIndexDone() &&
		m.MinimockGetNodeIDDone() &&
		m.MinimockGetOpModeDone() &&
		m.MinimockGetSignatureVerifierDone() &&
		m.MinimockGetStaticDone() &&
		m.MinimockHasFullProfileDone() &&
		m.MinimockIsJoinerDone() &&
		m.MinimockIsPoweredDone() &&
		m.MinimockIsStatefulDone() &&
		m.MinimockIsVoterDone() &&
		m.MinimockLocalNodeProfileDone()
}
