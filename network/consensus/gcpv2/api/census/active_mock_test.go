package census

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/network/consensus/common/cryptkit"
	"github.com/insolar/insolar/network/consensus/gcpv2/api/profiles"
	"github.com/insolar/insolar/network/consensus/gcpv2/api/proofs"
	"github.com/insolar/insolar/pulse"
)

// ActiveMock implements Active
type ActiveMock struct {
	t minimock.Tester

	funcCreateBuilder          func(ctx context.Context, pn pulse.Number) (b1 Builder)
	inspectFuncCreateBuilder   func(ctx context.Context, pn pulse.Number)
	afterCreateBuilderCounter  uint64
	beforeCreateBuilderCounter uint64
	CreateBuilderMock          mActiveMockCreateBuilder

	funcGetCensusState          func() (s1 State)
	inspectFuncGetCensusState   func()
	afterGetCensusStateCounter  uint64
	beforeGetCensusStateCounter uint64
	GetCensusStateMock          mActiveMockGetCensusState

	funcGetCloudStateHash          func() (c1 proofs.CloudStateHash)
	inspectFuncGetCloudStateHash   func()
	afterGetCloudStateHashCounter  uint64
	beforeGetCloudStateHashCounter uint64
	GetCloudStateHashMock          mActiveMockGetCloudStateHash

	funcGetEvictedPopulation          func() (e1 EvictedPopulation)
	inspectFuncGetEvictedPopulation   func()
	afterGetEvictedPopulationCounter  uint64
	beforeGetEvictedPopulationCounter uint64
	GetEvictedPopulationMock          mActiveMockGetEvictedPopulation

	funcGetExpectedPulseNumber          func() (n1 pulse.Number)
	inspectFuncGetExpectedPulseNumber   func()
	afterGetExpectedPulseNumberCounter  uint64
	beforeGetExpectedPulseNumberCounter uint64
	GetExpectedPulseNumberMock          mActiveMockGetExpectedPulseNumber

	funcGetGlobulaStateHash          func() (g1 proofs.GlobulaStateHash)
	inspectFuncGetGlobulaStateHash   func()
	afterGetGlobulaStateHashCounter  uint64
	beforeGetGlobulaStateHashCounter uint64
	GetGlobulaStateHashMock          mActiveMockGetGlobulaStateHash

	funcGetMandateRegistry          func() (m1 MandateRegistry)
	inspectFuncGetMandateRegistry   func()
	afterGetMandateRegistryCounter  uint64
	beforeGetMandateRegistryCounter uint64
	GetMandateRegistryMock          mActiveMockGetMandateRegistry

	funcGetMisbehaviorRegistry          func() (m1 MisbehaviorRegistry)
	inspectFuncGetMisbehaviorRegistry   func()
	afterGetMisbehaviorRegistryCounter  uint64
	beforeGetMisbehaviorRegistryCounter uint64
	GetMisbehaviorRegistryMock          mActiveMockGetMisbehaviorRegistry

	funcGetNearestPulseData          func() (b1 bool, d1 pulse.Data)
	inspectFuncGetNearestPulseData   func()
	afterGetNearestPulseDataCounter  uint64
	beforeGetNearestPulseDataCounter uint64
	GetNearestPulseDataMock          mActiveMockGetNearestPulseData

	funcGetOfflinePopulation          func() (o1 OfflinePopulation)
	inspectFuncGetOfflinePopulation   func()
	afterGetOfflinePopulationCounter  uint64
	beforeGetOfflinePopulationCounter uint64
	GetOfflinePopulationMock          mActiveMockGetOfflinePopulation

	funcGetOnlinePopulation          func() (o1 OnlinePopulation)
	inspectFuncGetOnlinePopulation   func()
	afterGetOnlinePopulationCounter  uint64
	beforeGetOnlinePopulationCounter uint64
	GetOnlinePopulationMock          mActiveMockGetOnlinePopulation

	funcGetProfileFactory          func(ksf cryptkit.KeyStoreFactory) (f1 profiles.Factory)
	inspectFuncGetProfileFactory   func(ksf cryptkit.KeyStoreFactory)
	afterGetProfileFactoryCounter  uint64
	beforeGetProfileFactoryCounter uint64
	GetProfileFactoryMock          mActiveMockGetProfileFactory

	funcGetPulseData          func() (d1 pulse.Data)
	inspectFuncGetPulseData   func()
	afterGetPulseDataCounter  uint64
	beforeGetPulseDataCounter uint64
	GetPulseDataMock          mActiveMockGetPulseData

	funcGetPulseNumber          func() (n1 pulse.Number)
	inspectFuncGetPulseNumber   func()
	afterGetPulseNumberCounter  uint64
	beforeGetPulseNumberCounter uint64
	GetPulseNumberMock          mActiveMockGetPulseNumber

	funcIsActive          func() (b1 bool)
	inspectFuncIsActive   func()
	afterIsActiveCounter  uint64
	beforeIsActiveCounter uint64
	IsActiveMock          mActiveMockIsActive
}

// NewActiveMock returns a mock for Active
func NewActiveMock(t minimock.Tester) *ActiveMock {
	m := &ActiveMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateBuilderMock = mActiveMockCreateBuilder{mock: m}
	m.CreateBuilderMock.callArgs = []*ActiveMockCreateBuilderParams{}

	m.GetCensusStateMock = mActiveMockGetCensusState{mock: m}

	m.GetCloudStateHashMock = mActiveMockGetCloudStateHash{mock: m}

	m.GetEvictedPopulationMock = mActiveMockGetEvictedPopulation{mock: m}

	m.GetExpectedPulseNumberMock = mActiveMockGetExpectedPulseNumber{mock: m}

	m.GetGlobulaStateHashMock = mActiveMockGetGlobulaStateHash{mock: m}

	m.GetMandateRegistryMock = mActiveMockGetMandateRegistry{mock: m}

	m.GetMisbehaviorRegistryMock = mActiveMockGetMisbehaviorRegistry{mock: m}

	m.GetNearestPulseDataMock = mActiveMockGetNearestPulseData{mock: m}

	m.GetOfflinePopulationMock = mActiveMockGetOfflinePopulation{mock: m}

	m.GetOnlinePopulationMock = mActiveMockGetOnlinePopulation{mock: m}

	m.GetProfileFactoryMock = mActiveMockGetProfileFactory{mock: m}
	m.GetProfileFactoryMock.callArgs = []*ActiveMockGetProfileFactoryParams{}

	m.GetPulseDataMock = mActiveMockGetPulseData{mock: m}

	m.GetPulseNumberMock = mActiveMockGetPulseNumber{mock: m}

	m.IsActiveMock = mActiveMockIsActive{mock: m}

	return m
}

type mActiveMockCreateBuilder struct {
	mock               *ActiveMock
	defaultExpectation *ActiveMockCreateBuilderExpectation
	expectations       []*ActiveMockCreateBuilderExpectation

	callArgs []*ActiveMockCreateBuilderParams
	mutex    sync.RWMutex
}

// ActiveMockCreateBuilderExpectation specifies expectation struct of the Active.CreateBuilder
type ActiveMockCreateBuilderExpectation struct {
	mock    *ActiveMock
	params  *ActiveMockCreateBuilderParams
	results *ActiveMockCreateBuilderResults
	Counter uint64
}

// ActiveMockCreateBuilderParams contains parameters of the Active.CreateBuilder
type ActiveMockCreateBuilderParams struct {
	ctx context.Context
	pn  pulse.Number
}

// ActiveMockCreateBuilderResults contains results of the Active.CreateBuilder
type ActiveMockCreateBuilderResults struct {
	b1 Builder
}

// Expect sets up expected params for Active.CreateBuilder
func (mmCreateBuilder *mActiveMockCreateBuilder) Expect(ctx context.Context, pn pulse.Number) *mActiveMockCreateBuilder {
	if mmCreateBuilder.mock.funcCreateBuilder != nil {
		mmCreateBuilder.mock.t.Fatalf("ActiveMock.CreateBuilder mock is already set by Set")
	}

	if mmCreateBuilder.defaultExpectation == nil {
		mmCreateBuilder.defaultExpectation = &ActiveMockCreateBuilderExpectation{}
	}

	mmCreateBuilder.defaultExpectation.params = &ActiveMockCreateBuilderParams{ctx, pn}
	for _, e := range mmCreateBuilder.expectations {
		if minimock.Equal(e.params, mmCreateBuilder.defaultExpectation.params) {
			mmCreateBuilder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateBuilder.defaultExpectation.params)
		}
	}

	return mmCreateBuilder
}

// Inspect accepts an inspector function that has same arguments as the Active.CreateBuilder
func (mmCreateBuilder *mActiveMockCreateBuilder) Inspect(f func(ctx context.Context, pn pulse.Number)) *mActiveMockCreateBuilder {
	if mmCreateBuilder.mock.inspectFuncCreateBuilder != nil {
		mmCreateBuilder.mock.t.Fatalf("Inspect function is already set for ActiveMock.CreateBuilder")
	}

	mmCreateBuilder.mock.inspectFuncCreateBuilder = f

	return mmCreateBuilder
}

// Return sets up results that will be returned by Active.CreateBuilder
func (mmCreateBuilder *mActiveMockCreateBuilder) Return(b1 Builder) *ActiveMock {
	if mmCreateBuilder.mock.funcCreateBuilder != nil {
		mmCreateBuilder.mock.t.Fatalf("ActiveMock.CreateBuilder mock is already set by Set")
	}

	if mmCreateBuilder.defaultExpectation == nil {
		mmCreateBuilder.defaultExpectation = &ActiveMockCreateBuilderExpectation{mock: mmCreateBuilder.mock}
	}
	mmCreateBuilder.defaultExpectation.results = &ActiveMockCreateBuilderResults{b1}
	return mmCreateBuilder.mock
}

//Set uses given function f to mock the Active.CreateBuilder method
func (mmCreateBuilder *mActiveMockCreateBuilder) Set(f func(ctx context.Context, pn pulse.Number) (b1 Builder)) *ActiveMock {
	if mmCreateBuilder.defaultExpectation != nil {
		mmCreateBuilder.mock.t.Fatalf("Default expectation is already set for the Active.CreateBuilder method")
	}

	if len(mmCreateBuilder.expectations) > 0 {
		mmCreateBuilder.mock.t.Fatalf("Some expectations are already set for the Active.CreateBuilder method")
	}

	mmCreateBuilder.mock.funcCreateBuilder = f
	return mmCreateBuilder.mock
}

// When sets expectation for the Active.CreateBuilder which will trigger the result defined by the following
// Then helper
func (mmCreateBuilder *mActiveMockCreateBuilder) When(ctx context.Context, pn pulse.Number) *ActiveMockCreateBuilderExpectation {
	if mmCreateBuilder.mock.funcCreateBuilder != nil {
		mmCreateBuilder.mock.t.Fatalf("ActiveMock.CreateBuilder mock is already set by Set")
	}

	expectation := &ActiveMockCreateBuilderExpectation{
		mock:   mmCreateBuilder.mock,
		params: &ActiveMockCreateBuilderParams{ctx, pn},
	}
	mmCreateBuilder.expectations = append(mmCreateBuilder.expectations, expectation)
	return expectation
}

// Then sets up Active.CreateBuilder return parameters for the expectation previously defined by the When method
func (e *ActiveMockCreateBuilderExpectation) Then(b1 Builder) *ActiveMock {
	e.results = &ActiveMockCreateBuilderResults{b1}
	return e.mock
}

// CreateBuilder implements Active
func (mmCreateBuilder *ActiveMock) CreateBuilder(ctx context.Context, pn pulse.Number) (b1 Builder) {
	mm_atomic.AddUint64(&mmCreateBuilder.beforeCreateBuilderCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateBuilder.afterCreateBuilderCounter, 1)

	if mmCreateBuilder.inspectFuncCreateBuilder != nil {
		mmCreateBuilder.inspectFuncCreateBuilder(ctx, pn)
	}

	params := &ActiveMockCreateBuilderParams{ctx, pn}

	// Record call args
	mmCreateBuilder.CreateBuilderMock.mutex.Lock()
	mmCreateBuilder.CreateBuilderMock.callArgs = append(mmCreateBuilder.CreateBuilderMock.callArgs, params)
	mmCreateBuilder.CreateBuilderMock.mutex.Unlock()

	for _, e := range mmCreateBuilder.CreateBuilderMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmCreateBuilder.CreateBuilderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateBuilder.CreateBuilderMock.defaultExpectation.Counter, 1)
		want := mmCreateBuilder.CreateBuilderMock.defaultExpectation.params
		got := ActiveMockCreateBuilderParams{ctx, pn}
		if want != nil && !minimock.Equal(*want, got) {
			mmCreateBuilder.t.Errorf("ActiveMock.CreateBuilder got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmCreateBuilder.CreateBuilderMock.defaultExpectation.results
		if results == nil {
			mmCreateBuilder.t.Fatal("No results are set for the ActiveMock.CreateBuilder")
		}
		return (*results).b1
	}
	if mmCreateBuilder.funcCreateBuilder != nil {
		return mmCreateBuilder.funcCreateBuilder(ctx, pn)
	}
	mmCreateBuilder.t.Fatalf("Unexpected call to ActiveMock.CreateBuilder. %v %v", ctx, pn)
	return
}

// CreateBuilderAfterCounter returns a count of finished ActiveMock.CreateBuilder invocations
func (mmCreateBuilder *ActiveMock) CreateBuilderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateBuilder.afterCreateBuilderCounter)
}

// CreateBuilderBeforeCounter returns a count of ActiveMock.CreateBuilder invocations
func (mmCreateBuilder *ActiveMock) CreateBuilderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateBuilder.beforeCreateBuilderCounter)
}

// Calls returns a list of arguments used in each call to ActiveMock.CreateBuilder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateBuilder *mActiveMockCreateBuilder) Calls() []*ActiveMockCreateBuilderParams {
	mmCreateBuilder.mutex.RLock()

	argCopy := make([]*ActiveMockCreateBuilderParams, len(mmCreateBuilder.callArgs))
	copy(argCopy, mmCreateBuilder.callArgs)

	mmCreateBuilder.mutex.RUnlock()

	return argCopy
}

// MinimockCreateBuilderDone returns true if the count of the CreateBuilder invocations corresponds
// the number of defined expectations
func (m *ActiveMock) MinimockCreateBuilderDone() bool {
	for _, e := range m.CreateBuilderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateBuilderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateBuilderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateBuilder != nil && mm_atomic.LoadUint64(&m.afterCreateBuilderCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateBuilderInspect logs each unmet expectation
func (m *ActiveMock) MinimockCreateBuilderInspect() {
	for _, e := range m.CreateBuilderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ActiveMock.CreateBuilder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateBuilderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateBuilderCounter) < 1 {
		if m.CreateBuilderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ActiveMock.CreateBuilder")
		} else {
			m.t.Errorf("Expected call to ActiveMock.CreateBuilder with params: %#v", *m.CreateBuilderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateBuilder != nil && mm_atomic.LoadUint64(&m.afterCreateBuilderCounter) < 1 {
		m.t.Error("Expected call to ActiveMock.CreateBuilder")
	}
}

type mActiveMockGetCensusState struct {
	mock               *ActiveMock
	defaultExpectation *ActiveMockGetCensusStateExpectation
	expectations       []*ActiveMockGetCensusStateExpectation
}

// ActiveMockGetCensusStateExpectation specifies expectation struct of the Active.GetCensusState
type ActiveMockGetCensusStateExpectation struct {
	mock *ActiveMock

	results *ActiveMockGetCensusStateResults
	Counter uint64
}

// ActiveMockGetCensusStateResults contains results of the Active.GetCensusState
type ActiveMockGetCensusStateResults struct {
	s1 State
}

// Expect sets up expected params for Active.GetCensusState
func (mmGetCensusState *mActiveMockGetCensusState) Expect() *mActiveMockGetCensusState {
	if mmGetCensusState.mock.funcGetCensusState != nil {
		mmGetCensusState.mock.t.Fatalf("ActiveMock.GetCensusState mock is already set by Set")
	}

	if mmGetCensusState.defaultExpectation == nil {
		mmGetCensusState.defaultExpectation = &ActiveMockGetCensusStateExpectation{}
	}

	return mmGetCensusState
}

// Inspect accepts an inspector function that has same arguments as the Active.GetCensusState
func (mmGetCensusState *mActiveMockGetCensusState) Inspect(f func()) *mActiveMockGetCensusState {
	if mmGetCensusState.mock.inspectFuncGetCensusState != nil {
		mmGetCensusState.mock.t.Fatalf("Inspect function is already set for ActiveMock.GetCensusState")
	}

	mmGetCensusState.mock.inspectFuncGetCensusState = f

	return mmGetCensusState
}

// Return sets up results that will be returned by Active.GetCensusState
func (mmGetCensusState *mActiveMockGetCensusState) Return(s1 State) *ActiveMock {
	if mmGetCensusState.mock.funcGetCensusState != nil {
		mmGetCensusState.mock.t.Fatalf("ActiveMock.GetCensusState mock is already set by Set")
	}

	if mmGetCensusState.defaultExpectation == nil {
		mmGetCensusState.defaultExpectation = &ActiveMockGetCensusStateExpectation{mock: mmGetCensusState.mock}
	}
	mmGetCensusState.defaultExpectation.results = &ActiveMockGetCensusStateResults{s1}
	return mmGetCensusState.mock
}

//Set uses given function f to mock the Active.GetCensusState method
func (mmGetCensusState *mActiveMockGetCensusState) Set(f func() (s1 State)) *ActiveMock {
	if mmGetCensusState.defaultExpectation != nil {
		mmGetCensusState.mock.t.Fatalf("Default expectation is already set for the Active.GetCensusState method")
	}

	if len(mmGetCensusState.expectations) > 0 {
		mmGetCensusState.mock.t.Fatalf("Some expectations are already set for the Active.GetCensusState method")
	}

	mmGetCensusState.mock.funcGetCensusState = f
	return mmGetCensusState.mock
}

// GetCensusState implements Active
func (mmGetCensusState *ActiveMock) GetCensusState() (s1 State) {
	mm_atomic.AddUint64(&mmGetCensusState.beforeGetCensusStateCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCensusState.afterGetCensusStateCounter, 1)

	if mmGetCensusState.inspectFuncGetCensusState != nil {
		mmGetCensusState.inspectFuncGetCensusState()
	}

	if mmGetCensusState.GetCensusStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCensusState.GetCensusStateMock.defaultExpectation.Counter, 1)

		results := mmGetCensusState.GetCensusStateMock.defaultExpectation.results
		if results == nil {
			mmGetCensusState.t.Fatal("No results are set for the ActiveMock.GetCensusState")
		}
		return (*results).s1
	}
	if mmGetCensusState.funcGetCensusState != nil {
		return mmGetCensusState.funcGetCensusState()
	}
	mmGetCensusState.t.Fatalf("Unexpected call to ActiveMock.GetCensusState.")
	return
}

// GetCensusStateAfterCounter returns a count of finished ActiveMock.GetCensusState invocations
func (mmGetCensusState *ActiveMock) GetCensusStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCensusState.afterGetCensusStateCounter)
}

// GetCensusStateBeforeCounter returns a count of ActiveMock.GetCensusState invocations
func (mmGetCensusState *ActiveMock) GetCensusStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCensusState.beforeGetCensusStateCounter)
}

// MinimockGetCensusStateDone returns true if the count of the GetCensusState invocations corresponds
// the number of defined expectations
func (m *ActiveMock) MinimockGetCensusStateDone() bool {
	for _, e := range m.GetCensusStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCensusStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCensusStateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCensusState != nil && mm_atomic.LoadUint64(&m.afterGetCensusStateCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCensusStateInspect logs each unmet expectation
func (m *ActiveMock) MinimockGetCensusStateInspect() {
	for _, e := range m.GetCensusStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ActiveMock.GetCensusState")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCensusStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCensusStateCounter) < 1 {
		m.t.Error("Expected call to ActiveMock.GetCensusState")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCensusState != nil && mm_atomic.LoadUint64(&m.afterGetCensusStateCounter) < 1 {
		m.t.Error("Expected call to ActiveMock.GetCensusState")
	}
}

type mActiveMockGetCloudStateHash struct {
	mock               *ActiveMock
	defaultExpectation *ActiveMockGetCloudStateHashExpectation
	expectations       []*ActiveMockGetCloudStateHashExpectation
}

// ActiveMockGetCloudStateHashExpectation specifies expectation struct of the Active.GetCloudStateHash
type ActiveMockGetCloudStateHashExpectation struct {
	mock *ActiveMock

	results *ActiveMockGetCloudStateHashResults
	Counter uint64
}

// ActiveMockGetCloudStateHashResults contains results of the Active.GetCloudStateHash
type ActiveMockGetCloudStateHashResults struct {
	c1 proofs.CloudStateHash
}

// Expect sets up expected params for Active.GetCloudStateHash
func (mmGetCloudStateHash *mActiveMockGetCloudStateHash) Expect() *mActiveMockGetCloudStateHash {
	if mmGetCloudStateHash.mock.funcGetCloudStateHash != nil {
		mmGetCloudStateHash.mock.t.Fatalf("ActiveMock.GetCloudStateHash mock is already set by Set")
	}

	if mmGetCloudStateHash.defaultExpectation == nil {
		mmGetCloudStateHash.defaultExpectation = &ActiveMockGetCloudStateHashExpectation{}
	}

	return mmGetCloudStateHash
}

// Inspect accepts an inspector function that has same arguments as the Active.GetCloudStateHash
func (mmGetCloudStateHash *mActiveMockGetCloudStateHash) Inspect(f func()) *mActiveMockGetCloudStateHash {
	if mmGetCloudStateHash.mock.inspectFuncGetCloudStateHash != nil {
		mmGetCloudStateHash.mock.t.Fatalf("Inspect function is already set for ActiveMock.GetCloudStateHash")
	}

	mmGetCloudStateHash.mock.inspectFuncGetCloudStateHash = f

	return mmGetCloudStateHash
}

// Return sets up results that will be returned by Active.GetCloudStateHash
func (mmGetCloudStateHash *mActiveMockGetCloudStateHash) Return(c1 proofs.CloudStateHash) *ActiveMock {
	if mmGetCloudStateHash.mock.funcGetCloudStateHash != nil {
		mmGetCloudStateHash.mock.t.Fatalf("ActiveMock.GetCloudStateHash mock is already set by Set")
	}

	if mmGetCloudStateHash.defaultExpectation == nil {
		mmGetCloudStateHash.defaultExpectation = &ActiveMockGetCloudStateHashExpectation{mock: mmGetCloudStateHash.mock}
	}
	mmGetCloudStateHash.defaultExpectation.results = &ActiveMockGetCloudStateHashResults{c1}
	return mmGetCloudStateHash.mock
}

//Set uses given function f to mock the Active.GetCloudStateHash method
func (mmGetCloudStateHash *mActiveMockGetCloudStateHash) Set(f func() (c1 proofs.CloudStateHash)) *ActiveMock {
	if mmGetCloudStateHash.defaultExpectation != nil {
		mmGetCloudStateHash.mock.t.Fatalf("Default expectation is already set for the Active.GetCloudStateHash method")
	}

	if len(mmGetCloudStateHash.expectations) > 0 {
		mmGetCloudStateHash.mock.t.Fatalf("Some expectations are already set for the Active.GetCloudStateHash method")
	}

	mmGetCloudStateHash.mock.funcGetCloudStateHash = f
	return mmGetCloudStateHash.mock
}

// GetCloudStateHash implements Active
func (mmGetCloudStateHash *ActiveMock) GetCloudStateHash() (c1 proofs.CloudStateHash) {
	mm_atomic.AddUint64(&mmGetCloudStateHash.beforeGetCloudStateHashCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCloudStateHash.afterGetCloudStateHashCounter, 1)

	if mmGetCloudStateHash.inspectFuncGetCloudStateHash != nil {
		mmGetCloudStateHash.inspectFuncGetCloudStateHash()
	}

	if mmGetCloudStateHash.GetCloudStateHashMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCloudStateHash.GetCloudStateHashMock.defaultExpectation.Counter, 1)

		results := mmGetCloudStateHash.GetCloudStateHashMock.defaultExpectation.results
		if results == nil {
			mmGetCloudStateHash.t.Fatal("No results are set for the ActiveMock.GetCloudStateHash")
		}
		return (*results).c1
	}
	if mmGetCloudStateHash.funcGetCloudStateHash != nil {
		return mmGetCloudStateHash.funcGetCloudStateHash()
	}
	mmGetCloudStateHash.t.Fatalf("Unexpected call to ActiveMock.GetCloudStateHash.")
	return
}

// GetCloudStateHashAfterCounter returns a count of finished ActiveMock.GetCloudStateHash invocations
func (mmGetCloudStateHash *ActiveMock) GetCloudStateHashAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCloudStateHash.afterGetCloudStateHashCounter)
}

// GetCloudStateHashBeforeCounter returns a count of ActiveMock.GetCloudStateHash invocations
func (mmGetCloudStateHash *ActiveMock) GetCloudStateHashBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCloudStateHash.beforeGetCloudStateHashCounter)
}

// MinimockGetCloudStateHashDone returns true if the count of the GetCloudStateHash invocations corresponds
// the number of defined expectations
func (m *ActiveMock) MinimockGetCloudStateHashDone() bool {
	for _, e := range m.GetCloudStateHashMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCloudStateHashMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCloudStateHashCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCloudStateHash != nil && mm_atomic.LoadUint64(&m.afterGetCloudStateHashCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCloudStateHashInspect logs each unmet expectation
func (m *ActiveMock) MinimockGetCloudStateHashInspect() {
	for _, e := range m.GetCloudStateHashMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ActiveMock.GetCloudStateHash")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCloudStateHashMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCloudStateHashCounter) < 1 {
		m.t.Error("Expected call to ActiveMock.GetCloudStateHash")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCloudStateHash != nil && mm_atomic.LoadUint64(&m.afterGetCloudStateHashCounter) < 1 {
		m.t.Error("Expected call to ActiveMock.GetCloudStateHash")
	}
}

type mActiveMockGetEvictedPopulation struct {
	mock               *ActiveMock
	defaultExpectation *ActiveMockGetEvictedPopulationExpectation
	expectations       []*ActiveMockGetEvictedPopulationExpectation
}

// ActiveMockGetEvictedPopulationExpectation specifies expectation struct of the Active.GetEvictedPopulation
type ActiveMockGetEvictedPopulationExpectation struct {
	mock *ActiveMock

	results *ActiveMockGetEvictedPopulationResults
	Counter uint64
}

// ActiveMockGetEvictedPopulationResults contains results of the Active.GetEvictedPopulation
type ActiveMockGetEvictedPopulationResults struct {
	e1 EvictedPopulation
}

// Expect sets up expected params for Active.GetEvictedPopulation
func (mmGetEvictedPopulation *mActiveMockGetEvictedPopulation) Expect() *mActiveMockGetEvictedPopulation {
	if mmGetEvictedPopulation.mock.funcGetEvictedPopulation != nil {
		mmGetEvictedPopulation.mock.t.Fatalf("ActiveMock.GetEvictedPopulation mock is already set by Set")
	}

	if mmGetEvictedPopulation.defaultExpectation == nil {
		mmGetEvictedPopulation.defaultExpectation = &ActiveMockGetEvictedPopulationExpectation{}
	}

	return mmGetEvictedPopulation
}

// Inspect accepts an inspector function that has same arguments as the Active.GetEvictedPopulation
func (mmGetEvictedPopulation *mActiveMockGetEvictedPopulation) Inspect(f func()) *mActiveMockGetEvictedPopulation {
	if mmGetEvictedPopulation.mock.inspectFuncGetEvictedPopulation != nil {
		mmGetEvictedPopulation.mock.t.Fatalf("Inspect function is already set for ActiveMock.GetEvictedPopulation")
	}

	mmGetEvictedPopulation.mock.inspectFuncGetEvictedPopulation = f

	return mmGetEvictedPopulation
}

// Return sets up results that will be returned by Active.GetEvictedPopulation
func (mmGetEvictedPopulation *mActiveMockGetEvictedPopulation) Return(e1 EvictedPopulation) *ActiveMock {
	if mmGetEvictedPopulation.mock.funcGetEvictedPopulation != nil {
		mmGetEvictedPopulation.mock.t.Fatalf("ActiveMock.GetEvictedPopulation mock is already set by Set")
	}

	if mmGetEvictedPopulation.defaultExpectation == nil {
		mmGetEvictedPopulation.defaultExpectation = &ActiveMockGetEvictedPopulationExpectation{mock: mmGetEvictedPopulation.mock}
	}
	mmGetEvictedPopulation.defaultExpectation.results = &ActiveMockGetEvictedPopulationResults{e1}
	return mmGetEvictedPopulation.mock
}

//Set uses given function f to mock the Active.GetEvictedPopulation method
func (mmGetEvictedPopulation *mActiveMockGetEvictedPopulation) Set(f func() (e1 EvictedPopulation)) *ActiveMock {
	if mmGetEvictedPopulation.defaultExpectation != nil {
		mmGetEvictedPopulation.mock.t.Fatalf("Default expectation is already set for the Active.GetEvictedPopulation method")
	}

	if len(mmGetEvictedPopulation.expectations) > 0 {
		mmGetEvictedPopulation.mock.t.Fatalf("Some expectations are already set for the Active.GetEvictedPopulation method")
	}

	mmGetEvictedPopulation.mock.funcGetEvictedPopulation = f
	return mmGetEvictedPopulation.mock
}

// GetEvictedPopulation implements Active
func (mmGetEvictedPopulation *ActiveMock) GetEvictedPopulation() (e1 EvictedPopulation) {
	mm_atomic.AddUint64(&mmGetEvictedPopulation.beforeGetEvictedPopulationCounter, 1)
	defer mm_atomic.AddUint64(&mmGetEvictedPopulation.afterGetEvictedPopulationCounter, 1)

	if mmGetEvictedPopulation.inspectFuncGetEvictedPopulation != nil {
		mmGetEvictedPopulation.inspectFuncGetEvictedPopulation()
	}

	if mmGetEvictedPopulation.GetEvictedPopulationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetEvictedPopulation.GetEvictedPopulationMock.defaultExpectation.Counter, 1)

		results := mmGetEvictedPopulation.GetEvictedPopulationMock.defaultExpectation.results
		if results == nil {
			mmGetEvictedPopulation.t.Fatal("No results are set for the ActiveMock.GetEvictedPopulation")
		}
		return (*results).e1
	}
	if mmGetEvictedPopulation.funcGetEvictedPopulation != nil {
		return mmGetEvictedPopulation.funcGetEvictedPopulation()
	}
	mmGetEvictedPopulation.t.Fatalf("Unexpected call to ActiveMock.GetEvictedPopulation.")
	return
}

// GetEvictedPopulationAfterCounter returns a count of finished ActiveMock.GetEvictedPopulation invocations
func (mmGetEvictedPopulation *ActiveMock) GetEvictedPopulationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetEvictedPopulation.afterGetEvictedPopulationCounter)
}

// GetEvictedPopulationBeforeCounter returns a count of ActiveMock.GetEvictedPopulation invocations
func (mmGetEvictedPopulation *ActiveMock) GetEvictedPopulationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetEvictedPopulation.beforeGetEvictedPopulationCounter)
}

// MinimockGetEvictedPopulationDone returns true if the count of the GetEvictedPopulation invocations corresponds
// the number of defined expectations
func (m *ActiveMock) MinimockGetEvictedPopulationDone() bool {
	for _, e := range m.GetEvictedPopulationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetEvictedPopulationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetEvictedPopulationCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetEvictedPopulation != nil && mm_atomic.LoadUint64(&m.afterGetEvictedPopulationCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetEvictedPopulationInspect logs each unmet expectation
func (m *ActiveMock) MinimockGetEvictedPopulationInspect() {
	for _, e := range m.GetEvictedPopulationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ActiveMock.GetEvictedPopulation")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetEvictedPopulationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetEvictedPopulationCounter) < 1 {
		m.t.Error("Expected call to ActiveMock.GetEvictedPopulation")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetEvictedPopulation != nil && mm_atomic.LoadUint64(&m.afterGetEvictedPopulationCounter) < 1 {
		m.t.Error("Expected call to ActiveMock.GetEvictedPopulation")
	}
}

type mActiveMockGetExpectedPulseNumber struct {
	mock               *ActiveMock
	defaultExpectation *ActiveMockGetExpectedPulseNumberExpectation
	expectations       []*ActiveMockGetExpectedPulseNumberExpectation
}

// ActiveMockGetExpectedPulseNumberExpectation specifies expectation struct of the Active.GetExpectedPulseNumber
type ActiveMockGetExpectedPulseNumberExpectation struct {
	mock *ActiveMock

	results *ActiveMockGetExpectedPulseNumberResults
	Counter uint64
}

// ActiveMockGetExpectedPulseNumberResults contains results of the Active.GetExpectedPulseNumber
type ActiveMockGetExpectedPulseNumberResults struct {
	n1 pulse.Number
}

// Expect sets up expected params for Active.GetExpectedPulseNumber
func (mmGetExpectedPulseNumber *mActiveMockGetExpectedPulseNumber) Expect() *mActiveMockGetExpectedPulseNumber {
	if mmGetExpectedPulseNumber.mock.funcGetExpectedPulseNumber != nil {
		mmGetExpectedPulseNumber.mock.t.Fatalf("ActiveMock.GetExpectedPulseNumber mock is already set by Set")
	}

	if mmGetExpectedPulseNumber.defaultExpectation == nil {
		mmGetExpectedPulseNumber.defaultExpectation = &ActiveMockGetExpectedPulseNumberExpectation{}
	}

	return mmGetExpectedPulseNumber
}

// Inspect accepts an inspector function that has same arguments as the Active.GetExpectedPulseNumber
func (mmGetExpectedPulseNumber *mActiveMockGetExpectedPulseNumber) Inspect(f func()) *mActiveMockGetExpectedPulseNumber {
	if mmGetExpectedPulseNumber.mock.inspectFuncGetExpectedPulseNumber != nil {
		mmGetExpectedPulseNumber.mock.t.Fatalf("Inspect function is already set for ActiveMock.GetExpectedPulseNumber")
	}

	mmGetExpectedPulseNumber.mock.inspectFuncGetExpectedPulseNumber = f

	return mmGetExpectedPulseNumber
}

// Return sets up results that will be returned by Active.GetExpectedPulseNumber
func (mmGetExpectedPulseNumber *mActiveMockGetExpectedPulseNumber) Return(n1 pulse.Number) *ActiveMock {
	if mmGetExpectedPulseNumber.mock.funcGetExpectedPulseNumber != nil {
		mmGetExpectedPulseNumber.mock.t.Fatalf("ActiveMock.GetExpectedPulseNumber mock is already set by Set")
	}

	if mmGetExpectedPulseNumber.defaultExpectation == nil {
		mmGetExpectedPulseNumber.defaultExpectation = &ActiveMockGetExpectedPulseNumberExpectation{mock: mmGetExpectedPulseNumber.mock}
	}
	mmGetExpectedPulseNumber.defaultExpectation.results = &ActiveMockGetExpectedPulseNumberResults{n1}
	return mmGetExpectedPulseNumber.mock
}

//Set uses given function f to mock the Active.GetExpectedPulseNumber method
func (mmGetExpectedPulseNumber *mActiveMockGetExpectedPulseNumber) Set(f func() (n1 pulse.Number)) *ActiveMock {
	if mmGetExpectedPulseNumber.defaultExpectation != nil {
		mmGetExpectedPulseNumber.mock.t.Fatalf("Default expectation is already set for the Active.GetExpectedPulseNumber method")
	}

	if len(mmGetExpectedPulseNumber.expectations) > 0 {
		mmGetExpectedPulseNumber.mock.t.Fatalf("Some expectations are already set for the Active.GetExpectedPulseNumber method")
	}

	mmGetExpectedPulseNumber.mock.funcGetExpectedPulseNumber = f
	return mmGetExpectedPulseNumber.mock
}

// GetExpectedPulseNumber implements Active
func (mmGetExpectedPulseNumber *ActiveMock) GetExpectedPulseNumber() (n1 pulse.Number) {
	mm_atomic.AddUint64(&mmGetExpectedPulseNumber.beforeGetExpectedPulseNumberCounter, 1)
	defer mm_atomic.AddUint64(&mmGetExpectedPulseNumber.afterGetExpectedPulseNumberCounter, 1)

	if mmGetExpectedPulseNumber.inspectFuncGetExpectedPulseNumber != nil {
		mmGetExpectedPulseNumber.inspectFuncGetExpectedPulseNumber()
	}

	if mmGetExpectedPulseNumber.GetExpectedPulseNumberMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetExpectedPulseNumber.GetExpectedPulseNumberMock.defaultExpectation.Counter, 1)

		results := mmGetExpectedPulseNumber.GetExpectedPulseNumberMock.defaultExpectation.results
		if results == nil {
			mmGetExpectedPulseNumber.t.Fatal("No results are set for the ActiveMock.GetExpectedPulseNumber")
		}
		return (*results).n1
	}
	if mmGetExpectedPulseNumber.funcGetExpectedPulseNumber != nil {
		return mmGetExpectedPulseNumber.funcGetExpectedPulseNumber()
	}
	mmGetExpectedPulseNumber.t.Fatalf("Unexpected call to ActiveMock.GetExpectedPulseNumber.")
	return
}

// GetExpectedPulseNumberAfterCounter returns a count of finished ActiveMock.GetExpectedPulseNumber invocations
func (mmGetExpectedPulseNumber *ActiveMock) GetExpectedPulseNumberAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetExpectedPulseNumber.afterGetExpectedPulseNumberCounter)
}

// GetExpectedPulseNumberBeforeCounter returns a count of ActiveMock.GetExpectedPulseNumber invocations
func (mmGetExpectedPulseNumber *ActiveMock) GetExpectedPulseNumberBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetExpectedPulseNumber.beforeGetExpectedPulseNumberCounter)
}

// MinimockGetExpectedPulseNumberDone returns true if the count of the GetExpectedPulseNumber invocations corresponds
// the number of defined expectations
func (m *ActiveMock) MinimockGetExpectedPulseNumberDone() bool {
	for _, e := range m.GetExpectedPulseNumberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetExpectedPulseNumberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetExpectedPulseNumberCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetExpectedPulseNumber != nil && mm_atomic.LoadUint64(&m.afterGetExpectedPulseNumberCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetExpectedPulseNumberInspect logs each unmet expectation
func (m *ActiveMock) MinimockGetExpectedPulseNumberInspect() {
	for _, e := range m.GetExpectedPulseNumberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ActiveMock.GetExpectedPulseNumber")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetExpectedPulseNumberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetExpectedPulseNumberCounter) < 1 {
		m.t.Error("Expected call to ActiveMock.GetExpectedPulseNumber")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetExpectedPulseNumber != nil && mm_atomic.LoadUint64(&m.afterGetExpectedPulseNumberCounter) < 1 {
		m.t.Error("Expected call to ActiveMock.GetExpectedPulseNumber")
	}
}

type mActiveMockGetGlobulaStateHash struct {
	mock               *ActiveMock
	defaultExpectation *ActiveMockGetGlobulaStateHashExpectation
	expectations       []*ActiveMockGetGlobulaStateHashExpectation
}

// ActiveMockGetGlobulaStateHashExpectation specifies expectation struct of the Active.GetGlobulaStateHash
type ActiveMockGetGlobulaStateHashExpectation struct {
	mock *ActiveMock

	results *ActiveMockGetGlobulaStateHashResults
	Counter uint64
}

// ActiveMockGetGlobulaStateHashResults contains results of the Active.GetGlobulaStateHash
type ActiveMockGetGlobulaStateHashResults struct {
	g1 proofs.GlobulaStateHash
}

// Expect sets up expected params for Active.GetGlobulaStateHash
func (mmGetGlobulaStateHash *mActiveMockGetGlobulaStateHash) Expect() *mActiveMockGetGlobulaStateHash {
	if mmGetGlobulaStateHash.mock.funcGetGlobulaStateHash != nil {
		mmGetGlobulaStateHash.mock.t.Fatalf("ActiveMock.GetGlobulaStateHash mock is already set by Set")
	}

	if mmGetGlobulaStateHash.defaultExpectation == nil {
		mmGetGlobulaStateHash.defaultExpectation = &ActiveMockGetGlobulaStateHashExpectation{}
	}

	return mmGetGlobulaStateHash
}

// Inspect accepts an inspector function that has same arguments as the Active.GetGlobulaStateHash
func (mmGetGlobulaStateHash *mActiveMockGetGlobulaStateHash) Inspect(f func()) *mActiveMockGetGlobulaStateHash {
	if mmGetGlobulaStateHash.mock.inspectFuncGetGlobulaStateHash != nil {
		mmGetGlobulaStateHash.mock.t.Fatalf("Inspect function is already set for ActiveMock.GetGlobulaStateHash")
	}

	mmGetGlobulaStateHash.mock.inspectFuncGetGlobulaStateHash = f

	return mmGetGlobulaStateHash
}

// Return sets up results that will be returned by Active.GetGlobulaStateHash
func (mmGetGlobulaStateHash *mActiveMockGetGlobulaStateHash) Return(g1 proofs.GlobulaStateHash) *ActiveMock {
	if mmGetGlobulaStateHash.mock.funcGetGlobulaStateHash != nil {
		mmGetGlobulaStateHash.mock.t.Fatalf("ActiveMock.GetGlobulaStateHash mock is already set by Set")
	}

	if mmGetGlobulaStateHash.defaultExpectation == nil {
		mmGetGlobulaStateHash.defaultExpectation = &ActiveMockGetGlobulaStateHashExpectation{mock: mmGetGlobulaStateHash.mock}
	}
	mmGetGlobulaStateHash.defaultExpectation.results = &ActiveMockGetGlobulaStateHashResults{g1}
	return mmGetGlobulaStateHash.mock
}

//Set uses given function f to mock the Active.GetGlobulaStateHash method
func (mmGetGlobulaStateHash *mActiveMockGetGlobulaStateHash) Set(f func() (g1 proofs.GlobulaStateHash)) *ActiveMock {
	if mmGetGlobulaStateHash.defaultExpectation != nil {
		mmGetGlobulaStateHash.mock.t.Fatalf("Default expectation is already set for the Active.GetGlobulaStateHash method")
	}

	if len(mmGetGlobulaStateHash.expectations) > 0 {
		mmGetGlobulaStateHash.mock.t.Fatalf("Some expectations are already set for the Active.GetGlobulaStateHash method")
	}

	mmGetGlobulaStateHash.mock.funcGetGlobulaStateHash = f
	return mmGetGlobulaStateHash.mock
}

// GetGlobulaStateHash implements Active
func (mmGetGlobulaStateHash *ActiveMock) GetGlobulaStateHash() (g1 proofs.GlobulaStateHash) {
	mm_atomic.AddUint64(&mmGetGlobulaStateHash.beforeGetGlobulaStateHashCounter, 1)
	defer mm_atomic.AddUint64(&mmGetGlobulaStateHash.afterGetGlobulaStateHashCounter, 1)

	if mmGetGlobulaStateHash.inspectFuncGetGlobulaStateHash != nil {
		mmGetGlobulaStateHash.inspectFuncGetGlobulaStateHash()
	}

	if mmGetGlobulaStateHash.GetGlobulaStateHashMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetGlobulaStateHash.GetGlobulaStateHashMock.defaultExpectation.Counter, 1)

		results := mmGetGlobulaStateHash.GetGlobulaStateHashMock.defaultExpectation.results
		if results == nil {
			mmGetGlobulaStateHash.t.Fatal("No results are set for the ActiveMock.GetGlobulaStateHash")
		}
		return (*results).g1
	}
	if mmGetGlobulaStateHash.funcGetGlobulaStateHash != nil {
		return mmGetGlobulaStateHash.funcGetGlobulaStateHash()
	}
	mmGetGlobulaStateHash.t.Fatalf("Unexpected call to ActiveMock.GetGlobulaStateHash.")
	return
}

// GetGlobulaStateHashAfterCounter returns a count of finished ActiveMock.GetGlobulaStateHash invocations
func (mmGetGlobulaStateHash *ActiveMock) GetGlobulaStateHashAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetGlobulaStateHash.afterGetGlobulaStateHashCounter)
}

// GetGlobulaStateHashBeforeCounter returns a count of ActiveMock.GetGlobulaStateHash invocations
func (mmGetGlobulaStateHash *ActiveMock) GetGlobulaStateHashBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetGlobulaStateHash.beforeGetGlobulaStateHashCounter)
}

// MinimockGetGlobulaStateHashDone returns true if the count of the GetGlobulaStateHash invocations corresponds
// the number of defined expectations
func (m *ActiveMock) MinimockGetGlobulaStateHashDone() bool {
	for _, e := range m.GetGlobulaStateHashMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetGlobulaStateHashMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetGlobulaStateHashCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetGlobulaStateHash != nil && mm_atomic.LoadUint64(&m.afterGetGlobulaStateHashCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetGlobulaStateHashInspect logs each unmet expectation
func (m *ActiveMock) MinimockGetGlobulaStateHashInspect() {
	for _, e := range m.GetGlobulaStateHashMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ActiveMock.GetGlobulaStateHash")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetGlobulaStateHashMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetGlobulaStateHashCounter) < 1 {
		m.t.Error("Expected call to ActiveMock.GetGlobulaStateHash")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetGlobulaStateHash != nil && mm_atomic.LoadUint64(&m.afterGetGlobulaStateHashCounter) < 1 {
		m.t.Error("Expected call to ActiveMock.GetGlobulaStateHash")
	}
}

type mActiveMockGetMandateRegistry struct {
	mock               *ActiveMock
	defaultExpectation *ActiveMockGetMandateRegistryExpectation
	expectations       []*ActiveMockGetMandateRegistryExpectation
}

// ActiveMockGetMandateRegistryExpectation specifies expectation struct of the Active.GetMandateRegistry
type ActiveMockGetMandateRegistryExpectation struct {
	mock *ActiveMock

	results *ActiveMockGetMandateRegistryResults
	Counter uint64
}

// ActiveMockGetMandateRegistryResults contains results of the Active.GetMandateRegistry
type ActiveMockGetMandateRegistryResults struct {
	m1 MandateRegistry
}

// Expect sets up expected params for Active.GetMandateRegistry
func (mmGetMandateRegistry *mActiveMockGetMandateRegistry) Expect() *mActiveMockGetMandateRegistry {
	if mmGetMandateRegistry.mock.funcGetMandateRegistry != nil {
		mmGetMandateRegistry.mock.t.Fatalf("ActiveMock.GetMandateRegistry mock is already set by Set")
	}

	if mmGetMandateRegistry.defaultExpectation == nil {
		mmGetMandateRegistry.defaultExpectation = &ActiveMockGetMandateRegistryExpectation{}
	}

	return mmGetMandateRegistry
}

// Inspect accepts an inspector function that has same arguments as the Active.GetMandateRegistry
func (mmGetMandateRegistry *mActiveMockGetMandateRegistry) Inspect(f func()) *mActiveMockGetMandateRegistry {
	if mmGetMandateRegistry.mock.inspectFuncGetMandateRegistry != nil {
		mmGetMandateRegistry.mock.t.Fatalf("Inspect function is already set for ActiveMock.GetMandateRegistry")
	}

	mmGetMandateRegistry.mock.inspectFuncGetMandateRegistry = f

	return mmGetMandateRegistry
}

// Return sets up results that will be returned by Active.GetMandateRegistry
func (mmGetMandateRegistry *mActiveMockGetMandateRegistry) Return(m1 MandateRegistry) *ActiveMock {
	if mmGetMandateRegistry.mock.funcGetMandateRegistry != nil {
		mmGetMandateRegistry.mock.t.Fatalf("ActiveMock.GetMandateRegistry mock is already set by Set")
	}

	if mmGetMandateRegistry.defaultExpectation == nil {
		mmGetMandateRegistry.defaultExpectation = &ActiveMockGetMandateRegistryExpectation{mock: mmGetMandateRegistry.mock}
	}
	mmGetMandateRegistry.defaultExpectation.results = &ActiveMockGetMandateRegistryResults{m1}
	return mmGetMandateRegistry.mock
}

//Set uses given function f to mock the Active.GetMandateRegistry method
func (mmGetMandateRegistry *mActiveMockGetMandateRegistry) Set(f func() (m1 MandateRegistry)) *ActiveMock {
	if mmGetMandateRegistry.defaultExpectation != nil {
		mmGetMandateRegistry.mock.t.Fatalf("Default expectation is already set for the Active.GetMandateRegistry method")
	}

	if len(mmGetMandateRegistry.expectations) > 0 {
		mmGetMandateRegistry.mock.t.Fatalf("Some expectations are already set for the Active.GetMandateRegistry method")
	}

	mmGetMandateRegistry.mock.funcGetMandateRegistry = f
	return mmGetMandateRegistry.mock
}

// GetMandateRegistry implements Active
func (mmGetMandateRegistry *ActiveMock) GetMandateRegistry() (m1 MandateRegistry) {
	mm_atomic.AddUint64(&mmGetMandateRegistry.beforeGetMandateRegistryCounter, 1)
	defer mm_atomic.AddUint64(&mmGetMandateRegistry.afterGetMandateRegistryCounter, 1)

	if mmGetMandateRegistry.inspectFuncGetMandateRegistry != nil {
		mmGetMandateRegistry.inspectFuncGetMandateRegistry()
	}

	if mmGetMandateRegistry.GetMandateRegistryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetMandateRegistry.GetMandateRegistryMock.defaultExpectation.Counter, 1)

		results := mmGetMandateRegistry.GetMandateRegistryMock.defaultExpectation.results
		if results == nil {
			mmGetMandateRegistry.t.Fatal("No results are set for the ActiveMock.GetMandateRegistry")
		}
		return (*results).m1
	}
	if mmGetMandateRegistry.funcGetMandateRegistry != nil {
		return mmGetMandateRegistry.funcGetMandateRegistry()
	}
	mmGetMandateRegistry.t.Fatalf("Unexpected call to ActiveMock.GetMandateRegistry.")
	return
}

// GetMandateRegistryAfterCounter returns a count of finished ActiveMock.GetMandateRegistry invocations
func (mmGetMandateRegistry *ActiveMock) GetMandateRegistryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMandateRegistry.afterGetMandateRegistryCounter)
}

// GetMandateRegistryBeforeCounter returns a count of ActiveMock.GetMandateRegistry invocations
func (mmGetMandateRegistry *ActiveMock) GetMandateRegistryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMandateRegistry.beforeGetMandateRegistryCounter)
}

// MinimockGetMandateRegistryDone returns true if the count of the GetMandateRegistry invocations corresponds
// the number of defined expectations
func (m *ActiveMock) MinimockGetMandateRegistryDone() bool {
	for _, e := range m.GetMandateRegistryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMandateRegistryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetMandateRegistryCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetMandateRegistry != nil && mm_atomic.LoadUint64(&m.afterGetMandateRegistryCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetMandateRegistryInspect logs each unmet expectation
func (m *ActiveMock) MinimockGetMandateRegistryInspect() {
	for _, e := range m.GetMandateRegistryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ActiveMock.GetMandateRegistry")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMandateRegistryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetMandateRegistryCounter) < 1 {
		m.t.Error("Expected call to ActiveMock.GetMandateRegistry")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetMandateRegistry != nil && mm_atomic.LoadUint64(&m.afterGetMandateRegistryCounter) < 1 {
		m.t.Error("Expected call to ActiveMock.GetMandateRegistry")
	}
}

type mActiveMockGetMisbehaviorRegistry struct {
	mock               *ActiveMock
	defaultExpectation *ActiveMockGetMisbehaviorRegistryExpectation
	expectations       []*ActiveMockGetMisbehaviorRegistryExpectation
}

// ActiveMockGetMisbehaviorRegistryExpectation specifies expectation struct of the Active.GetMisbehaviorRegistry
type ActiveMockGetMisbehaviorRegistryExpectation struct {
	mock *ActiveMock

	results *ActiveMockGetMisbehaviorRegistryResults
	Counter uint64
}

// ActiveMockGetMisbehaviorRegistryResults contains results of the Active.GetMisbehaviorRegistry
type ActiveMockGetMisbehaviorRegistryResults struct {
	m1 MisbehaviorRegistry
}

// Expect sets up expected params for Active.GetMisbehaviorRegistry
func (mmGetMisbehaviorRegistry *mActiveMockGetMisbehaviorRegistry) Expect() *mActiveMockGetMisbehaviorRegistry {
	if mmGetMisbehaviorRegistry.mock.funcGetMisbehaviorRegistry != nil {
		mmGetMisbehaviorRegistry.mock.t.Fatalf("ActiveMock.GetMisbehaviorRegistry mock is already set by Set")
	}

	if mmGetMisbehaviorRegistry.defaultExpectation == nil {
		mmGetMisbehaviorRegistry.defaultExpectation = &ActiveMockGetMisbehaviorRegistryExpectation{}
	}

	return mmGetMisbehaviorRegistry
}

// Inspect accepts an inspector function that has same arguments as the Active.GetMisbehaviorRegistry
func (mmGetMisbehaviorRegistry *mActiveMockGetMisbehaviorRegistry) Inspect(f func()) *mActiveMockGetMisbehaviorRegistry {
	if mmGetMisbehaviorRegistry.mock.inspectFuncGetMisbehaviorRegistry != nil {
		mmGetMisbehaviorRegistry.mock.t.Fatalf("Inspect function is already set for ActiveMock.GetMisbehaviorRegistry")
	}

	mmGetMisbehaviorRegistry.mock.inspectFuncGetMisbehaviorRegistry = f

	return mmGetMisbehaviorRegistry
}

// Return sets up results that will be returned by Active.GetMisbehaviorRegistry
func (mmGetMisbehaviorRegistry *mActiveMockGetMisbehaviorRegistry) Return(m1 MisbehaviorRegistry) *ActiveMock {
	if mmGetMisbehaviorRegistry.mock.funcGetMisbehaviorRegistry != nil {
		mmGetMisbehaviorRegistry.mock.t.Fatalf("ActiveMock.GetMisbehaviorRegistry mock is already set by Set")
	}

	if mmGetMisbehaviorRegistry.defaultExpectation == nil {
		mmGetMisbehaviorRegistry.defaultExpectation = &ActiveMockGetMisbehaviorRegistryExpectation{mock: mmGetMisbehaviorRegistry.mock}
	}
	mmGetMisbehaviorRegistry.defaultExpectation.results = &ActiveMockGetMisbehaviorRegistryResults{m1}
	return mmGetMisbehaviorRegistry.mock
}

//Set uses given function f to mock the Active.GetMisbehaviorRegistry method
func (mmGetMisbehaviorRegistry *mActiveMockGetMisbehaviorRegistry) Set(f func() (m1 MisbehaviorRegistry)) *ActiveMock {
	if mmGetMisbehaviorRegistry.defaultExpectation != nil {
		mmGetMisbehaviorRegistry.mock.t.Fatalf("Default expectation is already set for the Active.GetMisbehaviorRegistry method")
	}

	if len(mmGetMisbehaviorRegistry.expectations) > 0 {
		mmGetMisbehaviorRegistry.mock.t.Fatalf("Some expectations are already set for the Active.GetMisbehaviorRegistry method")
	}

	mmGetMisbehaviorRegistry.mock.funcGetMisbehaviorRegistry = f
	return mmGetMisbehaviorRegistry.mock
}

// GetMisbehaviorRegistry implements Active
func (mmGetMisbehaviorRegistry *ActiveMock) GetMisbehaviorRegistry() (m1 MisbehaviorRegistry) {
	mm_atomic.AddUint64(&mmGetMisbehaviorRegistry.beforeGetMisbehaviorRegistryCounter, 1)
	defer mm_atomic.AddUint64(&mmGetMisbehaviorRegistry.afterGetMisbehaviorRegistryCounter, 1)

	if mmGetMisbehaviorRegistry.inspectFuncGetMisbehaviorRegistry != nil {
		mmGetMisbehaviorRegistry.inspectFuncGetMisbehaviorRegistry()
	}

	if mmGetMisbehaviorRegistry.GetMisbehaviorRegistryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetMisbehaviorRegistry.GetMisbehaviorRegistryMock.defaultExpectation.Counter, 1)

		results := mmGetMisbehaviorRegistry.GetMisbehaviorRegistryMock.defaultExpectation.results
		if results == nil {
			mmGetMisbehaviorRegistry.t.Fatal("No results are set for the ActiveMock.GetMisbehaviorRegistry")
		}
		return (*results).m1
	}
	if mmGetMisbehaviorRegistry.funcGetMisbehaviorRegistry != nil {
		return mmGetMisbehaviorRegistry.funcGetMisbehaviorRegistry()
	}
	mmGetMisbehaviorRegistry.t.Fatalf("Unexpected call to ActiveMock.GetMisbehaviorRegistry.")
	return
}

// GetMisbehaviorRegistryAfterCounter returns a count of finished ActiveMock.GetMisbehaviorRegistry invocations
func (mmGetMisbehaviorRegistry *ActiveMock) GetMisbehaviorRegistryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMisbehaviorRegistry.afterGetMisbehaviorRegistryCounter)
}

// GetMisbehaviorRegistryBeforeCounter returns a count of ActiveMock.GetMisbehaviorRegistry invocations
func (mmGetMisbehaviorRegistry *ActiveMock) GetMisbehaviorRegistryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMisbehaviorRegistry.beforeGetMisbehaviorRegistryCounter)
}

// MinimockGetMisbehaviorRegistryDone returns true if the count of the GetMisbehaviorRegistry invocations corresponds
// the number of defined expectations
func (m *ActiveMock) MinimockGetMisbehaviorRegistryDone() bool {
	for _, e := range m.GetMisbehaviorRegistryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMisbehaviorRegistryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetMisbehaviorRegistryCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetMisbehaviorRegistry != nil && mm_atomic.LoadUint64(&m.afterGetMisbehaviorRegistryCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetMisbehaviorRegistryInspect logs each unmet expectation
func (m *ActiveMock) MinimockGetMisbehaviorRegistryInspect() {
	for _, e := range m.GetMisbehaviorRegistryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ActiveMock.GetMisbehaviorRegistry")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMisbehaviorRegistryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetMisbehaviorRegistryCounter) < 1 {
		m.t.Error("Expected call to ActiveMock.GetMisbehaviorRegistry")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetMisbehaviorRegistry != nil && mm_atomic.LoadUint64(&m.afterGetMisbehaviorRegistryCounter) < 1 {
		m.t.Error("Expected call to ActiveMock.GetMisbehaviorRegistry")
	}
}

type mActiveMockGetNearestPulseData struct {
	mock               *ActiveMock
	defaultExpectation *ActiveMockGetNearestPulseDataExpectation
	expectations       []*ActiveMockGetNearestPulseDataExpectation
}

// ActiveMockGetNearestPulseDataExpectation specifies expectation struct of the Active.GetNearestPulseData
type ActiveMockGetNearestPulseDataExpectation struct {
	mock *ActiveMock

	results *ActiveMockGetNearestPulseDataResults
	Counter uint64
}

// ActiveMockGetNearestPulseDataResults contains results of the Active.GetNearestPulseData
type ActiveMockGetNearestPulseDataResults struct {
	b1 bool
	d1 pulse.Data
}

// Expect sets up expected params for Active.GetNearestPulseData
func (mmGetNearestPulseData *mActiveMockGetNearestPulseData) Expect() *mActiveMockGetNearestPulseData {
	if mmGetNearestPulseData.mock.funcGetNearestPulseData != nil {
		mmGetNearestPulseData.mock.t.Fatalf("ActiveMock.GetNearestPulseData mock is already set by Set")
	}

	if mmGetNearestPulseData.defaultExpectation == nil {
		mmGetNearestPulseData.defaultExpectation = &ActiveMockGetNearestPulseDataExpectation{}
	}

	return mmGetNearestPulseData
}

// Inspect accepts an inspector function that has same arguments as the Active.GetNearestPulseData
func (mmGetNearestPulseData *mActiveMockGetNearestPulseData) Inspect(f func()) *mActiveMockGetNearestPulseData {
	if mmGetNearestPulseData.mock.inspectFuncGetNearestPulseData != nil {
		mmGetNearestPulseData.mock.t.Fatalf("Inspect function is already set for ActiveMock.GetNearestPulseData")
	}

	mmGetNearestPulseData.mock.inspectFuncGetNearestPulseData = f

	return mmGetNearestPulseData
}

// Return sets up results that will be returned by Active.GetNearestPulseData
func (mmGetNearestPulseData *mActiveMockGetNearestPulseData) Return(b1 bool, d1 pulse.Data) *ActiveMock {
	if mmGetNearestPulseData.mock.funcGetNearestPulseData != nil {
		mmGetNearestPulseData.mock.t.Fatalf("ActiveMock.GetNearestPulseData mock is already set by Set")
	}

	if mmGetNearestPulseData.defaultExpectation == nil {
		mmGetNearestPulseData.defaultExpectation = &ActiveMockGetNearestPulseDataExpectation{mock: mmGetNearestPulseData.mock}
	}
	mmGetNearestPulseData.defaultExpectation.results = &ActiveMockGetNearestPulseDataResults{b1, d1}
	return mmGetNearestPulseData.mock
}

//Set uses given function f to mock the Active.GetNearestPulseData method
func (mmGetNearestPulseData *mActiveMockGetNearestPulseData) Set(f func() (b1 bool, d1 pulse.Data)) *ActiveMock {
	if mmGetNearestPulseData.defaultExpectation != nil {
		mmGetNearestPulseData.mock.t.Fatalf("Default expectation is already set for the Active.GetNearestPulseData method")
	}

	if len(mmGetNearestPulseData.expectations) > 0 {
		mmGetNearestPulseData.mock.t.Fatalf("Some expectations are already set for the Active.GetNearestPulseData method")
	}

	mmGetNearestPulseData.mock.funcGetNearestPulseData = f
	return mmGetNearestPulseData.mock
}

// GetNearestPulseData implements Active
func (mmGetNearestPulseData *ActiveMock) GetNearestPulseData() (b1 bool, d1 pulse.Data) {
	mm_atomic.AddUint64(&mmGetNearestPulseData.beforeGetNearestPulseDataCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNearestPulseData.afterGetNearestPulseDataCounter, 1)

	if mmGetNearestPulseData.inspectFuncGetNearestPulseData != nil {
		mmGetNearestPulseData.inspectFuncGetNearestPulseData()
	}

	if mmGetNearestPulseData.GetNearestPulseDataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNearestPulseData.GetNearestPulseDataMock.defaultExpectation.Counter, 1)

		results := mmGetNearestPulseData.GetNearestPulseDataMock.defaultExpectation.results
		if results == nil {
			mmGetNearestPulseData.t.Fatal("No results are set for the ActiveMock.GetNearestPulseData")
		}
		return (*results).b1, (*results).d1
	}
	if mmGetNearestPulseData.funcGetNearestPulseData != nil {
		return mmGetNearestPulseData.funcGetNearestPulseData()
	}
	mmGetNearestPulseData.t.Fatalf("Unexpected call to ActiveMock.GetNearestPulseData.")
	return
}

// GetNearestPulseDataAfterCounter returns a count of finished ActiveMock.GetNearestPulseData invocations
func (mmGetNearestPulseData *ActiveMock) GetNearestPulseDataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNearestPulseData.afterGetNearestPulseDataCounter)
}

// GetNearestPulseDataBeforeCounter returns a count of ActiveMock.GetNearestPulseData invocations
func (mmGetNearestPulseData *ActiveMock) GetNearestPulseDataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNearestPulseData.beforeGetNearestPulseDataCounter)
}

// MinimockGetNearestPulseDataDone returns true if the count of the GetNearestPulseData invocations corresponds
// the number of defined expectations
func (m *ActiveMock) MinimockGetNearestPulseDataDone() bool {
	for _, e := range m.GetNearestPulseDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetNearestPulseDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetNearestPulseDataCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNearestPulseData != nil && mm_atomic.LoadUint64(&m.afterGetNearestPulseDataCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetNearestPulseDataInspect logs each unmet expectation
func (m *ActiveMock) MinimockGetNearestPulseDataInspect() {
	for _, e := range m.GetNearestPulseDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ActiveMock.GetNearestPulseData")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetNearestPulseDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetNearestPulseDataCounter) < 1 {
		m.t.Error("Expected call to ActiveMock.GetNearestPulseData")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNearestPulseData != nil && mm_atomic.LoadUint64(&m.afterGetNearestPulseDataCounter) < 1 {
		m.t.Error("Expected call to ActiveMock.GetNearestPulseData")
	}
}

type mActiveMockGetOfflinePopulation struct {
	mock               *ActiveMock
	defaultExpectation *ActiveMockGetOfflinePopulationExpectation
	expectations       []*ActiveMockGetOfflinePopulationExpectation
}

// ActiveMockGetOfflinePopulationExpectation specifies expectation struct of the Active.GetOfflinePopulation
type ActiveMockGetOfflinePopulationExpectation struct {
	mock *ActiveMock

	results *ActiveMockGetOfflinePopulationResults
	Counter uint64
}

// ActiveMockGetOfflinePopulationResults contains results of the Active.GetOfflinePopulation
type ActiveMockGetOfflinePopulationResults struct {
	o1 OfflinePopulation
}

// Expect sets up expected params for Active.GetOfflinePopulation
func (mmGetOfflinePopulation *mActiveMockGetOfflinePopulation) Expect() *mActiveMockGetOfflinePopulation {
	if mmGetOfflinePopulation.mock.funcGetOfflinePopulation != nil {
		mmGetOfflinePopulation.mock.t.Fatalf("ActiveMock.GetOfflinePopulation mock is already set by Set")
	}

	if mmGetOfflinePopulation.defaultExpectation == nil {
		mmGetOfflinePopulation.defaultExpectation = &ActiveMockGetOfflinePopulationExpectation{}
	}

	return mmGetOfflinePopulation
}

// Inspect accepts an inspector function that has same arguments as the Active.GetOfflinePopulation
func (mmGetOfflinePopulation *mActiveMockGetOfflinePopulation) Inspect(f func()) *mActiveMockGetOfflinePopulation {
	if mmGetOfflinePopulation.mock.inspectFuncGetOfflinePopulation != nil {
		mmGetOfflinePopulation.mock.t.Fatalf("Inspect function is already set for ActiveMock.GetOfflinePopulation")
	}

	mmGetOfflinePopulation.mock.inspectFuncGetOfflinePopulation = f

	return mmGetOfflinePopulation
}

// Return sets up results that will be returned by Active.GetOfflinePopulation
func (mmGetOfflinePopulation *mActiveMockGetOfflinePopulation) Return(o1 OfflinePopulation) *ActiveMock {
	if mmGetOfflinePopulation.mock.funcGetOfflinePopulation != nil {
		mmGetOfflinePopulation.mock.t.Fatalf("ActiveMock.GetOfflinePopulation mock is already set by Set")
	}

	if mmGetOfflinePopulation.defaultExpectation == nil {
		mmGetOfflinePopulation.defaultExpectation = &ActiveMockGetOfflinePopulationExpectation{mock: mmGetOfflinePopulation.mock}
	}
	mmGetOfflinePopulation.defaultExpectation.results = &ActiveMockGetOfflinePopulationResults{o1}
	return mmGetOfflinePopulation.mock
}

//Set uses given function f to mock the Active.GetOfflinePopulation method
func (mmGetOfflinePopulation *mActiveMockGetOfflinePopulation) Set(f func() (o1 OfflinePopulation)) *ActiveMock {
	if mmGetOfflinePopulation.defaultExpectation != nil {
		mmGetOfflinePopulation.mock.t.Fatalf("Default expectation is already set for the Active.GetOfflinePopulation method")
	}

	if len(mmGetOfflinePopulation.expectations) > 0 {
		mmGetOfflinePopulation.mock.t.Fatalf("Some expectations are already set for the Active.GetOfflinePopulation method")
	}

	mmGetOfflinePopulation.mock.funcGetOfflinePopulation = f
	return mmGetOfflinePopulation.mock
}

// GetOfflinePopulation implements Active
func (mmGetOfflinePopulation *ActiveMock) GetOfflinePopulation() (o1 OfflinePopulation) {
	mm_atomic.AddUint64(&mmGetOfflinePopulation.beforeGetOfflinePopulationCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOfflinePopulation.afterGetOfflinePopulationCounter, 1)

	if mmGetOfflinePopulation.inspectFuncGetOfflinePopulation != nil {
		mmGetOfflinePopulation.inspectFuncGetOfflinePopulation()
	}

	if mmGetOfflinePopulation.GetOfflinePopulationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOfflinePopulation.GetOfflinePopulationMock.defaultExpectation.Counter, 1)

		results := mmGetOfflinePopulation.GetOfflinePopulationMock.defaultExpectation.results
		if results == nil {
			mmGetOfflinePopulation.t.Fatal("No results are set for the ActiveMock.GetOfflinePopulation")
		}
		return (*results).o1
	}
	if mmGetOfflinePopulation.funcGetOfflinePopulation != nil {
		return mmGetOfflinePopulation.funcGetOfflinePopulation()
	}
	mmGetOfflinePopulation.t.Fatalf("Unexpected call to ActiveMock.GetOfflinePopulation.")
	return
}

// GetOfflinePopulationAfterCounter returns a count of finished ActiveMock.GetOfflinePopulation invocations
func (mmGetOfflinePopulation *ActiveMock) GetOfflinePopulationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOfflinePopulation.afterGetOfflinePopulationCounter)
}

// GetOfflinePopulationBeforeCounter returns a count of ActiveMock.GetOfflinePopulation invocations
func (mmGetOfflinePopulation *ActiveMock) GetOfflinePopulationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOfflinePopulation.beforeGetOfflinePopulationCounter)
}

// MinimockGetOfflinePopulationDone returns true if the count of the GetOfflinePopulation invocations corresponds
// the number of defined expectations
func (m *ActiveMock) MinimockGetOfflinePopulationDone() bool {
	for _, e := range m.GetOfflinePopulationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOfflinePopulationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOfflinePopulationCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOfflinePopulation != nil && mm_atomic.LoadUint64(&m.afterGetOfflinePopulationCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetOfflinePopulationInspect logs each unmet expectation
func (m *ActiveMock) MinimockGetOfflinePopulationInspect() {
	for _, e := range m.GetOfflinePopulationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ActiveMock.GetOfflinePopulation")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOfflinePopulationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOfflinePopulationCounter) < 1 {
		m.t.Error("Expected call to ActiveMock.GetOfflinePopulation")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOfflinePopulation != nil && mm_atomic.LoadUint64(&m.afterGetOfflinePopulationCounter) < 1 {
		m.t.Error("Expected call to ActiveMock.GetOfflinePopulation")
	}
}

type mActiveMockGetOnlinePopulation struct {
	mock               *ActiveMock
	defaultExpectation *ActiveMockGetOnlinePopulationExpectation
	expectations       []*ActiveMockGetOnlinePopulationExpectation
}

// ActiveMockGetOnlinePopulationExpectation specifies expectation struct of the Active.GetOnlinePopulation
type ActiveMockGetOnlinePopulationExpectation struct {
	mock *ActiveMock

	results *ActiveMockGetOnlinePopulationResults
	Counter uint64
}

// ActiveMockGetOnlinePopulationResults contains results of the Active.GetOnlinePopulation
type ActiveMockGetOnlinePopulationResults struct {
	o1 OnlinePopulation
}

// Expect sets up expected params for Active.GetOnlinePopulation
func (mmGetOnlinePopulation *mActiveMockGetOnlinePopulation) Expect() *mActiveMockGetOnlinePopulation {
	if mmGetOnlinePopulation.mock.funcGetOnlinePopulation != nil {
		mmGetOnlinePopulation.mock.t.Fatalf("ActiveMock.GetOnlinePopulation mock is already set by Set")
	}

	if mmGetOnlinePopulation.defaultExpectation == nil {
		mmGetOnlinePopulation.defaultExpectation = &ActiveMockGetOnlinePopulationExpectation{}
	}

	return mmGetOnlinePopulation
}

// Inspect accepts an inspector function that has same arguments as the Active.GetOnlinePopulation
func (mmGetOnlinePopulation *mActiveMockGetOnlinePopulation) Inspect(f func()) *mActiveMockGetOnlinePopulation {
	if mmGetOnlinePopulation.mock.inspectFuncGetOnlinePopulation != nil {
		mmGetOnlinePopulation.mock.t.Fatalf("Inspect function is already set for ActiveMock.GetOnlinePopulation")
	}

	mmGetOnlinePopulation.mock.inspectFuncGetOnlinePopulation = f

	return mmGetOnlinePopulation
}

// Return sets up results that will be returned by Active.GetOnlinePopulation
func (mmGetOnlinePopulation *mActiveMockGetOnlinePopulation) Return(o1 OnlinePopulation) *ActiveMock {
	if mmGetOnlinePopulation.mock.funcGetOnlinePopulation != nil {
		mmGetOnlinePopulation.mock.t.Fatalf("ActiveMock.GetOnlinePopulation mock is already set by Set")
	}

	if mmGetOnlinePopulation.defaultExpectation == nil {
		mmGetOnlinePopulation.defaultExpectation = &ActiveMockGetOnlinePopulationExpectation{mock: mmGetOnlinePopulation.mock}
	}
	mmGetOnlinePopulation.defaultExpectation.results = &ActiveMockGetOnlinePopulationResults{o1}
	return mmGetOnlinePopulation.mock
}

//Set uses given function f to mock the Active.GetOnlinePopulation method
func (mmGetOnlinePopulation *mActiveMockGetOnlinePopulation) Set(f func() (o1 OnlinePopulation)) *ActiveMock {
	if mmGetOnlinePopulation.defaultExpectation != nil {
		mmGetOnlinePopulation.mock.t.Fatalf("Default expectation is already set for the Active.GetOnlinePopulation method")
	}

	if len(mmGetOnlinePopulation.expectations) > 0 {
		mmGetOnlinePopulation.mock.t.Fatalf("Some expectations are already set for the Active.GetOnlinePopulation method")
	}

	mmGetOnlinePopulation.mock.funcGetOnlinePopulation = f
	return mmGetOnlinePopulation.mock
}

// GetOnlinePopulation implements Active
func (mmGetOnlinePopulation *ActiveMock) GetOnlinePopulation() (o1 OnlinePopulation) {
	mm_atomic.AddUint64(&mmGetOnlinePopulation.beforeGetOnlinePopulationCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOnlinePopulation.afterGetOnlinePopulationCounter, 1)

	if mmGetOnlinePopulation.inspectFuncGetOnlinePopulation != nil {
		mmGetOnlinePopulation.inspectFuncGetOnlinePopulation()
	}

	if mmGetOnlinePopulation.GetOnlinePopulationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOnlinePopulation.GetOnlinePopulationMock.defaultExpectation.Counter, 1)

		results := mmGetOnlinePopulation.GetOnlinePopulationMock.defaultExpectation.results
		if results == nil {
			mmGetOnlinePopulation.t.Fatal("No results are set for the ActiveMock.GetOnlinePopulation")
		}
		return (*results).o1
	}
	if mmGetOnlinePopulation.funcGetOnlinePopulation != nil {
		return mmGetOnlinePopulation.funcGetOnlinePopulation()
	}
	mmGetOnlinePopulation.t.Fatalf("Unexpected call to ActiveMock.GetOnlinePopulation.")
	return
}

// GetOnlinePopulationAfterCounter returns a count of finished ActiveMock.GetOnlinePopulation invocations
func (mmGetOnlinePopulation *ActiveMock) GetOnlinePopulationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOnlinePopulation.afterGetOnlinePopulationCounter)
}

// GetOnlinePopulationBeforeCounter returns a count of ActiveMock.GetOnlinePopulation invocations
func (mmGetOnlinePopulation *ActiveMock) GetOnlinePopulationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOnlinePopulation.beforeGetOnlinePopulationCounter)
}

// MinimockGetOnlinePopulationDone returns true if the count of the GetOnlinePopulation invocations corresponds
// the number of defined expectations
func (m *ActiveMock) MinimockGetOnlinePopulationDone() bool {
	for _, e := range m.GetOnlinePopulationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOnlinePopulationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOnlinePopulationCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOnlinePopulation != nil && mm_atomic.LoadUint64(&m.afterGetOnlinePopulationCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetOnlinePopulationInspect logs each unmet expectation
func (m *ActiveMock) MinimockGetOnlinePopulationInspect() {
	for _, e := range m.GetOnlinePopulationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ActiveMock.GetOnlinePopulation")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOnlinePopulationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOnlinePopulationCounter) < 1 {
		m.t.Error("Expected call to ActiveMock.GetOnlinePopulation")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOnlinePopulation != nil && mm_atomic.LoadUint64(&m.afterGetOnlinePopulationCounter) < 1 {
		m.t.Error("Expected call to ActiveMock.GetOnlinePopulation")
	}
}

type mActiveMockGetProfileFactory struct {
	mock               *ActiveMock
	defaultExpectation *ActiveMockGetProfileFactoryExpectation
	expectations       []*ActiveMockGetProfileFactoryExpectation

	callArgs []*ActiveMockGetProfileFactoryParams
	mutex    sync.RWMutex
}

// ActiveMockGetProfileFactoryExpectation specifies expectation struct of the Active.GetProfileFactory
type ActiveMockGetProfileFactoryExpectation struct {
	mock    *ActiveMock
	params  *ActiveMockGetProfileFactoryParams
	results *ActiveMockGetProfileFactoryResults
	Counter uint64
}

// ActiveMockGetProfileFactoryParams contains parameters of the Active.GetProfileFactory
type ActiveMockGetProfileFactoryParams struct {
	ksf cryptkit.KeyStoreFactory
}

// ActiveMockGetProfileFactoryResults contains results of the Active.GetProfileFactory
type ActiveMockGetProfileFactoryResults struct {
	f1 profiles.Factory
}

// Expect sets up expected params for Active.GetProfileFactory
func (mmGetProfileFactory *mActiveMockGetProfileFactory) Expect(ksf cryptkit.KeyStoreFactory) *mActiveMockGetProfileFactory {
	if mmGetProfileFactory.mock.funcGetProfileFactory != nil {
		mmGetProfileFactory.mock.t.Fatalf("ActiveMock.GetProfileFactory mock is already set by Set")
	}

	if mmGetProfileFactory.defaultExpectation == nil {
		mmGetProfileFactory.defaultExpectation = &ActiveMockGetProfileFactoryExpectation{}
	}

	mmGetProfileFactory.defaultExpectation.params = &ActiveMockGetProfileFactoryParams{ksf}
	for _, e := range mmGetProfileFactory.expectations {
		if minimock.Equal(e.params, mmGetProfileFactory.defaultExpectation.params) {
			mmGetProfileFactory.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetProfileFactory.defaultExpectation.params)
		}
	}

	return mmGetProfileFactory
}

// Inspect accepts an inspector function that has same arguments as the Active.GetProfileFactory
func (mmGetProfileFactory *mActiveMockGetProfileFactory) Inspect(f func(ksf cryptkit.KeyStoreFactory)) *mActiveMockGetProfileFactory {
	if mmGetProfileFactory.mock.inspectFuncGetProfileFactory != nil {
		mmGetProfileFactory.mock.t.Fatalf("Inspect function is already set for ActiveMock.GetProfileFactory")
	}

	mmGetProfileFactory.mock.inspectFuncGetProfileFactory = f

	return mmGetProfileFactory
}

// Return sets up results that will be returned by Active.GetProfileFactory
func (mmGetProfileFactory *mActiveMockGetProfileFactory) Return(f1 profiles.Factory) *ActiveMock {
	if mmGetProfileFactory.mock.funcGetProfileFactory != nil {
		mmGetProfileFactory.mock.t.Fatalf("ActiveMock.GetProfileFactory mock is already set by Set")
	}

	if mmGetProfileFactory.defaultExpectation == nil {
		mmGetProfileFactory.defaultExpectation = &ActiveMockGetProfileFactoryExpectation{mock: mmGetProfileFactory.mock}
	}
	mmGetProfileFactory.defaultExpectation.results = &ActiveMockGetProfileFactoryResults{f1}
	return mmGetProfileFactory.mock
}

//Set uses given function f to mock the Active.GetProfileFactory method
func (mmGetProfileFactory *mActiveMockGetProfileFactory) Set(f func(ksf cryptkit.KeyStoreFactory) (f1 profiles.Factory)) *ActiveMock {
	if mmGetProfileFactory.defaultExpectation != nil {
		mmGetProfileFactory.mock.t.Fatalf("Default expectation is already set for the Active.GetProfileFactory method")
	}

	if len(mmGetProfileFactory.expectations) > 0 {
		mmGetProfileFactory.mock.t.Fatalf("Some expectations are already set for the Active.GetProfileFactory method")
	}

	mmGetProfileFactory.mock.funcGetProfileFactory = f
	return mmGetProfileFactory.mock
}

// When sets expectation for the Active.GetProfileFactory which will trigger the result defined by the following
// Then helper
func (mmGetProfileFactory *mActiveMockGetProfileFactory) When(ksf cryptkit.KeyStoreFactory) *ActiveMockGetProfileFactoryExpectation {
	if mmGetProfileFactory.mock.funcGetProfileFactory != nil {
		mmGetProfileFactory.mock.t.Fatalf("ActiveMock.GetProfileFactory mock is already set by Set")
	}

	expectation := &ActiveMockGetProfileFactoryExpectation{
		mock:   mmGetProfileFactory.mock,
		params: &ActiveMockGetProfileFactoryParams{ksf},
	}
	mmGetProfileFactory.expectations = append(mmGetProfileFactory.expectations, expectation)
	return expectation
}

// Then sets up Active.GetProfileFactory return parameters for the expectation previously defined by the When method
func (e *ActiveMockGetProfileFactoryExpectation) Then(f1 profiles.Factory) *ActiveMock {
	e.results = &ActiveMockGetProfileFactoryResults{f1}
	return e.mock
}

// GetProfileFactory implements Active
func (mmGetProfileFactory *ActiveMock) GetProfileFactory(ksf cryptkit.KeyStoreFactory) (f1 profiles.Factory) {
	mm_atomic.AddUint64(&mmGetProfileFactory.beforeGetProfileFactoryCounter, 1)
	defer mm_atomic.AddUint64(&mmGetProfileFactory.afterGetProfileFactoryCounter, 1)

	if mmGetProfileFactory.inspectFuncGetProfileFactory != nil {
		mmGetProfileFactory.inspectFuncGetProfileFactory(ksf)
	}

	params := &ActiveMockGetProfileFactoryParams{ksf}

	// Record call args
	mmGetProfileFactory.GetProfileFactoryMock.mutex.Lock()
	mmGetProfileFactory.GetProfileFactoryMock.callArgs = append(mmGetProfileFactory.GetProfileFactoryMock.callArgs, params)
	mmGetProfileFactory.GetProfileFactoryMock.mutex.Unlock()

	for _, e := range mmGetProfileFactory.GetProfileFactoryMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.f1
		}
	}

	if mmGetProfileFactory.GetProfileFactoryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetProfileFactory.GetProfileFactoryMock.defaultExpectation.Counter, 1)
		want := mmGetProfileFactory.GetProfileFactoryMock.defaultExpectation.params
		got := ActiveMockGetProfileFactoryParams{ksf}
		if want != nil && !minimock.Equal(*want, got) {
			mmGetProfileFactory.t.Errorf("ActiveMock.GetProfileFactory got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmGetProfileFactory.GetProfileFactoryMock.defaultExpectation.results
		if results == nil {
			mmGetProfileFactory.t.Fatal("No results are set for the ActiveMock.GetProfileFactory")
		}
		return (*results).f1
	}
	if mmGetProfileFactory.funcGetProfileFactory != nil {
		return mmGetProfileFactory.funcGetProfileFactory(ksf)
	}
	mmGetProfileFactory.t.Fatalf("Unexpected call to ActiveMock.GetProfileFactory. %v", ksf)
	return
}

// GetProfileFactoryAfterCounter returns a count of finished ActiveMock.GetProfileFactory invocations
func (mmGetProfileFactory *ActiveMock) GetProfileFactoryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetProfileFactory.afterGetProfileFactoryCounter)
}

// GetProfileFactoryBeforeCounter returns a count of ActiveMock.GetProfileFactory invocations
func (mmGetProfileFactory *ActiveMock) GetProfileFactoryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetProfileFactory.beforeGetProfileFactoryCounter)
}

// Calls returns a list of arguments used in each call to ActiveMock.GetProfileFactory.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetProfileFactory *mActiveMockGetProfileFactory) Calls() []*ActiveMockGetProfileFactoryParams {
	mmGetProfileFactory.mutex.RLock()

	argCopy := make([]*ActiveMockGetProfileFactoryParams, len(mmGetProfileFactory.callArgs))
	copy(argCopy, mmGetProfileFactory.callArgs)

	mmGetProfileFactory.mutex.RUnlock()

	return argCopy
}

// MinimockGetProfileFactoryDone returns true if the count of the GetProfileFactory invocations corresponds
// the number of defined expectations
func (m *ActiveMock) MinimockGetProfileFactoryDone() bool {
	for _, e := range m.GetProfileFactoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetProfileFactoryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetProfileFactoryCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetProfileFactory != nil && mm_atomic.LoadUint64(&m.afterGetProfileFactoryCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetProfileFactoryInspect logs each unmet expectation
func (m *ActiveMock) MinimockGetProfileFactoryInspect() {
	for _, e := range m.GetProfileFactoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ActiveMock.GetProfileFactory with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetProfileFactoryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetProfileFactoryCounter) < 1 {
		if m.GetProfileFactoryMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ActiveMock.GetProfileFactory")
		} else {
			m.t.Errorf("Expected call to ActiveMock.GetProfileFactory with params: %#v", *m.GetProfileFactoryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetProfileFactory != nil && mm_atomic.LoadUint64(&m.afterGetProfileFactoryCounter) < 1 {
		m.t.Error("Expected call to ActiveMock.GetProfileFactory")
	}
}

type mActiveMockGetPulseData struct {
	mock               *ActiveMock
	defaultExpectation *ActiveMockGetPulseDataExpectation
	expectations       []*ActiveMockGetPulseDataExpectation
}

// ActiveMockGetPulseDataExpectation specifies expectation struct of the Active.GetPulseData
type ActiveMockGetPulseDataExpectation struct {
	mock *ActiveMock

	results *ActiveMockGetPulseDataResults
	Counter uint64
}

// ActiveMockGetPulseDataResults contains results of the Active.GetPulseData
type ActiveMockGetPulseDataResults struct {
	d1 pulse.Data
}

// Expect sets up expected params for Active.GetPulseData
func (mmGetPulseData *mActiveMockGetPulseData) Expect() *mActiveMockGetPulseData {
	if mmGetPulseData.mock.funcGetPulseData != nil {
		mmGetPulseData.mock.t.Fatalf("ActiveMock.GetPulseData mock is already set by Set")
	}

	if mmGetPulseData.defaultExpectation == nil {
		mmGetPulseData.defaultExpectation = &ActiveMockGetPulseDataExpectation{}
	}

	return mmGetPulseData
}

// Inspect accepts an inspector function that has same arguments as the Active.GetPulseData
func (mmGetPulseData *mActiveMockGetPulseData) Inspect(f func()) *mActiveMockGetPulseData {
	if mmGetPulseData.mock.inspectFuncGetPulseData != nil {
		mmGetPulseData.mock.t.Fatalf("Inspect function is already set for ActiveMock.GetPulseData")
	}

	mmGetPulseData.mock.inspectFuncGetPulseData = f

	return mmGetPulseData
}

// Return sets up results that will be returned by Active.GetPulseData
func (mmGetPulseData *mActiveMockGetPulseData) Return(d1 pulse.Data) *ActiveMock {
	if mmGetPulseData.mock.funcGetPulseData != nil {
		mmGetPulseData.mock.t.Fatalf("ActiveMock.GetPulseData mock is already set by Set")
	}

	if mmGetPulseData.defaultExpectation == nil {
		mmGetPulseData.defaultExpectation = &ActiveMockGetPulseDataExpectation{mock: mmGetPulseData.mock}
	}
	mmGetPulseData.defaultExpectation.results = &ActiveMockGetPulseDataResults{d1}
	return mmGetPulseData.mock
}

//Set uses given function f to mock the Active.GetPulseData method
func (mmGetPulseData *mActiveMockGetPulseData) Set(f func() (d1 pulse.Data)) *ActiveMock {
	if mmGetPulseData.defaultExpectation != nil {
		mmGetPulseData.mock.t.Fatalf("Default expectation is already set for the Active.GetPulseData method")
	}

	if len(mmGetPulseData.expectations) > 0 {
		mmGetPulseData.mock.t.Fatalf("Some expectations are already set for the Active.GetPulseData method")
	}

	mmGetPulseData.mock.funcGetPulseData = f
	return mmGetPulseData.mock
}

// GetPulseData implements Active
func (mmGetPulseData *ActiveMock) GetPulseData() (d1 pulse.Data) {
	mm_atomic.AddUint64(&mmGetPulseData.beforeGetPulseDataCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPulseData.afterGetPulseDataCounter, 1)

	if mmGetPulseData.inspectFuncGetPulseData != nil {
		mmGetPulseData.inspectFuncGetPulseData()
	}

	if mmGetPulseData.GetPulseDataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPulseData.GetPulseDataMock.defaultExpectation.Counter, 1)

		results := mmGetPulseData.GetPulseDataMock.defaultExpectation.results
		if results == nil {
			mmGetPulseData.t.Fatal("No results are set for the ActiveMock.GetPulseData")
		}
		return (*results).d1
	}
	if mmGetPulseData.funcGetPulseData != nil {
		return mmGetPulseData.funcGetPulseData()
	}
	mmGetPulseData.t.Fatalf("Unexpected call to ActiveMock.GetPulseData.")
	return
}

// GetPulseDataAfterCounter returns a count of finished ActiveMock.GetPulseData invocations
func (mmGetPulseData *ActiveMock) GetPulseDataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPulseData.afterGetPulseDataCounter)
}

// GetPulseDataBeforeCounter returns a count of ActiveMock.GetPulseData invocations
func (mmGetPulseData *ActiveMock) GetPulseDataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPulseData.beforeGetPulseDataCounter)
}

// MinimockGetPulseDataDone returns true if the count of the GetPulseData invocations corresponds
// the number of defined expectations
func (m *ActiveMock) MinimockGetPulseDataDone() bool {
	for _, e := range m.GetPulseDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPulseDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPulseDataCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPulseData != nil && mm_atomic.LoadUint64(&m.afterGetPulseDataCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPulseDataInspect logs each unmet expectation
func (m *ActiveMock) MinimockGetPulseDataInspect() {
	for _, e := range m.GetPulseDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ActiveMock.GetPulseData")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPulseDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPulseDataCounter) < 1 {
		m.t.Error("Expected call to ActiveMock.GetPulseData")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPulseData != nil && mm_atomic.LoadUint64(&m.afterGetPulseDataCounter) < 1 {
		m.t.Error("Expected call to ActiveMock.GetPulseData")
	}
}

type mActiveMockGetPulseNumber struct {
	mock               *ActiveMock
	defaultExpectation *ActiveMockGetPulseNumberExpectation
	expectations       []*ActiveMockGetPulseNumberExpectation
}

// ActiveMockGetPulseNumberExpectation specifies expectation struct of the Active.GetPulseNumber
type ActiveMockGetPulseNumberExpectation struct {
	mock *ActiveMock

	results *ActiveMockGetPulseNumberResults
	Counter uint64
}

// ActiveMockGetPulseNumberResults contains results of the Active.GetPulseNumber
type ActiveMockGetPulseNumberResults struct {
	n1 pulse.Number
}

// Expect sets up expected params for Active.GetPulseNumber
func (mmGetPulseNumber *mActiveMockGetPulseNumber) Expect() *mActiveMockGetPulseNumber {
	if mmGetPulseNumber.mock.funcGetPulseNumber != nil {
		mmGetPulseNumber.mock.t.Fatalf("ActiveMock.GetPulseNumber mock is already set by Set")
	}

	if mmGetPulseNumber.defaultExpectation == nil {
		mmGetPulseNumber.defaultExpectation = &ActiveMockGetPulseNumberExpectation{}
	}

	return mmGetPulseNumber
}

// Inspect accepts an inspector function that has same arguments as the Active.GetPulseNumber
func (mmGetPulseNumber *mActiveMockGetPulseNumber) Inspect(f func()) *mActiveMockGetPulseNumber {
	if mmGetPulseNumber.mock.inspectFuncGetPulseNumber != nil {
		mmGetPulseNumber.mock.t.Fatalf("Inspect function is already set for ActiveMock.GetPulseNumber")
	}

	mmGetPulseNumber.mock.inspectFuncGetPulseNumber = f

	return mmGetPulseNumber
}

// Return sets up results that will be returned by Active.GetPulseNumber
func (mmGetPulseNumber *mActiveMockGetPulseNumber) Return(n1 pulse.Number) *ActiveMock {
	if mmGetPulseNumber.mock.funcGetPulseNumber != nil {
		mmGetPulseNumber.mock.t.Fatalf("ActiveMock.GetPulseNumber mock is already set by Set")
	}

	if mmGetPulseNumber.defaultExpectation == nil {
		mmGetPulseNumber.defaultExpectation = &ActiveMockGetPulseNumberExpectation{mock: mmGetPulseNumber.mock}
	}
	mmGetPulseNumber.defaultExpectation.results = &ActiveMockGetPulseNumberResults{n1}
	return mmGetPulseNumber.mock
}

//Set uses given function f to mock the Active.GetPulseNumber method
func (mmGetPulseNumber *mActiveMockGetPulseNumber) Set(f func() (n1 pulse.Number)) *ActiveMock {
	if mmGetPulseNumber.defaultExpectation != nil {
		mmGetPulseNumber.mock.t.Fatalf("Default expectation is already set for the Active.GetPulseNumber method")
	}

	if len(mmGetPulseNumber.expectations) > 0 {
		mmGetPulseNumber.mock.t.Fatalf("Some expectations are already set for the Active.GetPulseNumber method")
	}

	mmGetPulseNumber.mock.funcGetPulseNumber = f
	return mmGetPulseNumber.mock
}

// GetPulseNumber implements Active
func (mmGetPulseNumber *ActiveMock) GetPulseNumber() (n1 pulse.Number) {
	mm_atomic.AddUint64(&mmGetPulseNumber.beforeGetPulseNumberCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPulseNumber.afterGetPulseNumberCounter, 1)

	if mmGetPulseNumber.inspectFuncGetPulseNumber != nil {
		mmGetPulseNumber.inspectFuncGetPulseNumber()
	}

	if mmGetPulseNumber.GetPulseNumberMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPulseNumber.GetPulseNumberMock.defaultExpectation.Counter, 1)

		results := mmGetPulseNumber.GetPulseNumberMock.defaultExpectation.results
		if results == nil {
			mmGetPulseNumber.t.Fatal("No results are set for the ActiveMock.GetPulseNumber")
		}
		return (*results).n1
	}
	if mmGetPulseNumber.funcGetPulseNumber != nil {
		return mmGetPulseNumber.funcGetPulseNumber()
	}
	mmGetPulseNumber.t.Fatalf("Unexpected call to ActiveMock.GetPulseNumber.")
	return
}

// GetPulseNumberAfterCounter returns a count of finished ActiveMock.GetPulseNumber invocations
func (mmGetPulseNumber *ActiveMock) GetPulseNumberAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPulseNumber.afterGetPulseNumberCounter)
}

// GetPulseNumberBeforeCounter returns a count of ActiveMock.GetPulseNumber invocations
func (mmGetPulseNumber *ActiveMock) GetPulseNumberBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPulseNumber.beforeGetPulseNumberCounter)
}

// MinimockGetPulseNumberDone returns true if the count of the GetPulseNumber invocations corresponds
// the number of defined expectations
func (m *ActiveMock) MinimockGetPulseNumberDone() bool {
	for _, e := range m.GetPulseNumberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPulseNumberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPulseNumberCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPulseNumber != nil && mm_atomic.LoadUint64(&m.afterGetPulseNumberCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPulseNumberInspect logs each unmet expectation
func (m *ActiveMock) MinimockGetPulseNumberInspect() {
	for _, e := range m.GetPulseNumberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ActiveMock.GetPulseNumber")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPulseNumberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPulseNumberCounter) < 1 {
		m.t.Error("Expected call to ActiveMock.GetPulseNumber")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPulseNumber != nil && mm_atomic.LoadUint64(&m.afterGetPulseNumberCounter) < 1 {
		m.t.Error("Expected call to ActiveMock.GetPulseNumber")
	}
}

type mActiveMockIsActive struct {
	mock               *ActiveMock
	defaultExpectation *ActiveMockIsActiveExpectation
	expectations       []*ActiveMockIsActiveExpectation
}

// ActiveMockIsActiveExpectation specifies expectation struct of the Active.IsActive
type ActiveMockIsActiveExpectation struct {
	mock *ActiveMock

	results *ActiveMockIsActiveResults
	Counter uint64
}

// ActiveMockIsActiveResults contains results of the Active.IsActive
type ActiveMockIsActiveResults struct {
	b1 bool
}

// Expect sets up expected params for Active.IsActive
func (mmIsActive *mActiveMockIsActive) Expect() *mActiveMockIsActive {
	if mmIsActive.mock.funcIsActive != nil {
		mmIsActive.mock.t.Fatalf("ActiveMock.IsActive mock is already set by Set")
	}

	if mmIsActive.defaultExpectation == nil {
		mmIsActive.defaultExpectation = &ActiveMockIsActiveExpectation{}
	}

	return mmIsActive
}

// Inspect accepts an inspector function that has same arguments as the Active.IsActive
func (mmIsActive *mActiveMockIsActive) Inspect(f func()) *mActiveMockIsActive {
	if mmIsActive.mock.inspectFuncIsActive != nil {
		mmIsActive.mock.t.Fatalf("Inspect function is already set for ActiveMock.IsActive")
	}

	mmIsActive.mock.inspectFuncIsActive = f

	return mmIsActive
}

// Return sets up results that will be returned by Active.IsActive
func (mmIsActive *mActiveMockIsActive) Return(b1 bool) *ActiveMock {
	if mmIsActive.mock.funcIsActive != nil {
		mmIsActive.mock.t.Fatalf("ActiveMock.IsActive mock is already set by Set")
	}

	if mmIsActive.defaultExpectation == nil {
		mmIsActive.defaultExpectation = &ActiveMockIsActiveExpectation{mock: mmIsActive.mock}
	}
	mmIsActive.defaultExpectation.results = &ActiveMockIsActiveResults{b1}
	return mmIsActive.mock
}

//Set uses given function f to mock the Active.IsActive method
func (mmIsActive *mActiveMockIsActive) Set(f func() (b1 bool)) *ActiveMock {
	if mmIsActive.defaultExpectation != nil {
		mmIsActive.mock.t.Fatalf("Default expectation is already set for the Active.IsActive method")
	}

	if len(mmIsActive.expectations) > 0 {
		mmIsActive.mock.t.Fatalf("Some expectations are already set for the Active.IsActive method")
	}

	mmIsActive.mock.funcIsActive = f
	return mmIsActive.mock
}

// IsActive implements Active
func (mmIsActive *ActiveMock) IsActive() (b1 bool) {
	mm_atomic.AddUint64(&mmIsActive.beforeIsActiveCounter, 1)
	defer mm_atomic.AddUint64(&mmIsActive.afterIsActiveCounter, 1)

	if mmIsActive.inspectFuncIsActive != nil {
		mmIsActive.inspectFuncIsActive()
	}

	if mmIsActive.IsActiveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsActive.IsActiveMock.defaultExpectation.Counter, 1)

		results := mmIsActive.IsActiveMock.defaultExpectation.results
		if results == nil {
			mmIsActive.t.Fatal("No results are set for the ActiveMock.IsActive")
		}
		return (*results).b1
	}
	if mmIsActive.funcIsActive != nil {
		return mmIsActive.funcIsActive()
	}
	mmIsActive.t.Fatalf("Unexpected call to ActiveMock.IsActive.")
	return
}

// IsActiveAfterCounter returns a count of finished ActiveMock.IsActive invocations
func (mmIsActive *ActiveMock) IsActiveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsActive.afterIsActiveCounter)
}

// IsActiveBeforeCounter returns a count of ActiveMock.IsActive invocations
func (mmIsActive *ActiveMock) IsActiveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsActive.beforeIsActiveCounter)
}

// MinimockIsActiveDone returns true if the count of the IsActive invocations corresponds
// the number of defined expectations
func (m *ActiveMock) MinimockIsActiveDone() bool {
	for _, e := range m.IsActiveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsActiveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsActiveCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsActive != nil && mm_atomic.LoadUint64(&m.afterIsActiveCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsActiveInspect logs each unmet expectation
func (m *ActiveMock) MinimockIsActiveInspect() {
	for _, e := range m.IsActiveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ActiveMock.IsActive")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsActiveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsActiveCounter) < 1 {
		m.t.Error("Expected call to ActiveMock.IsActive")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsActive != nil && mm_atomic.LoadUint64(&m.afterIsActiveCounter) < 1 {
		m.t.Error("Expected call to ActiveMock.IsActive")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ActiveMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateBuilderInspect()

		m.MinimockGetCensusStateInspect()

		m.MinimockGetCloudStateHashInspect()

		m.MinimockGetEvictedPopulationInspect()

		m.MinimockGetExpectedPulseNumberInspect()

		m.MinimockGetGlobulaStateHashInspect()

		m.MinimockGetMandateRegistryInspect()

		m.MinimockGetMisbehaviorRegistryInspect()

		m.MinimockGetNearestPulseDataInspect()

		m.MinimockGetOfflinePopulationInspect()

		m.MinimockGetOnlinePopulationInspect()

		m.MinimockGetProfileFactoryInspect()

		m.MinimockGetPulseDataInspect()

		m.MinimockGetPulseNumberInspect()

		m.MinimockIsActiveInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ActiveMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ActiveMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateBuilderDone() &&
		m.MinimockGetCensusStateDone() &&
		m.MinimockGetCloudStateHashDone() &&
		m.MinimockGetEvictedPopulationDone() &&
		m.MinimockGetExpectedPulseNumberDone() &&
		m.MinimockGetGlobulaStateHashDone() &&
		m.MinimockGetMandateRegistryDone() &&
		m.MinimockGetMisbehaviorRegistryDone() &&
		m.MinimockGetNearestPulseDataDone() &&
		m.MinimockGetOfflinePopulationDone() &&
		m.MinimockGetOnlinePopulationDone() &&
		m.MinimockGetProfileFactoryDone() &&
		m.MinimockGetPulseDataDone() &&
		m.MinimockGetPulseNumberDone() &&
		m.MinimockIsActiveDone()
}
