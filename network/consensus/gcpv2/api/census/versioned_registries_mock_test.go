package census

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/pulse"
)

// VersionedRegistriesMock implements VersionedRegistries
type VersionedRegistriesMock struct {
	t minimock.Tester

	funcCommitNextPulse          func(pd pulse.Data, population OnlinePopulation) (v1 VersionedRegistries)
	inspectFuncCommitNextPulse   func(pd pulse.Data, population OnlinePopulation)
	afterCommitNextPulseCounter  uint64
	beforeCommitNextPulseCounter uint64
	CommitNextPulseMock          mVersionedRegistriesMockCommitNextPulse

	funcGetMandateRegistry          func() (m1 MandateRegistry)
	inspectFuncGetMandateRegistry   func()
	afterGetMandateRegistryCounter  uint64
	beforeGetMandateRegistryCounter uint64
	GetMandateRegistryMock          mVersionedRegistriesMockGetMandateRegistry

	funcGetMisbehaviorRegistry          func() (m1 MisbehaviorRegistry)
	inspectFuncGetMisbehaviorRegistry   func()
	afterGetMisbehaviorRegistryCounter  uint64
	beforeGetMisbehaviorRegistryCounter uint64
	GetMisbehaviorRegistryMock          mVersionedRegistriesMockGetMisbehaviorRegistry

	funcGetNearestValidPulseData          func() (d1 pulse.Data)
	inspectFuncGetNearestValidPulseData   func()
	afterGetNearestValidPulseDataCounter  uint64
	beforeGetNearestValidPulseDataCounter uint64
	GetNearestValidPulseDataMock          mVersionedRegistriesMockGetNearestValidPulseData

	funcGetOfflinePopulation          func() (o1 OfflinePopulation)
	inspectFuncGetOfflinePopulation   func()
	afterGetOfflinePopulationCounter  uint64
	beforeGetOfflinePopulationCounter uint64
	GetOfflinePopulationMock          mVersionedRegistriesMockGetOfflinePopulation

	funcGetVersionPulseData          func() (d1 pulse.Data)
	inspectFuncGetVersionPulseData   func()
	afterGetVersionPulseDataCounter  uint64
	beforeGetVersionPulseDataCounter uint64
	GetVersionPulseDataMock          mVersionedRegistriesMockGetVersionPulseData
}

// NewVersionedRegistriesMock returns a mock for VersionedRegistries
func NewVersionedRegistriesMock(t minimock.Tester) *VersionedRegistriesMock {
	m := &VersionedRegistriesMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CommitNextPulseMock = mVersionedRegistriesMockCommitNextPulse{mock: m}
	m.CommitNextPulseMock.callArgs = []*VersionedRegistriesMockCommitNextPulseParams{}

	m.GetMandateRegistryMock = mVersionedRegistriesMockGetMandateRegistry{mock: m}

	m.GetMisbehaviorRegistryMock = mVersionedRegistriesMockGetMisbehaviorRegistry{mock: m}

	m.GetNearestValidPulseDataMock = mVersionedRegistriesMockGetNearestValidPulseData{mock: m}

	m.GetOfflinePopulationMock = mVersionedRegistriesMockGetOfflinePopulation{mock: m}

	m.GetVersionPulseDataMock = mVersionedRegistriesMockGetVersionPulseData{mock: m}

	return m
}

type mVersionedRegistriesMockCommitNextPulse struct {
	mock               *VersionedRegistriesMock
	defaultExpectation *VersionedRegistriesMockCommitNextPulseExpectation
	expectations       []*VersionedRegistriesMockCommitNextPulseExpectation

	callArgs []*VersionedRegistriesMockCommitNextPulseParams
	mutex    sync.RWMutex
}

// VersionedRegistriesMockCommitNextPulseExpectation specifies expectation struct of the VersionedRegistries.CommitNextPulse
type VersionedRegistriesMockCommitNextPulseExpectation struct {
	mock    *VersionedRegistriesMock
	params  *VersionedRegistriesMockCommitNextPulseParams
	results *VersionedRegistriesMockCommitNextPulseResults
	Counter uint64
}

// VersionedRegistriesMockCommitNextPulseParams contains parameters of the VersionedRegistries.CommitNextPulse
type VersionedRegistriesMockCommitNextPulseParams struct {
	pd         pulse.Data
	population OnlinePopulation
}

// VersionedRegistriesMockCommitNextPulseResults contains results of the VersionedRegistries.CommitNextPulse
type VersionedRegistriesMockCommitNextPulseResults struct {
	v1 VersionedRegistries
}

// Expect sets up expected params for VersionedRegistries.CommitNextPulse
func (mmCommitNextPulse *mVersionedRegistriesMockCommitNextPulse) Expect(pd pulse.Data, population OnlinePopulation) *mVersionedRegistriesMockCommitNextPulse {
	if mmCommitNextPulse.mock.funcCommitNextPulse != nil {
		mmCommitNextPulse.mock.t.Fatalf("VersionedRegistriesMock.CommitNextPulse mock is already set by Set")
	}

	if mmCommitNextPulse.defaultExpectation == nil {
		mmCommitNextPulse.defaultExpectation = &VersionedRegistriesMockCommitNextPulseExpectation{}
	}

	mmCommitNextPulse.defaultExpectation.params = &VersionedRegistriesMockCommitNextPulseParams{pd, population}
	for _, e := range mmCommitNextPulse.expectations {
		if minimock.Equal(e.params, mmCommitNextPulse.defaultExpectation.params) {
			mmCommitNextPulse.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCommitNextPulse.defaultExpectation.params)
		}
	}

	return mmCommitNextPulse
}

// Inspect accepts an inspector function that has same arguments as the VersionedRegistries.CommitNextPulse
func (mmCommitNextPulse *mVersionedRegistriesMockCommitNextPulse) Inspect(f func(pd pulse.Data, population OnlinePopulation)) *mVersionedRegistriesMockCommitNextPulse {
	if mmCommitNextPulse.mock.inspectFuncCommitNextPulse != nil {
		mmCommitNextPulse.mock.t.Fatalf("Inspect function is already set for VersionedRegistriesMock.CommitNextPulse")
	}

	mmCommitNextPulse.mock.inspectFuncCommitNextPulse = f

	return mmCommitNextPulse
}

// Return sets up results that will be returned by VersionedRegistries.CommitNextPulse
func (mmCommitNextPulse *mVersionedRegistriesMockCommitNextPulse) Return(v1 VersionedRegistries) *VersionedRegistriesMock {
	if mmCommitNextPulse.mock.funcCommitNextPulse != nil {
		mmCommitNextPulse.mock.t.Fatalf("VersionedRegistriesMock.CommitNextPulse mock is already set by Set")
	}

	if mmCommitNextPulse.defaultExpectation == nil {
		mmCommitNextPulse.defaultExpectation = &VersionedRegistriesMockCommitNextPulseExpectation{mock: mmCommitNextPulse.mock}
	}
	mmCommitNextPulse.defaultExpectation.results = &VersionedRegistriesMockCommitNextPulseResults{v1}
	return mmCommitNextPulse.mock
}

//Set uses given function f to mock the VersionedRegistries.CommitNextPulse method
func (mmCommitNextPulse *mVersionedRegistriesMockCommitNextPulse) Set(f func(pd pulse.Data, population OnlinePopulation) (v1 VersionedRegistries)) *VersionedRegistriesMock {
	if mmCommitNextPulse.defaultExpectation != nil {
		mmCommitNextPulse.mock.t.Fatalf("Default expectation is already set for the VersionedRegistries.CommitNextPulse method")
	}

	if len(mmCommitNextPulse.expectations) > 0 {
		mmCommitNextPulse.mock.t.Fatalf("Some expectations are already set for the VersionedRegistries.CommitNextPulse method")
	}

	mmCommitNextPulse.mock.funcCommitNextPulse = f
	return mmCommitNextPulse.mock
}

// When sets expectation for the VersionedRegistries.CommitNextPulse which will trigger the result defined by the following
// Then helper
func (mmCommitNextPulse *mVersionedRegistriesMockCommitNextPulse) When(pd pulse.Data, population OnlinePopulation) *VersionedRegistriesMockCommitNextPulseExpectation {
	if mmCommitNextPulse.mock.funcCommitNextPulse != nil {
		mmCommitNextPulse.mock.t.Fatalf("VersionedRegistriesMock.CommitNextPulse mock is already set by Set")
	}

	expectation := &VersionedRegistriesMockCommitNextPulseExpectation{
		mock:   mmCommitNextPulse.mock,
		params: &VersionedRegistriesMockCommitNextPulseParams{pd, population},
	}
	mmCommitNextPulse.expectations = append(mmCommitNextPulse.expectations, expectation)
	return expectation
}

// Then sets up VersionedRegistries.CommitNextPulse return parameters for the expectation previously defined by the When method
func (e *VersionedRegistriesMockCommitNextPulseExpectation) Then(v1 VersionedRegistries) *VersionedRegistriesMock {
	e.results = &VersionedRegistriesMockCommitNextPulseResults{v1}
	return e.mock
}

// CommitNextPulse implements VersionedRegistries
func (mmCommitNextPulse *VersionedRegistriesMock) CommitNextPulse(pd pulse.Data, population OnlinePopulation) (v1 VersionedRegistries) {
	mm_atomic.AddUint64(&mmCommitNextPulse.beforeCommitNextPulseCounter, 1)
	defer mm_atomic.AddUint64(&mmCommitNextPulse.afterCommitNextPulseCounter, 1)

	if mmCommitNextPulse.inspectFuncCommitNextPulse != nil {
		mmCommitNextPulse.inspectFuncCommitNextPulse(pd, population)
	}

	params := &VersionedRegistriesMockCommitNextPulseParams{pd, population}

	// Record call args
	mmCommitNextPulse.CommitNextPulseMock.mutex.Lock()
	mmCommitNextPulse.CommitNextPulseMock.callArgs = append(mmCommitNextPulse.CommitNextPulseMock.callArgs, params)
	mmCommitNextPulse.CommitNextPulseMock.mutex.Unlock()

	for _, e := range mmCommitNextPulse.CommitNextPulseMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.v1
		}
	}

	if mmCommitNextPulse.CommitNextPulseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCommitNextPulse.CommitNextPulseMock.defaultExpectation.Counter, 1)
		want := mmCommitNextPulse.CommitNextPulseMock.defaultExpectation.params
		got := VersionedRegistriesMockCommitNextPulseParams{pd, population}
		if want != nil && !minimock.Equal(*want, got) {
			mmCommitNextPulse.t.Errorf("VersionedRegistriesMock.CommitNextPulse got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmCommitNextPulse.CommitNextPulseMock.defaultExpectation.results
		if results == nil {
			mmCommitNextPulse.t.Fatal("No results are set for the VersionedRegistriesMock.CommitNextPulse")
		}
		return (*results).v1
	}
	if mmCommitNextPulse.funcCommitNextPulse != nil {
		return mmCommitNextPulse.funcCommitNextPulse(pd, population)
	}
	mmCommitNextPulse.t.Fatalf("Unexpected call to VersionedRegistriesMock.CommitNextPulse. %v %v", pd, population)
	return
}

// CommitNextPulseAfterCounter returns a count of finished VersionedRegistriesMock.CommitNextPulse invocations
func (mmCommitNextPulse *VersionedRegistriesMock) CommitNextPulseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommitNextPulse.afterCommitNextPulseCounter)
}

// CommitNextPulseBeforeCounter returns a count of VersionedRegistriesMock.CommitNextPulse invocations
func (mmCommitNextPulse *VersionedRegistriesMock) CommitNextPulseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommitNextPulse.beforeCommitNextPulseCounter)
}

// Calls returns a list of arguments used in each call to VersionedRegistriesMock.CommitNextPulse.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCommitNextPulse *mVersionedRegistriesMockCommitNextPulse) Calls() []*VersionedRegistriesMockCommitNextPulseParams {
	mmCommitNextPulse.mutex.RLock()

	argCopy := make([]*VersionedRegistriesMockCommitNextPulseParams, len(mmCommitNextPulse.callArgs))
	copy(argCopy, mmCommitNextPulse.callArgs)

	mmCommitNextPulse.mutex.RUnlock()

	return argCopy
}

// MinimockCommitNextPulseDone returns true if the count of the CommitNextPulse invocations corresponds
// the number of defined expectations
func (m *VersionedRegistriesMock) MinimockCommitNextPulseDone() bool {
	for _, e := range m.CommitNextPulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CommitNextPulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCommitNextPulseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommitNextPulse != nil && mm_atomic.LoadUint64(&m.afterCommitNextPulseCounter) < 1 {
		return false
	}
	return true
}

// MinimockCommitNextPulseInspect logs each unmet expectation
func (m *VersionedRegistriesMock) MinimockCommitNextPulseInspect() {
	for _, e := range m.CommitNextPulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to VersionedRegistriesMock.CommitNextPulse with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CommitNextPulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCommitNextPulseCounter) < 1 {
		if m.CommitNextPulseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to VersionedRegistriesMock.CommitNextPulse")
		} else {
			m.t.Errorf("Expected call to VersionedRegistriesMock.CommitNextPulse with params: %#v", *m.CommitNextPulseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommitNextPulse != nil && mm_atomic.LoadUint64(&m.afterCommitNextPulseCounter) < 1 {
		m.t.Error("Expected call to VersionedRegistriesMock.CommitNextPulse")
	}
}

type mVersionedRegistriesMockGetMandateRegistry struct {
	mock               *VersionedRegistriesMock
	defaultExpectation *VersionedRegistriesMockGetMandateRegistryExpectation
	expectations       []*VersionedRegistriesMockGetMandateRegistryExpectation
}

// VersionedRegistriesMockGetMandateRegistryExpectation specifies expectation struct of the VersionedRegistries.GetMandateRegistry
type VersionedRegistriesMockGetMandateRegistryExpectation struct {
	mock *VersionedRegistriesMock

	results *VersionedRegistriesMockGetMandateRegistryResults
	Counter uint64
}

// VersionedRegistriesMockGetMandateRegistryResults contains results of the VersionedRegistries.GetMandateRegistry
type VersionedRegistriesMockGetMandateRegistryResults struct {
	m1 MandateRegistry
}

// Expect sets up expected params for VersionedRegistries.GetMandateRegistry
func (mmGetMandateRegistry *mVersionedRegistriesMockGetMandateRegistry) Expect() *mVersionedRegistriesMockGetMandateRegistry {
	if mmGetMandateRegistry.mock.funcGetMandateRegistry != nil {
		mmGetMandateRegistry.mock.t.Fatalf("VersionedRegistriesMock.GetMandateRegistry mock is already set by Set")
	}

	if mmGetMandateRegistry.defaultExpectation == nil {
		mmGetMandateRegistry.defaultExpectation = &VersionedRegistriesMockGetMandateRegistryExpectation{}
	}

	return mmGetMandateRegistry
}

// Inspect accepts an inspector function that has same arguments as the VersionedRegistries.GetMandateRegistry
func (mmGetMandateRegistry *mVersionedRegistriesMockGetMandateRegistry) Inspect(f func()) *mVersionedRegistriesMockGetMandateRegistry {
	if mmGetMandateRegistry.mock.inspectFuncGetMandateRegistry != nil {
		mmGetMandateRegistry.mock.t.Fatalf("Inspect function is already set for VersionedRegistriesMock.GetMandateRegistry")
	}

	mmGetMandateRegistry.mock.inspectFuncGetMandateRegistry = f

	return mmGetMandateRegistry
}

// Return sets up results that will be returned by VersionedRegistries.GetMandateRegistry
func (mmGetMandateRegistry *mVersionedRegistriesMockGetMandateRegistry) Return(m1 MandateRegistry) *VersionedRegistriesMock {
	if mmGetMandateRegistry.mock.funcGetMandateRegistry != nil {
		mmGetMandateRegistry.mock.t.Fatalf("VersionedRegistriesMock.GetMandateRegistry mock is already set by Set")
	}

	if mmGetMandateRegistry.defaultExpectation == nil {
		mmGetMandateRegistry.defaultExpectation = &VersionedRegistriesMockGetMandateRegistryExpectation{mock: mmGetMandateRegistry.mock}
	}
	mmGetMandateRegistry.defaultExpectation.results = &VersionedRegistriesMockGetMandateRegistryResults{m1}
	return mmGetMandateRegistry.mock
}

//Set uses given function f to mock the VersionedRegistries.GetMandateRegistry method
func (mmGetMandateRegistry *mVersionedRegistriesMockGetMandateRegistry) Set(f func() (m1 MandateRegistry)) *VersionedRegistriesMock {
	if mmGetMandateRegistry.defaultExpectation != nil {
		mmGetMandateRegistry.mock.t.Fatalf("Default expectation is already set for the VersionedRegistries.GetMandateRegistry method")
	}

	if len(mmGetMandateRegistry.expectations) > 0 {
		mmGetMandateRegistry.mock.t.Fatalf("Some expectations are already set for the VersionedRegistries.GetMandateRegistry method")
	}

	mmGetMandateRegistry.mock.funcGetMandateRegistry = f
	return mmGetMandateRegistry.mock
}

// GetMandateRegistry implements VersionedRegistries
func (mmGetMandateRegistry *VersionedRegistriesMock) GetMandateRegistry() (m1 MandateRegistry) {
	mm_atomic.AddUint64(&mmGetMandateRegistry.beforeGetMandateRegistryCounter, 1)
	defer mm_atomic.AddUint64(&mmGetMandateRegistry.afterGetMandateRegistryCounter, 1)

	if mmGetMandateRegistry.inspectFuncGetMandateRegistry != nil {
		mmGetMandateRegistry.inspectFuncGetMandateRegistry()
	}

	if mmGetMandateRegistry.GetMandateRegistryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetMandateRegistry.GetMandateRegistryMock.defaultExpectation.Counter, 1)

		results := mmGetMandateRegistry.GetMandateRegistryMock.defaultExpectation.results
		if results == nil {
			mmGetMandateRegistry.t.Fatal("No results are set for the VersionedRegistriesMock.GetMandateRegistry")
		}
		return (*results).m1
	}
	if mmGetMandateRegistry.funcGetMandateRegistry != nil {
		return mmGetMandateRegistry.funcGetMandateRegistry()
	}
	mmGetMandateRegistry.t.Fatalf("Unexpected call to VersionedRegistriesMock.GetMandateRegistry.")
	return
}

// GetMandateRegistryAfterCounter returns a count of finished VersionedRegistriesMock.GetMandateRegistry invocations
func (mmGetMandateRegistry *VersionedRegistriesMock) GetMandateRegistryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMandateRegistry.afterGetMandateRegistryCounter)
}

// GetMandateRegistryBeforeCounter returns a count of VersionedRegistriesMock.GetMandateRegistry invocations
func (mmGetMandateRegistry *VersionedRegistriesMock) GetMandateRegistryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMandateRegistry.beforeGetMandateRegistryCounter)
}

// MinimockGetMandateRegistryDone returns true if the count of the GetMandateRegistry invocations corresponds
// the number of defined expectations
func (m *VersionedRegistriesMock) MinimockGetMandateRegistryDone() bool {
	for _, e := range m.GetMandateRegistryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMandateRegistryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetMandateRegistryCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetMandateRegistry != nil && mm_atomic.LoadUint64(&m.afterGetMandateRegistryCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetMandateRegistryInspect logs each unmet expectation
func (m *VersionedRegistriesMock) MinimockGetMandateRegistryInspect() {
	for _, e := range m.GetMandateRegistryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to VersionedRegistriesMock.GetMandateRegistry")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMandateRegistryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetMandateRegistryCounter) < 1 {
		m.t.Error("Expected call to VersionedRegistriesMock.GetMandateRegistry")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetMandateRegistry != nil && mm_atomic.LoadUint64(&m.afterGetMandateRegistryCounter) < 1 {
		m.t.Error("Expected call to VersionedRegistriesMock.GetMandateRegistry")
	}
}

type mVersionedRegistriesMockGetMisbehaviorRegistry struct {
	mock               *VersionedRegistriesMock
	defaultExpectation *VersionedRegistriesMockGetMisbehaviorRegistryExpectation
	expectations       []*VersionedRegistriesMockGetMisbehaviorRegistryExpectation
}

// VersionedRegistriesMockGetMisbehaviorRegistryExpectation specifies expectation struct of the VersionedRegistries.GetMisbehaviorRegistry
type VersionedRegistriesMockGetMisbehaviorRegistryExpectation struct {
	mock *VersionedRegistriesMock

	results *VersionedRegistriesMockGetMisbehaviorRegistryResults
	Counter uint64
}

// VersionedRegistriesMockGetMisbehaviorRegistryResults contains results of the VersionedRegistries.GetMisbehaviorRegistry
type VersionedRegistriesMockGetMisbehaviorRegistryResults struct {
	m1 MisbehaviorRegistry
}

// Expect sets up expected params for VersionedRegistries.GetMisbehaviorRegistry
func (mmGetMisbehaviorRegistry *mVersionedRegistriesMockGetMisbehaviorRegistry) Expect() *mVersionedRegistriesMockGetMisbehaviorRegistry {
	if mmGetMisbehaviorRegistry.mock.funcGetMisbehaviorRegistry != nil {
		mmGetMisbehaviorRegistry.mock.t.Fatalf("VersionedRegistriesMock.GetMisbehaviorRegistry mock is already set by Set")
	}

	if mmGetMisbehaviorRegistry.defaultExpectation == nil {
		mmGetMisbehaviorRegistry.defaultExpectation = &VersionedRegistriesMockGetMisbehaviorRegistryExpectation{}
	}

	return mmGetMisbehaviorRegistry
}

// Inspect accepts an inspector function that has same arguments as the VersionedRegistries.GetMisbehaviorRegistry
func (mmGetMisbehaviorRegistry *mVersionedRegistriesMockGetMisbehaviorRegistry) Inspect(f func()) *mVersionedRegistriesMockGetMisbehaviorRegistry {
	if mmGetMisbehaviorRegistry.mock.inspectFuncGetMisbehaviorRegistry != nil {
		mmGetMisbehaviorRegistry.mock.t.Fatalf("Inspect function is already set for VersionedRegistriesMock.GetMisbehaviorRegistry")
	}

	mmGetMisbehaviorRegistry.mock.inspectFuncGetMisbehaviorRegistry = f

	return mmGetMisbehaviorRegistry
}

// Return sets up results that will be returned by VersionedRegistries.GetMisbehaviorRegistry
func (mmGetMisbehaviorRegistry *mVersionedRegistriesMockGetMisbehaviorRegistry) Return(m1 MisbehaviorRegistry) *VersionedRegistriesMock {
	if mmGetMisbehaviorRegistry.mock.funcGetMisbehaviorRegistry != nil {
		mmGetMisbehaviorRegistry.mock.t.Fatalf("VersionedRegistriesMock.GetMisbehaviorRegistry mock is already set by Set")
	}

	if mmGetMisbehaviorRegistry.defaultExpectation == nil {
		mmGetMisbehaviorRegistry.defaultExpectation = &VersionedRegistriesMockGetMisbehaviorRegistryExpectation{mock: mmGetMisbehaviorRegistry.mock}
	}
	mmGetMisbehaviorRegistry.defaultExpectation.results = &VersionedRegistriesMockGetMisbehaviorRegistryResults{m1}
	return mmGetMisbehaviorRegistry.mock
}

//Set uses given function f to mock the VersionedRegistries.GetMisbehaviorRegistry method
func (mmGetMisbehaviorRegistry *mVersionedRegistriesMockGetMisbehaviorRegistry) Set(f func() (m1 MisbehaviorRegistry)) *VersionedRegistriesMock {
	if mmGetMisbehaviorRegistry.defaultExpectation != nil {
		mmGetMisbehaviorRegistry.mock.t.Fatalf("Default expectation is already set for the VersionedRegistries.GetMisbehaviorRegistry method")
	}

	if len(mmGetMisbehaviorRegistry.expectations) > 0 {
		mmGetMisbehaviorRegistry.mock.t.Fatalf("Some expectations are already set for the VersionedRegistries.GetMisbehaviorRegistry method")
	}

	mmGetMisbehaviorRegistry.mock.funcGetMisbehaviorRegistry = f
	return mmGetMisbehaviorRegistry.mock
}

// GetMisbehaviorRegistry implements VersionedRegistries
func (mmGetMisbehaviorRegistry *VersionedRegistriesMock) GetMisbehaviorRegistry() (m1 MisbehaviorRegistry) {
	mm_atomic.AddUint64(&mmGetMisbehaviorRegistry.beforeGetMisbehaviorRegistryCounter, 1)
	defer mm_atomic.AddUint64(&mmGetMisbehaviorRegistry.afterGetMisbehaviorRegistryCounter, 1)

	if mmGetMisbehaviorRegistry.inspectFuncGetMisbehaviorRegistry != nil {
		mmGetMisbehaviorRegistry.inspectFuncGetMisbehaviorRegistry()
	}

	if mmGetMisbehaviorRegistry.GetMisbehaviorRegistryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetMisbehaviorRegistry.GetMisbehaviorRegistryMock.defaultExpectation.Counter, 1)

		results := mmGetMisbehaviorRegistry.GetMisbehaviorRegistryMock.defaultExpectation.results
		if results == nil {
			mmGetMisbehaviorRegistry.t.Fatal("No results are set for the VersionedRegistriesMock.GetMisbehaviorRegistry")
		}
		return (*results).m1
	}
	if mmGetMisbehaviorRegistry.funcGetMisbehaviorRegistry != nil {
		return mmGetMisbehaviorRegistry.funcGetMisbehaviorRegistry()
	}
	mmGetMisbehaviorRegistry.t.Fatalf("Unexpected call to VersionedRegistriesMock.GetMisbehaviorRegistry.")
	return
}

// GetMisbehaviorRegistryAfterCounter returns a count of finished VersionedRegistriesMock.GetMisbehaviorRegistry invocations
func (mmGetMisbehaviorRegistry *VersionedRegistriesMock) GetMisbehaviorRegistryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMisbehaviorRegistry.afterGetMisbehaviorRegistryCounter)
}

// GetMisbehaviorRegistryBeforeCounter returns a count of VersionedRegistriesMock.GetMisbehaviorRegistry invocations
func (mmGetMisbehaviorRegistry *VersionedRegistriesMock) GetMisbehaviorRegistryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMisbehaviorRegistry.beforeGetMisbehaviorRegistryCounter)
}

// MinimockGetMisbehaviorRegistryDone returns true if the count of the GetMisbehaviorRegistry invocations corresponds
// the number of defined expectations
func (m *VersionedRegistriesMock) MinimockGetMisbehaviorRegistryDone() bool {
	for _, e := range m.GetMisbehaviorRegistryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMisbehaviorRegistryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetMisbehaviorRegistryCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetMisbehaviorRegistry != nil && mm_atomic.LoadUint64(&m.afterGetMisbehaviorRegistryCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetMisbehaviorRegistryInspect logs each unmet expectation
func (m *VersionedRegistriesMock) MinimockGetMisbehaviorRegistryInspect() {
	for _, e := range m.GetMisbehaviorRegistryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to VersionedRegistriesMock.GetMisbehaviorRegistry")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMisbehaviorRegistryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetMisbehaviorRegistryCounter) < 1 {
		m.t.Error("Expected call to VersionedRegistriesMock.GetMisbehaviorRegistry")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetMisbehaviorRegistry != nil && mm_atomic.LoadUint64(&m.afterGetMisbehaviorRegistryCounter) < 1 {
		m.t.Error("Expected call to VersionedRegistriesMock.GetMisbehaviorRegistry")
	}
}

type mVersionedRegistriesMockGetNearestValidPulseData struct {
	mock               *VersionedRegistriesMock
	defaultExpectation *VersionedRegistriesMockGetNearestValidPulseDataExpectation
	expectations       []*VersionedRegistriesMockGetNearestValidPulseDataExpectation
}

// VersionedRegistriesMockGetNearestValidPulseDataExpectation specifies expectation struct of the VersionedRegistries.GetNearestValidPulseData
type VersionedRegistriesMockGetNearestValidPulseDataExpectation struct {
	mock *VersionedRegistriesMock

	results *VersionedRegistriesMockGetNearestValidPulseDataResults
	Counter uint64
}

// VersionedRegistriesMockGetNearestValidPulseDataResults contains results of the VersionedRegistries.GetNearestValidPulseData
type VersionedRegistriesMockGetNearestValidPulseDataResults struct {
	d1 pulse.Data
}

// Expect sets up expected params for VersionedRegistries.GetNearestValidPulseData
func (mmGetNearestValidPulseData *mVersionedRegistriesMockGetNearestValidPulseData) Expect() *mVersionedRegistriesMockGetNearestValidPulseData {
	if mmGetNearestValidPulseData.mock.funcGetNearestValidPulseData != nil {
		mmGetNearestValidPulseData.mock.t.Fatalf("VersionedRegistriesMock.GetNearestValidPulseData mock is already set by Set")
	}

	if mmGetNearestValidPulseData.defaultExpectation == nil {
		mmGetNearestValidPulseData.defaultExpectation = &VersionedRegistriesMockGetNearestValidPulseDataExpectation{}
	}

	return mmGetNearestValidPulseData
}

// Inspect accepts an inspector function that has same arguments as the VersionedRegistries.GetNearestValidPulseData
func (mmGetNearestValidPulseData *mVersionedRegistriesMockGetNearestValidPulseData) Inspect(f func()) *mVersionedRegistriesMockGetNearestValidPulseData {
	if mmGetNearestValidPulseData.mock.inspectFuncGetNearestValidPulseData != nil {
		mmGetNearestValidPulseData.mock.t.Fatalf("Inspect function is already set for VersionedRegistriesMock.GetNearestValidPulseData")
	}

	mmGetNearestValidPulseData.mock.inspectFuncGetNearestValidPulseData = f

	return mmGetNearestValidPulseData
}

// Return sets up results that will be returned by VersionedRegistries.GetNearestValidPulseData
func (mmGetNearestValidPulseData *mVersionedRegistriesMockGetNearestValidPulseData) Return(d1 pulse.Data) *VersionedRegistriesMock {
	if mmGetNearestValidPulseData.mock.funcGetNearestValidPulseData != nil {
		mmGetNearestValidPulseData.mock.t.Fatalf("VersionedRegistriesMock.GetNearestValidPulseData mock is already set by Set")
	}

	if mmGetNearestValidPulseData.defaultExpectation == nil {
		mmGetNearestValidPulseData.defaultExpectation = &VersionedRegistriesMockGetNearestValidPulseDataExpectation{mock: mmGetNearestValidPulseData.mock}
	}
	mmGetNearestValidPulseData.defaultExpectation.results = &VersionedRegistriesMockGetNearestValidPulseDataResults{d1}
	return mmGetNearestValidPulseData.mock
}

//Set uses given function f to mock the VersionedRegistries.GetNearestValidPulseData method
func (mmGetNearestValidPulseData *mVersionedRegistriesMockGetNearestValidPulseData) Set(f func() (d1 pulse.Data)) *VersionedRegistriesMock {
	if mmGetNearestValidPulseData.defaultExpectation != nil {
		mmGetNearestValidPulseData.mock.t.Fatalf("Default expectation is already set for the VersionedRegistries.GetNearestValidPulseData method")
	}

	if len(mmGetNearestValidPulseData.expectations) > 0 {
		mmGetNearestValidPulseData.mock.t.Fatalf("Some expectations are already set for the VersionedRegistries.GetNearestValidPulseData method")
	}

	mmGetNearestValidPulseData.mock.funcGetNearestValidPulseData = f
	return mmGetNearestValidPulseData.mock
}

// GetNearestValidPulseData implements VersionedRegistries
func (mmGetNearestValidPulseData *VersionedRegistriesMock) GetNearestValidPulseData() (d1 pulse.Data) {
	mm_atomic.AddUint64(&mmGetNearestValidPulseData.beforeGetNearestValidPulseDataCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNearestValidPulseData.afterGetNearestValidPulseDataCounter, 1)

	if mmGetNearestValidPulseData.inspectFuncGetNearestValidPulseData != nil {
		mmGetNearestValidPulseData.inspectFuncGetNearestValidPulseData()
	}

	if mmGetNearestValidPulseData.GetNearestValidPulseDataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNearestValidPulseData.GetNearestValidPulseDataMock.defaultExpectation.Counter, 1)

		results := mmGetNearestValidPulseData.GetNearestValidPulseDataMock.defaultExpectation.results
		if results == nil {
			mmGetNearestValidPulseData.t.Fatal("No results are set for the VersionedRegistriesMock.GetNearestValidPulseData")
		}
		return (*results).d1
	}
	if mmGetNearestValidPulseData.funcGetNearestValidPulseData != nil {
		return mmGetNearestValidPulseData.funcGetNearestValidPulseData()
	}
	mmGetNearestValidPulseData.t.Fatalf("Unexpected call to VersionedRegistriesMock.GetNearestValidPulseData.")
	return
}

// GetNearestValidPulseDataAfterCounter returns a count of finished VersionedRegistriesMock.GetNearestValidPulseData invocations
func (mmGetNearestValidPulseData *VersionedRegistriesMock) GetNearestValidPulseDataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNearestValidPulseData.afterGetNearestValidPulseDataCounter)
}

// GetNearestValidPulseDataBeforeCounter returns a count of VersionedRegistriesMock.GetNearestValidPulseData invocations
func (mmGetNearestValidPulseData *VersionedRegistriesMock) GetNearestValidPulseDataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNearestValidPulseData.beforeGetNearestValidPulseDataCounter)
}

// MinimockGetNearestValidPulseDataDone returns true if the count of the GetNearestValidPulseData invocations corresponds
// the number of defined expectations
func (m *VersionedRegistriesMock) MinimockGetNearestValidPulseDataDone() bool {
	for _, e := range m.GetNearestValidPulseDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetNearestValidPulseDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetNearestValidPulseDataCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNearestValidPulseData != nil && mm_atomic.LoadUint64(&m.afterGetNearestValidPulseDataCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetNearestValidPulseDataInspect logs each unmet expectation
func (m *VersionedRegistriesMock) MinimockGetNearestValidPulseDataInspect() {
	for _, e := range m.GetNearestValidPulseDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to VersionedRegistriesMock.GetNearestValidPulseData")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetNearestValidPulseDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetNearestValidPulseDataCounter) < 1 {
		m.t.Error("Expected call to VersionedRegistriesMock.GetNearestValidPulseData")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNearestValidPulseData != nil && mm_atomic.LoadUint64(&m.afterGetNearestValidPulseDataCounter) < 1 {
		m.t.Error("Expected call to VersionedRegistriesMock.GetNearestValidPulseData")
	}
}

type mVersionedRegistriesMockGetOfflinePopulation struct {
	mock               *VersionedRegistriesMock
	defaultExpectation *VersionedRegistriesMockGetOfflinePopulationExpectation
	expectations       []*VersionedRegistriesMockGetOfflinePopulationExpectation
}

// VersionedRegistriesMockGetOfflinePopulationExpectation specifies expectation struct of the VersionedRegistries.GetOfflinePopulation
type VersionedRegistriesMockGetOfflinePopulationExpectation struct {
	mock *VersionedRegistriesMock

	results *VersionedRegistriesMockGetOfflinePopulationResults
	Counter uint64
}

// VersionedRegistriesMockGetOfflinePopulationResults contains results of the VersionedRegistries.GetOfflinePopulation
type VersionedRegistriesMockGetOfflinePopulationResults struct {
	o1 OfflinePopulation
}

// Expect sets up expected params for VersionedRegistries.GetOfflinePopulation
func (mmGetOfflinePopulation *mVersionedRegistriesMockGetOfflinePopulation) Expect() *mVersionedRegistriesMockGetOfflinePopulation {
	if mmGetOfflinePopulation.mock.funcGetOfflinePopulation != nil {
		mmGetOfflinePopulation.mock.t.Fatalf("VersionedRegistriesMock.GetOfflinePopulation mock is already set by Set")
	}

	if mmGetOfflinePopulation.defaultExpectation == nil {
		mmGetOfflinePopulation.defaultExpectation = &VersionedRegistriesMockGetOfflinePopulationExpectation{}
	}

	return mmGetOfflinePopulation
}

// Inspect accepts an inspector function that has same arguments as the VersionedRegistries.GetOfflinePopulation
func (mmGetOfflinePopulation *mVersionedRegistriesMockGetOfflinePopulation) Inspect(f func()) *mVersionedRegistriesMockGetOfflinePopulation {
	if mmGetOfflinePopulation.mock.inspectFuncGetOfflinePopulation != nil {
		mmGetOfflinePopulation.mock.t.Fatalf("Inspect function is already set for VersionedRegistriesMock.GetOfflinePopulation")
	}

	mmGetOfflinePopulation.mock.inspectFuncGetOfflinePopulation = f

	return mmGetOfflinePopulation
}

// Return sets up results that will be returned by VersionedRegistries.GetOfflinePopulation
func (mmGetOfflinePopulation *mVersionedRegistriesMockGetOfflinePopulation) Return(o1 OfflinePopulation) *VersionedRegistriesMock {
	if mmGetOfflinePopulation.mock.funcGetOfflinePopulation != nil {
		mmGetOfflinePopulation.mock.t.Fatalf("VersionedRegistriesMock.GetOfflinePopulation mock is already set by Set")
	}

	if mmGetOfflinePopulation.defaultExpectation == nil {
		mmGetOfflinePopulation.defaultExpectation = &VersionedRegistriesMockGetOfflinePopulationExpectation{mock: mmGetOfflinePopulation.mock}
	}
	mmGetOfflinePopulation.defaultExpectation.results = &VersionedRegistriesMockGetOfflinePopulationResults{o1}
	return mmGetOfflinePopulation.mock
}

//Set uses given function f to mock the VersionedRegistries.GetOfflinePopulation method
func (mmGetOfflinePopulation *mVersionedRegistriesMockGetOfflinePopulation) Set(f func() (o1 OfflinePopulation)) *VersionedRegistriesMock {
	if mmGetOfflinePopulation.defaultExpectation != nil {
		mmGetOfflinePopulation.mock.t.Fatalf("Default expectation is already set for the VersionedRegistries.GetOfflinePopulation method")
	}

	if len(mmGetOfflinePopulation.expectations) > 0 {
		mmGetOfflinePopulation.mock.t.Fatalf("Some expectations are already set for the VersionedRegistries.GetOfflinePopulation method")
	}

	mmGetOfflinePopulation.mock.funcGetOfflinePopulation = f
	return mmGetOfflinePopulation.mock
}

// GetOfflinePopulation implements VersionedRegistries
func (mmGetOfflinePopulation *VersionedRegistriesMock) GetOfflinePopulation() (o1 OfflinePopulation) {
	mm_atomic.AddUint64(&mmGetOfflinePopulation.beforeGetOfflinePopulationCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOfflinePopulation.afterGetOfflinePopulationCounter, 1)

	if mmGetOfflinePopulation.inspectFuncGetOfflinePopulation != nil {
		mmGetOfflinePopulation.inspectFuncGetOfflinePopulation()
	}

	if mmGetOfflinePopulation.GetOfflinePopulationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOfflinePopulation.GetOfflinePopulationMock.defaultExpectation.Counter, 1)

		results := mmGetOfflinePopulation.GetOfflinePopulationMock.defaultExpectation.results
		if results == nil {
			mmGetOfflinePopulation.t.Fatal("No results are set for the VersionedRegistriesMock.GetOfflinePopulation")
		}
		return (*results).o1
	}
	if mmGetOfflinePopulation.funcGetOfflinePopulation != nil {
		return mmGetOfflinePopulation.funcGetOfflinePopulation()
	}
	mmGetOfflinePopulation.t.Fatalf("Unexpected call to VersionedRegistriesMock.GetOfflinePopulation.")
	return
}

// GetOfflinePopulationAfterCounter returns a count of finished VersionedRegistriesMock.GetOfflinePopulation invocations
func (mmGetOfflinePopulation *VersionedRegistriesMock) GetOfflinePopulationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOfflinePopulation.afterGetOfflinePopulationCounter)
}

// GetOfflinePopulationBeforeCounter returns a count of VersionedRegistriesMock.GetOfflinePopulation invocations
func (mmGetOfflinePopulation *VersionedRegistriesMock) GetOfflinePopulationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOfflinePopulation.beforeGetOfflinePopulationCounter)
}

// MinimockGetOfflinePopulationDone returns true if the count of the GetOfflinePopulation invocations corresponds
// the number of defined expectations
func (m *VersionedRegistriesMock) MinimockGetOfflinePopulationDone() bool {
	for _, e := range m.GetOfflinePopulationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOfflinePopulationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOfflinePopulationCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOfflinePopulation != nil && mm_atomic.LoadUint64(&m.afterGetOfflinePopulationCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetOfflinePopulationInspect logs each unmet expectation
func (m *VersionedRegistriesMock) MinimockGetOfflinePopulationInspect() {
	for _, e := range m.GetOfflinePopulationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to VersionedRegistriesMock.GetOfflinePopulation")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOfflinePopulationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOfflinePopulationCounter) < 1 {
		m.t.Error("Expected call to VersionedRegistriesMock.GetOfflinePopulation")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOfflinePopulation != nil && mm_atomic.LoadUint64(&m.afterGetOfflinePopulationCounter) < 1 {
		m.t.Error("Expected call to VersionedRegistriesMock.GetOfflinePopulation")
	}
}

type mVersionedRegistriesMockGetVersionPulseData struct {
	mock               *VersionedRegistriesMock
	defaultExpectation *VersionedRegistriesMockGetVersionPulseDataExpectation
	expectations       []*VersionedRegistriesMockGetVersionPulseDataExpectation
}

// VersionedRegistriesMockGetVersionPulseDataExpectation specifies expectation struct of the VersionedRegistries.GetVersionPulseData
type VersionedRegistriesMockGetVersionPulseDataExpectation struct {
	mock *VersionedRegistriesMock

	results *VersionedRegistriesMockGetVersionPulseDataResults
	Counter uint64
}

// VersionedRegistriesMockGetVersionPulseDataResults contains results of the VersionedRegistries.GetVersionPulseData
type VersionedRegistriesMockGetVersionPulseDataResults struct {
	d1 pulse.Data
}

// Expect sets up expected params for VersionedRegistries.GetVersionPulseData
func (mmGetVersionPulseData *mVersionedRegistriesMockGetVersionPulseData) Expect() *mVersionedRegistriesMockGetVersionPulseData {
	if mmGetVersionPulseData.mock.funcGetVersionPulseData != nil {
		mmGetVersionPulseData.mock.t.Fatalf("VersionedRegistriesMock.GetVersionPulseData mock is already set by Set")
	}

	if mmGetVersionPulseData.defaultExpectation == nil {
		mmGetVersionPulseData.defaultExpectation = &VersionedRegistriesMockGetVersionPulseDataExpectation{}
	}

	return mmGetVersionPulseData
}

// Inspect accepts an inspector function that has same arguments as the VersionedRegistries.GetVersionPulseData
func (mmGetVersionPulseData *mVersionedRegistriesMockGetVersionPulseData) Inspect(f func()) *mVersionedRegistriesMockGetVersionPulseData {
	if mmGetVersionPulseData.mock.inspectFuncGetVersionPulseData != nil {
		mmGetVersionPulseData.mock.t.Fatalf("Inspect function is already set for VersionedRegistriesMock.GetVersionPulseData")
	}

	mmGetVersionPulseData.mock.inspectFuncGetVersionPulseData = f

	return mmGetVersionPulseData
}

// Return sets up results that will be returned by VersionedRegistries.GetVersionPulseData
func (mmGetVersionPulseData *mVersionedRegistriesMockGetVersionPulseData) Return(d1 pulse.Data) *VersionedRegistriesMock {
	if mmGetVersionPulseData.mock.funcGetVersionPulseData != nil {
		mmGetVersionPulseData.mock.t.Fatalf("VersionedRegistriesMock.GetVersionPulseData mock is already set by Set")
	}

	if mmGetVersionPulseData.defaultExpectation == nil {
		mmGetVersionPulseData.defaultExpectation = &VersionedRegistriesMockGetVersionPulseDataExpectation{mock: mmGetVersionPulseData.mock}
	}
	mmGetVersionPulseData.defaultExpectation.results = &VersionedRegistriesMockGetVersionPulseDataResults{d1}
	return mmGetVersionPulseData.mock
}

//Set uses given function f to mock the VersionedRegistries.GetVersionPulseData method
func (mmGetVersionPulseData *mVersionedRegistriesMockGetVersionPulseData) Set(f func() (d1 pulse.Data)) *VersionedRegistriesMock {
	if mmGetVersionPulseData.defaultExpectation != nil {
		mmGetVersionPulseData.mock.t.Fatalf("Default expectation is already set for the VersionedRegistries.GetVersionPulseData method")
	}

	if len(mmGetVersionPulseData.expectations) > 0 {
		mmGetVersionPulseData.mock.t.Fatalf("Some expectations are already set for the VersionedRegistries.GetVersionPulseData method")
	}

	mmGetVersionPulseData.mock.funcGetVersionPulseData = f
	return mmGetVersionPulseData.mock
}

// GetVersionPulseData implements VersionedRegistries
func (mmGetVersionPulseData *VersionedRegistriesMock) GetVersionPulseData() (d1 pulse.Data) {
	mm_atomic.AddUint64(&mmGetVersionPulseData.beforeGetVersionPulseDataCounter, 1)
	defer mm_atomic.AddUint64(&mmGetVersionPulseData.afterGetVersionPulseDataCounter, 1)

	if mmGetVersionPulseData.inspectFuncGetVersionPulseData != nil {
		mmGetVersionPulseData.inspectFuncGetVersionPulseData()
	}

	if mmGetVersionPulseData.GetVersionPulseDataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetVersionPulseData.GetVersionPulseDataMock.defaultExpectation.Counter, 1)

		results := mmGetVersionPulseData.GetVersionPulseDataMock.defaultExpectation.results
		if results == nil {
			mmGetVersionPulseData.t.Fatal("No results are set for the VersionedRegistriesMock.GetVersionPulseData")
		}
		return (*results).d1
	}
	if mmGetVersionPulseData.funcGetVersionPulseData != nil {
		return mmGetVersionPulseData.funcGetVersionPulseData()
	}
	mmGetVersionPulseData.t.Fatalf("Unexpected call to VersionedRegistriesMock.GetVersionPulseData.")
	return
}

// GetVersionPulseDataAfterCounter returns a count of finished VersionedRegistriesMock.GetVersionPulseData invocations
func (mmGetVersionPulseData *VersionedRegistriesMock) GetVersionPulseDataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetVersionPulseData.afterGetVersionPulseDataCounter)
}

// GetVersionPulseDataBeforeCounter returns a count of VersionedRegistriesMock.GetVersionPulseData invocations
func (mmGetVersionPulseData *VersionedRegistriesMock) GetVersionPulseDataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetVersionPulseData.beforeGetVersionPulseDataCounter)
}

// MinimockGetVersionPulseDataDone returns true if the count of the GetVersionPulseData invocations corresponds
// the number of defined expectations
func (m *VersionedRegistriesMock) MinimockGetVersionPulseDataDone() bool {
	for _, e := range m.GetVersionPulseDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetVersionPulseDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetVersionPulseDataCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetVersionPulseData != nil && mm_atomic.LoadUint64(&m.afterGetVersionPulseDataCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetVersionPulseDataInspect logs each unmet expectation
func (m *VersionedRegistriesMock) MinimockGetVersionPulseDataInspect() {
	for _, e := range m.GetVersionPulseDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to VersionedRegistriesMock.GetVersionPulseData")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetVersionPulseDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetVersionPulseDataCounter) < 1 {
		m.t.Error("Expected call to VersionedRegistriesMock.GetVersionPulseData")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetVersionPulseData != nil && mm_atomic.LoadUint64(&m.afterGetVersionPulseDataCounter) < 1 {
		m.t.Error("Expected call to VersionedRegistriesMock.GetVersionPulseData")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *VersionedRegistriesMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCommitNextPulseInspect()

		m.MinimockGetMandateRegistryInspect()

		m.MinimockGetMisbehaviorRegistryInspect()

		m.MinimockGetNearestValidPulseDataInspect()

		m.MinimockGetOfflinePopulationInspect()

		m.MinimockGetVersionPulseDataInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *VersionedRegistriesMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *VersionedRegistriesMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCommitNextPulseDone() &&
		m.MinimockGetMandateRegistryDone() &&
		m.MinimockGetMisbehaviorRegistryDone() &&
		m.MinimockGetNearestValidPulseDataDone() &&
		m.MinimockGetOfflinePopulationDone() &&
		m.MinimockGetVersionPulseDataDone()
}
