package census

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/insolar/insolar"
	"github.com/insolar/insolar/network/consensus/gcpv2/api/profiles"
)

// EvictedPopulationMock implements EvictedPopulation
type EvictedPopulationMock struct {
	t minimock.Tester

	funcFindProfile          func(nodeID insolar.ShortNodeID) (e1 profiles.EvictedNode)
	inspectFuncFindProfile   func(nodeID insolar.ShortNodeID)
	afterFindProfileCounter  uint64
	beforeFindProfileCounter uint64
	FindProfileMock          mEvictedPopulationMockFindProfile

	funcGetCount          func() (i1 int)
	inspectFuncGetCount   func()
	afterGetCountCounter  uint64
	beforeGetCountCounter uint64
	GetCountMock          mEvictedPopulationMockGetCount

	funcGetDetectedErrors          func() (r1 RecoverableErrorTypes)
	inspectFuncGetDetectedErrors   func()
	afterGetDetectedErrorsCounter  uint64
	beforeGetDetectedErrorsCounter uint64
	GetDetectedErrorsMock          mEvictedPopulationMockGetDetectedErrors

	funcGetProfiles          func() (ea1 []profiles.EvictedNode)
	inspectFuncGetProfiles   func()
	afterGetProfilesCounter  uint64
	beforeGetProfilesCounter uint64
	GetProfilesMock          mEvictedPopulationMockGetProfiles

	funcIsValid          func() (b1 bool)
	inspectFuncIsValid   func()
	afterIsValidCounter  uint64
	beforeIsValidCounter uint64
	IsValidMock          mEvictedPopulationMockIsValid
}

// NewEvictedPopulationMock returns a mock for EvictedPopulation
func NewEvictedPopulationMock(t minimock.Tester) *EvictedPopulationMock {
	m := &EvictedPopulationMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.FindProfileMock = mEvictedPopulationMockFindProfile{mock: m}
	m.FindProfileMock.callArgs = []*EvictedPopulationMockFindProfileParams{}

	m.GetCountMock = mEvictedPopulationMockGetCount{mock: m}

	m.GetDetectedErrorsMock = mEvictedPopulationMockGetDetectedErrors{mock: m}

	m.GetProfilesMock = mEvictedPopulationMockGetProfiles{mock: m}

	m.IsValidMock = mEvictedPopulationMockIsValid{mock: m}

	return m
}

type mEvictedPopulationMockFindProfile struct {
	mock               *EvictedPopulationMock
	defaultExpectation *EvictedPopulationMockFindProfileExpectation
	expectations       []*EvictedPopulationMockFindProfileExpectation

	callArgs []*EvictedPopulationMockFindProfileParams
	mutex    sync.RWMutex
}

// EvictedPopulationMockFindProfileExpectation specifies expectation struct of the EvictedPopulation.FindProfile
type EvictedPopulationMockFindProfileExpectation struct {
	mock    *EvictedPopulationMock
	params  *EvictedPopulationMockFindProfileParams
	results *EvictedPopulationMockFindProfileResults
	Counter uint64
}

// EvictedPopulationMockFindProfileParams contains parameters of the EvictedPopulation.FindProfile
type EvictedPopulationMockFindProfileParams struct {
	nodeID insolar.ShortNodeID
}

// EvictedPopulationMockFindProfileResults contains results of the EvictedPopulation.FindProfile
type EvictedPopulationMockFindProfileResults struct {
	e1 profiles.EvictedNode
}

// Expect sets up expected params for EvictedPopulation.FindProfile
func (mmFindProfile *mEvictedPopulationMockFindProfile) Expect(nodeID insolar.ShortNodeID) *mEvictedPopulationMockFindProfile {
	if mmFindProfile.mock.funcFindProfile != nil {
		mmFindProfile.mock.t.Fatalf("EvictedPopulationMock.FindProfile mock is already set by Set")
	}

	if mmFindProfile.defaultExpectation == nil {
		mmFindProfile.defaultExpectation = &EvictedPopulationMockFindProfileExpectation{}
	}

	mmFindProfile.defaultExpectation.params = &EvictedPopulationMockFindProfileParams{nodeID}
	for _, e := range mmFindProfile.expectations {
		if minimock.Equal(e.params, mmFindProfile.defaultExpectation.params) {
			mmFindProfile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindProfile.defaultExpectation.params)
		}
	}

	return mmFindProfile
}

// Inspect accepts an inspector function that has same arguments as the EvictedPopulation.FindProfile
func (mmFindProfile *mEvictedPopulationMockFindProfile) Inspect(f func(nodeID insolar.ShortNodeID)) *mEvictedPopulationMockFindProfile {
	if mmFindProfile.mock.inspectFuncFindProfile != nil {
		mmFindProfile.mock.t.Fatalf("Inspect function is already set for EvictedPopulationMock.FindProfile")
	}

	mmFindProfile.mock.inspectFuncFindProfile = f

	return mmFindProfile
}

// Return sets up results that will be returned by EvictedPopulation.FindProfile
func (mmFindProfile *mEvictedPopulationMockFindProfile) Return(e1 profiles.EvictedNode) *EvictedPopulationMock {
	if mmFindProfile.mock.funcFindProfile != nil {
		mmFindProfile.mock.t.Fatalf("EvictedPopulationMock.FindProfile mock is already set by Set")
	}

	if mmFindProfile.defaultExpectation == nil {
		mmFindProfile.defaultExpectation = &EvictedPopulationMockFindProfileExpectation{mock: mmFindProfile.mock}
	}
	mmFindProfile.defaultExpectation.results = &EvictedPopulationMockFindProfileResults{e1}
	return mmFindProfile.mock
}

//Set uses given function f to mock the EvictedPopulation.FindProfile method
func (mmFindProfile *mEvictedPopulationMockFindProfile) Set(f func(nodeID insolar.ShortNodeID) (e1 profiles.EvictedNode)) *EvictedPopulationMock {
	if mmFindProfile.defaultExpectation != nil {
		mmFindProfile.mock.t.Fatalf("Default expectation is already set for the EvictedPopulation.FindProfile method")
	}

	if len(mmFindProfile.expectations) > 0 {
		mmFindProfile.mock.t.Fatalf("Some expectations are already set for the EvictedPopulation.FindProfile method")
	}

	mmFindProfile.mock.funcFindProfile = f
	return mmFindProfile.mock
}

// When sets expectation for the EvictedPopulation.FindProfile which will trigger the result defined by the following
// Then helper
func (mmFindProfile *mEvictedPopulationMockFindProfile) When(nodeID insolar.ShortNodeID) *EvictedPopulationMockFindProfileExpectation {
	if mmFindProfile.mock.funcFindProfile != nil {
		mmFindProfile.mock.t.Fatalf("EvictedPopulationMock.FindProfile mock is already set by Set")
	}

	expectation := &EvictedPopulationMockFindProfileExpectation{
		mock:   mmFindProfile.mock,
		params: &EvictedPopulationMockFindProfileParams{nodeID},
	}
	mmFindProfile.expectations = append(mmFindProfile.expectations, expectation)
	return expectation
}

// Then sets up EvictedPopulation.FindProfile return parameters for the expectation previously defined by the When method
func (e *EvictedPopulationMockFindProfileExpectation) Then(e1 profiles.EvictedNode) *EvictedPopulationMock {
	e.results = &EvictedPopulationMockFindProfileResults{e1}
	return e.mock
}

// FindProfile implements EvictedPopulation
func (mmFindProfile *EvictedPopulationMock) FindProfile(nodeID insolar.ShortNodeID) (e1 profiles.EvictedNode) {
	mm_atomic.AddUint64(&mmFindProfile.beforeFindProfileCounter, 1)
	defer mm_atomic.AddUint64(&mmFindProfile.afterFindProfileCounter, 1)

	if mmFindProfile.inspectFuncFindProfile != nil {
		mmFindProfile.inspectFuncFindProfile(nodeID)
	}

	mm_params := &EvictedPopulationMockFindProfileParams{nodeID}

	// Record call args
	mmFindProfile.FindProfileMock.mutex.Lock()
	mmFindProfile.FindProfileMock.callArgs = append(mmFindProfile.FindProfileMock.callArgs, mm_params)
	mmFindProfile.FindProfileMock.mutex.Unlock()

	for _, e := range mmFindProfile.FindProfileMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.e1
		}
	}

	if mmFindProfile.FindProfileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFindProfile.FindProfileMock.defaultExpectation.Counter, 1)
		mm_want := mmFindProfile.FindProfileMock.defaultExpectation.params
		mm_got := EvictedPopulationMockFindProfileParams{nodeID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFindProfile.t.Errorf("EvictedPopulationMock.FindProfile got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFindProfile.FindProfileMock.defaultExpectation.results
		if mm_results == nil {
			mmFindProfile.t.Fatal("No results are set for the EvictedPopulationMock.FindProfile")
		}
		return (*mm_results).e1
	}
	if mmFindProfile.funcFindProfile != nil {
		return mmFindProfile.funcFindProfile(nodeID)
	}
	mmFindProfile.t.Fatalf("Unexpected call to EvictedPopulationMock.FindProfile. %v", nodeID)
	return
}

// FindProfileAfterCounter returns a count of finished EvictedPopulationMock.FindProfile invocations
func (mmFindProfile *EvictedPopulationMock) FindProfileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindProfile.afterFindProfileCounter)
}

// FindProfileBeforeCounter returns a count of EvictedPopulationMock.FindProfile invocations
func (mmFindProfile *EvictedPopulationMock) FindProfileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindProfile.beforeFindProfileCounter)
}

// Calls returns a list of arguments used in each call to EvictedPopulationMock.FindProfile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindProfile *mEvictedPopulationMockFindProfile) Calls() []*EvictedPopulationMockFindProfileParams {
	mmFindProfile.mutex.RLock()

	argCopy := make([]*EvictedPopulationMockFindProfileParams, len(mmFindProfile.callArgs))
	copy(argCopy, mmFindProfile.callArgs)

	mmFindProfile.mutex.RUnlock()

	return argCopy
}

// MinimockFindProfileDone returns true if the count of the FindProfile invocations corresponds
// the number of defined expectations
func (m *EvictedPopulationMock) MinimockFindProfileDone() bool {
	for _, e := range m.FindProfileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FindProfileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFindProfileCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindProfile != nil && mm_atomic.LoadUint64(&m.afterFindProfileCounter) < 1 {
		return false
	}
	return true
}

// MinimockFindProfileInspect logs each unmet expectation
func (m *EvictedPopulationMock) MinimockFindProfileInspect() {
	for _, e := range m.FindProfileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EvictedPopulationMock.FindProfile with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FindProfileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFindProfileCounter) < 1 {
		if m.FindProfileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to EvictedPopulationMock.FindProfile")
		} else {
			m.t.Errorf("Expected call to EvictedPopulationMock.FindProfile with params: %#v", *m.FindProfileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindProfile != nil && mm_atomic.LoadUint64(&m.afterFindProfileCounter) < 1 {
		m.t.Error("Expected call to EvictedPopulationMock.FindProfile")
	}
}

type mEvictedPopulationMockGetCount struct {
	mock               *EvictedPopulationMock
	defaultExpectation *EvictedPopulationMockGetCountExpectation
	expectations       []*EvictedPopulationMockGetCountExpectation
}

// EvictedPopulationMockGetCountExpectation specifies expectation struct of the EvictedPopulation.GetCount
type EvictedPopulationMockGetCountExpectation struct {
	mock *EvictedPopulationMock

	results *EvictedPopulationMockGetCountResults
	Counter uint64
}

// EvictedPopulationMockGetCountResults contains results of the EvictedPopulation.GetCount
type EvictedPopulationMockGetCountResults struct {
	i1 int
}

// Expect sets up expected params for EvictedPopulation.GetCount
func (mmGetCount *mEvictedPopulationMockGetCount) Expect() *mEvictedPopulationMockGetCount {
	if mmGetCount.mock.funcGetCount != nil {
		mmGetCount.mock.t.Fatalf("EvictedPopulationMock.GetCount mock is already set by Set")
	}

	if mmGetCount.defaultExpectation == nil {
		mmGetCount.defaultExpectation = &EvictedPopulationMockGetCountExpectation{}
	}

	return mmGetCount
}

// Inspect accepts an inspector function that has same arguments as the EvictedPopulation.GetCount
func (mmGetCount *mEvictedPopulationMockGetCount) Inspect(f func()) *mEvictedPopulationMockGetCount {
	if mmGetCount.mock.inspectFuncGetCount != nil {
		mmGetCount.mock.t.Fatalf("Inspect function is already set for EvictedPopulationMock.GetCount")
	}

	mmGetCount.mock.inspectFuncGetCount = f

	return mmGetCount
}

// Return sets up results that will be returned by EvictedPopulation.GetCount
func (mmGetCount *mEvictedPopulationMockGetCount) Return(i1 int) *EvictedPopulationMock {
	if mmGetCount.mock.funcGetCount != nil {
		mmGetCount.mock.t.Fatalf("EvictedPopulationMock.GetCount mock is already set by Set")
	}

	if mmGetCount.defaultExpectation == nil {
		mmGetCount.defaultExpectation = &EvictedPopulationMockGetCountExpectation{mock: mmGetCount.mock}
	}
	mmGetCount.defaultExpectation.results = &EvictedPopulationMockGetCountResults{i1}
	return mmGetCount.mock
}

//Set uses given function f to mock the EvictedPopulation.GetCount method
func (mmGetCount *mEvictedPopulationMockGetCount) Set(f func() (i1 int)) *EvictedPopulationMock {
	if mmGetCount.defaultExpectation != nil {
		mmGetCount.mock.t.Fatalf("Default expectation is already set for the EvictedPopulation.GetCount method")
	}

	if len(mmGetCount.expectations) > 0 {
		mmGetCount.mock.t.Fatalf("Some expectations are already set for the EvictedPopulation.GetCount method")
	}

	mmGetCount.mock.funcGetCount = f
	return mmGetCount.mock
}

// GetCount implements EvictedPopulation
func (mmGetCount *EvictedPopulationMock) GetCount() (i1 int) {
	mm_atomic.AddUint64(&mmGetCount.beforeGetCountCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCount.afterGetCountCounter, 1)

	if mmGetCount.inspectFuncGetCount != nil {
		mmGetCount.inspectFuncGetCount()
	}

	if mmGetCount.GetCountMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCount.GetCountMock.defaultExpectation.Counter, 1)

		mm_results := mmGetCount.GetCountMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCount.t.Fatal("No results are set for the EvictedPopulationMock.GetCount")
		}
		return (*mm_results).i1
	}
	if mmGetCount.funcGetCount != nil {
		return mmGetCount.funcGetCount()
	}
	mmGetCount.t.Fatalf("Unexpected call to EvictedPopulationMock.GetCount.")
	return
}

// GetCountAfterCounter returns a count of finished EvictedPopulationMock.GetCount invocations
func (mmGetCount *EvictedPopulationMock) GetCountAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCount.afterGetCountCounter)
}

// GetCountBeforeCounter returns a count of EvictedPopulationMock.GetCount invocations
func (mmGetCount *EvictedPopulationMock) GetCountBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCount.beforeGetCountCounter)
}

// MinimockGetCountDone returns true if the count of the GetCount invocations corresponds
// the number of defined expectations
func (m *EvictedPopulationMock) MinimockGetCountDone() bool {
	for _, e := range m.GetCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCountCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCount != nil && mm_atomic.LoadUint64(&m.afterGetCountCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCountInspect logs each unmet expectation
func (m *EvictedPopulationMock) MinimockGetCountInspect() {
	for _, e := range m.GetCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to EvictedPopulationMock.GetCount")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCountCounter) < 1 {
		m.t.Error("Expected call to EvictedPopulationMock.GetCount")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCount != nil && mm_atomic.LoadUint64(&m.afterGetCountCounter) < 1 {
		m.t.Error("Expected call to EvictedPopulationMock.GetCount")
	}
}

type mEvictedPopulationMockGetDetectedErrors struct {
	mock               *EvictedPopulationMock
	defaultExpectation *EvictedPopulationMockGetDetectedErrorsExpectation
	expectations       []*EvictedPopulationMockGetDetectedErrorsExpectation
}

// EvictedPopulationMockGetDetectedErrorsExpectation specifies expectation struct of the EvictedPopulation.GetDetectedErrors
type EvictedPopulationMockGetDetectedErrorsExpectation struct {
	mock *EvictedPopulationMock

	results *EvictedPopulationMockGetDetectedErrorsResults
	Counter uint64
}

// EvictedPopulationMockGetDetectedErrorsResults contains results of the EvictedPopulation.GetDetectedErrors
type EvictedPopulationMockGetDetectedErrorsResults struct {
	r1 RecoverableErrorTypes
}

// Expect sets up expected params for EvictedPopulation.GetDetectedErrors
func (mmGetDetectedErrors *mEvictedPopulationMockGetDetectedErrors) Expect() *mEvictedPopulationMockGetDetectedErrors {
	if mmGetDetectedErrors.mock.funcGetDetectedErrors != nil {
		mmGetDetectedErrors.mock.t.Fatalf("EvictedPopulationMock.GetDetectedErrors mock is already set by Set")
	}

	if mmGetDetectedErrors.defaultExpectation == nil {
		mmGetDetectedErrors.defaultExpectation = &EvictedPopulationMockGetDetectedErrorsExpectation{}
	}

	return mmGetDetectedErrors
}

// Inspect accepts an inspector function that has same arguments as the EvictedPopulation.GetDetectedErrors
func (mmGetDetectedErrors *mEvictedPopulationMockGetDetectedErrors) Inspect(f func()) *mEvictedPopulationMockGetDetectedErrors {
	if mmGetDetectedErrors.mock.inspectFuncGetDetectedErrors != nil {
		mmGetDetectedErrors.mock.t.Fatalf("Inspect function is already set for EvictedPopulationMock.GetDetectedErrors")
	}

	mmGetDetectedErrors.mock.inspectFuncGetDetectedErrors = f

	return mmGetDetectedErrors
}

// Return sets up results that will be returned by EvictedPopulation.GetDetectedErrors
func (mmGetDetectedErrors *mEvictedPopulationMockGetDetectedErrors) Return(r1 RecoverableErrorTypes) *EvictedPopulationMock {
	if mmGetDetectedErrors.mock.funcGetDetectedErrors != nil {
		mmGetDetectedErrors.mock.t.Fatalf("EvictedPopulationMock.GetDetectedErrors mock is already set by Set")
	}

	if mmGetDetectedErrors.defaultExpectation == nil {
		mmGetDetectedErrors.defaultExpectation = &EvictedPopulationMockGetDetectedErrorsExpectation{mock: mmGetDetectedErrors.mock}
	}
	mmGetDetectedErrors.defaultExpectation.results = &EvictedPopulationMockGetDetectedErrorsResults{r1}
	return mmGetDetectedErrors.mock
}

//Set uses given function f to mock the EvictedPopulation.GetDetectedErrors method
func (mmGetDetectedErrors *mEvictedPopulationMockGetDetectedErrors) Set(f func() (r1 RecoverableErrorTypes)) *EvictedPopulationMock {
	if mmGetDetectedErrors.defaultExpectation != nil {
		mmGetDetectedErrors.mock.t.Fatalf("Default expectation is already set for the EvictedPopulation.GetDetectedErrors method")
	}

	if len(mmGetDetectedErrors.expectations) > 0 {
		mmGetDetectedErrors.mock.t.Fatalf("Some expectations are already set for the EvictedPopulation.GetDetectedErrors method")
	}

	mmGetDetectedErrors.mock.funcGetDetectedErrors = f
	return mmGetDetectedErrors.mock
}

// GetDetectedErrors implements EvictedPopulation
func (mmGetDetectedErrors *EvictedPopulationMock) GetDetectedErrors() (r1 RecoverableErrorTypes) {
	mm_atomic.AddUint64(&mmGetDetectedErrors.beforeGetDetectedErrorsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDetectedErrors.afterGetDetectedErrorsCounter, 1)

	if mmGetDetectedErrors.inspectFuncGetDetectedErrors != nil {
		mmGetDetectedErrors.inspectFuncGetDetectedErrors()
	}

	if mmGetDetectedErrors.GetDetectedErrorsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDetectedErrors.GetDetectedErrorsMock.defaultExpectation.Counter, 1)

		mm_results := mmGetDetectedErrors.GetDetectedErrorsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDetectedErrors.t.Fatal("No results are set for the EvictedPopulationMock.GetDetectedErrors")
		}
		return (*mm_results).r1
	}
	if mmGetDetectedErrors.funcGetDetectedErrors != nil {
		return mmGetDetectedErrors.funcGetDetectedErrors()
	}
	mmGetDetectedErrors.t.Fatalf("Unexpected call to EvictedPopulationMock.GetDetectedErrors.")
	return
}

// GetDetectedErrorsAfterCounter returns a count of finished EvictedPopulationMock.GetDetectedErrors invocations
func (mmGetDetectedErrors *EvictedPopulationMock) GetDetectedErrorsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDetectedErrors.afterGetDetectedErrorsCounter)
}

// GetDetectedErrorsBeforeCounter returns a count of EvictedPopulationMock.GetDetectedErrors invocations
func (mmGetDetectedErrors *EvictedPopulationMock) GetDetectedErrorsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDetectedErrors.beforeGetDetectedErrorsCounter)
}

// MinimockGetDetectedErrorsDone returns true if the count of the GetDetectedErrors invocations corresponds
// the number of defined expectations
func (m *EvictedPopulationMock) MinimockGetDetectedErrorsDone() bool {
	for _, e := range m.GetDetectedErrorsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDetectedErrorsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDetectedErrorsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDetectedErrors != nil && mm_atomic.LoadUint64(&m.afterGetDetectedErrorsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetDetectedErrorsInspect logs each unmet expectation
func (m *EvictedPopulationMock) MinimockGetDetectedErrorsInspect() {
	for _, e := range m.GetDetectedErrorsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to EvictedPopulationMock.GetDetectedErrors")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDetectedErrorsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDetectedErrorsCounter) < 1 {
		m.t.Error("Expected call to EvictedPopulationMock.GetDetectedErrors")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDetectedErrors != nil && mm_atomic.LoadUint64(&m.afterGetDetectedErrorsCounter) < 1 {
		m.t.Error("Expected call to EvictedPopulationMock.GetDetectedErrors")
	}
}

type mEvictedPopulationMockGetProfiles struct {
	mock               *EvictedPopulationMock
	defaultExpectation *EvictedPopulationMockGetProfilesExpectation
	expectations       []*EvictedPopulationMockGetProfilesExpectation
}

// EvictedPopulationMockGetProfilesExpectation specifies expectation struct of the EvictedPopulation.GetProfiles
type EvictedPopulationMockGetProfilesExpectation struct {
	mock *EvictedPopulationMock

	results *EvictedPopulationMockGetProfilesResults
	Counter uint64
}

// EvictedPopulationMockGetProfilesResults contains results of the EvictedPopulation.GetProfiles
type EvictedPopulationMockGetProfilesResults struct {
	ea1 []profiles.EvictedNode
}

// Expect sets up expected params for EvictedPopulation.GetProfiles
func (mmGetProfiles *mEvictedPopulationMockGetProfiles) Expect() *mEvictedPopulationMockGetProfiles {
	if mmGetProfiles.mock.funcGetProfiles != nil {
		mmGetProfiles.mock.t.Fatalf("EvictedPopulationMock.GetProfiles mock is already set by Set")
	}

	if mmGetProfiles.defaultExpectation == nil {
		mmGetProfiles.defaultExpectation = &EvictedPopulationMockGetProfilesExpectation{}
	}

	return mmGetProfiles
}

// Inspect accepts an inspector function that has same arguments as the EvictedPopulation.GetProfiles
func (mmGetProfiles *mEvictedPopulationMockGetProfiles) Inspect(f func()) *mEvictedPopulationMockGetProfiles {
	if mmGetProfiles.mock.inspectFuncGetProfiles != nil {
		mmGetProfiles.mock.t.Fatalf("Inspect function is already set for EvictedPopulationMock.GetProfiles")
	}

	mmGetProfiles.mock.inspectFuncGetProfiles = f

	return mmGetProfiles
}

// Return sets up results that will be returned by EvictedPopulation.GetProfiles
func (mmGetProfiles *mEvictedPopulationMockGetProfiles) Return(ea1 []profiles.EvictedNode) *EvictedPopulationMock {
	if mmGetProfiles.mock.funcGetProfiles != nil {
		mmGetProfiles.mock.t.Fatalf("EvictedPopulationMock.GetProfiles mock is already set by Set")
	}

	if mmGetProfiles.defaultExpectation == nil {
		mmGetProfiles.defaultExpectation = &EvictedPopulationMockGetProfilesExpectation{mock: mmGetProfiles.mock}
	}
	mmGetProfiles.defaultExpectation.results = &EvictedPopulationMockGetProfilesResults{ea1}
	return mmGetProfiles.mock
}

//Set uses given function f to mock the EvictedPopulation.GetProfiles method
func (mmGetProfiles *mEvictedPopulationMockGetProfiles) Set(f func() (ea1 []profiles.EvictedNode)) *EvictedPopulationMock {
	if mmGetProfiles.defaultExpectation != nil {
		mmGetProfiles.mock.t.Fatalf("Default expectation is already set for the EvictedPopulation.GetProfiles method")
	}

	if len(mmGetProfiles.expectations) > 0 {
		mmGetProfiles.mock.t.Fatalf("Some expectations are already set for the EvictedPopulation.GetProfiles method")
	}

	mmGetProfiles.mock.funcGetProfiles = f
	return mmGetProfiles.mock
}

// GetProfiles implements EvictedPopulation
func (mmGetProfiles *EvictedPopulationMock) GetProfiles() (ea1 []profiles.EvictedNode) {
	mm_atomic.AddUint64(&mmGetProfiles.beforeGetProfilesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetProfiles.afterGetProfilesCounter, 1)

	if mmGetProfiles.inspectFuncGetProfiles != nil {
		mmGetProfiles.inspectFuncGetProfiles()
	}

	if mmGetProfiles.GetProfilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetProfiles.GetProfilesMock.defaultExpectation.Counter, 1)

		mm_results := mmGetProfiles.GetProfilesMock.defaultExpectation.results
		if mm_results == nil {
			mmGetProfiles.t.Fatal("No results are set for the EvictedPopulationMock.GetProfiles")
		}
		return (*mm_results).ea1
	}
	if mmGetProfiles.funcGetProfiles != nil {
		return mmGetProfiles.funcGetProfiles()
	}
	mmGetProfiles.t.Fatalf("Unexpected call to EvictedPopulationMock.GetProfiles.")
	return
}

// GetProfilesAfterCounter returns a count of finished EvictedPopulationMock.GetProfiles invocations
func (mmGetProfiles *EvictedPopulationMock) GetProfilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetProfiles.afterGetProfilesCounter)
}

// GetProfilesBeforeCounter returns a count of EvictedPopulationMock.GetProfiles invocations
func (mmGetProfiles *EvictedPopulationMock) GetProfilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetProfiles.beforeGetProfilesCounter)
}

// MinimockGetProfilesDone returns true if the count of the GetProfiles invocations corresponds
// the number of defined expectations
func (m *EvictedPopulationMock) MinimockGetProfilesDone() bool {
	for _, e := range m.GetProfilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetProfilesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetProfilesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetProfiles != nil && mm_atomic.LoadUint64(&m.afterGetProfilesCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetProfilesInspect logs each unmet expectation
func (m *EvictedPopulationMock) MinimockGetProfilesInspect() {
	for _, e := range m.GetProfilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to EvictedPopulationMock.GetProfiles")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetProfilesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetProfilesCounter) < 1 {
		m.t.Error("Expected call to EvictedPopulationMock.GetProfiles")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetProfiles != nil && mm_atomic.LoadUint64(&m.afterGetProfilesCounter) < 1 {
		m.t.Error("Expected call to EvictedPopulationMock.GetProfiles")
	}
}

type mEvictedPopulationMockIsValid struct {
	mock               *EvictedPopulationMock
	defaultExpectation *EvictedPopulationMockIsValidExpectation
	expectations       []*EvictedPopulationMockIsValidExpectation
}

// EvictedPopulationMockIsValidExpectation specifies expectation struct of the EvictedPopulation.IsValid
type EvictedPopulationMockIsValidExpectation struct {
	mock *EvictedPopulationMock

	results *EvictedPopulationMockIsValidResults
	Counter uint64
}

// EvictedPopulationMockIsValidResults contains results of the EvictedPopulation.IsValid
type EvictedPopulationMockIsValidResults struct {
	b1 bool
}

// Expect sets up expected params for EvictedPopulation.IsValid
func (mmIsValid *mEvictedPopulationMockIsValid) Expect() *mEvictedPopulationMockIsValid {
	if mmIsValid.mock.funcIsValid != nil {
		mmIsValid.mock.t.Fatalf("EvictedPopulationMock.IsValid mock is already set by Set")
	}

	if mmIsValid.defaultExpectation == nil {
		mmIsValid.defaultExpectation = &EvictedPopulationMockIsValidExpectation{}
	}

	return mmIsValid
}

// Inspect accepts an inspector function that has same arguments as the EvictedPopulation.IsValid
func (mmIsValid *mEvictedPopulationMockIsValid) Inspect(f func()) *mEvictedPopulationMockIsValid {
	if mmIsValid.mock.inspectFuncIsValid != nil {
		mmIsValid.mock.t.Fatalf("Inspect function is already set for EvictedPopulationMock.IsValid")
	}

	mmIsValid.mock.inspectFuncIsValid = f

	return mmIsValid
}

// Return sets up results that will be returned by EvictedPopulation.IsValid
func (mmIsValid *mEvictedPopulationMockIsValid) Return(b1 bool) *EvictedPopulationMock {
	if mmIsValid.mock.funcIsValid != nil {
		mmIsValid.mock.t.Fatalf("EvictedPopulationMock.IsValid mock is already set by Set")
	}

	if mmIsValid.defaultExpectation == nil {
		mmIsValid.defaultExpectation = &EvictedPopulationMockIsValidExpectation{mock: mmIsValid.mock}
	}
	mmIsValid.defaultExpectation.results = &EvictedPopulationMockIsValidResults{b1}
	return mmIsValid.mock
}

//Set uses given function f to mock the EvictedPopulation.IsValid method
func (mmIsValid *mEvictedPopulationMockIsValid) Set(f func() (b1 bool)) *EvictedPopulationMock {
	if mmIsValid.defaultExpectation != nil {
		mmIsValid.mock.t.Fatalf("Default expectation is already set for the EvictedPopulation.IsValid method")
	}

	if len(mmIsValid.expectations) > 0 {
		mmIsValid.mock.t.Fatalf("Some expectations are already set for the EvictedPopulation.IsValid method")
	}

	mmIsValid.mock.funcIsValid = f
	return mmIsValid.mock
}

// IsValid implements EvictedPopulation
func (mmIsValid *EvictedPopulationMock) IsValid() (b1 bool) {
	mm_atomic.AddUint64(&mmIsValid.beforeIsValidCounter, 1)
	defer mm_atomic.AddUint64(&mmIsValid.afterIsValidCounter, 1)

	if mmIsValid.inspectFuncIsValid != nil {
		mmIsValid.inspectFuncIsValid()
	}

	if mmIsValid.IsValidMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsValid.IsValidMock.defaultExpectation.Counter, 1)

		mm_results := mmIsValid.IsValidMock.defaultExpectation.results
		if mm_results == nil {
			mmIsValid.t.Fatal("No results are set for the EvictedPopulationMock.IsValid")
		}
		return (*mm_results).b1
	}
	if mmIsValid.funcIsValid != nil {
		return mmIsValid.funcIsValid()
	}
	mmIsValid.t.Fatalf("Unexpected call to EvictedPopulationMock.IsValid.")
	return
}

// IsValidAfterCounter returns a count of finished EvictedPopulationMock.IsValid invocations
func (mmIsValid *EvictedPopulationMock) IsValidAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsValid.afterIsValidCounter)
}

// IsValidBeforeCounter returns a count of EvictedPopulationMock.IsValid invocations
func (mmIsValid *EvictedPopulationMock) IsValidBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsValid.beforeIsValidCounter)
}

// MinimockIsValidDone returns true if the count of the IsValid invocations corresponds
// the number of defined expectations
func (m *EvictedPopulationMock) MinimockIsValidDone() bool {
	for _, e := range m.IsValidMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsValidMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsValidCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsValid != nil && mm_atomic.LoadUint64(&m.afterIsValidCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsValidInspect logs each unmet expectation
func (m *EvictedPopulationMock) MinimockIsValidInspect() {
	for _, e := range m.IsValidMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to EvictedPopulationMock.IsValid")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsValidMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsValidCounter) < 1 {
		m.t.Error("Expected call to EvictedPopulationMock.IsValid")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsValid != nil && mm_atomic.LoadUint64(&m.afterIsValidCounter) < 1 {
		m.t.Error("Expected call to EvictedPopulationMock.IsValid")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *EvictedPopulationMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockFindProfileInspect()

		m.MinimockGetCountInspect()

		m.MinimockGetDetectedErrorsInspect()

		m.MinimockGetProfilesInspect()

		m.MinimockIsValidInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *EvictedPopulationMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *EvictedPopulationMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockFindProfileDone() &&
		m.MinimockGetCountDone() &&
		m.MinimockGetDetectedErrorsDone() &&
		m.MinimockGetProfilesDone() &&
		m.MinimockIsValidDone()
}
