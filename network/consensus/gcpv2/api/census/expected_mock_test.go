package census

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/network/consensus/common/cryptkit"
	"github.com/insolar/insolar/network/consensus/gcpv2/api/profiles"
	"github.com/insolar/insolar/network/consensus/gcpv2/api/proofs"
	"github.com/insolar/insolar/pulse"
)

// ExpectedMock implements Expected
type ExpectedMock struct {
	t minimock.Tester

	funcCreateBuilder          func(ctx context.Context, pn pulse.Number) (b1 Builder)
	inspectFuncCreateBuilder   func(ctx context.Context, pn pulse.Number)
	afterCreateBuilderCounter  uint64
	beforeCreateBuilderCounter uint64
	CreateBuilderMock          mExpectedMockCreateBuilder

	funcGetCensusState          func() (s1 State)
	inspectFuncGetCensusState   func()
	afterGetCensusStateCounter  uint64
	beforeGetCensusStateCounter uint64
	GetCensusStateMock          mExpectedMockGetCensusState

	funcGetCloudStateHash          func() (c1 proofs.CloudStateHash)
	inspectFuncGetCloudStateHash   func()
	afterGetCloudStateHashCounter  uint64
	beforeGetCloudStateHashCounter uint64
	GetCloudStateHashMock          mExpectedMockGetCloudStateHash

	funcGetEvictedPopulation          func() (e1 EvictedPopulation)
	inspectFuncGetEvictedPopulation   func()
	afterGetEvictedPopulationCounter  uint64
	beforeGetEvictedPopulationCounter uint64
	GetEvictedPopulationMock          mExpectedMockGetEvictedPopulation

	funcGetExpectedPulseNumber          func() (n1 pulse.Number)
	inspectFuncGetExpectedPulseNumber   func()
	afterGetExpectedPulseNumberCounter  uint64
	beforeGetExpectedPulseNumberCounter uint64
	GetExpectedPulseNumberMock          mExpectedMockGetExpectedPulseNumber

	funcGetGlobulaStateHash          func() (g1 proofs.GlobulaStateHash)
	inspectFuncGetGlobulaStateHash   func()
	afterGetGlobulaStateHashCounter  uint64
	beforeGetGlobulaStateHashCounter uint64
	GetGlobulaStateHashMock          mExpectedMockGetGlobulaStateHash

	funcGetMandateRegistry          func() (m1 MandateRegistry)
	inspectFuncGetMandateRegistry   func()
	afterGetMandateRegistryCounter  uint64
	beforeGetMandateRegistryCounter uint64
	GetMandateRegistryMock          mExpectedMockGetMandateRegistry

	funcGetMisbehaviorRegistry          func() (m1 MisbehaviorRegistry)
	inspectFuncGetMisbehaviorRegistry   func()
	afterGetMisbehaviorRegistryCounter  uint64
	beforeGetMisbehaviorRegistryCounter uint64
	GetMisbehaviorRegistryMock          mExpectedMockGetMisbehaviorRegistry

	funcGetNearestPulseData          func() (b1 bool, d1 pulse.Data)
	inspectFuncGetNearestPulseData   func()
	afterGetNearestPulseDataCounter  uint64
	beforeGetNearestPulseDataCounter uint64
	GetNearestPulseDataMock          mExpectedMockGetNearestPulseData

	funcGetOfflinePopulation          func() (o1 OfflinePopulation)
	inspectFuncGetOfflinePopulation   func()
	afterGetOfflinePopulationCounter  uint64
	beforeGetOfflinePopulationCounter uint64
	GetOfflinePopulationMock          mExpectedMockGetOfflinePopulation

	funcGetOnlinePopulation          func() (o1 OnlinePopulation)
	inspectFuncGetOnlinePopulation   func()
	afterGetOnlinePopulationCounter  uint64
	beforeGetOnlinePopulationCounter uint64
	GetOnlinePopulationMock          mExpectedMockGetOnlinePopulation

	funcGetPrevious          func() (a1 Active)
	inspectFuncGetPrevious   func()
	afterGetPreviousCounter  uint64
	beforeGetPreviousCounter uint64
	GetPreviousMock          mExpectedMockGetPrevious

	funcGetProfileFactory          func(ksf cryptkit.KeyStoreFactory) (f1 profiles.Factory)
	inspectFuncGetProfileFactory   func(ksf cryptkit.KeyStoreFactory)
	afterGetProfileFactoryCounter  uint64
	beforeGetProfileFactoryCounter uint64
	GetProfileFactoryMock          mExpectedMockGetProfileFactory

	funcGetPulseNumber          func() (n1 pulse.Number)
	inspectFuncGetPulseNumber   func()
	afterGetPulseNumberCounter  uint64
	beforeGetPulseNumberCounter uint64
	GetPulseNumberMock          mExpectedMockGetPulseNumber

	funcIsActive          func() (b1 bool)
	inspectFuncIsActive   func()
	afterIsActiveCounter  uint64
	beforeIsActiveCounter uint64
	IsActiveMock          mExpectedMockIsActive

	funcMakeActive          func(pd pulse.Data) (a1 Active)
	inspectFuncMakeActive   func(pd pulse.Data)
	afterMakeActiveCounter  uint64
	beforeMakeActiveCounter uint64
	MakeActiveMock          mExpectedMockMakeActive

	funcRebuild          func(pn pulse.Number) (b1 Built)
	inspectFuncRebuild   func(pn pulse.Number)
	afterRebuildCounter  uint64
	beforeRebuildCounter uint64
	RebuildMock          mExpectedMockRebuild
}

// NewExpectedMock returns a mock for Expected
func NewExpectedMock(t minimock.Tester) *ExpectedMock {
	m := &ExpectedMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateBuilderMock = mExpectedMockCreateBuilder{mock: m}
	m.CreateBuilderMock.callArgs = []*ExpectedMockCreateBuilderParams{}

	m.GetCensusStateMock = mExpectedMockGetCensusState{mock: m}

	m.GetCloudStateHashMock = mExpectedMockGetCloudStateHash{mock: m}

	m.GetEvictedPopulationMock = mExpectedMockGetEvictedPopulation{mock: m}

	m.GetExpectedPulseNumberMock = mExpectedMockGetExpectedPulseNumber{mock: m}

	m.GetGlobulaStateHashMock = mExpectedMockGetGlobulaStateHash{mock: m}

	m.GetMandateRegistryMock = mExpectedMockGetMandateRegistry{mock: m}

	m.GetMisbehaviorRegistryMock = mExpectedMockGetMisbehaviorRegistry{mock: m}

	m.GetNearestPulseDataMock = mExpectedMockGetNearestPulseData{mock: m}

	m.GetOfflinePopulationMock = mExpectedMockGetOfflinePopulation{mock: m}

	m.GetOnlinePopulationMock = mExpectedMockGetOnlinePopulation{mock: m}

	m.GetPreviousMock = mExpectedMockGetPrevious{mock: m}

	m.GetProfileFactoryMock = mExpectedMockGetProfileFactory{mock: m}
	m.GetProfileFactoryMock.callArgs = []*ExpectedMockGetProfileFactoryParams{}

	m.GetPulseNumberMock = mExpectedMockGetPulseNumber{mock: m}

	m.IsActiveMock = mExpectedMockIsActive{mock: m}

	m.MakeActiveMock = mExpectedMockMakeActive{mock: m}
	m.MakeActiveMock.callArgs = []*ExpectedMockMakeActiveParams{}

	m.RebuildMock = mExpectedMockRebuild{mock: m}
	m.RebuildMock.callArgs = []*ExpectedMockRebuildParams{}

	return m
}

type mExpectedMockCreateBuilder struct {
	mock               *ExpectedMock
	defaultExpectation *ExpectedMockCreateBuilderExpectation
	expectations       []*ExpectedMockCreateBuilderExpectation

	callArgs []*ExpectedMockCreateBuilderParams
	mutex    sync.RWMutex
}

// ExpectedMockCreateBuilderExpectation specifies expectation struct of the Expected.CreateBuilder
type ExpectedMockCreateBuilderExpectation struct {
	mock    *ExpectedMock
	params  *ExpectedMockCreateBuilderParams
	results *ExpectedMockCreateBuilderResults
	Counter uint64
}

// ExpectedMockCreateBuilderParams contains parameters of the Expected.CreateBuilder
type ExpectedMockCreateBuilderParams struct {
	ctx context.Context
	pn  pulse.Number
}

// ExpectedMockCreateBuilderResults contains results of the Expected.CreateBuilder
type ExpectedMockCreateBuilderResults struct {
	b1 Builder
}

// Expect sets up expected params for Expected.CreateBuilder
func (mmCreateBuilder *mExpectedMockCreateBuilder) Expect(ctx context.Context, pn pulse.Number) *mExpectedMockCreateBuilder {
	if mmCreateBuilder.mock.funcCreateBuilder != nil {
		mmCreateBuilder.mock.t.Fatalf("ExpectedMock.CreateBuilder mock is already set by Set")
	}

	if mmCreateBuilder.defaultExpectation == nil {
		mmCreateBuilder.defaultExpectation = &ExpectedMockCreateBuilderExpectation{}
	}

	mmCreateBuilder.defaultExpectation.params = &ExpectedMockCreateBuilderParams{ctx, pn}
	for _, e := range mmCreateBuilder.expectations {
		if minimock.Equal(e.params, mmCreateBuilder.defaultExpectation.params) {
			mmCreateBuilder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateBuilder.defaultExpectation.params)
		}
	}

	return mmCreateBuilder
}

// Inspect accepts an inspector function that has same arguments as the Expected.CreateBuilder
func (mmCreateBuilder *mExpectedMockCreateBuilder) Inspect(f func(ctx context.Context, pn pulse.Number)) *mExpectedMockCreateBuilder {
	if mmCreateBuilder.mock.inspectFuncCreateBuilder != nil {
		mmCreateBuilder.mock.t.Fatalf("Inspect function is already set for ExpectedMock.CreateBuilder")
	}

	mmCreateBuilder.mock.inspectFuncCreateBuilder = f

	return mmCreateBuilder
}

// Return sets up results that will be returned by Expected.CreateBuilder
func (mmCreateBuilder *mExpectedMockCreateBuilder) Return(b1 Builder) *ExpectedMock {
	if mmCreateBuilder.mock.funcCreateBuilder != nil {
		mmCreateBuilder.mock.t.Fatalf("ExpectedMock.CreateBuilder mock is already set by Set")
	}

	if mmCreateBuilder.defaultExpectation == nil {
		mmCreateBuilder.defaultExpectation = &ExpectedMockCreateBuilderExpectation{mock: mmCreateBuilder.mock}
	}
	mmCreateBuilder.defaultExpectation.results = &ExpectedMockCreateBuilderResults{b1}
	return mmCreateBuilder.mock
}

//Set uses given function f to mock the Expected.CreateBuilder method
func (mmCreateBuilder *mExpectedMockCreateBuilder) Set(f func(ctx context.Context, pn pulse.Number) (b1 Builder)) *ExpectedMock {
	if mmCreateBuilder.defaultExpectation != nil {
		mmCreateBuilder.mock.t.Fatalf("Default expectation is already set for the Expected.CreateBuilder method")
	}

	if len(mmCreateBuilder.expectations) > 0 {
		mmCreateBuilder.mock.t.Fatalf("Some expectations are already set for the Expected.CreateBuilder method")
	}

	mmCreateBuilder.mock.funcCreateBuilder = f
	return mmCreateBuilder.mock
}

// When sets expectation for the Expected.CreateBuilder which will trigger the result defined by the following
// Then helper
func (mmCreateBuilder *mExpectedMockCreateBuilder) When(ctx context.Context, pn pulse.Number) *ExpectedMockCreateBuilderExpectation {
	if mmCreateBuilder.mock.funcCreateBuilder != nil {
		mmCreateBuilder.mock.t.Fatalf("ExpectedMock.CreateBuilder mock is already set by Set")
	}

	expectation := &ExpectedMockCreateBuilderExpectation{
		mock:   mmCreateBuilder.mock,
		params: &ExpectedMockCreateBuilderParams{ctx, pn},
	}
	mmCreateBuilder.expectations = append(mmCreateBuilder.expectations, expectation)
	return expectation
}

// Then sets up Expected.CreateBuilder return parameters for the expectation previously defined by the When method
func (e *ExpectedMockCreateBuilderExpectation) Then(b1 Builder) *ExpectedMock {
	e.results = &ExpectedMockCreateBuilderResults{b1}
	return e.mock
}

// CreateBuilder implements Expected
func (mmCreateBuilder *ExpectedMock) CreateBuilder(ctx context.Context, pn pulse.Number) (b1 Builder) {
	mm_atomic.AddUint64(&mmCreateBuilder.beforeCreateBuilderCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateBuilder.afterCreateBuilderCounter, 1)

	if mmCreateBuilder.inspectFuncCreateBuilder != nil {
		mmCreateBuilder.inspectFuncCreateBuilder(ctx, pn)
	}

	params := &ExpectedMockCreateBuilderParams{ctx, pn}

	// Record call args
	mmCreateBuilder.CreateBuilderMock.mutex.Lock()
	mmCreateBuilder.CreateBuilderMock.callArgs = append(mmCreateBuilder.CreateBuilderMock.callArgs, params)
	mmCreateBuilder.CreateBuilderMock.mutex.Unlock()

	for _, e := range mmCreateBuilder.CreateBuilderMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmCreateBuilder.CreateBuilderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateBuilder.CreateBuilderMock.defaultExpectation.Counter, 1)
		want := mmCreateBuilder.CreateBuilderMock.defaultExpectation.params
		got := ExpectedMockCreateBuilderParams{ctx, pn}
		if want != nil && !minimock.Equal(*want, got) {
			mmCreateBuilder.t.Errorf("ExpectedMock.CreateBuilder got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmCreateBuilder.CreateBuilderMock.defaultExpectation.results
		if results == nil {
			mmCreateBuilder.t.Fatal("No results are set for the ExpectedMock.CreateBuilder")
		}
		return (*results).b1
	}
	if mmCreateBuilder.funcCreateBuilder != nil {
		return mmCreateBuilder.funcCreateBuilder(ctx, pn)
	}
	mmCreateBuilder.t.Fatalf("Unexpected call to ExpectedMock.CreateBuilder. %v %v", ctx, pn)
	return
}

// CreateBuilderAfterCounter returns a count of finished ExpectedMock.CreateBuilder invocations
func (mmCreateBuilder *ExpectedMock) CreateBuilderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateBuilder.afterCreateBuilderCounter)
}

// CreateBuilderBeforeCounter returns a count of ExpectedMock.CreateBuilder invocations
func (mmCreateBuilder *ExpectedMock) CreateBuilderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateBuilder.beforeCreateBuilderCounter)
}

// Calls returns a list of arguments used in each call to ExpectedMock.CreateBuilder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateBuilder *mExpectedMockCreateBuilder) Calls() []*ExpectedMockCreateBuilderParams {
	mmCreateBuilder.mutex.RLock()

	argCopy := make([]*ExpectedMockCreateBuilderParams, len(mmCreateBuilder.callArgs))
	copy(argCopy, mmCreateBuilder.callArgs)

	mmCreateBuilder.mutex.RUnlock()

	return argCopy
}

// MinimockCreateBuilderDone returns true if the count of the CreateBuilder invocations corresponds
// the number of defined expectations
func (m *ExpectedMock) MinimockCreateBuilderDone() bool {
	for _, e := range m.CreateBuilderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateBuilderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateBuilderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateBuilder != nil && mm_atomic.LoadUint64(&m.afterCreateBuilderCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateBuilderInspect logs each unmet expectation
func (m *ExpectedMock) MinimockCreateBuilderInspect() {
	for _, e := range m.CreateBuilderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExpectedMock.CreateBuilder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateBuilderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateBuilderCounter) < 1 {
		if m.CreateBuilderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExpectedMock.CreateBuilder")
		} else {
			m.t.Errorf("Expected call to ExpectedMock.CreateBuilder with params: %#v", *m.CreateBuilderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateBuilder != nil && mm_atomic.LoadUint64(&m.afterCreateBuilderCounter) < 1 {
		m.t.Error("Expected call to ExpectedMock.CreateBuilder")
	}
}

type mExpectedMockGetCensusState struct {
	mock               *ExpectedMock
	defaultExpectation *ExpectedMockGetCensusStateExpectation
	expectations       []*ExpectedMockGetCensusStateExpectation
}

// ExpectedMockGetCensusStateExpectation specifies expectation struct of the Expected.GetCensusState
type ExpectedMockGetCensusStateExpectation struct {
	mock *ExpectedMock

	results *ExpectedMockGetCensusStateResults
	Counter uint64
}

// ExpectedMockGetCensusStateResults contains results of the Expected.GetCensusState
type ExpectedMockGetCensusStateResults struct {
	s1 State
}

// Expect sets up expected params for Expected.GetCensusState
func (mmGetCensusState *mExpectedMockGetCensusState) Expect() *mExpectedMockGetCensusState {
	if mmGetCensusState.mock.funcGetCensusState != nil {
		mmGetCensusState.mock.t.Fatalf("ExpectedMock.GetCensusState mock is already set by Set")
	}

	if mmGetCensusState.defaultExpectation == nil {
		mmGetCensusState.defaultExpectation = &ExpectedMockGetCensusStateExpectation{}
	}

	return mmGetCensusState
}

// Inspect accepts an inspector function that has same arguments as the Expected.GetCensusState
func (mmGetCensusState *mExpectedMockGetCensusState) Inspect(f func()) *mExpectedMockGetCensusState {
	if mmGetCensusState.mock.inspectFuncGetCensusState != nil {
		mmGetCensusState.mock.t.Fatalf("Inspect function is already set for ExpectedMock.GetCensusState")
	}

	mmGetCensusState.mock.inspectFuncGetCensusState = f

	return mmGetCensusState
}

// Return sets up results that will be returned by Expected.GetCensusState
func (mmGetCensusState *mExpectedMockGetCensusState) Return(s1 State) *ExpectedMock {
	if mmGetCensusState.mock.funcGetCensusState != nil {
		mmGetCensusState.mock.t.Fatalf("ExpectedMock.GetCensusState mock is already set by Set")
	}

	if mmGetCensusState.defaultExpectation == nil {
		mmGetCensusState.defaultExpectation = &ExpectedMockGetCensusStateExpectation{mock: mmGetCensusState.mock}
	}
	mmGetCensusState.defaultExpectation.results = &ExpectedMockGetCensusStateResults{s1}
	return mmGetCensusState.mock
}

//Set uses given function f to mock the Expected.GetCensusState method
func (mmGetCensusState *mExpectedMockGetCensusState) Set(f func() (s1 State)) *ExpectedMock {
	if mmGetCensusState.defaultExpectation != nil {
		mmGetCensusState.mock.t.Fatalf("Default expectation is already set for the Expected.GetCensusState method")
	}

	if len(mmGetCensusState.expectations) > 0 {
		mmGetCensusState.mock.t.Fatalf("Some expectations are already set for the Expected.GetCensusState method")
	}

	mmGetCensusState.mock.funcGetCensusState = f
	return mmGetCensusState.mock
}

// GetCensusState implements Expected
func (mmGetCensusState *ExpectedMock) GetCensusState() (s1 State) {
	mm_atomic.AddUint64(&mmGetCensusState.beforeGetCensusStateCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCensusState.afterGetCensusStateCounter, 1)

	if mmGetCensusState.inspectFuncGetCensusState != nil {
		mmGetCensusState.inspectFuncGetCensusState()
	}

	if mmGetCensusState.GetCensusStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCensusState.GetCensusStateMock.defaultExpectation.Counter, 1)

		results := mmGetCensusState.GetCensusStateMock.defaultExpectation.results
		if results == nil {
			mmGetCensusState.t.Fatal("No results are set for the ExpectedMock.GetCensusState")
		}
		return (*results).s1
	}
	if mmGetCensusState.funcGetCensusState != nil {
		return mmGetCensusState.funcGetCensusState()
	}
	mmGetCensusState.t.Fatalf("Unexpected call to ExpectedMock.GetCensusState.")
	return
}

// GetCensusStateAfterCounter returns a count of finished ExpectedMock.GetCensusState invocations
func (mmGetCensusState *ExpectedMock) GetCensusStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCensusState.afterGetCensusStateCounter)
}

// GetCensusStateBeforeCounter returns a count of ExpectedMock.GetCensusState invocations
func (mmGetCensusState *ExpectedMock) GetCensusStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCensusState.beforeGetCensusStateCounter)
}

// MinimockGetCensusStateDone returns true if the count of the GetCensusState invocations corresponds
// the number of defined expectations
func (m *ExpectedMock) MinimockGetCensusStateDone() bool {
	for _, e := range m.GetCensusStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCensusStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCensusStateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCensusState != nil && mm_atomic.LoadUint64(&m.afterGetCensusStateCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCensusStateInspect logs each unmet expectation
func (m *ExpectedMock) MinimockGetCensusStateInspect() {
	for _, e := range m.GetCensusStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExpectedMock.GetCensusState")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCensusStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCensusStateCounter) < 1 {
		m.t.Error("Expected call to ExpectedMock.GetCensusState")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCensusState != nil && mm_atomic.LoadUint64(&m.afterGetCensusStateCounter) < 1 {
		m.t.Error("Expected call to ExpectedMock.GetCensusState")
	}
}

type mExpectedMockGetCloudStateHash struct {
	mock               *ExpectedMock
	defaultExpectation *ExpectedMockGetCloudStateHashExpectation
	expectations       []*ExpectedMockGetCloudStateHashExpectation
}

// ExpectedMockGetCloudStateHashExpectation specifies expectation struct of the Expected.GetCloudStateHash
type ExpectedMockGetCloudStateHashExpectation struct {
	mock *ExpectedMock

	results *ExpectedMockGetCloudStateHashResults
	Counter uint64
}

// ExpectedMockGetCloudStateHashResults contains results of the Expected.GetCloudStateHash
type ExpectedMockGetCloudStateHashResults struct {
	c1 proofs.CloudStateHash
}

// Expect sets up expected params for Expected.GetCloudStateHash
func (mmGetCloudStateHash *mExpectedMockGetCloudStateHash) Expect() *mExpectedMockGetCloudStateHash {
	if mmGetCloudStateHash.mock.funcGetCloudStateHash != nil {
		mmGetCloudStateHash.mock.t.Fatalf("ExpectedMock.GetCloudStateHash mock is already set by Set")
	}

	if mmGetCloudStateHash.defaultExpectation == nil {
		mmGetCloudStateHash.defaultExpectation = &ExpectedMockGetCloudStateHashExpectation{}
	}

	return mmGetCloudStateHash
}

// Inspect accepts an inspector function that has same arguments as the Expected.GetCloudStateHash
func (mmGetCloudStateHash *mExpectedMockGetCloudStateHash) Inspect(f func()) *mExpectedMockGetCloudStateHash {
	if mmGetCloudStateHash.mock.inspectFuncGetCloudStateHash != nil {
		mmGetCloudStateHash.mock.t.Fatalf("Inspect function is already set for ExpectedMock.GetCloudStateHash")
	}

	mmGetCloudStateHash.mock.inspectFuncGetCloudStateHash = f

	return mmGetCloudStateHash
}

// Return sets up results that will be returned by Expected.GetCloudStateHash
func (mmGetCloudStateHash *mExpectedMockGetCloudStateHash) Return(c1 proofs.CloudStateHash) *ExpectedMock {
	if mmGetCloudStateHash.mock.funcGetCloudStateHash != nil {
		mmGetCloudStateHash.mock.t.Fatalf("ExpectedMock.GetCloudStateHash mock is already set by Set")
	}

	if mmGetCloudStateHash.defaultExpectation == nil {
		mmGetCloudStateHash.defaultExpectation = &ExpectedMockGetCloudStateHashExpectation{mock: mmGetCloudStateHash.mock}
	}
	mmGetCloudStateHash.defaultExpectation.results = &ExpectedMockGetCloudStateHashResults{c1}
	return mmGetCloudStateHash.mock
}

//Set uses given function f to mock the Expected.GetCloudStateHash method
func (mmGetCloudStateHash *mExpectedMockGetCloudStateHash) Set(f func() (c1 proofs.CloudStateHash)) *ExpectedMock {
	if mmGetCloudStateHash.defaultExpectation != nil {
		mmGetCloudStateHash.mock.t.Fatalf("Default expectation is already set for the Expected.GetCloudStateHash method")
	}

	if len(mmGetCloudStateHash.expectations) > 0 {
		mmGetCloudStateHash.mock.t.Fatalf("Some expectations are already set for the Expected.GetCloudStateHash method")
	}

	mmGetCloudStateHash.mock.funcGetCloudStateHash = f
	return mmGetCloudStateHash.mock
}

// GetCloudStateHash implements Expected
func (mmGetCloudStateHash *ExpectedMock) GetCloudStateHash() (c1 proofs.CloudStateHash) {
	mm_atomic.AddUint64(&mmGetCloudStateHash.beforeGetCloudStateHashCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCloudStateHash.afterGetCloudStateHashCounter, 1)

	if mmGetCloudStateHash.inspectFuncGetCloudStateHash != nil {
		mmGetCloudStateHash.inspectFuncGetCloudStateHash()
	}

	if mmGetCloudStateHash.GetCloudStateHashMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCloudStateHash.GetCloudStateHashMock.defaultExpectation.Counter, 1)

		results := mmGetCloudStateHash.GetCloudStateHashMock.defaultExpectation.results
		if results == nil {
			mmGetCloudStateHash.t.Fatal("No results are set for the ExpectedMock.GetCloudStateHash")
		}
		return (*results).c1
	}
	if mmGetCloudStateHash.funcGetCloudStateHash != nil {
		return mmGetCloudStateHash.funcGetCloudStateHash()
	}
	mmGetCloudStateHash.t.Fatalf("Unexpected call to ExpectedMock.GetCloudStateHash.")
	return
}

// GetCloudStateHashAfterCounter returns a count of finished ExpectedMock.GetCloudStateHash invocations
func (mmGetCloudStateHash *ExpectedMock) GetCloudStateHashAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCloudStateHash.afterGetCloudStateHashCounter)
}

// GetCloudStateHashBeforeCounter returns a count of ExpectedMock.GetCloudStateHash invocations
func (mmGetCloudStateHash *ExpectedMock) GetCloudStateHashBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCloudStateHash.beforeGetCloudStateHashCounter)
}

// MinimockGetCloudStateHashDone returns true if the count of the GetCloudStateHash invocations corresponds
// the number of defined expectations
func (m *ExpectedMock) MinimockGetCloudStateHashDone() bool {
	for _, e := range m.GetCloudStateHashMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCloudStateHashMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCloudStateHashCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCloudStateHash != nil && mm_atomic.LoadUint64(&m.afterGetCloudStateHashCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCloudStateHashInspect logs each unmet expectation
func (m *ExpectedMock) MinimockGetCloudStateHashInspect() {
	for _, e := range m.GetCloudStateHashMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExpectedMock.GetCloudStateHash")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCloudStateHashMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCloudStateHashCounter) < 1 {
		m.t.Error("Expected call to ExpectedMock.GetCloudStateHash")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCloudStateHash != nil && mm_atomic.LoadUint64(&m.afterGetCloudStateHashCounter) < 1 {
		m.t.Error("Expected call to ExpectedMock.GetCloudStateHash")
	}
}

type mExpectedMockGetEvictedPopulation struct {
	mock               *ExpectedMock
	defaultExpectation *ExpectedMockGetEvictedPopulationExpectation
	expectations       []*ExpectedMockGetEvictedPopulationExpectation
}

// ExpectedMockGetEvictedPopulationExpectation specifies expectation struct of the Expected.GetEvictedPopulation
type ExpectedMockGetEvictedPopulationExpectation struct {
	mock *ExpectedMock

	results *ExpectedMockGetEvictedPopulationResults
	Counter uint64
}

// ExpectedMockGetEvictedPopulationResults contains results of the Expected.GetEvictedPopulation
type ExpectedMockGetEvictedPopulationResults struct {
	e1 EvictedPopulation
}

// Expect sets up expected params for Expected.GetEvictedPopulation
func (mmGetEvictedPopulation *mExpectedMockGetEvictedPopulation) Expect() *mExpectedMockGetEvictedPopulation {
	if mmGetEvictedPopulation.mock.funcGetEvictedPopulation != nil {
		mmGetEvictedPopulation.mock.t.Fatalf("ExpectedMock.GetEvictedPopulation mock is already set by Set")
	}

	if mmGetEvictedPopulation.defaultExpectation == nil {
		mmGetEvictedPopulation.defaultExpectation = &ExpectedMockGetEvictedPopulationExpectation{}
	}

	return mmGetEvictedPopulation
}

// Inspect accepts an inspector function that has same arguments as the Expected.GetEvictedPopulation
func (mmGetEvictedPopulation *mExpectedMockGetEvictedPopulation) Inspect(f func()) *mExpectedMockGetEvictedPopulation {
	if mmGetEvictedPopulation.mock.inspectFuncGetEvictedPopulation != nil {
		mmGetEvictedPopulation.mock.t.Fatalf("Inspect function is already set for ExpectedMock.GetEvictedPopulation")
	}

	mmGetEvictedPopulation.mock.inspectFuncGetEvictedPopulation = f

	return mmGetEvictedPopulation
}

// Return sets up results that will be returned by Expected.GetEvictedPopulation
func (mmGetEvictedPopulation *mExpectedMockGetEvictedPopulation) Return(e1 EvictedPopulation) *ExpectedMock {
	if mmGetEvictedPopulation.mock.funcGetEvictedPopulation != nil {
		mmGetEvictedPopulation.mock.t.Fatalf("ExpectedMock.GetEvictedPopulation mock is already set by Set")
	}

	if mmGetEvictedPopulation.defaultExpectation == nil {
		mmGetEvictedPopulation.defaultExpectation = &ExpectedMockGetEvictedPopulationExpectation{mock: mmGetEvictedPopulation.mock}
	}
	mmGetEvictedPopulation.defaultExpectation.results = &ExpectedMockGetEvictedPopulationResults{e1}
	return mmGetEvictedPopulation.mock
}

//Set uses given function f to mock the Expected.GetEvictedPopulation method
func (mmGetEvictedPopulation *mExpectedMockGetEvictedPopulation) Set(f func() (e1 EvictedPopulation)) *ExpectedMock {
	if mmGetEvictedPopulation.defaultExpectation != nil {
		mmGetEvictedPopulation.mock.t.Fatalf("Default expectation is already set for the Expected.GetEvictedPopulation method")
	}

	if len(mmGetEvictedPopulation.expectations) > 0 {
		mmGetEvictedPopulation.mock.t.Fatalf("Some expectations are already set for the Expected.GetEvictedPopulation method")
	}

	mmGetEvictedPopulation.mock.funcGetEvictedPopulation = f
	return mmGetEvictedPopulation.mock
}

// GetEvictedPopulation implements Expected
func (mmGetEvictedPopulation *ExpectedMock) GetEvictedPopulation() (e1 EvictedPopulation) {
	mm_atomic.AddUint64(&mmGetEvictedPopulation.beforeGetEvictedPopulationCounter, 1)
	defer mm_atomic.AddUint64(&mmGetEvictedPopulation.afterGetEvictedPopulationCounter, 1)

	if mmGetEvictedPopulation.inspectFuncGetEvictedPopulation != nil {
		mmGetEvictedPopulation.inspectFuncGetEvictedPopulation()
	}

	if mmGetEvictedPopulation.GetEvictedPopulationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetEvictedPopulation.GetEvictedPopulationMock.defaultExpectation.Counter, 1)

		results := mmGetEvictedPopulation.GetEvictedPopulationMock.defaultExpectation.results
		if results == nil {
			mmGetEvictedPopulation.t.Fatal("No results are set for the ExpectedMock.GetEvictedPopulation")
		}
		return (*results).e1
	}
	if mmGetEvictedPopulation.funcGetEvictedPopulation != nil {
		return mmGetEvictedPopulation.funcGetEvictedPopulation()
	}
	mmGetEvictedPopulation.t.Fatalf("Unexpected call to ExpectedMock.GetEvictedPopulation.")
	return
}

// GetEvictedPopulationAfterCounter returns a count of finished ExpectedMock.GetEvictedPopulation invocations
func (mmGetEvictedPopulation *ExpectedMock) GetEvictedPopulationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetEvictedPopulation.afterGetEvictedPopulationCounter)
}

// GetEvictedPopulationBeforeCounter returns a count of ExpectedMock.GetEvictedPopulation invocations
func (mmGetEvictedPopulation *ExpectedMock) GetEvictedPopulationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetEvictedPopulation.beforeGetEvictedPopulationCounter)
}

// MinimockGetEvictedPopulationDone returns true if the count of the GetEvictedPopulation invocations corresponds
// the number of defined expectations
func (m *ExpectedMock) MinimockGetEvictedPopulationDone() bool {
	for _, e := range m.GetEvictedPopulationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetEvictedPopulationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetEvictedPopulationCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetEvictedPopulation != nil && mm_atomic.LoadUint64(&m.afterGetEvictedPopulationCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetEvictedPopulationInspect logs each unmet expectation
func (m *ExpectedMock) MinimockGetEvictedPopulationInspect() {
	for _, e := range m.GetEvictedPopulationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExpectedMock.GetEvictedPopulation")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetEvictedPopulationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetEvictedPopulationCounter) < 1 {
		m.t.Error("Expected call to ExpectedMock.GetEvictedPopulation")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetEvictedPopulation != nil && mm_atomic.LoadUint64(&m.afterGetEvictedPopulationCounter) < 1 {
		m.t.Error("Expected call to ExpectedMock.GetEvictedPopulation")
	}
}

type mExpectedMockGetExpectedPulseNumber struct {
	mock               *ExpectedMock
	defaultExpectation *ExpectedMockGetExpectedPulseNumberExpectation
	expectations       []*ExpectedMockGetExpectedPulseNumberExpectation
}

// ExpectedMockGetExpectedPulseNumberExpectation specifies expectation struct of the Expected.GetExpectedPulseNumber
type ExpectedMockGetExpectedPulseNumberExpectation struct {
	mock *ExpectedMock

	results *ExpectedMockGetExpectedPulseNumberResults
	Counter uint64
}

// ExpectedMockGetExpectedPulseNumberResults contains results of the Expected.GetExpectedPulseNumber
type ExpectedMockGetExpectedPulseNumberResults struct {
	n1 pulse.Number
}

// Expect sets up expected params for Expected.GetExpectedPulseNumber
func (mmGetExpectedPulseNumber *mExpectedMockGetExpectedPulseNumber) Expect() *mExpectedMockGetExpectedPulseNumber {
	if mmGetExpectedPulseNumber.mock.funcGetExpectedPulseNumber != nil {
		mmGetExpectedPulseNumber.mock.t.Fatalf("ExpectedMock.GetExpectedPulseNumber mock is already set by Set")
	}

	if mmGetExpectedPulseNumber.defaultExpectation == nil {
		mmGetExpectedPulseNumber.defaultExpectation = &ExpectedMockGetExpectedPulseNumberExpectation{}
	}

	return mmGetExpectedPulseNumber
}

// Inspect accepts an inspector function that has same arguments as the Expected.GetExpectedPulseNumber
func (mmGetExpectedPulseNumber *mExpectedMockGetExpectedPulseNumber) Inspect(f func()) *mExpectedMockGetExpectedPulseNumber {
	if mmGetExpectedPulseNumber.mock.inspectFuncGetExpectedPulseNumber != nil {
		mmGetExpectedPulseNumber.mock.t.Fatalf("Inspect function is already set for ExpectedMock.GetExpectedPulseNumber")
	}

	mmGetExpectedPulseNumber.mock.inspectFuncGetExpectedPulseNumber = f

	return mmGetExpectedPulseNumber
}

// Return sets up results that will be returned by Expected.GetExpectedPulseNumber
func (mmGetExpectedPulseNumber *mExpectedMockGetExpectedPulseNumber) Return(n1 pulse.Number) *ExpectedMock {
	if mmGetExpectedPulseNumber.mock.funcGetExpectedPulseNumber != nil {
		mmGetExpectedPulseNumber.mock.t.Fatalf("ExpectedMock.GetExpectedPulseNumber mock is already set by Set")
	}

	if mmGetExpectedPulseNumber.defaultExpectation == nil {
		mmGetExpectedPulseNumber.defaultExpectation = &ExpectedMockGetExpectedPulseNumberExpectation{mock: mmGetExpectedPulseNumber.mock}
	}
	mmGetExpectedPulseNumber.defaultExpectation.results = &ExpectedMockGetExpectedPulseNumberResults{n1}
	return mmGetExpectedPulseNumber.mock
}

//Set uses given function f to mock the Expected.GetExpectedPulseNumber method
func (mmGetExpectedPulseNumber *mExpectedMockGetExpectedPulseNumber) Set(f func() (n1 pulse.Number)) *ExpectedMock {
	if mmGetExpectedPulseNumber.defaultExpectation != nil {
		mmGetExpectedPulseNumber.mock.t.Fatalf("Default expectation is already set for the Expected.GetExpectedPulseNumber method")
	}

	if len(mmGetExpectedPulseNumber.expectations) > 0 {
		mmGetExpectedPulseNumber.mock.t.Fatalf("Some expectations are already set for the Expected.GetExpectedPulseNumber method")
	}

	mmGetExpectedPulseNumber.mock.funcGetExpectedPulseNumber = f
	return mmGetExpectedPulseNumber.mock
}

// GetExpectedPulseNumber implements Expected
func (mmGetExpectedPulseNumber *ExpectedMock) GetExpectedPulseNumber() (n1 pulse.Number) {
	mm_atomic.AddUint64(&mmGetExpectedPulseNumber.beforeGetExpectedPulseNumberCounter, 1)
	defer mm_atomic.AddUint64(&mmGetExpectedPulseNumber.afterGetExpectedPulseNumberCounter, 1)

	if mmGetExpectedPulseNumber.inspectFuncGetExpectedPulseNumber != nil {
		mmGetExpectedPulseNumber.inspectFuncGetExpectedPulseNumber()
	}

	if mmGetExpectedPulseNumber.GetExpectedPulseNumberMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetExpectedPulseNumber.GetExpectedPulseNumberMock.defaultExpectation.Counter, 1)

		results := mmGetExpectedPulseNumber.GetExpectedPulseNumberMock.defaultExpectation.results
		if results == nil {
			mmGetExpectedPulseNumber.t.Fatal("No results are set for the ExpectedMock.GetExpectedPulseNumber")
		}
		return (*results).n1
	}
	if mmGetExpectedPulseNumber.funcGetExpectedPulseNumber != nil {
		return mmGetExpectedPulseNumber.funcGetExpectedPulseNumber()
	}
	mmGetExpectedPulseNumber.t.Fatalf("Unexpected call to ExpectedMock.GetExpectedPulseNumber.")
	return
}

// GetExpectedPulseNumberAfterCounter returns a count of finished ExpectedMock.GetExpectedPulseNumber invocations
func (mmGetExpectedPulseNumber *ExpectedMock) GetExpectedPulseNumberAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetExpectedPulseNumber.afterGetExpectedPulseNumberCounter)
}

// GetExpectedPulseNumberBeforeCounter returns a count of ExpectedMock.GetExpectedPulseNumber invocations
func (mmGetExpectedPulseNumber *ExpectedMock) GetExpectedPulseNumberBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetExpectedPulseNumber.beforeGetExpectedPulseNumberCounter)
}

// MinimockGetExpectedPulseNumberDone returns true if the count of the GetExpectedPulseNumber invocations corresponds
// the number of defined expectations
func (m *ExpectedMock) MinimockGetExpectedPulseNumberDone() bool {
	for _, e := range m.GetExpectedPulseNumberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetExpectedPulseNumberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetExpectedPulseNumberCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetExpectedPulseNumber != nil && mm_atomic.LoadUint64(&m.afterGetExpectedPulseNumberCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetExpectedPulseNumberInspect logs each unmet expectation
func (m *ExpectedMock) MinimockGetExpectedPulseNumberInspect() {
	for _, e := range m.GetExpectedPulseNumberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExpectedMock.GetExpectedPulseNumber")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetExpectedPulseNumberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetExpectedPulseNumberCounter) < 1 {
		m.t.Error("Expected call to ExpectedMock.GetExpectedPulseNumber")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetExpectedPulseNumber != nil && mm_atomic.LoadUint64(&m.afterGetExpectedPulseNumberCounter) < 1 {
		m.t.Error("Expected call to ExpectedMock.GetExpectedPulseNumber")
	}
}

type mExpectedMockGetGlobulaStateHash struct {
	mock               *ExpectedMock
	defaultExpectation *ExpectedMockGetGlobulaStateHashExpectation
	expectations       []*ExpectedMockGetGlobulaStateHashExpectation
}

// ExpectedMockGetGlobulaStateHashExpectation specifies expectation struct of the Expected.GetGlobulaStateHash
type ExpectedMockGetGlobulaStateHashExpectation struct {
	mock *ExpectedMock

	results *ExpectedMockGetGlobulaStateHashResults
	Counter uint64
}

// ExpectedMockGetGlobulaStateHashResults contains results of the Expected.GetGlobulaStateHash
type ExpectedMockGetGlobulaStateHashResults struct {
	g1 proofs.GlobulaStateHash
}

// Expect sets up expected params for Expected.GetGlobulaStateHash
func (mmGetGlobulaStateHash *mExpectedMockGetGlobulaStateHash) Expect() *mExpectedMockGetGlobulaStateHash {
	if mmGetGlobulaStateHash.mock.funcGetGlobulaStateHash != nil {
		mmGetGlobulaStateHash.mock.t.Fatalf("ExpectedMock.GetGlobulaStateHash mock is already set by Set")
	}

	if mmGetGlobulaStateHash.defaultExpectation == nil {
		mmGetGlobulaStateHash.defaultExpectation = &ExpectedMockGetGlobulaStateHashExpectation{}
	}

	return mmGetGlobulaStateHash
}

// Inspect accepts an inspector function that has same arguments as the Expected.GetGlobulaStateHash
func (mmGetGlobulaStateHash *mExpectedMockGetGlobulaStateHash) Inspect(f func()) *mExpectedMockGetGlobulaStateHash {
	if mmGetGlobulaStateHash.mock.inspectFuncGetGlobulaStateHash != nil {
		mmGetGlobulaStateHash.mock.t.Fatalf("Inspect function is already set for ExpectedMock.GetGlobulaStateHash")
	}

	mmGetGlobulaStateHash.mock.inspectFuncGetGlobulaStateHash = f

	return mmGetGlobulaStateHash
}

// Return sets up results that will be returned by Expected.GetGlobulaStateHash
func (mmGetGlobulaStateHash *mExpectedMockGetGlobulaStateHash) Return(g1 proofs.GlobulaStateHash) *ExpectedMock {
	if mmGetGlobulaStateHash.mock.funcGetGlobulaStateHash != nil {
		mmGetGlobulaStateHash.mock.t.Fatalf("ExpectedMock.GetGlobulaStateHash mock is already set by Set")
	}

	if mmGetGlobulaStateHash.defaultExpectation == nil {
		mmGetGlobulaStateHash.defaultExpectation = &ExpectedMockGetGlobulaStateHashExpectation{mock: mmGetGlobulaStateHash.mock}
	}
	mmGetGlobulaStateHash.defaultExpectation.results = &ExpectedMockGetGlobulaStateHashResults{g1}
	return mmGetGlobulaStateHash.mock
}

//Set uses given function f to mock the Expected.GetGlobulaStateHash method
func (mmGetGlobulaStateHash *mExpectedMockGetGlobulaStateHash) Set(f func() (g1 proofs.GlobulaStateHash)) *ExpectedMock {
	if mmGetGlobulaStateHash.defaultExpectation != nil {
		mmGetGlobulaStateHash.mock.t.Fatalf("Default expectation is already set for the Expected.GetGlobulaStateHash method")
	}

	if len(mmGetGlobulaStateHash.expectations) > 0 {
		mmGetGlobulaStateHash.mock.t.Fatalf("Some expectations are already set for the Expected.GetGlobulaStateHash method")
	}

	mmGetGlobulaStateHash.mock.funcGetGlobulaStateHash = f
	return mmGetGlobulaStateHash.mock
}

// GetGlobulaStateHash implements Expected
func (mmGetGlobulaStateHash *ExpectedMock) GetGlobulaStateHash() (g1 proofs.GlobulaStateHash) {
	mm_atomic.AddUint64(&mmGetGlobulaStateHash.beforeGetGlobulaStateHashCounter, 1)
	defer mm_atomic.AddUint64(&mmGetGlobulaStateHash.afterGetGlobulaStateHashCounter, 1)

	if mmGetGlobulaStateHash.inspectFuncGetGlobulaStateHash != nil {
		mmGetGlobulaStateHash.inspectFuncGetGlobulaStateHash()
	}

	if mmGetGlobulaStateHash.GetGlobulaStateHashMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetGlobulaStateHash.GetGlobulaStateHashMock.defaultExpectation.Counter, 1)

		results := mmGetGlobulaStateHash.GetGlobulaStateHashMock.defaultExpectation.results
		if results == nil {
			mmGetGlobulaStateHash.t.Fatal("No results are set for the ExpectedMock.GetGlobulaStateHash")
		}
		return (*results).g1
	}
	if mmGetGlobulaStateHash.funcGetGlobulaStateHash != nil {
		return mmGetGlobulaStateHash.funcGetGlobulaStateHash()
	}
	mmGetGlobulaStateHash.t.Fatalf("Unexpected call to ExpectedMock.GetGlobulaStateHash.")
	return
}

// GetGlobulaStateHashAfterCounter returns a count of finished ExpectedMock.GetGlobulaStateHash invocations
func (mmGetGlobulaStateHash *ExpectedMock) GetGlobulaStateHashAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetGlobulaStateHash.afterGetGlobulaStateHashCounter)
}

// GetGlobulaStateHashBeforeCounter returns a count of ExpectedMock.GetGlobulaStateHash invocations
func (mmGetGlobulaStateHash *ExpectedMock) GetGlobulaStateHashBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetGlobulaStateHash.beforeGetGlobulaStateHashCounter)
}

// MinimockGetGlobulaStateHashDone returns true if the count of the GetGlobulaStateHash invocations corresponds
// the number of defined expectations
func (m *ExpectedMock) MinimockGetGlobulaStateHashDone() bool {
	for _, e := range m.GetGlobulaStateHashMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetGlobulaStateHashMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetGlobulaStateHashCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetGlobulaStateHash != nil && mm_atomic.LoadUint64(&m.afterGetGlobulaStateHashCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetGlobulaStateHashInspect logs each unmet expectation
func (m *ExpectedMock) MinimockGetGlobulaStateHashInspect() {
	for _, e := range m.GetGlobulaStateHashMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExpectedMock.GetGlobulaStateHash")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetGlobulaStateHashMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetGlobulaStateHashCounter) < 1 {
		m.t.Error("Expected call to ExpectedMock.GetGlobulaStateHash")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetGlobulaStateHash != nil && mm_atomic.LoadUint64(&m.afterGetGlobulaStateHashCounter) < 1 {
		m.t.Error("Expected call to ExpectedMock.GetGlobulaStateHash")
	}
}

type mExpectedMockGetMandateRegistry struct {
	mock               *ExpectedMock
	defaultExpectation *ExpectedMockGetMandateRegistryExpectation
	expectations       []*ExpectedMockGetMandateRegistryExpectation
}

// ExpectedMockGetMandateRegistryExpectation specifies expectation struct of the Expected.GetMandateRegistry
type ExpectedMockGetMandateRegistryExpectation struct {
	mock *ExpectedMock

	results *ExpectedMockGetMandateRegistryResults
	Counter uint64
}

// ExpectedMockGetMandateRegistryResults contains results of the Expected.GetMandateRegistry
type ExpectedMockGetMandateRegistryResults struct {
	m1 MandateRegistry
}

// Expect sets up expected params for Expected.GetMandateRegistry
func (mmGetMandateRegistry *mExpectedMockGetMandateRegistry) Expect() *mExpectedMockGetMandateRegistry {
	if mmGetMandateRegistry.mock.funcGetMandateRegistry != nil {
		mmGetMandateRegistry.mock.t.Fatalf("ExpectedMock.GetMandateRegistry mock is already set by Set")
	}

	if mmGetMandateRegistry.defaultExpectation == nil {
		mmGetMandateRegistry.defaultExpectation = &ExpectedMockGetMandateRegistryExpectation{}
	}

	return mmGetMandateRegistry
}

// Inspect accepts an inspector function that has same arguments as the Expected.GetMandateRegistry
func (mmGetMandateRegistry *mExpectedMockGetMandateRegistry) Inspect(f func()) *mExpectedMockGetMandateRegistry {
	if mmGetMandateRegistry.mock.inspectFuncGetMandateRegistry != nil {
		mmGetMandateRegistry.mock.t.Fatalf("Inspect function is already set for ExpectedMock.GetMandateRegistry")
	}

	mmGetMandateRegistry.mock.inspectFuncGetMandateRegistry = f

	return mmGetMandateRegistry
}

// Return sets up results that will be returned by Expected.GetMandateRegistry
func (mmGetMandateRegistry *mExpectedMockGetMandateRegistry) Return(m1 MandateRegistry) *ExpectedMock {
	if mmGetMandateRegistry.mock.funcGetMandateRegistry != nil {
		mmGetMandateRegistry.mock.t.Fatalf("ExpectedMock.GetMandateRegistry mock is already set by Set")
	}

	if mmGetMandateRegistry.defaultExpectation == nil {
		mmGetMandateRegistry.defaultExpectation = &ExpectedMockGetMandateRegistryExpectation{mock: mmGetMandateRegistry.mock}
	}
	mmGetMandateRegistry.defaultExpectation.results = &ExpectedMockGetMandateRegistryResults{m1}
	return mmGetMandateRegistry.mock
}

//Set uses given function f to mock the Expected.GetMandateRegistry method
func (mmGetMandateRegistry *mExpectedMockGetMandateRegistry) Set(f func() (m1 MandateRegistry)) *ExpectedMock {
	if mmGetMandateRegistry.defaultExpectation != nil {
		mmGetMandateRegistry.mock.t.Fatalf("Default expectation is already set for the Expected.GetMandateRegistry method")
	}

	if len(mmGetMandateRegistry.expectations) > 0 {
		mmGetMandateRegistry.mock.t.Fatalf("Some expectations are already set for the Expected.GetMandateRegistry method")
	}

	mmGetMandateRegistry.mock.funcGetMandateRegistry = f
	return mmGetMandateRegistry.mock
}

// GetMandateRegistry implements Expected
func (mmGetMandateRegistry *ExpectedMock) GetMandateRegistry() (m1 MandateRegistry) {
	mm_atomic.AddUint64(&mmGetMandateRegistry.beforeGetMandateRegistryCounter, 1)
	defer mm_atomic.AddUint64(&mmGetMandateRegistry.afterGetMandateRegistryCounter, 1)

	if mmGetMandateRegistry.inspectFuncGetMandateRegistry != nil {
		mmGetMandateRegistry.inspectFuncGetMandateRegistry()
	}

	if mmGetMandateRegistry.GetMandateRegistryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetMandateRegistry.GetMandateRegistryMock.defaultExpectation.Counter, 1)

		results := mmGetMandateRegistry.GetMandateRegistryMock.defaultExpectation.results
		if results == nil {
			mmGetMandateRegistry.t.Fatal("No results are set for the ExpectedMock.GetMandateRegistry")
		}
		return (*results).m1
	}
	if mmGetMandateRegistry.funcGetMandateRegistry != nil {
		return mmGetMandateRegistry.funcGetMandateRegistry()
	}
	mmGetMandateRegistry.t.Fatalf("Unexpected call to ExpectedMock.GetMandateRegistry.")
	return
}

// GetMandateRegistryAfterCounter returns a count of finished ExpectedMock.GetMandateRegistry invocations
func (mmGetMandateRegistry *ExpectedMock) GetMandateRegistryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMandateRegistry.afterGetMandateRegistryCounter)
}

// GetMandateRegistryBeforeCounter returns a count of ExpectedMock.GetMandateRegistry invocations
func (mmGetMandateRegistry *ExpectedMock) GetMandateRegistryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMandateRegistry.beforeGetMandateRegistryCounter)
}

// MinimockGetMandateRegistryDone returns true if the count of the GetMandateRegistry invocations corresponds
// the number of defined expectations
func (m *ExpectedMock) MinimockGetMandateRegistryDone() bool {
	for _, e := range m.GetMandateRegistryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMandateRegistryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetMandateRegistryCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetMandateRegistry != nil && mm_atomic.LoadUint64(&m.afterGetMandateRegistryCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetMandateRegistryInspect logs each unmet expectation
func (m *ExpectedMock) MinimockGetMandateRegistryInspect() {
	for _, e := range m.GetMandateRegistryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExpectedMock.GetMandateRegistry")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMandateRegistryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetMandateRegistryCounter) < 1 {
		m.t.Error("Expected call to ExpectedMock.GetMandateRegistry")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetMandateRegistry != nil && mm_atomic.LoadUint64(&m.afterGetMandateRegistryCounter) < 1 {
		m.t.Error("Expected call to ExpectedMock.GetMandateRegistry")
	}
}

type mExpectedMockGetMisbehaviorRegistry struct {
	mock               *ExpectedMock
	defaultExpectation *ExpectedMockGetMisbehaviorRegistryExpectation
	expectations       []*ExpectedMockGetMisbehaviorRegistryExpectation
}

// ExpectedMockGetMisbehaviorRegistryExpectation specifies expectation struct of the Expected.GetMisbehaviorRegistry
type ExpectedMockGetMisbehaviorRegistryExpectation struct {
	mock *ExpectedMock

	results *ExpectedMockGetMisbehaviorRegistryResults
	Counter uint64
}

// ExpectedMockGetMisbehaviorRegistryResults contains results of the Expected.GetMisbehaviorRegistry
type ExpectedMockGetMisbehaviorRegistryResults struct {
	m1 MisbehaviorRegistry
}

// Expect sets up expected params for Expected.GetMisbehaviorRegistry
func (mmGetMisbehaviorRegistry *mExpectedMockGetMisbehaviorRegistry) Expect() *mExpectedMockGetMisbehaviorRegistry {
	if mmGetMisbehaviorRegistry.mock.funcGetMisbehaviorRegistry != nil {
		mmGetMisbehaviorRegistry.mock.t.Fatalf("ExpectedMock.GetMisbehaviorRegistry mock is already set by Set")
	}

	if mmGetMisbehaviorRegistry.defaultExpectation == nil {
		mmGetMisbehaviorRegistry.defaultExpectation = &ExpectedMockGetMisbehaviorRegistryExpectation{}
	}

	return mmGetMisbehaviorRegistry
}

// Inspect accepts an inspector function that has same arguments as the Expected.GetMisbehaviorRegistry
func (mmGetMisbehaviorRegistry *mExpectedMockGetMisbehaviorRegistry) Inspect(f func()) *mExpectedMockGetMisbehaviorRegistry {
	if mmGetMisbehaviorRegistry.mock.inspectFuncGetMisbehaviorRegistry != nil {
		mmGetMisbehaviorRegistry.mock.t.Fatalf("Inspect function is already set for ExpectedMock.GetMisbehaviorRegistry")
	}

	mmGetMisbehaviorRegistry.mock.inspectFuncGetMisbehaviorRegistry = f

	return mmGetMisbehaviorRegistry
}

// Return sets up results that will be returned by Expected.GetMisbehaviorRegistry
func (mmGetMisbehaviorRegistry *mExpectedMockGetMisbehaviorRegistry) Return(m1 MisbehaviorRegistry) *ExpectedMock {
	if mmGetMisbehaviorRegistry.mock.funcGetMisbehaviorRegistry != nil {
		mmGetMisbehaviorRegistry.mock.t.Fatalf("ExpectedMock.GetMisbehaviorRegistry mock is already set by Set")
	}

	if mmGetMisbehaviorRegistry.defaultExpectation == nil {
		mmGetMisbehaviorRegistry.defaultExpectation = &ExpectedMockGetMisbehaviorRegistryExpectation{mock: mmGetMisbehaviorRegistry.mock}
	}
	mmGetMisbehaviorRegistry.defaultExpectation.results = &ExpectedMockGetMisbehaviorRegistryResults{m1}
	return mmGetMisbehaviorRegistry.mock
}

//Set uses given function f to mock the Expected.GetMisbehaviorRegistry method
func (mmGetMisbehaviorRegistry *mExpectedMockGetMisbehaviorRegistry) Set(f func() (m1 MisbehaviorRegistry)) *ExpectedMock {
	if mmGetMisbehaviorRegistry.defaultExpectation != nil {
		mmGetMisbehaviorRegistry.mock.t.Fatalf("Default expectation is already set for the Expected.GetMisbehaviorRegistry method")
	}

	if len(mmGetMisbehaviorRegistry.expectations) > 0 {
		mmGetMisbehaviorRegistry.mock.t.Fatalf("Some expectations are already set for the Expected.GetMisbehaviorRegistry method")
	}

	mmGetMisbehaviorRegistry.mock.funcGetMisbehaviorRegistry = f
	return mmGetMisbehaviorRegistry.mock
}

// GetMisbehaviorRegistry implements Expected
func (mmGetMisbehaviorRegistry *ExpectedMock) GetMisbehaviorRegistry() (m1 MisbehaviorRegistry) {
	mm_atomic.AddUint64(&mmGetMisbehaviorRegistry.beforeGetMisbehaviorRegistryCounter, 1)
	defer mm_atomic.AddUint64(&mmGetMisbehaviorRegistry.afterGetMisbehaviorRegistryCounter, 1)

	if mmGetMisbehaviorRegistry.inspectFuncGetMisbehaviorRegistry != nil {
		mmGetMisbehaviorRegistry.inspectFuncGetMisbehaviorRegistry()
	}

	if mmGetMisbehaviorRegistry.GetMisbehaviorRegistryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetMisbehaviorRegistry.GetMisbehaviorRegistryMock.defaultExpectation.Counter, 1)

		results := mmGetMisbehaviorRegistry.GetMisbehaviorRegistryMock.defaultExpectation.results
		if results == nil {
			mmGetMisbehaviorRegistry.t.Fatal("No results are set for the ExpectedMock.GetMisbehaviorRegistry")
		}
		return (*results).m1
	}
	if mmGetMisbehaviorRegistry.funcGetMisbehaviorRegistry != nil {
		return mmGetMisbehaviorRegistry.funcGetMisbehaviorRegistry()
	}
	mmGetMisbehaviorRegistry.t.Fatalf("Unexpected call to ExpectedMock.GetMisbehaviorRegistry.")
	return
}

// GetMisbehaviorRegistryAfterCounter returns a count of finished ExpectedMock.GetMisbehaviorRegistry invocations
func (mmGetMisbehaviorRegistry *ExpectedMock) GetMisbehaviorRegistryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMisbehaviorRegistry.afterGetMisbehaviorRegistryCounter)
}

// GetMisbehaviorRegistryBeforeCounter returns a count of ExpectedMock.GetMisbehaviorRegistry invocations
func (mmGetMisbehaviorRegistry *ExpectedMock) GetMisbehaviorRegistryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMisbehaviorRegistry.beforeGetMisbehaviorRegistryCounter)
}

// MinimockGetMisbehaviorRegistryDone returns true if the count of the GetMisbehaviorRegistry invocations corresponds
// the number of defined expectations
func (m *ExpectedMock) MinimockGetMisbehaviorRegistryDone() bool {
	for _, e := range m.GetMisbehaviorRegistryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMisbehaviorRegistryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetMisbehaviorRegistryCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetMisbehaviorRegistry != nil && mm_atomic.LoadUint64(&m.afterGetMisbehaviorRegistryCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetMisbehaviorRegistryInspect logs each unmet expectation
func (m *ExpectedMock) MinimockGetMisbehaviorRegistryInspect() {
	for _, e := range m.GetMisbehaviorRegistryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExpectedMock.GetMisbehaviorRegistry")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMisbehaviorRegistryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetMisbehaviorRegistryCounter) < 1 {
		m.t.Error("Expected call to ExpectedMock.GetMisbehaviorRegistry")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetMisbehaviorRegistry != nil && mm_atomic.LoadUint64(&m.afterGetMisbehaviorRegistryCounter) < 1 {
		m.t.Error("Expected call to ExpectedMock.GetMisbehaviorRegistry")
	}
}

type mExpectedMockGetNearestPulseData struct {
	mock               *ExpectedMock
	defaultExpectation *ExpectedMockGetNearestPulseDataExpectation
	expectations       []*ExpectedMockGetNearestPulseDataExpectation
}

// ExpectedMockGetNearestPulseDataExpectation specifies expectation struct of the Expected.GetNearestPulseData
type ExpectedMockGetNearestPulseDataExpectation struct {
	mock *ExpectedMock

	results *ExpectedMockGetNearestPulseDataResults
	Counter uint64
}

// ExpectedMockGetNearestPulseDataResults contains results of the Expected.GetNearestPulseData
type ExpectedMockGetNearestPulseDataResults struct {
	b1 bool
	d1 pulse.Data
}

// Expect sets up expected params for Expected.GetNearestPulseData
func (mmGetNearestPulseData *mExpectedMockGetNearestPulseData) Expect() *mExpectedMockGetNearestPulseData {
	if mmGetNearestPulseData.mock.funcGetNearestPulseData != nil {
		mmGetNearestPulseData.mock.t.Fatalf("ExpectedMock.GetNearestPulseData mock is already set by Set")
	}

	if mmGetNearestPulseData.defaultExpectation == nil {
		mmGetNearestPulseData.defaultExpectation = &ExpectedMockGetNearestPulseDataExpectation{}
	}

	return mmGetNearestPulseData
}

// Inspect accepts an inspector function that has same arguments as the Expected.GetNearestPulseData
func (mmGetNearestPulseData *mExpectedMockGetNearestPulseData) Inspect(f func()) *mExpectedMockGetNearestPulseData {
	if mmGetNearestPulseData.mock.inspectFuncGetNearestPulseData != nil {
		mmGetNearestPulseData.mock.t.Fatalf("Inspect function is already set for ExpectedMock.GetNearestPulseData")
	}

	mmGetNearestPulseData.mock.inspectFuncGetNearestPulseData = f

	return mmGetNearestPulseData
}

// Return sets up results that will be returned by Expected.GetNearestPulseData
func (mmGetNearestPulseData *mExpectedMockGetNearestPulseData) Return(b1 bool, d1 pulse.Data) *ExpectedMock {
	if mmGetNearestPulseData.mock.funcGetNearestPulseData != nil {
		mmGetNearestPulseData.mock.t.Fatalf("ExpectedMock.GetNearestPulseData mock is already set by Set")
	}

	if mmGetNearestPulseData.defaultExpectation == nil {
		mmGetNearestPulseData.defaultExpectation = &ExpectedMockGetNearestPulseDataExpectation{mock: mmGetNearestPulseData.mock}
	}
	mmGetNearestPulseData.defaultExpectation.results = &ExpectedMockGetNearestPulseDataResults{b1, d1}
	return mmGetNearestPulseData.mock
}

//Set uses given function f to mock the Expected.GetNearestPulseData method
func (mmGetNearestPulseData *mExpectedMockGetNearestPulseData) Set(f func() (b1 bool, d1 pulse.Data)) *ExpectedMock {
	if mmGetNearestPulseData.defaultExpectation != nil {
		mmGetNearestPulseData.mock.t.Fatalf("Default expectation is already set for the Expected.GetNearestPulseData method")
	}

	if len(mmGetNearestPulseData.expectations) > 0 {
		mmGetNearestPulseData.mock.t.Fatalf("Some expectations are already set for the Expected.GetNearestPulseData method")
	}

	mmGetNearestPulseData.mock.funcGetNearestPulseData = f
	return mmGetNearestPulseData.mock
}

// GetNearestPulseData implements Expected
func (mmGetNearestPulseData *ExpectedMock) GetNearestPulseData() (b1 bool, d1 pulse.Data) {
	mm_atomic.AddUint64(&mmGetNearestPulseData.beforeGetNearestPulseDataCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNearestPulseData.afterGetNearestPulseDataCounter, 1)

	if mmGetNearestPulseData.inspectFuncGetNearestPulseData != nil {
		mmGetNearestPulseData.inspectFuncGetNearestPulseData()
	}

	if mmGetNearestPulseData.GetNearestPulseDataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNearestPulseData.GetNearestPulseDataMock.defaultExpectation.Counter, 1)

		results := mmGetNearestPulseData.GetNearestPulseDataMock.defaultExpectation.results
		if results == nil {
			mmGetNearestPulseData.t.Fatal("No results are set for the ExpectedMock.GetNearestPulseData")
		}
		return (*results).b1, (*results).d1
	}
	if mmGetNearestPulseData.funcGetNearestPulseData != nil {
		return mmGetNearestPulseData.funcGetNearestPulseData()
	}
	mmGetNearestPulseData.t.Fatalf("Unexpected call to ExpectedMock.GetNearestPulseData.")
	return
}

// GetNearestPulseDataAfterCounter returns a count of finished ExpectedMock.GetNearestPulseData invocations
func (mmGetNearestPulseData *ExpectedMock) GetNearestPulseDataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNearestPulseData.afterGetNearestPulseDataCounter)
}

// GetNearestPulseDataBeforeCounter returns a count of ExpectedMock.GetNearestPulseData invocations
func (mmGetNearestPulseData *ExpectedMock) GetNearestPulseDataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNearestPulseData.beforeGetNearestPulseDataCounter)
}

// MinimockGetNearestPulseDataDone returns true if the count of the GetNearestPulseData invocations corresponds
// the number of defined expectations
func (m *ExpectedMock) MinimockGetNearestPulseDataDone() bool {
	for _, e := range m.GetNearestPulseDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetNearestPulseDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetNearestPulseDataCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNearestPulseData != nil && mm_atomic.LoadUint64(&m.afterGetNearestPulseDataCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetNearestPulseDataInspect logs each unmet expectation
func (m *ExpectedMock) MinimockGetNearestPulseDataInspect() {
	for _, e := range m.GetNearestPulseDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExpectedMock.GetNearestPulseData")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetNearestPulseDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetNearestPulseDataCounter) < 1 {
		m.t.Error("Expected call to ExpectedMock.GetNearestPulseData")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNearestPulseData != nil && mm_atomic.LoadUint64(&m.afterGetNearestPulseDataCounter) < 1 {
		m.t.Error("Expected call to ExpectedMock.GetNearestPulseData")
	}
}

type mExpectedMockGetOfflinePopulation struct {
	mock               *ExpectedMock
	defaultExpectation *ExpectedMockGetOfflinePopulationExpectation
	expectations       []*ExpectedMockGetOfflinePopulationExpectation
}

// ExpectedMockGetOfflinePopulationExpectation specifies expectation struct of the Expected.GetOfflinePopulation
type ExpectedMockGetOfflinePopulationExpectation struct {
	mock *ExpectedMock

	results *ExpectedMockGetOfflinePopulationResults
	Counter uint64
}

// ExpectedMockGetOfflinePopulationResults contains results of the Expected.GetOfflinePopulation
type ExpectedMockGetOfflinePopulationResults struct {
	o1 OfflinePopulation
}

// Expect sets up expected params for Expected.GetOfflinePopulation
func (mmGetOfflinePopulation *mExpectedMockGetOfflinePopulation) Expect() *mExpectedMockGetOfflinePopulation {
	if mmGetOfflinePopulation.mock.funcGetOfflinePopulation != nil {
		mmGetOfflinePopulation.mock.t.Fatalf("ExpectedMock.GetOfflinePopulation mock is already set by Set")
	}

	if mmGetOfflinePopulation.defaultExpectation == nil {
		mmGetOfflinePopulation.defaultExpectation = &ExpectedMockGetOfflinePopulationExpectation{}
	}

	return mmGetOfflinePopulation
}

// Inspect accepts an inspector function that has same arguments as the Expected.GetOfflinePopulation
func (mmGetOfflinePopulation *mExpectedMockGetOfflinePopulation) Inspect(f func()) *mExpectedMockGetOfflinePopulation {
	if mmGetOfflinePopulation.mock.inspectFuncGetOfflinePopulation != nil {
		mmGetOfflinePopulation.mock.t.Fatalf("Inspect function is already set for ExpectedMock.GetOfflinePopulation")
	}

	mmGetOfflinePopulation.mock.inspectFuncGetOfflinePopulation = f

	return mmGetOfflinePopulation
}

// Return sets up results that will be returned by Expected.GetOfflinePopulation
func (mmGetOfflinePopulation *mExpectedMockGetOfflinePopulation) Return(o1 OfflinePopulation) *ExpectedMock {
	if mmGetOfflinePopulation.mock.funcGetOfflinePopulation != nil {
		mmGetOfflinePopulation.mock.t.Fatalf("ExpectedMock.GetOfflinePopulation mock is already set by Set")
	}

	if mmGetOfflinePopulation.defaultExpectation == nil {
		mmGetOfflinePopulation.defaultExpectation = &ExpectedMockGetOfflinePopulationExpectation{mock: mmGetOfflinePopulation.mock}
	}
	mmGetOfflinePopulation.defaultExpectation.results = &ExpectedMockGetOfflinePopulationResults{o1}
	return mmGetOfflinePopulation.mock
}

//Set uses given function f to mock the Expected.GetOfflinePopulation method
func (mmGetOfflinePopulation *mExpectedMockGetOfflinePopulation) Set(f func() (o1 OfflinePopulation)) *ExpectedMock {
	if mmGetOfflinePopulation.defaultExpectation != nil {
		mmGetOfflinePopulation.mock.t.Fatalf("Default expectation is already set for the Expected.GetOfflinePopulation method")
	}

	if len(mmGetOfflinePopulation.expectations) > 0 {
		mmGetOfflinePopulation.mock.t.Fatalf("Some expectations are already set for the Expected.GetOfflinePopulation method")
	}

	mmGetOfflinePopulation.mock.funcGetOfflinePopulation = f
	return mmGetOfflinePopulation.mock
}

// GetOfflinePopulation implements Expected
func (mmGetOfflinePopulation *ExpectedMock) GetOfflinePopulation() (o1 OfflinePopulation) {
	mm_atomic.AddUint64(&mmGetOfflinePopulation.beforeGetOfflinePopulationCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOfflinePopulation.afterGetOfflinePopulationCounter, 1)

	if mmGetOfflinePopulation.inspectFuncGetOfflinePopulation != nil {
		mmGetOfflinePopulation.inspectFuncGetOfflinePopulation()
	}

	if mmGetOfflinePopulation.GetOfflinePopulationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOfflinePopulation.GetOfflinePopulationMock.defaultExpectation.Counter, 1)

		results := mmGetOfflinePopulation.GetOfflinePopulationMock.defaultExpectation.results
		if results == nil {
			mmGetOfflinePopulation.t.Fatal("No results are set for the ExpectedMock.GetOfflinePopulation")
		}
		return (*results).o1
	}
	if mmGetOfflinePopulation.funcGetOfflinePopulation != nil {
		return mmGetOfflinePopulation.funcGetOfflinePopulation()
	}
	mmGetOfflinePopulation.t.Fatalf("Unexpected call to ExpectedMock.GetOfflinePopulation.")
	return
}

// GetOfflinePopulationAfterCounter returns a count of finished ExpectedMock.GetOfflinePopulation invocations
func (mmGetOfflinePopulation *ExpectedMock) GetOfflinePopulationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOfflinePopulation.afterGetOfflinePopulationCounter)
}

// GetOfflinePopulationBeforeCounter returns a count of ExpectedMock.GetOfflinePopulation invocations
func (mmGetOfflinePopulation *ExpectedMock) GetOfflinePopulationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOfflinePopulation.beforeGetOfflinePopulationCounter)
}

// MinimockGetOfflinePopulationDone returns true if the count of the GetOfflinePopulation invocations corresponds
// the number of defined expectations
func (m *ExpectedMock) MinimockGetOfflinePopulationDone() bool {
	for _, e := range m.GetOfflinePopulationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOfflinePopulationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOfflinePopulationCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOfflinePopulation != nil && mm_atomic.LoadUint64(&m.afterGetOfflinePopulationCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetOfflinePopulationInspect logs each unmet expectation
func (m *ExpectedMock) MinimockGetOfflinePopulationInspect() {
	for _, e := range m.GetOfflinePopulationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExpectedMock.GetOfflinePopulation")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOfflinePopulationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOfflinePopulationCounter) < 1 {
		m.t.Error("Expected call to ExpectedMock.GetOfflinePopulation")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOfflinePopulation != nil && mm_atomic.LoadUint64(&m.afterGetOfflinePopulationCounter) < 1 {
		m.t.Error("Expected call to ExpectedMock.GetOfflinePopulation")
	}
}

type mExpectedMockGetOnlinePopulation struct {
	mock               *ExpectedMock
	defaultExpectation *ExpectedMockGetOnlinePopulationExpectation
	expectations       []*ExpectedMockGetOnlinePopulationExpectation
}

// ExpectedMockGetOnlinePopulationExpectation specifies expectation struct of the Expected.GetOnlinePopulation
type ExpectedMockGetOnlinePopulationExpectation struct {
	mock *ExpectedMock

	results *ExpectedMockGetOnlinePopulationResults
	Counter uint64
}

// ExpectedMockGetOnlinePopulationResults contains results of the Expected.GetOnlinePopulation
type ExpectedMockGetOnlinePopulationResults struct {
	o1 OnlinePopulation
}

// Expect sets up expected params for Expected.GetOnlinePopulation
func (mmGetOnlinePopulation *mExpectedMockGetOnlinePopulation) Expect() *mExpectedMockGetOnlinePopulation {
	if mmGetOnlinePopulation.mock.funcGetOnlinePopulation != nil {
		mmGetOnlinePopulation.mock.t.Fatalf("ExpectedMock.GetOnlinePopulation mock is already set by Set")
	}

	if mmGetOnlinePopulation.defaultExpectation == nil {
		mmGetOnlinePopulation.defaultExpectation = &ExpectedMockGetOnlinePopulationExpectation{}
	}

	return mmGetOnlinePopulation
}

// Inspect accepts an inspector function that has same arguments as the Expected.GetOnlinePopulation
func (mmGetOnlinePopulation *mExpectedMockGetOnlinePopulation) Inspect(f func()) *mExpectedMockGetOnlinePopulation {
	if mmGetOnlinePopulation.mock.inspectFuncGetOnlinePopulation != nil {
		mmGetOnlinePopulation.mock.t.Fatalf("Inspect function is already set for ExpectedMock.GetOnlinePopulation")
	}

	mmGetOnlinePopulation.mock.inspectFuncGetOnlinePopulation = f

	return mmGetOnlinePopulation
}

// Return sets up results that will be returned by Expected.GetOnlinePopulation
func (mmGetOnlinePopulation *mExpectedMockGetOnlinePopulation) Return(o1 OnlinePopulation) *ExpectedMock {
	if mmGetOnlinePopulation.mock.funcGetOnlinePopulation != nil {
		mmGetOnlinePopulation.mock.t.Fatalf("ExpectedMock.GetOnlinePopulation mock is already set by Set")
	}

	if mmGetOnlinePopulation.defaultExpectation == nil {
		mmGetOnlinePopulation.defaultExpectation = &ExpectedMockGetOnlinePopulationExpectation{mock: mmGetOnlinePopulation.mock}
	}
	mmGetOnlinePopulation.defaultExpectation.results = &ExpectedMockGetOnlinePopulationResults{o1}
	return mmGetOnlinePopulation.mock
}

//Set uses given function f to mock the Expected.GetOnlinePopulation method
func (mmGetOnlinePopulation *mExpectedMockGetOnlinePopulation) Set(f func() (o1 OnlinePopulation)) *ExpectedMock {
	if mmGetOnlinePopulation.defaultExpectation != nil {
		mmGetOnlinePopulation.mock.t.Fatalf("Default expectation is already set for the Expected.GetOnlinePopulation method")
	}

	if len(mmGetOnlinePopulation.expectations) > 0 {
		mmGetOnlinePopulation.mock.t.Fatalf("Some expectations are already set for the Expected.GetOnlinePopulation method")
	}

	mmGetOnlinePopulation.mock.funcGetOnlinePopulation = f
	return mmGetOnlinePopulation.mock
}

// GetOnlinePopulation implements Expected
func (mmGetOnlinePopulation *ExpectedMock) GetOnlinePopulation() (o1 OnlinePopulation) {
	mm_atomic.AddUint64(&mmGetOnlinePopulation.beforeGetOnlinePopulationCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOnlinePopulation.afterGetOnlinePopulationCounter, 1)

	if mmGetOnlinePopulation.inspectFuncGetOnlinePopulation != nil {
		mmGetOnlinePopulation.inspectFuncGetOnlinePopulation()
	}

	if mmGetOnlinePopulation.GetOnlinePopulationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOnlinePopulation.GetOnlinePopulationMock.defaultExpectation.Counter, 1)

		results := mmGetOnlinePopulation.GetOnlinePopulationMock.defaultExpectation.results
		if results == nil {
			mmGetOnlinePopulation.t.Fatal("No results are set for the ExpectedMock.GetOnlinePopulation")
		}
		return (*results).o1
	}
	if mmGetOnlinePopulation.funcGetOnlinePopulation != nil {
		return mmGetOnlinePopulation.funcGetOnlinePopulation()
	}
	mmGetOnlinePopulation.t.Fatalf("Unexpected call to ExpectedMock.GetOnlinePopulation.")
	return
}

// GetOnlinePopulationAfterCounter returns a count of finished ExpectedMock.GetOnlinePopulation invocations
func (mmGetOnlinePopulation *ExpectedMock) GetOnlinePopulationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOnlinePopulation.afterGetOnlinePopulationCounter)
}

// GetOnlinePopulationBeforeCounter returns a count of ExpectedMock.GetOnlinePopulation invocations
func (mmGetOnlinePopulation *ExpectedMock) GetOnlinePopulationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOnlinePopulation.beforeGetOnlinePopulationCounter)
}

// MinimockGetOnlinePopulationDone returns true if the count of the GetOnlinePopulation invocations corresponds
// the number of defined expectations
func (m *ExpectedMock) MinimockGetOnlinePopulationDone() bool {
	for _, e := range m.GetOnlinePopulationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOnlinePopulationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOnlinePopulationCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOnlinePopulation != nil && mm_atomic.LoadUint64(&m.afterGetOnlinePopulationCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetOnlinePopulationInspect logs each unmet expectation
func (m *ExpectedMock) MinimockGetOnlinePopulationInspect() {
	for _, e := range m.GetOnlinePopulationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExpectedMock.GetOnlinePopulation")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOnlinePopulationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOnlinePopulationCounter) < 1 {
		m.t.Error("Expected call to ExpectedMock.GetOnlinePopulation")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOnlinePopulation != nil && mm_atomic.LoadUint64(&m.afterGetOnlinePopulationCounter) < 1 {
		m.t.Error("Expected call to ExpectedMock.GetOnlinePopulation")
	}
}

type mExpectedMockGetPrevious struct {
	mock               *ExpectedMock
	defaultExpectation *ExpectedMockGetPreviousExpectation
	expectations       []*ExpectedMockGetPreviousExpectation
}

// ExpectedMockGetPreviousExpectation specifies expectation struct of the Expected.GetPrevious
type ExpectedMockGetPreviousExpectation struct {
	mock *ExpectedMock

	results *ExpectedMockGetPreviousResults
	Counter uint64
}

// ExpectedMockGetPreviousResults contains results of the Expected.GetPrevious
type ExpectedMockGetPreviousResults struct {
	a1 Active
}

// Expect sets up expected params for Expected.GetPrevious
func (mmGetPrevious *mExpectedMockGetPrevious) Expect() *mExpectedMockGetPrevious {
	if mmGetPrevious.mock.funcGetPrevious != nil {
		mmGetPrevious.mock.t.Fatalf("ExpectedMock.GetPrevious mock is already set by Set")
	}

	if mmGetPrevious.defaultExpectation == nil {
		mmGetPrevious.defaultExpectation = &ExpectedMockGetPreviousExpectation{}
	}

	return mmGetPrevious
}

// Inspect accepts an inspector function that has same arguments as the Expected.GetPrevious
func (mmGetPrevious *mExpectedMockGetPrevious) Inspect(f func()) *mExpectedMockGetPrevious {
	if mmGetPrevious.mock.inspectFuncGetPrevious != nil {
		mmGetPrevious.mock.t.Fatalf("Inspect function is already set for ExpectedMock.GetPrevious")
	}

	mmGetPrevious.mock.inspectFuncGetPrevious = f

	return mmGetPrevious
}

// Return sets up results that will be returned by Expected.GetPrevious
func (mmGetPrevious *mExpectedMockGetPrevious) Return(a1 Active) *ExpectedMock {
	if mmGetPrevious.mock.funcGetPrevious != nil {
		mmGetPrevious.mock.t.Fatalf("ExpectedMock.GetPrevious mock is already set by Set")
	}

	if mmGetPrevious.defaultExpectation == nil {
		mmGetPrevious.defaultExpectation = &ExpectedMockGetPreviousExpectation{mock: mmGetPrevious.mock}
	}
	mmGetPrevious.defaultExpectation.results = &ExpectedMockGetPreviousResults{a1}
	return mmGetPrevious.mock
}

//Set uses given function f to mock the Expected.GetPrevious method
func (mmGetPrevious *mExpectedMockGetPrevious) Set(f func() (a1 Active)) *ExpectedMock {
	if mmGetPrevious.defaultExpectation != nil {
		mmGetPrevious.mock.t.Fatalf("Default expectation is already set for the Expected.GetPrevious method")
	}

	if len(mmGetPrevious.expectations) > 0 {
		mmGetPrevious.mock.t.Fatalf("Some expectations are already set for the Expected.GetPrevious method")
	}

	mmGetPrevious.mock.funcGetPrevious = f
	return mmGetPrevious.mock
}

// GetPrevious implements Expected
func (mmGetPrevious *ExpectedMock) GetPrevious() (a1 Active) {
	mm_atomic.AddUint64(&mmGetPrevious.beforeGetPreviousCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPrevious.afterGetPreviousCounter, 1)

	if mmGetPrevious.inspectFuncGetPrevious != nil {
		mmGetPrevious.inspectFuncGetPrevious()
	}

	if mmGetPrevious.GetPreviousMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPrevious.GetPreviousMock.defaultExpectation.Counter, 1)

		results := mmGetPrevious.GetPreviousMock.defaultExpectation.results
		if results == nil {
			mmGetPrevious.t.Fatal("No results are set for the ExpectedMock.GetPrevious")
		}
		return (*results).a1
	}
	if mmGetPrevious.funcGetPrevious != nil {
		return mmGetPrevious.funcGetPrevious()
	}
	mmGetPrevious.t.Fatalf("Unexpected call to ExpectedMock.GetPrevious.")
	return
}

// GetPreviousAfterCounter returns a count of finished ExpectedMock.GetPrevious invocations
func (mmGetPrevious *ExpectedMock) GetPreviousAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPrevious.afterGetPreviousCounter)
}

// GetPreviousBeforeCounter returns a count of ExpectedMock.GetPrevious invocations
func (mmGetPrevious *ExpectedMock) GetPreviousBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPrevious.beforeGetPreviousCounter)
}

// MinimockGetPreviousDone returns true if the count of the GetPrevious invocations corresponds
// the number of defined expectations
func (m *ExpectedMock) MinimockGetPreviousDone() bool {
	for _, e := range m.GetPreviousMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPreviousMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPreviousCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPrevious != nil && mm_atomic.LoadUint64(&m.afterGetPreviousCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPreviousInspect logs each unmet expectation
func (m *ExpectedMock) MinimockGetPreviousInspect() {
	for _, e := range m.GetPreviousMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExpectedMock.GetPrevious")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPreviousMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPreviousCounter) < 1 {
		m.t.Error("Expected call to ExpectedMock.GetPrevious")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPrevious != nil && mm_atomic.LoadUint64(&m.afterGetPreviousCounter) < 1 {
		m.t.Error("Expected call to ExpectedMock.GetPrevious")
	}
}

type mExpectedMockGetProfileFactory struct {
	mock               *ExpectedMock
	defaultExpectation *ExpectedMockGetProfileFactoryExpectation
	expectations       []*ExpectedMockGetProfileFactoryExpectation

	callArgs []*ExpectedMockGetProfileFactoryParams
	mutex    sync.RWMutex
}

// ExpectedMockGetProfileFactoryExpectation specifies expectation struct of the Expected.GetProfileFactory
type ExpectedMockGetProfileFactoryExpectation struct {
	mock    *ExpectedMock
	params  *ExpectedMockGetProfileFactoryParams
	results *ExpectedMockGetProfileFactoryResults
	Counter uint64
}

// ExpectedMockGetProfileFactoryParams contains parameters of the Expected.GetProfileFactory
type ExpectedMockGetProfileFactoryParams struct {
	ksf cryptkit.KeyStoreFactory
}

// ExpectedMockGetProfileFactoryResults contains results of the Expected.GetProfileFactory
type ExpectedMockGetProfileFactoryResults struct {
	f1 profiles.Factory
}

// Expect sets up expected params for Expected.GetProfileFactory
func (mmGetProfileFactory *mExpectedMockGetProfileFactory) Expect(ksf cryptkit.KeyStoreFactory) *mExpectedMockGetProfileFactory {
	if mmGetProfileFactory.mock.funcGetProfileFactory != nil {
		mmGetProfileFactory.mock.t.Fatalf("ExpectedMock.GetProfileFactory mock is already set by Set")
	}

	if mmGetProfileFactory.defaultExpectation == nil {
		mmGetProfileFactory.defaultExpectation = &ExpectedMockGetProfileFactoryExpectation{}
	}

	mmGetProfileFactory.defaultExpectation.params = &ExpectedMockGetProfileFactoryParams{ksf}
	for _, e := range mmGetProfileFactory.expectations {
		if minimock.Equal(e.params, mmGetProfileFactory.defaultExpectation.params) {
			mmGetProfileFactory.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetProfileFactory.defaultExpectation.params)
		}
	}

	return mmGetProfileFactory
}

// Inspect accepts an inspector function that has same arguments as the Expected.GetProfileFactory
func (mmGetProfileFactory *mExpectedMockGetProfileFactory) Inspect(f func(ksf cryptkit.KeyStoreFactory)) *mExpectedMockGetProfileFactory {
	if mmGetProfileFactory.mock.inspectFuncGetProfileFactory != nil {
		mmGetProfileFactory.mock.t.Fatalf("Inspect function is already set for ExpectedMock.GetProfileFactory")
	}

	mmGetProfileFactory.mock.inspectFuncGetProfileFactory = f

	return mmGetProfileFactory
}

// Return sets up results that will be returned by Expected.GetProfileFactory
func (mmGetProfileFactory *mExpectedMockGetProfileFactory) Return(f1 profiles.Factory) *ExpectedMock {
	if mmGetProfileFactory.mock.funcGetProfileFactory != nil {
		mmGetProfileFactory.mock.t.Fatalf("ExpectedMock.GetProfileFactory mock is already set by Set")
	}

	if mmGetProfileFactory.defaultExpectation == nil {
		mmGetProfileFactory.defaultExpectation = &ExpectedMockGetProfileFactoryExpectation{mock: mmGetProfileFactory.mock}
	}
	mmGetProfileFactory.defaultExpectation.results = &ExpectedMockGetProfileFactoryResults{f1}
	return mmGetProfileFactory.mock
}

//Set uses given function f to mock the Expected.GetProfileFactory method
func (mmGetProfileFactory *mExpectedMockGetProfileFactory) Set(f func(ksf cryptkit.KeyStoreFactory) (f1 profiles.Factory)) *ExpectedMock {
	if mmGetProfileFactory.defaultExpectation != nil {
		mmGetProfileFactory.mock.t.Fatalf("Default expectation is already set for the Expected.GetProfileFactory method")
	}

	if len(mmGetProfileFactory.expectations) > 0 {
		mmGetProfileFactory.mock.t.Fatalf("Some expectations are already set for the Expected.GetProfileFactory method")
	}

	mmGetProfileFactory.mock.funcGetProfileFactory = f
	return mmGetProfileFactory.mock
}

// When sets expectation for the Expected.GetProfileFactory which will trigger the result defined by the following
// Then helper
func (mmGetProfileFactory *mExpectedMockGetProfileFactory) When(ksf cryptkit.KeyStoreFactory) *ExpectedMockGetProfileFactoryExpectation {
	if mmGetProfileFactory.mock.funcGetProfileFactory != nil {
		mmGetProfileFactory.mock.t.Fatalf("ExpectedMock.GetProfileFactory mock is already set by Set")
	}

	expectation := &ExpectedMockGetProfileFactoryExpectation{
		mock:   mmGetProfileFactory.mock,
		params: &ExpectedMockGetProfileFactoryParams{ksf},
	}
	mmGetProfileFactory.expectations = append(mmGetProfileFactory.expectations, expectation)
	return expectation
}

// Then sets up Expected.GetProfileFactory return parameters for the expectation previously defined by the When method
func (e *ExpectedMockGetProfileFactoryExpectation) Then(f1 profiles.Factory) *ExpectedMock {
	e.results = &ExpectedMockGetProfileFactoryResults{f1}
	return e.mock
}

// GetProfileFactory implements Expected
func (mmGetProfileFactory *ExpectedMock) GetProfileFactory(ksf cryptkit.KeyStoreFactory) (f1 profiles.Factory) {
	mm_atomic.AddUint64(&mmGetProfileFactory.beforeGetProfileFactoryCounter, 1)
	defer mm_atomic.AddUint64(&mmGetProfileFactory.afterGetProfileFactoryCounter, 1)

	if mmGetProfileFactory.inspectFuncGetProfileFactory != nil {
		mmGetProfileFactory.inspectFuncGetProfileFactory(ksf)
	}

	params := &ExpectedMockGetProfileFactoryParams{ksf}

	// Record call args
	mmGetProfileFactory.GetProfileFactoryMock.mutex.Lock()
	mmGetProfileFactory.GetProfileFactoryMock.callArgs = append(mmGetProfileFactory.GetProfileFactoryMock.callArgs, params)
	mmGetProfileFactory.GetProfileFactoryMock.mutex.Unlock()

	for _, e := range mmGetProfileFactory.GetProfileFactoryMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.f1
		}
	}

	if mmGetProfileFactory.GetProfileFactoryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetProfileFactory.GetProfileFactoryMock.defaultExpectation.Counter, 1)
		want := mmGetProfileFactory.GetProfileFactoryMock.defaultExpectation.params
		got := ExpectedMockGetProfileFactoryParams{ksf}
		if want != nil && !minimock.Equal(*want, got) {
			mmGetProfileFactory.t.Errorf("ExpectedMock.GetProfileFactory got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmGetProfileFactory.GetProfileFactoryMock.defaultExpectation.results
		if results == nil {
			mmGetProfileFactory.t.Fatal("No results are set for the ExpectedMock.GetProfileFactory")
		}
		return (*results).f1
	}
	if mmGetProfileFactory.funcGetProfileFactory != nil {
		return mmGetProfileFactory.funcGetProfileFactory(ksf)
	}
	mmGetProfileFactory.t.Fatalf("Unexpected call to ExpectedMock.GetProfileFactory. %v", ksf)
	return
}

// GetProfileFactoryAfterCounter returns a count of finished ExpectedMock.GetProfileFactory invocations
func (mmGetProfileFactory *ExpectedMock) GetProfileFactoryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetProfileFactory.afterGetProfileFactoryCounter)
}

// GetProfileFactoryBeforeCounter returns a count of ExpectedMock.GetProfileFactory invocations
func (mmGetProfileFactory *ExpectedMock) GetProfileFactoryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetProfileFactory.beforeGetProfileFactoryCounter)
}

// Calls returns a list of arguments used in each call to ExpectedMock.GetProfileFactory.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetProfileFactory *mExpectedMockGetProfileFactory) Calls() []*ExpectedMockGetProfileFactoryParams {
	mmGetProfileFactory.mutex.RLock()

	argCopy := make([]*ExpectedMockGetProfileFactoryParams, len(mmGetProfileFactory.callArgs))
	copy(argCopy, mmGetProfileFactory.callArgs)

	mmGetProfileFactory.mutex.RUnlock()

	return argCopy
}

// MinimockGetProfileFactoryDone returns true if the count of the GetProfileFactory invocations corresponds
// the number of defined expectations
func (m *ExpectedMock) MinimockGetProfileFactoryDone() bool {
	for _, e := range m.GetProfileFactoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetProfileFactoryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetProfileFactoryCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetProfileFactory != nil && mm_atomic.LoadUint64(&m.afterGetProfileFactoryCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetProfileFactoryInspect logs each unmet expectation
func (m *ExpectedMock) MinimockGetProfileFactoryInspect() {
	for _, e := range m.GetProfileFactoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExpectedMock.GetProfileFactory with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetProfileFactoryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetProfileFactoryCounter) < 1 {
		if m.GetProfileFactoryMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExpectedMock.GetProfileFactory")
		} else {
			m.t.Errorf("Expected call to ExpectedMock.GetProfileFactory with params: %#v", *m.GetProfileFactoryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetProfileFactory != nil && mm_atomic.LoadUint64(&m.afterGetProfileFactoryCounter) < 1 {
		m.t.Error("Expected call to ExpectedMock.GetProfileFactory")
	}
}

type mExpectedMockGetPulseNumber struct {
	mock               *ExpectedMock
	defaultExpectation *ExpectedMockGetPulseNumberExpectation
	expectations       []*ExpectedMockGetPulseNumberExpectation
}

// ExpectedMockGetPulseNumberExpectation specifies expectation struct of the Expected.GetPulseNumber
type ExpectedMockGetPulseNumberExpectation struct {
	mock *ExpectedMock

	results *ExpectedMockGetPulseNumberResults
	Counter uint64
}

// ExpectedMockGetPulseNumberResults contains results of the Expected.GetPulseNumber
type ExpectedMockGetPulseNumberResults struct {
	n1 pulse.Number
}

// Expect sets up expected params for Expected.GetPulseNumber
func (mmGetPulseNumber *mExpectedMockGetPulseNumber) Expect() *mExpectedMockGetPulseNumber {
	if mmGetPulseNumber.mock.funcGetPulseNumber != nil {
		mmGetPulseNumber.mock.t.Fatalf("ExpectedMock.GetPulseNumber mock is already set by Set")
	}

	if mmGetPulseNumber.defaultExpectation == nil {
		mmGetPulseNumber.defaultExpectation = &ExpectedMockGetPulseNumberExpectation{}
	}

	return mmGetPulseNumber
}

// Inspect accepts an inspector function that has same arguments as the Expected.GetPulseNumber
func (mmGetPulseNumber *mExpectedMockGetPulseNumber) Inspect(f func()) *mExpectedMockGetPulseNumber {
	if mmGetPulseNumber.mock.inspectFuncGetPulseNumber != nil {
		mmGetPulseNumber.mock.t.Fatalf("Inspect function is already set for ExpectedMock.GetPulseNumber")
	}

	mmGetPulseNumber.mock.inspectFuncGetPulseNumber = f

	return mmGetPulseNumber
}

// Return sets up results that will be returned by Expected.GetPulseNumber
func (mmGetPulseNumber *mExpectedMockGetPulseNumber) Return(n1 pulse.Number) *ExpectedMock {
	if mmGetPulseNumber.mock.funcGetPulseNumber != nil {
		mmGetPulseNumber.mock.t.Fatalf("ExpectedMock.GetPulseNumber mock is already set by Set")
	}

	if mmGetPulseNumber.defaultExpectation == nil {
		mmGetPulseNumber.defaultExpectation = &ExpectedMockGetPulseNumberExpectation{mock: mmGetPulseNumber.mock}
	}
	mmGetPulseNumber.defaultExpectation.results = &ExpectedMockGetPulseNumberResults{n1}
	return mmGetPulseNumber.mock
}

//Set uses given function f to mock the Expected.GetPulseNumber method
func (mmGetPulseNumber *mExpectedMockGetPulseNumber) Set(f func() (n1 pulse.Number)) *ExpectedMock {
	if mmGetPulseNumber.defaultExpectation != nil {
		mmGetPulseNumber.mock.t.Fatalf("Default expectation is already set for the Expected.GetPulseNumber method")
	}

	if len(mmGetPulseNumber.expectations) > 0 {
		mmGetPulseNumber.mock.t.Fatalf("Some expectations are already set for the Expected.GetPulseNumber method")
	}

	mmGetPulseNumber.mock.funcGetPulseNumber = f
	return mmGetPulseNumber.mock
}

// GetPulseNumber implements Expected
func (mmGetPulseNumber *ExpectedMock) GetPulseNumber() (n1 pulse.Number) {
	mm_atomic.AddUint64(&mmGetPulseNumber.beforeGetPulseNumberCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPulseNumber.afterGetPulseNumberCounter, 1)

	if mmGetPulseNumber.inspectFuncGetPulseNumber != nil {
		mmGetPulseNumber.inspectFuncGetPulseNumber()
	}

	if mmGetPulseNumber.GetPulseNumberMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPulseNumber.GetPulseNumberMock.defaultExpectation.Counter, 1)

		results := mmGetPulseNumber.GetPulseNumberMock.defaultExpectation.results
		if results == nil {
			mmGetPulseNumber.t.Fatal("No results are set for the ExpectedMock.GetPulseNumber")
		}
		return (*results).n1
	}
	if mmGetPulseNumber.funcGetPulseNumber != nil {
		return mmGetPulseNumber.funcGetPulseNumber()
	}
	mmGetPulseNumber.t.Fatalf("Unexpected call to ExpectedMock.GetPulseNumber.")
	return
}

// GetPulseNumberAfterCounter returns a count of finished ExpectedMock.GetPulseNumber invocations
func (mmGetPulseNumber *ExpectedMock) GetPulseNumberAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPulseNumber.afterGetPulseNumberCounter)
}

// GetPulseNumberBeforeCounter returns a count of ExpectedMock.GetPulseNumber invocations
func (mmGetPulseNumber *ExpectedMock) GetPulseNumberBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPulseNumber.beforeGetPulseNumberCounter)
}

// MinimockGetPulseNumberDone returns true if the count of the GetPulseNumber invocations corresponds
// the number of defined expectations
func (m *ExpectedMock) MinimockGetPulseNumberDone() bool {
	for _, e := range m.GetPulseNumberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPulseNumberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPulseNumberCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPulseNumber != nil && mm_atomic.LoadUint64(&m.afterGetPulseNumberCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPulseNumberInspect logs each unmet expectation
func (m *ExpectedMock) MinimockGetPulseNumberInspect() {
	for _, e := range m.GetPulseNumberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExpectedMock.GetPulseNumber")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPulseNumberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPulseNumberCounter) < 1 {
		m.t.Error("Expected call to ExpectedMock.GetPulseNumber")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPulseNumber != nil && mm_atomic.LoadUint64(&m.afterGetPulseNumberCounter) < 1 {
		m.t.Error("Expected call to ExpectedMock.GetPulseNumber")
	}
}

type mExpectedMockIsActive struct {
	mock               *ExpectedMock
	defaultExpectation *ExpectedMockIsActiveExpectation
	expectations       []*ExpectedMockIsActiveExpectation
}

// ExpectedMockIsActiveExpectation specifies expectation struct of the Expected.IsActive
type ExpectedMockIsActiveExpectation struct {
	mock *ExpectedMock

	results *ExpectedMockIsActiveResults
	Counter uint64
}

// ExpectedMockIsActiveResults contains results of the Expected.IsActive
type ExpectedMockIsActiveResults struct {
	b1 bool
}

// Expect sets up expected params for Expected.IsActive
func (mmIsActive *mExpectedMockIsActive) Expect() *mExpectedMockIsActive {
	if mmIsActive.mock.funcIsActive != nil {
		mmIsActive.mock.t.Fatalf("ExpectedMock.IsActive mock is already set by Set")
	}

	if mmIsActive.defaultExpectation == nil {
		mmIsActive.defaultExpectation = &ExpectedMockIsActiveExpectation{}
	}

	return mmIsActive
}

// Inspect accepts an inspector function that has same arguments as the Expected.IsActive
func (mmIsActive *mExpectedMockIsActive) Inspect(f func()) *mExpectedMockIsActive {
	if mmIsActive.mock.inspectFuncIsActive != nil {
		mmIsActive.mock.t.Fatalf("Inspect function is already set for ExpectedMock.IsActive")
	}

	mmIsActive.mock.inspectFuncIsActive = f

	return mmIsActive
}

// Return sets up results that will be returned by Expected.IsActive
func (mmIsActive *mExpectedMockIsActive) Return(b1 bool) *ExpectedMock {
	if mmIsActive.mock.funcIsActive != nil {
		mmIsActive.mock.t.Fatalf("ExpectedMock.IsActive mock is already set by Set")
	}

	if mmIsActive.defaultExpectation == nil {
		mmIsActive.defaultExpectation = &ExpectedMockIsActiveExpectation{mock: mmIsActive.mock}
	}
	mmIsActive.defaultExpectation.results = &ExpectedMockIsActiveResults{b1}
	return mmIsActive.mock
}

//Set uses given function f to mock the Expected.IsActive method
func (mmIsActive *mExpectedMockIsActive) Set(f func() (b1 bool)) *ExpectedMock {
	if mmIsActive.defaultExpectation != nil {
		mmIsActive.mock.t.Fatalf("Default expectation is already set for the Expected.IsActive method")
	}

	if len(mmIsActive.expectations) > 0 {
		mmIsActive.mock.t.Fatalf("Some expectations are already set for the Expected.IsActive method")
	}

	mmIsActive.mock.funcIsActive = f
	return mmIsActive.mock
}

// IsActive implements Expected
func (mmIsActive *ExpectedMock) IsActive() (b1 bool) {
	mm_atomic.AddUint64(&mmIsActive.beforeIsActiveCounter, 1)
	defer mm_atomic.AddUint64(&mmIsActive.afterIsActiveCounter, 1)

	if mmIsActive.inspectFuncIsActive != nil {
		mmIsActive.inspectFuncIsActive()
	}

	if mmIsActive.IsActiveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsActive.IsActiveMock.defaultExpectation.Counter, 1)

		results := mmIsActive.IsActiveMock.defaultExpectation.results
		if results == nil {
			mmIsActive.t.Fatal("No results are set for the ExpectedMock.IsActive")
		}
		return (*results).b1
	}
	if mmIsActive.funcIsActive != nil {
		return mmIsActive.funcIsActive()
	}
	mmIsActive.t.Fatalf("Unexpected call to ExpectedMock.IsActive.")
	return
}

// IsActiveAfterCounter returns a count of finished ExpectedMock.IsActive invocations
func (mmIsActive *ExpectedMock) IsActiveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsActive.afterIsActiveCounter)
}

// IsActiveBeforeCounter returns a count of ExpectedMock.IsActive invocations
func (mmIsActive *ExpectedMock) IsActiveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsActive.beforeIsActiveCounter)
}

// MinimockIsActiveDone returns true if the count of the IsActive invocations corresponds
// the number of defined expectations
func (m *ExpectedMock) MinimockIsActiveDone() bool {
	for _, e := range m.IsActiveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsActiveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsActiveCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsActive != nil && mm_atomic.LoadUint64(&m.afterIsActiveCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsActiveInspect logs each unmet expectation
func (m *ExpectedMock) MinimockIsActiveInspect() {
	for _, e := range m.IsActiveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExpectedMock.IsActive")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsActiveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsActiveCounter) < 1 {
		m.t.Error("Expected call to ExpectedMock.IsActive")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsActive != nil && mm_atomic.LoadUint64(&m.afterIsActiveCounter) < 1 {
		m.t.Error("Expected call to ExpectedMock.IsActive")
	}
}

type mExpectedMockMakeActive struct {
	mock               *ExpectedMock
	defaultExpectation *ExpectedMockMakeActiveExpectation
	expectations       []*ExpectedMockMakeActiveExpectation

	callArgs []*ExpectedMockMakeActiveParams
	mutex    sync.RWMutex
}

// ExpectedMockMakeActiveExpectation specifies expectation struct of the Expected.MakeActive
type ExpectedMockMakeActiveExpectation struct {
	mock    *ExpectedMock
	params  *ExpectedMockMakeActiveParams
	results *ExpectedMockMakeActiveResults
	Counter uint64
}

// ExpectedMockMakeActiveParams contains parameters of the Expected.MakeActive
type ExpectedMockMakeActiveParams struct {
	pd pulse.Data
}

// ExpectedMockMakeActiveResults contains results of the Expected.MakeActive
type ExpectedMockMakeActiveResults struct {
	a1 Active
}

// Expect sets up expected params for Expected.MakeActive
func (mmMakeActive *mExpectedMockMakeActive) Expect(pd pulse.Data) *mExpectedMockMakeActive {
	if mmMakeActive.mock.funcMakeActive != nil {
		mmMakeActive.mock.t.Fatalf("ExpectedMock.MakeActive mock is already set by Set")
	}

	if mmMakeActive.defaultExpectation == nil {
		mmMakeActive.defaultExpectation = &ExpectedMockMakeActiveExpectation{}
	}

	mmMakeActive.defaultExpectation.params = &ExpectedMockMakeActiveParams{pd}
	for _, e := range mmMakeActive.expectations {
		if minimock.Equal(e.params, mmMakeActive.defaultExpectation.params) {
			mmMakeActive.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMakeActive.defaultExpectation.params)
		}
	}

	return mmMakeActive
}

// Inspect accepts an inspector function that has same arguments as the Expected.MakeActive
func (mmMakeActive *mExpectedMockMakeActive) Inspect(f func(pd pulse.Data)) *mExpectedMockMakeActive {
	if mmMakeActive.mock.inspectFuncMakeActive != nil {
		mmMakeActive.mock.t.Fatalf("Inspect function is already set for ExpectedMock.MakeActive")
	}

	mmMakeActive.mock.inspectFuncMakeActive = f

	return mmMakeActive
}

// Return sets up results that will be returned by Expected.MakeActive
func (mmMakeActive *mExpectedMockMakeActive) Return(a1 Active) *ExpectedMock {
	if mmMakeActive.mock.funcMakeActive != nil {
		mmMakeActive.mock.t.Fatalf("ExpectedMock.MakeActive mock is already set by Set")
	}

	if mmMakeActive.defaultExpectation == nil {
		mmMakeActive.defaultExpectation = &ExpectedMockMakeActiveExpectation{mock: mmMakeActive.mock}
	}
	mmMakeActive.defaultExpectation.results = &ExpectedMockMakeActiveResults{a1}
	return mmMakeActive.mock
}

//Set uses given function f to mock the Expected.MakeActive method
func (mmMakeActive *mExpectedMockMakeActive) Set(f func(pd pulse.Data) (a1 Active)) *ExpectedMock {
	if mmMakeActive.defaultExpectation != nil {
		mmMakeActive.mock.t.Fatalf("Default expectation is already set for the Expected.MakeActive method")
	}

	if len(mmMakeActive.expectations) > 0 {
		mmMakeActive.mock.t.Fatalf("Some expectations are already set for the Expected.MakeActive method")
	}

	mmMakeActive.mock.funcMakeActive = f
	return mmMakeActive.mock
}

// When sets expectation for the Expected.MakeActive which will trigger the result defined by the following
// Then helper
func (mmMakeActive *mExpectedMockMakeActive) When(pd pulse.Data) *ExpectedMockMakeActiveExpectation {
	if mmMakeActive.mock.funcMakeActive != nil {
		mmMakeActive.mock.t.Fatalf("ExpectedMock.MakeActive mock is already set by Set")
	}

	expectation := &ExpectedMockMakeActiveExpectation{
		mock:   mmMakeActive.mock,
		params: &ExpectedMockMakeActiveParams{pd},
	}
	mmMakeActive.expectations = append(mmMakeActive.expectations, expectation)
	return expectation
}

// Then sets up Expected.MakeActive return parameters for the expectation previously defined by the When method
func (e *ExpectedMockMakeActiveExpectation) Then(a1 Active) *ExpectedMock {
	e.results = &ExpectedMockMakeActiveResults{a1}
	return e.mock
}

// MakeActive implements Expected
func (mmMakeActive *ExpectedMock) MakeActive(pd pulse.Data) (a1 Active) {
	mm_atomic.AddUint64(&mmMakeActive.beforeMakeActiveCounter, 1)
	defer mm_atomic.AddUint64(&mmMakeActive.afterMakeActiveCounter, 1)

	if mmMakeActive.inspectFuncMakeActive != nil {
		mmMakeActive.inspectFuncMakeActive(pd)
	}

	params := &ExpectedMockMakeActiveParams{pd}

	// Record call args
	mmMakeActive.MakeActiveMock.mutex.Lock()
	mmMakeActive.MakeActiveMock.callArgs = append(mmMakeActive.MakeActiveMock.callArgs, params)
	mmMakeActive.MakeActiveMock.mutex.Unlock()

	for _, e := range mmMakeActive.MakeActiveMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.a1
		}
	}

	if mmMakeActive.MakeActiveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMakeActive.MakeActiveMock.defaultExpectation.Counter, 1)
		want := mmMakeActive.MakeActiveMock.defaultExpectation.params
		got := ExpectedMockMakeActiveParams{pd}
		if want != nil && !minimock.Equal(*want, got) {
			mmMakeActive.t.Errorf("ExpectedMock.MakeActive got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmMakeActive.MakeActiveMock.defaultExpectation.results
		if results == nil {
			mmMakeActive.t.Fatal("No results are set for the ExpectedMock.MakeActive")
		}
		return (*results).a1
	}
	if mmMakeActive.funcMakeActive != nil {
		return mmMakeActive.funcMakeActive(pd)
	}
	mmMakeActive.t.Fatalf("Unexpected call to ExpectedMock.MakeActive. %v", pd)
	return
}

// MakeActiveAfterCounter returns a count of finished ExpectedMock.MakeActive invocations
func (mmMakeActive *ExpectedMock) MakeActiveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMakeActive.afterMakeActiveCounter)
}

// MakeActiveBeforeCounter returns a count of ExpectedMock.MakeActive invocations
func (mmMakeActive *ExpectedMock) MakeActiveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMakeActive.beforeMakeActiveCounter)
}

// Calls returns a list of arguments used in each call to ExpectedMock.MakeActive.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMakeActive *mExpectedMockMakeActive) Calls() []*ExpectedMockMakeActiveParams {
	mmMakeActive.mutex.RLock()

	argCopy := make([]*ExpectedMockMakeActiveParams, len(mmMakeActive.callArgs))
	copy(argCopy, mmMakeActive.callArgs)

	mmMakeActive.mutex.RUnlock()

	return argCopy
}

// MinimockMakeActiveDone returns true if the count of the MakeActive invocations corresponds
// the number of defined expectations
func (m *ExpectedMock) MinimockMakeActiveDone() bool {
	for _, e := range m.MakeActiveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MakeActiveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMakeActiveCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMakeActive != nil && mm_atomic.LoadUint64(&m.afterMakeActiveCounter) < 1 {
		return false
	}
	return true
}

// MinimockMakeActiveInspect logs each unmet expectation
func (m *ExpectedMock) MinimockMakeActiveInspect() {
	for _, e := range m.MakeActiveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExpectedMock.MakeActive with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MakeActiveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMakeActiveCounter) < 1 {
		if m.MakeActiveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExpectedMock.MakeActive")
		} else {
			m.t.Errorf("Expected call to ExpectedMock.MakeActive with params: %#v", *m.MakeActiveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMakeActive != nil && mm_atomic.LoadUint64(&m.afterMakeActiveCounter) < 1 {
		m.t.Error("Expected call to ExpectedMock.MakeActive")
	}
}

type mExpectedMockRebuild struct {
	mock               *ExpectedMock
	defaultExpectation *ExpectedMockRebuildExpectation
	expectations       []*ExpectedMockRebuildExpectation

	callArgs []*ExpectedMockRebuildParams
	mutex    sync.RWMutex
}

// ExpectedMockRebuildExpectation specifies expectation struct of the Expected.Rebuild
type ExpectedMockRebuildExpectation struct {
	mock    *ExpectedMock
	params  *ExpectedMockRebuildParams
	results *ExpectedMockRebuildResults
	Counter uint64
}

// ExpectedMockRebuildParams contains parameters of the Expected.Rebuild
type ExpectedMockRebuildParams struct {
	pn pulse.Number
}

// ExpectedMockRebuildResults contains results of the Expected.Rebuild
type ExpectedMockRebuildResults struct {
	b1 Built
}

// Expect sets up expected params for Expected.Rebuild
func (mmRebuild *mExpectedMockRebuild) Expect(pn pulse.Number) *mExpectedMockRebuild {
	if mmRebuild.mock.funcRebuild != nil {
		mmRebuild.mock.t.Fatalf("ExpectedMock.Rebuild mock is already set by Set")
	}

	if mmRebuild.defaultExpectation == nil {
		mmRebuild.defaultExpectation = &ExpectedMockRebuildExpectation{}
	}

	mmRebuild.defaultExpectation.params = &ExpectedMockRebuildParams{pn}
	for _, e := range mmRebuild.expectations {
		if minimock.Equal(e.params, mmRebuild.defaultExpectation.params) {
			mmRebuild.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRebuild.defaultExpectation.params)
		}
	}

	return mmRebuild
}

// Inspect accepts an inspector function that has same arguments as the Expected.Rebuild
func (mmRebuild *mExpectedMockRebuild) Inspect(f func(pn pulse.Number)) *mExpectedMockRebuild {
	if mmRebuild.mock.inspectFuncRebuild != nil {
		mmRebuild.mock.t.Fatalf("Inspect function is already set for ExpectedMock.Rebuild")
	}

	mmRebuild.mock.inspectFuncRebuild = f

	return mmRebuild
}

// Return sets up results that will be returned by Expected.Rebuild
func (mmRebuild *mExpectedMockRebuild) Return(b1 Built) *ExpectedMock {
	if mmRebuild.mock.funcRebuild != nil {
		mmRebuild.mock.t.Fatalf("ExpectedMock.Rebuild mock is already set by Set")
	}

	if mmRebuild.defaultExpectation == nil {
		mmRebuild.defaultExpectation = &ExpectedMockRebuildExpectation{mock: mmRebuild.mock}
	}
	mmRebuild.defaultExpectation.results = &ExpectedMockRebuildResults{b1}
	return mmRebuild.mock
}

//Set uses given function f to mock the Expected.Rebuild method
func (mmRebuild *mExpectedMockRebuild) Set(f func(pn pulse.Number) (b1 Built)) *ExpectedMock {
	if mmRebuild.defaultExpectation != nil {
		mmRebuild.mock.t.Fatalf("Default expectation is already set for the Expected.Rebuild method")
	}

	if len(mmRebuild.expectations) > 0 {
		mmRebuild.mock.t.Fatalf("Some expectations are already set for the Expected.Rebuild method")
	}

	mmRebuild.mock.funcRebuild = f
	return mmRebuild.mock
}

// When sets expectation for the Expected.Rebuild which will trigger the result defined by the following
// Then helper
func (mmRebuild *mExpectedMockRebuild) When(pn pulse.Number) *ExpectedMockRebuildExpectation {
	if mmRebuild.mock.funcRebuild != nil {
		mmRebuild.mock.t.Fatalf("ExpectedMock.Rebuild mock is already set by Set")
	}

	expectation := &ExpectedMockRebuildExpectation{
		mock:   mmRebuild.mock,
		params: &ExpectedMockRebuildParams{pn},
	}
	mmRebuild.expectations = append(mmRebuild.expectations, expectation)
	return expectation
}

// Then sets up Expected.Rebuild return parameters for the expectation previously defined by the When method
func (e *ExpectedMockRebuildExpectation) Then(b1 Built) *ExpectedMock {
	e.results = &ExpectedMockRebuildResults{b1}
	return e.mock
}

// Rebuild implements Expected
func (mmRebuild *ExpectedMock) Rebuild(pn pulse.Number) (b1 Built) {
	mm_atomic.AddUint64(&mmRebuild.beforeRebuildCounter, 1)
	defer mm_atomic.AddUint64(&mmRebuild.afterRebuildCounter, 1)

	if mmRebuild.inspectFuncRebuild != nil {
		mmRebuild.inspectFuncRebuild(pn)
	}

	params := &ExpectedMockRebuildParams{pn}

	// Record call args
	mmRebuild.RebuildMock.mutex.Lock()
	mmRebuild.RebuildMock.callArgs = append(mmRebuild.RebuildMock.callArgs, params)
	mmRebuild.RebuildMock.mutex.Unlock()

	for _, e := range mmRebuild.RebuildMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmRebuild.RebuildMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRebuild.RebuildMock.defaultExpectation.Counter, 1)
		want := mmRebuild.RebuildMock.defaultExpectation.params
		got := ExpectedMockRebuildParams{pn}
		if want != nil && !minimock.Equal(*want, got) {
			mmRebuild.t.Errorf("ExpectedMock.Rebuild got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmRebuild.RebuildMock.defaultExpectation.results
		if results == nil {
			mmRebuild.t.Fatal("No results are set for the ExpectedMock.Rebuild")
		}
		return (*results).b1
	}
	if mmRebuild.funcRebuild != nil {
		return mmRebuild.funcRebuild(pn)
	}
	mmRebuild.t.Fatalf("Unexpected call to ExpectedMock.Rebuild. %v", pn)
	return
}

// RebuildAfterCounter returns a count of finished ExpectedMock.Rebuild invocations
func (mmRebuild *ExpectedMock) RebuildAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRebuild.afterRebuildCounter)
}

// RebuildBeforeCounter returns a count of ExpectedMock.Rebuild invocations
func (mmRebuild *ExpectedMock) RebuildBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRebuild.beforeRebuildCounter)
}

// Calls returns a list of arguments used in each call to ExpectedMock.Rebuild.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRebuild *mExpectedMockRebuild) Calls() []*ExpectedMockRebuildParams {
	mmRebuild.mutex.RLock()

	argCopy := make([]*ExpectedMockRebuildParams, len(mmRebuild.callArgs))
	copy(argCopy, mmRebuild.callArgs)

	mmRebuild.mutex.RUnlock()

	return argCopy
}

// MinimockRebuildDone returns true if the count of the Rebuild invocations corresponds
// the number of defined expectations
func (m *ExpectedMock) MinimockRebuildDone() bool {
	for _, e := range m.RebuildMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RebuildMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRebuildCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRebuild != nil && mm_atomic.LoadUint64(&m.afterRebuildCounter) < 1 {
		return false
	}
	return true
}

// MinimockRebuildInspect logs each unmet expectation
func (m *ExpectedMock) MinimockRebuildInspect() {
	for _, e := range m.RebuildMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExpectedMock.Rebuild with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RebuildMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRebuildCounter) < 1 {
		if m.RebuildMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExpectedMock.Rebuild")
		} else {
			m.t.Errorf("Expected call to ExpectedMock.Rebuild with params: %#v", *m.RebuildMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRebuild != nil && mm_atomic.LoadUint64(&m.afterRebuildCounter) < 1 {
		m.t.Error("Expected call to ExpectedMock.Rebuild")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ExpectedMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateBuilderInspect()

		m.MinimockGetCensusStateInspect()

		m.MinimockGetCloudStateHashInspect()

		m.MinimockGetEvictedPopulationInspect()

		m.MinimockGetExpectedPulseNumberInspect()

		m.MinimockGetGlobulaStateHashInspect()

		m.MinimockGetMandateRegistryInspect()

		m.MinimockGetMisbehaviorRegistryInspect()

		m.MinimockGetNearestPulseDataInspect()

		m.MinimockGetOfflinePopulationInspect()

		m.MinimockGetOnlinePopulationInspect()

		m.MinimockGetPreviousInspect()

		m.MinimockGetProfileFactoryInspect()

		m.MinimockGetPulseNumberInspect()

		m.MinimockIsActiveInspect()

		m.MinimockMakeActiveInspect()

		m.MinimockRebuildInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ExpectedMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ExpectedMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateBuilderDone() &&
		m.MinimockGetCensusStateDone() &&
		m.MinimockGetCloudStateHashDone() &&
		m.MinimockGetEvictedPopulationDone() &&
		m.MinimockGetExpectedPulseNumberDone() &&
		m.MinimockGetGlobulaStateHashDone() &&
		m.MinimockGetMandateRegistryDone() &&
		m.MinimockGetMisbehaviorRegistryDone() &&
		m.MinimockGetNearestPulseDataDone() &&
		m.MinimockGetOfflinePopulationDone() &&
		m.MinimockGetOnlinePopulationDone() &&
		m.MinimockGetPreviousDone() &&
		m.MinimockGetProfileFactoryDone() &&
		m.MinimockGetPulseNumberDone() &&
		m.MinimockIsActiveDone() &&
		m.MinimockMakeActiveDone() &&
		m.MinimockRebuildDone()
}
