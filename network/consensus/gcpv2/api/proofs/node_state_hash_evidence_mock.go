package proofs

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/insolar/network/consensus/common/cryptkit"
)

// NodeStateHashEvidenceMock implements NodeStateHashEvidence
type NodeStateHashEvidenceMock struct {
	t minimock.Tester

	funcCopyOfSignedDigest          func() (s1 cryptkit.SignedDigest)
	inspectFuncCopyOfSignedDigest   func()
	afterCopyOfSignedDigestCounter  uint64
	beforeCopyOfSignedDigestCounter uint64
	CopyOfSignedDigestMock          mNodeStateHashEvidenceMockCopyOfSignedDigest

	funcEquals          func(o cryptkit.SignedDigestHolder) (b1 bool)
	inspectFuncEquals   func(o cryptkit.SignedDigestHolder)
	afterEqualsCounter  uint64
	beforeEqualsCounter uint64
	EqualsMock          mNodeStateHashEvidenceMockEquals

	funcGetDigestHolder          func() (d1 cryptkit.DigestHolder)
	inspectFuncGetDigestHolder   func()
	afterGetDigestHolderCounter  uint64
	beforeGetDigestHolderCounter uint64
	GetDigestHolderMock          mNodeStateHashEvidenceMockGetDigestHolder

	funcGetSignatureHolder          func() (s1 cryptkit.SignatureHolder)
	inspectFuncGetSignatureHolder   func()
	afterGetSignatureHolderCounter  uint64
	beforeGetSignatureHolderCounter uint64
	GetSignatureHolderMock          mNodeStateHashEvidenceMockGetSignatureHolder

	funcGetSignatureMethod          func() (s1 cryptkit.SignatureMethod)
	inspectFuncGetSignatureMethod   func()
	afterGetSignatureMethodCounter  uint64
	beforeGetSignatureMethodCounter uint64
	GetSignatureMethodMock          mNodeStateHashEvidenceMockGetSignatureMethod

	funcIsVerifiableBy          func(v cryptkit.SignatureVerifier) (b1 bool)
	inspectFuncIsVerifiableBy   func(v cryptkit.SignatureVerifier)
	afterIsVerifiableByCounter  uint64
	beforeIsVerifiableByCounter uint64
	IsVerifiableByMock          mNodeStateHashEvidenceMockIsVerifiableBy

	funcVerifyWith          func(v cryptkit.SignatureVerifier) (b1 bool)
	inspectFuncVerifyWith   func(v cryptkit.SignatureVerifier)
	afterVerifyWithCounter  uint64
	beforeVerifyWithCounter uint64
	VerifyWithMock          mNodeStateHashEvidenceMockVerifyWith
}

// NewNodeStateHashEvidenceMock returns a mock for NodeStateHashEvidence
func NewNodeStateHashEvidenceMock(t minimock.Tester) *NodeStateHashEvidenceMock {
	m := &NodeStateHashEvidenceMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CopyOfSignedDigestMock = mNodeStateHashEvidenceMockCopyOfSignedDigest{mock: m}

	m.EqualsMock = mNodeStateHashEvidenceMockEquals{mock: m}
	m.EqualsMock.callArgs = []*NodeStateHashEvidenceMockEqualsParams{}

	m.GetDigestHolderMock = mNodeStateHashEvidenceMockGetDigestHolder{mock: m}

	m.GetSignatureHolderMock = mNodeStateHashEvidenceMockGetSignatureHolder{mock: m}

	m.GetSignatureMethodMock = mNodeStateHashEvidenceMockGetSignatureMethod{mock: m}

	m.IsVerifiableByMock = mNodeStateHashEvidenceMockIsVerifiableBy{mock: m}
	m.IsVerifiableByMock.callArgs = []*NodeStateHashEvidenceMockIsVerifiableByParams{}

	m.VerifyWithMock = mNodeStateHashEvidenceMockVerifyWith{mock: m}
	m.VerifyWithMock.callArgs = []*NodeStateHashEvidenceMockVerifyWithParams{}

	return m
}

type mNodeStateHashEvidenceMockCopyOfSignedDigest struct {
	mock               *NodeStateHashEvidenceMock
	defaultExpectation *NodeStateHashEvidenceMockCopyOfSignedDigestExpectation
	expectations       []*NodeStateHashEvidenceMockCopyOfSignedDigestExpectation
}

// NodeStateHashEvidenceMockCopyOfSignedDigestExpectation specifies expectation struct of the NodeStateHashEvidence.CopyOfSignedDigest
type NodeStateHashEvidenceMockCopyOfSignedDigestExpectation struct {
	mock *NodeStateHashEvidenceMock

	results *NodeStateHashEvidenceMockCopyOfSignedDigestResults
	Counter uint64
}

// NodeStateHashEvidenceMockCopyOfSignedDigestResults contains results of the NodeStateHashEvidence.CopyOfSignedDigest
type NodeStateHashEvidenceMockCopyOfSignedDigestResults struct {
	s1 cryptkit.SignedDigest
}

// Expect sets up expected params for NodeStateHashEvidence.CopyOfSignedDigest
func (mmCopyOfSignedDigest *mNodeStateHashEvidenceMockCopyOfSignedDigest) Expect() *mNodeStateHashEvidenceMockCopyOfSignedDigest {
	if mmCopyOfSignedDigest.mock.funcCopyOfSignedDigest != nil {
		mmCopyOfSignedDigest.mock.t.Fatalf("NodeStateHashEvidenceMock.CopyOfSignedDigest mock is already set by Set")
	}

	if mmCopyOfSignedDigest.defaultExpectation == nil {
		mmCopyOfSignedDigest.defaultExpectation = &NodeStateHashEvidenceMockCopyOfSignedDigestExpectation{}
	}

	return mmCopyOfSignedDigest
}

// Inspect accepts an inspector function that has same arguments as the NodeStateHashEvidence.CopyOfSignedDigest
func (mmCopyOfSignedDigest *mNodeStateHashEvidenceMockCopyOfSignedDigest) Inspect(f func()) *mNodeStateHashEvidenceMockCopyOfSignedDigest {
	if mmCopyOfSignedDigest.mock.inspectFuncCopyOfSignedDigest != nil {
		mmCopyOfSignedDigest.mock.t.Fatalf("Inspect function is already set for NodeStateHashEvidenceMock.CopyOfSignedDigest")
	}

	mmCopyOfSignedDigest.mock.inspectFuncCopyOfSignedDigest = f

	return mmCopyOfSignedDigest
}

// Return sets up results that will be returned by NodeStateHashEvidence.CopyOfSignedDigest
func (mmCopyOfSignedDigest *mNodeStateHashEvidenceMockCopyOfSignedDigest) Return(s1 cryptkit.SignedDigest) *NodeStateHashEvidenceMock {
	if mmCopyOfSignedDigest.mock.funcCopyOfSignedDigest != nil {
		mmCopyOfSignedDigest.mock.t.Fatalf("NodeStateHashEvidenceMock.CopyOfSignedDigest mock is already set by Set")
	}

	if mmCopyOfSignedDigest.defaultExpectation == nil {
		mmCopyOfSignedDigest.defaultExpectation = &NodeStateHashEvidenceMockCopyOfSignedDigestExpectation{mock: mmCopyOfSignedDigest.mock}
	}
	mmCopyOfSignedDigest.defaultExpectation.results = &NodeStateHashEvidenceMockCopyOfSignedDigestResults{s1}
	return mmCopyOfSignedDigest.mock
}

//Set uses given function f to mock the NodeStateHashEvidence.CopyOfSignedDigest method
func (mmCopyOfSignedDigest *mNodeStateHashEvidenceMockCopyOfSignedDigest) Set(f func() (s1 cryptkit.SignedDigest)) *NodeStateHashEvidenceMock {
	if mmCopyOfSignedDigest.defaultExpectation != nil {
		mmCopyOfSignedDigest.mock.t.Fatalf("Default expectation is already set for the NodeStateHashEvidence.CopyOfSignedDigest method")
	}

	if len(mmCopyOfSignedDigest.expectations) > 0 {
		mmCopyOfSignedDigest.mock.t.Fatalf("Some expectations are already set for the NodeStateHashEvidence.CopyOfSignedDigest method")
	}

	mmCopyOfSignedDigest.mock.funcCopyOfSignedDigest = f
	return mmCopyOfSignedDigest.mock
}

// CopyOfSignedDigest implements NodeStateHashEvidence
func (mmCopyOfSignedDigest *NodeStateHashEvidenceMock) CopyOfSignedDigest() (s1 cryptkit.SignedDigest) {
	mm_atomic.AddUint64(&mmCopyOfSignedDigest.beforeCopyOfSignedDigestCounter, 1)
	defer mm_atomic.AddUint64(&mmCopyOfSignedDigest.afterCopyOfSignedDigestCounter, 1)

	if mmCopyOfSignedDigest.inspectFuncCopyOfSignedDigest != nil {
		mmCopyOfSignedDigest.inspectFuncCopyOfSignedDigest()
	}

	if mmCopyOfSignedDigest.CopyOfSignedDigestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCopyOfSignedDigest.CopyOfSignedDigestMock.defaultExpectation.Counter, 1)

		mm_results := mmCopyOfSignedDigest.CopyOfSignedDigestMock.defaultExpectation.results
		if mm_results == nil {
			mmCopyOfSignedDigest.t.Fatal("No results are set for the NodeStateHashEvidenceMock.CopyOfSignedDigest")
		}
		return (*mm_results).s1
	}
	if mmCopyOfSignedDigest.funcCopyOfSignedDigest != nil {
		return mmCopyOfSignedDigest.funcCopyOfSignedDigest()
	}
	mmCopyOfSignedDigest.t.Fatalf("Unexpected call to NodeStateHashEvidenceMock.CopyOfSignedDigest.")
	return
}

// CopyOfSignedDigestAfterCounter returns a count of finished NodeStateHashEvidenceMock.CopyOfSignedDigest invocations
func (mmCopyOfSignedDigest *NodeStateHashEvidenceMock) CopyOfSignedDigestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyOfSignedDigest.afterCopyOfSignedDigestCounter)
}

// CopyOfSignedDigestBeforeCounter returns a count of NodeStateHashEvidenceMock.CopyOfSignedDigest invocations
func (mmCopyOfSignedDigest *NodeStateHashEvidenceMock) CopyOfSignedDigestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyOfSignedDigest.beforeCopyOfSignedDigestCounter)
}

// MinimockCopyOfSignedDigestDone returns true if the count of the CopyOfSignedDigest invocations corresponds
// the number of defined expectations
func (m *NodeStateHashEvidenceMock) MinimockCopyOfSignedDigestDone() bool {
	for _, e := range m.CopyOfSignedDigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyOfSignedDigestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyOfSignedDigestCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyOfSignedDigest != nil && mm_atomic.LoadUint64(&m.afterCopyOfSignedDigestCounter) < 1 {
		return false
	}
	return true
}

// MinimockCopyOfSignedDigestInspect logs each unmet expectation
func (m *NodeStateHashEvidenceMock) MinimockCopyOfSignedDigestInspect() {
	for _, e := range m.CopyOfSignedDigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NodeStateHashEvidenceMock.CopyOfSignedDigest")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyOfSignedDigestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyOfSignedDigestCounter) < 1 {
		m.t.Error("Expected call to NodeStateHashEvidenceMock.CopyOfSignedDigest")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyOfSignedDigest != nil && mm_atomic.LoadUint64(&m.afterCopyOfSignedDigestCounter) < 1 {
		m.t.Error("Expected call to NodeStateHashEvidenceMock.CopyOfSignedDigest")
	}
}

type mNodeStateHashEvidenceMockEquals struct {
	mock               *NodeStateHashEvidenceMock
	defaultExpectation *NodeStateHashEvidenceMockEqualsExpectation
	expectations       []*NodeStateHashEvidenceMockEqualsExpectation

	callArgs []*NodeStateHashEvidenceMockEqualsParams
	mutex    sync.RWMutex
}

// NodeStateHashEvidenceMockEqualsExpectation specifies expectation struct of the NodeStateHashEvidence.Equals
type NodeStateHashEvidenceMockEqualsExpectation struct {
	mock    *NodeStateHashEvidenceMock
	params  *NodeStateHashEvidenceMockEqualsParams
	results *NodeStateHashEvidenceMockEqualsResults
	Counter uint64
}

// NodeStateHashEvidenceMockEqualsParams contains parameters of the NodeStateHashEvidence.Equals
type NodeStateHashEvidenceMockEqualsParams struct {
	o cryptkit.SignedDigestHolder
}

// NodeStateHashEvidenceMockEqualsResults contains results of the NodeStateHashEvidence.Equals
type NodeStateHashEvidenceMockEqualsResults struct {
	b1 bool
}

// Expect sets up expected params for NodeStateHashEvidence.Equals
func (mmEquals *mNodeStateHashEvidenceMockEquals) Expect(o cryptkit.SignedDigestHolder) *mNodeStateHashEvidenceMockEquals {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("NodeStateHashEvidenceMock.Equals mock is already set by Set")
	}

	if mmEquals.defaultExpectation == nil {
		mmEquals.defaultExpectation = &NodeStateHashEvidenceMockEqualsExpectation{}
	}

	mmEquals.defaultExpectation.params = &NodeStateHashEvidenceMockEqualsParams{o}
	for _, e := range mmEquals.expectations {
		if minimock.Equal(e.params, mmEquals.defaultExpectation.params) {
			mmEquals.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEquals.defaultExpectation.params)
		}
	}

	return mmEquals
}

// Inspect accepts an inspector function that has same arguments as the NodeStateHashEvidence.Equals
func (mmEquals *mNodeStateHashEvidenceMockEquals) Inspect(f func(o cryptkit.SignedDigestHolder)) *mNodeStateHashEvidenceMockEquals {
	if mmEquals.mock.inspectFuncEquals != nil {
		mmEquals.mock.t.Fatalf("Inspect function is already set for NodeStateHashEvidenceMock.Equals")
	}

	mmEquals.mock.inspectFuncEquals = f

	return mmEquals
}

// Return sets up results that will be returned by NodeStateHashEvidence.Equals
func (mmEquals *mNodeStateHashEvidenceMockEquals) Return(b1 bool) *NodeStateHashEvidenceMock {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("NodeStateHashEvidenceMock.Equals mock is already set by Set")
	}

	if mmEquals.defaultExpectation == nil {
		mmEquals.defaultExpectation = &NodeStateHashEvidenceMockEqualsExpectation{mock: mmEquals.mock}
	}
	mmEquals.defaultExpectation.results = &NodeStateHashEvidenceMockEqualsResults{b1}
	return mmEquals.mock
}

//Set uses given function f to mock the NodeStateHashEvidence.Equals method
func (mmEquals *mNodeStateHashEvidenceMockEquals) Set(f func(o cryptkit.SignedDigestHolder) (b1 bool)) *NodeStateHashEvidenceMock {
	if mmEquals.defaultExpectation != nil {
		mmEquals.mock.t.Fatalf("Default expectation is already set for the NodeStateHashEvidence.Equals method")
	}

	if len(mmEquals.expectations) > 0 {
		mmEquals.mock.t.Fatalf("Some expectations are already set for the NodeStateHashEvidence.Equals method")
	}

	mmEquals.mock.funcEquals = f
	return mmEquals.mock
}

// When sets expectation for the NodeStateHashEvidence.Equals which will trigger the result defined by the following
// Then helper
func (mmEquals *mNodeStateHashEvidenceMockEquals) When(o cryptkit.SignedDigestHolder) *NodeStateHashEvidenceMockEqualsExpectation {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("NodeStateHashEvidenceMock.Equals mock is already set by Set")
	}

	expectation := &NodeStateHashEvidenceMockEqualsExpectation{
		mock:   mmEquals.mock,
		params: &NodeStateHashEvidenceMockEqualsParams{o},
	}
	mmEquals.expectations = append(mmEquals.expectations, expectation)
	return expectation
}

// Then sets up NodeStateHashEvidence.Equals return parameters for the expectation previously defined by the When method
func (e *NodeStateHashEvidenceMockEqualsExpectation) Then(b1 bool) *NodeStateHashEvidenceMock {
	e.results = &NodeStateHashEvidenceMockEqualsResults{b1}
	return e.mock
}

// Equals implements NodeStateHashEvidence
func (mmEquals *NodeStateHashEvidenceMock) Equals(o cryptkit.SignedDigestHolder) (b1 bool) {
	mm_atomic.AddUint64(&mmEquals.beforeEqualsCounter, 1)
	defer mm_atomic.AddUint64(&mmEquals.afterEqualsCounter, 1)

	if mmEquals.inspectFuncEquals != nil {
		mmEquals.inspectFuncEquals(o)
	}

	mm_params := &NodeStateHashEvidenceMockEqualsParams{o}

	// Record call args
	mmEquals.EqualsMock.mutex.Lock()
	mmEquals.EqualsMock.callArgs = append(mmEquals.EqualsMock.callArgs, mm_params)
	mmEquals.EqualsMock.mutex.Unlock()

	for _, e := range mmEquals.EqualsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmEquals.EqualsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEquals.EqualsMock.defaultExpectation.Counter, 1)
		mm_want := mmEquals.EqualsMock.defaultExpectation.params
		mm_got := NodeStateHashEvidenceMockEqualsParams{o}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEquals.t.Errorf("NodeStateHashEvidenceMock.Equals got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEquals.EqualsMock.defaultExpectation.results
		if mm_results == nil {
			mmEquals.t.Fatal("No results are set for the NodeStateHashEvidenceMock.Equals")
		}
		return (*mm_results).b1
	}
	if mmEquals.funcEquals != nil {
		return mmEquals.funcEquals(o)
	}
	mmEquals.t.Fatalf("Unexpected call to NodeStateHashEvidenceMock.Equals. %v", o)
	return
}

// EqualsAfterCounter returns a count of finished NodeStateHashEvidenceMock.Equals invocations
func (mmEquals *NodeStateHashEvidenceMock) EqualsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEquals.afterEqualsCounter)
}

// EqualsBeforeCounter returns a count of NodeStateHashEvidenceMock.Equals invocations
func (mmEquals *NodeStateHashEvidenceMock) EqualsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEquals.beforeEqualsCounter)
}

// Calls returns a list of arguments used in each call to NodeStateHashEvidenceMock.Equals.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEquals *mNodeStateHashEvidenceMockEquals) Calls() []*NodeStateHashEvidenceMockEqualsParams {
	mmEquals.mutex.RLock()

	argCopy := make([]*NodeStateHashEvidenceMockEqualsParams, len(mmEquals.callArgs))
	copy(argCopy, mmEquals.callArgs)

	mmEquals.mutex.RUnlock()

	return argCopy
}

// MinimockEqualsDone returns true if the count of the Equals invocations corresponds
// the number of defined expectations
func (m *NodeStateHashEvidenceMock) MinimockEqualsDone() bool {
	for _, e := range m.EqualsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EqualsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEquals != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		return false
	}
	return true
}

// MinimockEqualsInspect logs each unmet expectation
func (m *NodeStateHashEvidenceMock) MinimockEqualsInspect() {
	for _, e := range m.EqualsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NodeStateHashEvidenceMock.Equals with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EqualsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		if m.EqualsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to NodeStateHashEvidenceMock.Equals")
		} else {
			m.t.Errorf("Expected call to NodeStateHashEvidenceMock.Equals with params: %#v", *m.EqualsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEquals != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		m.t.Error("Expected call to NodeStateHashEvidenceMock.Equals")
	}
}

type mNodeStateHashEvidenceMockGetDigestHolder struct {
	mock               *NodeStateHashEvidenceMock
	defaultExpectation *NodeStateHashEvidenceMockGetDigestHolderExpectation
	expectations       []*NodeStateHashEvidenceMockGetDigestHolderExpectation
}

// NodeStateHashEvidenceMockGetDigestHolderExpectation specifies expectation struct of the NodeStateHashEvidence.GetDigestHolder
type NodeStateHashEvidenceMockGetDigestHolderExpectation struct {
	mock *NodeStateHashEvidenceMock

	results *NodeStateHashEvidenceMockGetDigestHolderResults
	Counter uint64
}

// NodeStateHashEvidenceMockGetDigestHolderResults contains results of the NodeStateHashEvidence.GetDigestHolder
type NodeStateHashEvidenceMockGetDigestHolderResults struct {
	d1 cryptkit.DigestHolder
}

// Expect sets up expected params for NodeStateHashEvidence.GetDigestHolder
func (mmGetDigestHolder *mNodeStateHashEvidenceMockGetDigestHolder) Expect() *mNodeStateHashEvidenceMockGetDigestHolder {
	if mmGetDigestHolder.mock.funcGetDigestHolder != nil {
		mmGetDigestHolder.mock.t.Fatalf("NodeStateHashEvidenceMock.GetDigestHolder mock is already set by Set")
	}

	if mmGetDigestHolder.defaultExpectation == nil {
		mmGetDigestHolder.defaultExpectation = &NodeStateHashEvidenceMockGetDigestHolderExpectation{}
	}

	return mmGetDigestHolder
}

// Inspect accepts an inspector function that has same arguments as the NodeStateHashEvidence.GetDigestHolder
func (mmGetDigestHolder *mNodeStateHashEvidenceMockGetDigestHolder) Inspect(f func()) *mNodeStateHashEvidenceMockGetDigestHolder {
	if mmGetDigestHolder.mock.inspectFuncGetDigestHolder != nil {
		mmGetDigestHolder.mock.t.Fatalf("Inspect function is already set for NodeStateHashEvidenceMock.GetDigestHolder")
	}

	mmGetDigestHolder.mock.inspectFuncGetDigestHolder = f

	return mmGetDigestHolder
}

// Return sets up results that will be returned by NodeStateHashEvidence.GetDigestHolder
func (mmGetDigestHolder *mNodeStateHashEvidenceMockGetDigestHolder) Return(d1 cryptkit.DigestHolder) *NodeStateHashEvidenceMock {
	if mmGetDigestHolder.mock.funcGetDigestHolder != nil {
		mmGetDigestHolder.mock.t.Fatalf("NodeStateHashEvidenceMock.GetDigestHolder mock is already set by Set")
	}

	if mmGetDigestHolder.defaultExpectation == nil {
		mmGetDigestHolder.defaultExpectation = &NodeStateHashEvidenceMockGetDigestHolderExpectation{mock: mmGetDigestHolder.mock}
	}
	mmGetDigestHolder.defaultExpectation.results = &NodeStateHashEvidenceMockGetDigestHolderResults{d1}
	return mmGetDigestHolder.mock
}

//Set uses given function f to mock the NodeStateHashEvidence.GetDigestHolder method
func (mmGetDigestHolder *mNodeStateHashEvidenceMockGetDigestHolder) Set(f func() (d1 cryptkit.DigestHolder)) *NodeStateHashEvidenceMock {
	if mmGetDigestHolder.defaultExpectation != nil {
		mmGetDigestHolder.mock.t.Fatalf("Default expectation is already set for the NodeStateHashEvidence.GetDigestHolder method")
	}

	if len(mmGetDigestHolder.expectations) > 0 {
		mmGetDigestHolder.mock.t.Fatalf("Some expectations are already set for the NodeStateHashEvidence.GetDigestHolder method")
	}

	mmGetDigestHolder.mock.funcGetDigestHolder = f
	return mmGetDigestHolder.mock
}

// GetDigestHolder implements NodeStateHashEvidence
func (mmGetDigestHolder *NodeStateHashEvidenceMock) GetDigestHolder() (d1 cryptkit.DigestHolder) {
	mm_atomic.AddUint64(&mmGetDigestHolder.beforeGetDigestHolderCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDigestHolder.afterGetDigestHolderCounter, 1)

	if mmGetDigestHolder.inspectFuncGetDigestHolder != nil {
		mmGetDigestHolder.inspectFuncGetDigestHolder()
	}

	if mmGetDigestHolder.GetDigestHolderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDigestHolder.GetDigestHolderMock.defaultExpectation.Counter, 1)

		mm_results := mmGetDigestHolder.GetDigestHolderMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDigestHolder.t.Fatal("No results are set for the NodeStateHashEvidenceMock.GetDigestHolder")
		}
		return (*mm_results).d1
	}
	if mmGetDigestHolder.funcGetDigestHolder != nil {
		return mmGetDigestHolder.funcGetDigestHolder()
	}
	mmGetDigestHolder.t.Fatalf("Unexpected call to NodeStateHashEvidenceMock.GetDigestHolder.")
	return
}

// GetDigestHolderAfterCounter returns a count of finished NodeStateHashEvidenceMock.GetDigestHolder invocations
func (mmGetDigestHolder *NodeStateHashEvidenceMock) GetDigestHolderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestHolder.afterGetDigestHolderCounter)
}

// GetDigestHolderBeforeCounter returns a count of NodeStateHashEvidenceMock.GetDigestHolder invocations
func (mmGetDigestHolder *NodeStateHashEvidenceMock) GetDigestHolderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestHolder.beforeGetDigestHolderCounter)
}

// MinimockGetDigestHolderDone returns true if the count of the GetDigestHolder invocations corresponds
// the number of defined expectations
func (m *NodeStateHashEvidenceMock) MinimockGetDigestHolderDone() bool {
	for _, e := range m.GetDigestHolderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestHolderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestHolderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestHolder != nil && mm_atomic.LoadUint64(&m.afterGetDigestHolderCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetDigestHolderInspect logs each unmet expectation
func (m *NodeStateHashEvidenceMock) MinimockGetDigestHolderInspect() {
	for _, e := range m.GetDigestHolderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NodeStateHashEvidenceMock.GetDigestHolder")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestHolderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestHolderCounter) < 1 {
		m.t.Error("Expected call to NodeStateHashEvidenceMock.GetDigestHolder")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestHolder != nil && mm_atomic.LoadUint64(&m.afterGetDigestHolderCounter) < 1 {
		m.t.Error("Expected call to NodeStateHashEvidenceMock.GetDigestHolder")
	}
}

type mNodeStateHashEvidenceMockGetSignatureHolder struct {
	mock               *NodeStateHashEvidenceMock
	defaultExpectation *NodeStateHashEvidenceMockGetSignatureHolderExpectation
	expectations       []*NodeStateHashEvidenceMockGetSignatureHolderExpectation
}

// NodeStateHashEvidenceMockGetSignatureHolderExpectation specifies expectation struct of the NodeStateHashEvidence.GetSignatureHolder
type NodeStateHashEvidenceMockGetSignatureHolderExpectation struct {
	mock *NodeStateHashEvidenceMock

	results *NodeStateHashEvidenceMockGetSignatureHolderResults
	Counter uint64
}

// NodeStateHashEvidenceMockGetSignatureHolderResults contains results of the NodeStateHashEvidence.GetSignatureHolder
type NodeStateHashEvidenceMockGetSignatureHolderResults struct {
	s1 cryptkit.SignatureHolder
}

// Expect sets up expected params for NodeStateHashEvidence.GetSignatureHolder
func (mmGetSignatureHolder *mNodeStateHashEvidenceMockGetSignatureHolder) Expect() *mNodeStateHashEvidenceMockGetSignatureHolder {
	if mmGetSignatureHolder.mock.funcGetSignatureHolder != nil {
		mmGetSignatureHolder.mock.t.Fatalf("NodeStateHashEvidenceMock.GetSignatureHolder mock is already set by Set")
	}

	if mmGetSignatureHolder.defaultExpectation == nil {
		mmGetSignatureHolder.defaultExpectation = &NodeStateHashEvidenceMockGetSignatureHolderExpectation{}
	}

	return mmGetSignatureHolder
}

// Inspect accepts an inspector function that has same arguments as the NodeStateHashEvidence.GetSignatureHolder
func (mmGetSignatureHolder *mNodeStateHashEvidenceMockGetSignatureHolder) Inspect(f func()) *mNodeStateHashEvidenceMockGetSignatureHolder {
	if mmGetSignatureHolder.mock.inspectFuncGetSignatureHolder != nil {
		mmGetSignatureHolder.mock.t.Fatalf("Inspect function is already set for NodeStateHashEvidenceMock.GetSignatureHolder")
	}

	mmGetSignatureHolder.mock.inspectFuncGetSignatureHolder = f

	return mmGetSignatureHolder
}

// Return sets up results that will be returned by NodeStateHashEvidence.GetSignatureHolder
func (mmGetSignatureHolder *mNodeStateHashEvidenceMockGetSignatureHolder) Return(s1 cryptkit.SignatureHolder) *NodeStateHashEvidenceMock {
	if mmGetSignatureHolder.mock.funcGetSignatureHolder != nil {
		mmGetSignatureHolder.mock.t.Fatalf("NodeStateHashEvidenceMock.GetSignatureHolder mock is already set by Set")
	}

	if mmGetSignatureHolder.defaultExpectation == nil {
		mmGetSignatureHolder.defaultExpectation = &NodeStateHashEvidenceMockGetSignatureHolderExpectation{mock: mmGetSignatureHolder.mock}
	}
	mmGetSignatureHolder.defaultExpectation.results = &NodeStateHashEvidenceMockGetSignatureHolderResults{s1}
	return mmGetSignatureHolder.mock
}

//Set uses given function f to mock the NodeStateHashEvidence.GetSignatureHolder method
func (mmGetSignatureHolder *mNodeStateHashEvidenceMockGetSignatureHolder) Set(f func() (s1 cryptkit.SignatureHolder)) *NodeStateHashEvidenceMock {
	if mmGetSignatureHolder.defaultExpectation != nil {
		mmGetSignatureHolder.mock.t.Fatalf("Default expectation is already set for the NodeStateHashEvidence.GetSignatureHolder method")
	}

	if len(mmGetSignatureHolder.expectations) > 0 {
		mmGetSignatureHolder.mock.t.Fatalf("Some expectations are already set for the NodeStateHashEvidence.GetSignatureHolder method")
	}

	mmGetSignatureHolder.mock.funcGetSignatureHolder = f
	return mmGetSignatureHolder.mock
}

// GetSignatureHolder implements NodeStateHashEvidence
func (mmGetSignatureHolder *NodeStateHashEvidenceMock) GetSignatureHolder() (s1 cryptkit.SignatureHolder) {
	mm_atomic.AddUint64(&mmGetSignatureHolder.beforeGetSignatureHolderCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSignatureHolder.afterGetSignatureHolderCounter, 1)

	if mmGetSignatureHolder.inspectFuncGetSignatureHolder != nil {
		mmGetSignatureHolder.inspectFuncGetSignatureHolder()
	}

	if mmGetSignatureHolder.GetSignatureHolderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSignatureHolder.GetSignatureHolderMock.defaultExpectation.Counter, 1)

		mm_results := mmGetSignatureHolder.GetSignatureHolderMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSignatureHolder.t.Fatal("No results are set for the NodeStateHashEvidenceMock.GetSignatureHolder")
		}
		return (*mm_results).s1
	}
	if mmGetSignatureHolder.funcGetSignatureHolder != nil {
		return mmGetSignatureHolder.funcGetSignatureHolder()
	}
	mmGetSignatureHolder.t.Fatalf("Unexpected call to NodeStateHashEvidenceMock.GetSignatureHolder.")
	return
}

// GetSignatureHolderAfterCounter returns a count of finished NodeStateHashEvidenceMock.GetSignatureHolder invocations
func (mmGetSignatureHolder *NodeStateHashEvidenceMock) GetSignatureHolderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSignatureHolder.afterGetSignatureHolderCounter)
}

// GetSignatureHolderBeforeCounter returns a count of NodeStateHashEvidenceMock.GetSignatureHolder invocations
func (mmGetSignatureHolder *NodeStateHashEvidenceMock) GetSignatureHolderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSignatureHolder.beforeGetSignatureHolderCounter)
}

// MinimockGetSignatureHolderDone returns true if the count of the GetSignatureHolder invocations corresponds
// the number of defined expectations
func (m *NodeStateHashEvidenceMock) MinimockGetSignatureHolderDone() bool {
	for _, e := range m.GetSignatureHolderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSignatureHolderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSignatureHolderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSignatureHolder != nil && mm_atomic.LoadUint64(&m.afterGetSignatureHolderCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSignatureHolderInspect logs each unmet expectation
func (m *NodeStateHashEvidenceMock) MinimockGetSignatureHolderInspect() {
	for _, e := range m.GetSignatureHolderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NodeStateHashEvidenceMock.GetSignatureHolder")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSignatureHolderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSignatureHolderCounter) < 1 {
		m.t.Error("Expected call to NodeStateHashEvidenceMock.GetSignatureHolder")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSignatureHolder != nil && mm_atomic.LoadUint64(&m.afterGetSignatureHolderCounter) < 1 {
		m.t.Error("Expected call to NodeStateHashEvidenceMock.GetSignatureHolder")
	}
}

type mNodeStateHashEvidenceMockGetSignatureMethod struct {
	mock               *NodeStateHashEvidenceMock
	defaultExpectation *NodeStateHashEvidenceMockGetSignatureMethodExpectation
	expectations       []*NodeStateHashEvidenceMockGetSignatureMethodExpectation
}

// NodeStateHashEvidenceMockGetSignatureMethodExpectation specifies expectation struct of the NodeStateHashEvidence.GetSignatureMethod
type NodeStateHashEvidenceMockGetSignatureMethodExpectation struct {
	mock *NodeStateHashEvidenceMock

	results *NodeStateHashEvidenceMockGetSignatureMethodResults
	Counter uint64
}

// NodeStateHashEvidenceMockGetSignatureMethodResults contains results of the NodeStateHashEvidence.GetSignatureMethod
type NodeStateHashEvidenceMockGetSignatureMethodResults struct {
	s1 cryptkit.SignatureMethod
}

// Expect sets up expected params for NodeStateHashEvidence.GetSignatureMethod
func (mmGetSignatureMethod *mNodeStateHashEvidenceMockGetSignatureMethod) Expect() *mNodeStateHashEvidenceMockGetSignatureMethod {
	if mmGetSignatureMethod.mock.funcGetSignatureMethod != nil {
		mmGetSignatureMethod.mock.t.Fatalf("NodeStateHashEvidenceMock.GetSignatureMethod mock is already set by Set")
	}

	if mmGetSignatureMethod.defaultExpectation == nil {
		mmGetSignatureMethod.defaultExpectation = &NodeStateHashEvidenceMockGetSignatureMethodExpectation{}
	}

	return mmGetSignatureMethod
}

// Inspect accepts an inspector function that has same arguments as the NodeStateHashEvidence.GetSignatureMethod
func (mmGetSignatureMethod *mNodeStateHashEvidenceMockGetSignatureMethod) Inspect(f func()) *mNodeStateHashEvidenceMockGetSignatureMethod {
	if mmGetSignatureMethod.mock.inspectFuncGetSignatureMethod != nil {
		mmGetSignatureMethod.mock.t.Fatalf("Inspect function is already set for NodeStateHashEvidenceMock.GetSignatureMethod")
	}

	mmGetSignatureMethod.mock.inspectFuncGetSignatureMethod = f

	return mmGetSignatureMethod
}

// Return sets up results that will be returned by NodeStateHashEvidence.GetSignatureMethod
func (mmGetSignatureMethod *mNodeStateHashEvidenceMockGetSignatureMethod) Return(s1 cryptkit.SignatureMethod) *NodeStateHashEvidenceMock {
	if mmGetSignatureMethod.mock.funcGetSignatureMethod != nil {
		mmGetSignatureMethod.mock.t.Fatalf("NodeStateHashEvidenceMock.GetSignatureMethod mock is already set by Set")
	}

	if mmGetSignatureMethod.defaultExpectation == nil {
		mmGetSignatureMethod.defaultExpectation = &NodeStateHashEvidenceMockGetSignatureMethodExpectation{mock: mmGetSignatureMethod.mock}
	}
	mmGetSignatureMethod.defaultExpectation.results = &NodeStateHashEvidenceMockGetSignatureMethodResults{s1}
	return mmGetSignatureMethod.mock
}

//Set uses given function f to mock the NodeStateHashEvidence.GetSignatureMethod method
func (mmGetSignatureMethod *mNodeStateHashEvidenceMockGetSignatureMethod) Set(f func() (s1 cryptkit.SignatureMethod)) *NodeStateHashEvidenceMock {
	if mmGetSignatureMethod.defaultExpectation != nil {
		mmGetSignatureMethod.mock.t.Fatalf("Default expectation is already set for the NodeStateHashEvidence.GetSignatureMethod method")
	}

	if len(mmGetSignatureMethod.expectations) > 0 {
		mmGetSignatureMethod.mock.t.Fatalf("Some expectations are already set for the NodeStateHashEvidence.GetSignatureMethod method")
	}

	mmGetSignatureMethod.mock.funcGetSignatureMethod = f
	return mmGetSignatureMethod.mock
}

// GetSignatureMethod implements NodeStateHashEvidence
func (mmGetSignatureMethod *NodeStateHashEvidenceMock) GetSignatureMethod() (s1 cryptkit.SignatureMethod) {
	mm_atomic.AddUint64(&mmGetSignatureMethod.beforeGetSignatureMethodCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSignatureMethod.afterGetSignatureMethodCounter, 1)

	if mmGetSignatureMethod.inspectFuncGetSignatureMethod != nil {
		mmGetSignatureMethod.inspectFuncGetSignatureMethod()
	}

	if mmGetSignatureMethod.GetSignatureMethodMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSignatureMethod.GetSignatureMethodMock.defaultExpectation.Counter, 1)

		mm_results := mmGetSignatureMethod.GetSignatureMethodMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSignatureMethod.t.Fatal("No results are set for the NodeStateHashEvidenceMock.GetSignatureMethod")
		}
		return (*mm_results).s1
	}
	if mmGetSignatureMethod.funcGetSignatureMethod != nil {
		return mmGetSignatureMethod.funcGetSignatureMethod()
	}
	mmGetSignatureMethod.t.Fatalf("Unexpected call to NodeStateHashEvidenceMock.GetSignatureMethod.")
	return
}

// GetSignatureMethodAfterCounter returns a count of finished NodeStateHashEvidenceMock.GetSignatureMethod invocations
func (mmGetSignatureMethod *NodeStateHashEvidenceMock) GetSignatureMethodAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSignatureMethod.afterGetSignatureMethodCounter)
}

// GetSignatureMethodBeforeCounter returns a count of NodeStateHashEvidenceMock.GetSignatureMethod invocations
func (mmGetSignatureMethod *NodeStateHashEvidenceMock) GetSignatureMethodBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSignatureMethod.beforeGetSignatureMethodCounter)
}

// MinimockGetSignatureMethodDone returns true if the count of the GetSignatureMethod invocations corresponds
// the number of defined expectations
func (m *NodeStateHashEvidenceMock) MinimockGetSignatureMethodDone() bool {
	for _, e := range m.GetSignatureMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSignatureMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSignatureMethodCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSignatureMethod != nil && mm_atomic.LoadUint64(&m.afterGetSignatureMethodCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSignatureMethodInspect logs each unmet expectation
func (m *NodeStateHashEvidenceMock) MinimockGetSignatureMethodInspect() {
	for _, e := range m.GetSignatureMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NodeStateHashEvidenceMock.GetSignatureMethod")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSignatureMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSignatureMethodCounter) < 1 {
		m.t.Error("Expected call to NodeStateHashEvidenceMock.GetSignatureMethod")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSignatureMethod != nil && mm_atomic.LoadUint64(&m.afterGetSignatureMethodCounter) < 1 {
		m.t.Error("Expected call to NodeStateHashEvidenceMock.GetSignatureMethod")
	}
}

type mNodeStateHashEvidenceMockIsVerifiableBy struct {
	mock               *NodeStateHashEvidenceMock
	defaultExpectation *NodeStateHashEvidenceMockIsVerifiableByExpectation
	expectations       []*NodeStateHashEvidenceMockIsVerifiableByExpectation

	callArgs []*NodeStateHashEvidenceMockIsVerifiableByParams
	mutex    sync.RWMutex
}

// NodeStateHashEvidenceMockIsVerifiableByExpectation specifies expectation struct of the NodeStateHashEvidence.IsVerifiableBy
type NodeStateHashEvidenceMockIsVerifiableByExpectation struct {
	mock    *NodeStateHashEvidenceMock
	params  *NodeStateHashEvidenceMockIsVerifiableByParams
	results *NodeStateHashEvidenceMockIsVerifiableByResults
	Counter uint64
}

// NodeStateHashEvidenceMockIsVerifiableByParams contains parameters of the NodeStateHashEvidence.IsVerifiableBy
type NodeStateHashEvidenceMockIsVerifiableByParams struct {
	v cryptkit.SignatureVerifier
}

// NodeStateHashEvidenceMockIsVerifiableByResults contains results of the NodeStateHashEvidence.IsVerifiableBy
type NodeStateHashEvidenceMockIsVerifiableByResults struct {
	b1 bool
}

// Expect sets up expected params for NodeStateHashEvidence.IsVerifiableBy
func (mmIsVerifiableBy *mNodeStateHashEvidenceMockIsVerifiableBy) Expect(v cryptkit.SignatureVerifier) *mNodeStateHashEvidenceMockIsVerifiableBy {
	if mmIsVerifiableBy.mock.funcIsVerifiableBy != nil {
		mmIsVerifiableBy.mock.t.Fatalf("NodeStateHashEvidenceMock.IsVerifiableBy mock is already set by Set")
	}

	if mmIsVerifiableBy.defaultExpectation == nil {
		mmIsVerifiableBy.defaultExpectation = &NodeStateHashEvidenceMockIsVerifiableByExpectation{}
	}

	mmIsVerifiableBy.defaultExpectation.params = &NodeStateHashEvidenceMockIsVerifiableByParams{v}
	for _, e := range mmIsVerifiableBy.expectations {
		if minimock.Equal(e.params, mmIsVerifiableBy.defaultExpectation.params) {
			mmIsVerifiableBy.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsVerifiableBy.defaultExpectation.params)
		}
	}

	return mmIsVerifiableBy
}

// Inspect accepts an inspector function that has same arguments as the NodeStateHashEvidence.IsVerifiableBy
func (mmIsVerifiableBy *mNodeStateHashEvidenceMockIsVerifiableBy) Inspect(f func(v cryptkit.SignatureVerifier)) *mNodeStateHashEvidenceMockIsVerifiableBy {
	if mmIsVerifiableBy.mock.inspectFuncIsVerifiableBy != nil {
		mmIsVerifiableBy.mock.t.Fatalf("Inspect function is already set for NodeStateHashEvidenceMock.IsVerifiableBy")
	}

	mmIsVerifiableBy.mock.inspectFuncIsVerifiableBy = f

	return mmIsVerifiableBy
}

// Return sets up results that will be returned by NodeStateHashEvidence.IsVerifiableBy
func (mmIsVerifiableBy *mNodeStateHashEvidenceMockIsVerifiableBy) Return(b1 bool) *NodeStateHashEvidenceMock {
	if mmIsVerifiableBy.mock.funcIsVerifiableBy != nil {
		mmIsVerifiableBy.mock.t.Fatalf("NodeStateHashEvidenceMock.IsVerifiableBy mock is already set by Set")
	}

	if mmIsVerifiableBy.defaultExpectation == nil {
		mmIsVerifiableBy.defaultExpectation = &NodeStateHashEvidenceMockIsVerifiableByExpectation{mock: mmIsVerifiableBy.mock}
	}
	mmIsVerifiableBy.defaultExpectation.results = &NodeStateHashEvidenceMockIsVerifiableByResults{b1}
	return mmIsVerifiableBy.mock
}

//Set uses given function f to mock the NodeStateHashEvidence.IsVerifiableBy method
func (mmIsVerifiableBy *mNodeStateHashEvidenceMockIsVerifiableBy) Set(f func(v cryptkit.SignatureVerifier) (b1 bool)) *NodeStateHashEvidenceMock {
	if mmIsVerifiableBy.defaultExpectation != nil {
		mmIsVerifiableBy.mock.t.Fatalf("Default expectation is already set for the NodeStateHashEvidence.IsVerifiableBy method")
	}

	if len(mmIsVerifiableBy.expectations) > 0 {
		mmIsVerifiableBy.mock.t.Fatalf("Some expectations are already set for the NodeStateHashEvidence.IsVerifiableBy method")
	}

	mmIsVerifiableBy.mock.funcIsVerifiableBy = f
	return mmIsVerifiableBy.mock
}

// When sets expectation for the NodeStateHashEvidence.IsVerifiableBy which will trigger the result defined by the following
// Then helper
func (mmIsVerifiableBy *mNodeStateHashEvidenceMockIsVerifiableBy) When(v cryptkit.SignatureVerifier) *NodeStateHashEvidenceMockIsVerifiableByExpectation {
	if mmIsVerifiableBy.mock.funcIsVerifiableBy != nil {
		mmIsVerifiableBy.mock.t.Fatalf("NodeStateHashEvidenceMock.IsVerifiableBy mock is already set by Set")
	}

	expectation := &NodeStateHashEvidenceMockIsVerifiableByExpectation{
		mock:   mmIsVerifiableBy.mock,
		params: &NodeStateHashEvidenceMockIsVerifiableByParams{v},
	}
	mmIsVerifiableBy.expectations = append(mmIsVerifiableBy.expectations, expectation)
	return expectation
}

// Then sets up NodeStateHashEvidence.IsVerifiableBy return parameters for the expectation previously defined by the When method
func (e *NodeStateHashEvidenceMockIsVerifiableByExpectation) Then(b1 bool) *NodeStateHashEvidenceMock {
	e.results = &NodeStateHashEvidenceMockIsVerifiableByResults{b1}
	return e.mock
}

// IsVerifiableBy implements NodeStateHashEvidence
func (mmIsVerifiableBy *NodeStateHashEvidenceMock) IsVerifiableBy(v cryptkit.SignatureVerifier) (b1 bool) {
	mm_atomic.AddUint64(&mmIsVerifiableBy.beforeIsVerifiableByCounter, 1)
	defer mm_atomic.AddUint64(&mmIsVerifiableBy.afterIsVerifiableByCounter, 1)

	if mmIsVerifiableBy.inspectFuncIsVerifiableBy != nil {
		mmIsVerifiableBy.inspectFuncIsVerifiableBy(v)
	}

	mm_params := &NodeStateHashEvidenceMockIsVerifiableByParams{v}

	// Record call args
	mmIsVerifiableBy.IsVerifiableByMock.mutex.Lock()
	mmIsVerifiableBy.IsVerifiableByMock.callArgs = append(mmIsVerifiableBy.IsVerifiableByMock.callArgs, mm_params)
	mmIsVerifiableBy.IsVerifiableByMock.mutex.Unlock()

	for _, e := range mmIsVerifiableBy.IsVerifiableByMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmIsVerifiableBy.IsVerifiableByMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsVerifiableBy.IsVerifiableByMock.defaultExpectation.Counter, 1)
		mm_want := mmIsVerifiableBy.IsVerifiableByMock.defaultExpectation.params
		mm_got := NodeStateHashEvidenceMockIsVerifiableByParams{v}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsVerifiableBy.t.Errorf("NodeStateHashEvidenceMock.IsVerifiableBy got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsVerifiableBy.IsVerifiableByMock.defaultExpectation.results
		if mm_results == nil {
			mmIsVerifiableBy.t.Fatal("No results are set for the NodeStateHashEvidenceMock.IsVerifiableBy")
		}
		return (*mm_results).b1
	}
	if mmIsVerifiableBy.funcIsVerifiableBy != nil {
		return mmIsVerifiableBy.funcIsVerifiableBy(v)
	}
	mmIsVerifiableBy.t.Fatalf("Unexpected call to NodeStateHashEvidenceMock.IsVerifiableBy. %v", v)
	return
}

// IsVerifiableByAfterCounter returns a count of finished NodeStateHashEvidenceMock.IsVerifiableBy invocations
func (mmIsVerifiableBy *NodeStateHashEvidenceMock) IsVerifiableByAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsVerifiableBy.afterIsVerifiableByCounter)
}

// IsVerifiableByBeforeCounter returns a count of NodeStateHashEvidenceMock.IsVerifiableBy invocations
func (mmIsVerifiableBy *NodeStateHashEvidenceMock) IsVerifiableByBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsVerifiableBy.beforeIsVerifiableByCounter)
}

// Calls returns a list of arguments used in each call to NodeStateHashEvidenceMock.IsVerifiableBy.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsVerifiableBy *mNodeStateHashEvidenceMockIsVerifiableBy) Calls() []*NodeStateHashEvidenceMockIsVerifiableByParams {
	mmIsVerifiableBy.mutex.RLock()

	argCopy := make([]*NodeStateHashEvidenceMockIsVerifiableByParams, len(mmIsVerifiableBy.callArgs))
	copy(argCopy, mmIsVerifiableBy.callArgs)

	mmIsVerifiableBy.mutex.RUnlock()

	return argCopy
}

// MinimockIsVerifiableByDone returns true if the count of the IsVerifiableBy invocations corresponds
// the number of defined expectations
func (m *NodeStateHashEvidenceMock) MinimockIsVerifiableByDone() bool {
	for _, e := range m.IsVerifiableByMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsVerifiableByMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsVerifiableByCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsVerifiableBy != nil && mm_atomic.LoadUint64(&m.afterIsVerifiableByCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsVerifiableByInspect logs each unmet expectation
func (m *NodeStateHashEvidenceMock) MinimockIsVerifiableByInspect() {
	for _, e := range m.IsVerifiableByMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NodeStateHashEvidenceMock.IsVerifiableBy with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsVerifiableByMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsVerifiableByCounter) < 1 {
		if m.IsVerifiableByMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to NodeStateHashEvidenceMock.IsVerifiableBy")
		} else {
			m.t.Errorf("Expected call to NodeStateHashEvidenceMock.IsVerifiableBy with params: %#v", *m.IsVerifiableByMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsVerifiableBy != nil && mm_atomic.LoadUint64(&m.afterIsVerifiableByCounter) < 1 {
		m.t.Error("Expected call to NodeStateHashEvidenceMock.IsVerifiableBy")
	}
}

type mNodeStateHashEvidenceMockVerifyWith struct {
	mock               *NodeStateHashEvidenceMock
	defaultExpectation *NodeStateHashEvidenceMockVerifyWithExpectation
	expectations       []*NodeStateHashEvidenceMockVerifyWithExpectation

	callArgs []*NodeStateHashEvidenceMockVerifyWithParams
	mutex    sync.RWMutex
}

// NodeStateHashEvidenceMockVerifyWithExpectation specifies expectation struct of the NodeStateHashEvidence.VerifyWith
type NodeStateHashEvidenceMockVerifyWithExpectation struct {
	mock    *NodeStateHashEvidenceMock
	params  *NodeStateHashEvidenceMockVerifyWithParams
	results *NodeStateHashEvidenceMockVerifyWithResults
	Counter uint64
}

// NodeStateHashEvidenceMockVerifyWithParams contains parameters of the NodeStateHashEvidence.VerifyWith
type NodeStateHashEvidenceMockVerifyWithParams struct {
	v cryptkit.SignatureVerifier
}

// NodeStateHashEvidenceMockVerifyWithResults contains results of the NodeStateHashEvidence.VerifyWith
type NodeStateHashEvidenceMockVerifyWithResults struct {
	b1 bool
}

// Expect sets up expected params for NodeStateHashEvidence.VerifyWith
func (mmVerifyWith *mNodeStateHashEvidenceMockVerifyWith) Expect(v cryptkit.SignatureVerifier) *mNodeStateHashEvidenceMockVerifyWith {
	if mmVerifyWith.mock.funcVerifyWith != nil {
		mmVerifyWith.mock.t.Fatalf("NodeStateHashEvidenceMock.VerifyWith mock is already set by Set")
	}

	if mmVerifyWith.defaultExpectation == nil {
		mmVerifyWith.defaultExpectation = &NodeStateHashEvidenceMockVerifyWithExpectation{}
	}

	mmVerifyWith.defaultExpectation.params = &NodeStateHashEvidenceMockVerifyWithParams{v}
	for _, e := range mmVerifyWith.expectations {
		if minimock.Equal(e.params, mmVerifyWith.defaultExpectation.params) {
			mmVerifyWith.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmVerifyWith.defaultExpectation.params)
		}
	}

	return mmVerifyWith
}

// Inspect accepts an inspector function that has same arguments as the NodeStateHashEvidence.VerifyWith
func (mmVerifyWith *mNodeStateHashEvidenceMockVerifyWith) Inspect(f func(v cryptkit.SignatureVerifier)) *mNodeStateHashEvidenceMockVerifyWith {
	if mmVerifyWith.mock.inspectFuncVerifyWith != nil {
		mmVerifyWith.mock.t.Fatalf("Inspect function is already set for NodeStateHashEvidenceMock.VerifyWith")
	}

	mmVerifyWith.mock.inspectFuncVerifyWith = f

	return mmVerifyWith
}

// Return sets up results that will be returned by NodeStateHashEvidence.VerifyWith
func (mmVerifyWith *mNodeStateHashEvidenceMockVerifyWith) Return(b1 bool) *NodeStateHashEvidenceMock {
	if mmVerifyWith.mock.funcVerifyWith != nil {
		mmVerifyWith.mock.t.Fatalf("NodeStateHashEvidenceMock.VerifyWith mock is already set by Set")
	}

	if mmVerifyWith.defaultExpectation == nil {
		mmVerifyWith.defaultExpectation = &NodeStateHashEvidenceMockVerifyWithExpectation{mock: mmVerifyWith.mock}
	}
	mmVerifyWith.defaultExpectation.results = &NodeStateHashEvidenceMockVerifyWithResults{b1}
	return mmVerifyWith.mock
}

//Set uses given function f to mock the NodeStateHashEvidence.VerifyWith method
func (mmVerifyWith *mNodeStateHashEvidenceMockVerifyWith) Set(f func(v cryptkit.SignatureVerifier) (b1 bool)) *NodeStateHashEvidenceMock {
	if mmVerifyWith.defaultExpectation != nil {
		mmVerifyWith.mock.t.Fatalf("Default expectation is already set for the NodeStateHashEvidence.VerifyWith method")
	}

	if len(mmVerifyWith.expectations) > 0 {
		mmVerifyWith.mock.t.Fatalf("Some expectations are already set for the NodeStateHashEvidence.VerifyWith method")
	}

	mmVerifyWith.mock.funcVerifyWith = f
	return mmVerifyWith.mock
}

// When sets expectation for the NodeStateHashEvidence.VerifyWith which will trigger the result defined by the following
// Then helper
func (mmVerifyWith *mNodeStateHashEvidenceMockVerifyWith) When(v cryptkit.SignatureVerifier) *NodeStateHashEvidenceMockVerifyWithExpectation {
	if mmVerifyWith.mock.funcVerifyWith != nil {
		mmVerifyWith.mock.t.Fatalf("NodeStateHashEvidenceMock.VerifyWith mock is already set by Set")
	}

	expectation := &NodeStateHashEvidenceMockVerifyWithExpectation{
		mock:   mmVerifyWith.mock,
		params: &NodeStateHashEvidenceMockVerifyWithParams{v},
	}
	mmVerifyWith.expectations = append(mmVerifyWith.expectations, expectation)
	return expectation
}

// Then sets up NodeStateHashEvidence.VerifyWith return parameters for the expectation previously defined by the When method
func (e *NodeStateHashEvidenceMockVerifyWithExpectation) Then(b1 bool) *NodeStateHashEvidenceMock {
	e.results = &NodeStateHashEvidenceMockVerifyWithResults{b1}
	return e.mock
}

// VerifyWith implements NodeStateHashEvidence
func (mmVerifyWith *NodeStateHashEvidenceMock) VerifyWith(v cryptkit.SignatureVerifier) (b1 bool) {
	mm_atomic.AddUint64(&mmVerifyWith.beforeVerifyWithCounter, 1)
	defer mm_atomic.AddUint64(&mmVerifyWith.afterVerifyWithCounter, 1)

	if mmVerifyWith.inspectFuncVerifyWith != nil {
		mmVerifyWith.inspectFuncVerifyWith(v)
	}

	mm_params := &NodeStateHashEvidenceMockVerifyWithParams{v}

	// Record call args
	mmVerifyWith.VerifyWithMock.mutex.Lock()
	mmVerifyWith.VerifyWithMock.callArgs = append(mmVerifyWith.VerifyWithMock.callArgs, mm_params)
	mmVerifyWith.VerifyWithMock.mutex.Unlock()

	for _, e := range mmVerifyWith.VerifyWithMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmVerifyWith.VerifyWithMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmVerifyWith.VerifyWithMock.defaultExpectation.Counter, 1)
		mm_want := mmVerifyWith.VerifyWithMock.defaultExpectation.params
		mm_got := NodeStateHashEvidenceMockVerifyWithParams{v}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmVerifyWith.t.Errorf("NodeStateHashEvidenceMock.VerifyWith got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmVerifyWith.VerifyWithMock.defaultExpectation.results
		if mm_results == nil {
			mmVerifyWith.t.Fatal("No results are set for the NodeStateHashEvidenceMock.VerifyWith")
		}
		return (*mm_results).b1
	}
	if mmVerifyWith.funcVerifyWith != nil {
		return mmVerifyWith.funcVerifyWith(v)
	}
	mmVerifyWith.t.Fatalf("Unexpected call to NodeStateHashEvidenceMock.VerifyWith. %v", v)
	return
}

// VerifyWithAfterCounter returns a count of finished NodeStateHashEvidenceMock.VerifyWith invocations
func (mmVerifyWith *NodeStateHashEvidenceMock) VerifyWithAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmVerifyWith.afterVerifyWithCounter)
}

// VerifyWithBeforeCounter returns a count of NodeStateHashEvidenceMock.VerifyWith invocations
func (mmVerifyWith *NodeStateHashEvidenceMock) VerifyWithBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmVerifyWith.beforeVerifyWithCounter)
}

// Calls returns a list of arguments used in each call to NodeStateHashEvidenceMock.VerifyWith.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmVerifyWith *mNodeStateHashEvidenceMockVerifyWith) Calls() []*NodeStateHashEvidenceMockVerifyWithParams {
	mmVerifyWith.mutex.RLock()

	argCopy := make([]*NodeStateHashEvidenceMockVerifyWithParams, len(mmVerifyWith.callArgs))
	copy(argCopy, mmVerifyWith.callArgs)

	mmVerifyWith.mutex.RUnlock()

	return argCopy
}

// MinimockVerifyWithDone returns true if the count of the VerifyWith invocations corresponds
// the number of defined expectations
func (m *NodeStateHashEvidenceMock) MinimockVerifyWithDone() bool {
	for _, e := range m.VerifyWithMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.VerifyWithMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterVerifyWithCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcVerifyWith != nil && mm_atomic.LoadUint64(&m.afterVerifyWithCounter) < 1 {
		return false
	}
	return true
}

// MinimockVerifyWithInspect logs each unmet expectation
func (m *NodeStateHashEvidenceMock) MinimockVerifyWithInspect() {
	for _, e := range m.VerifyWithMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NodeStateHashEvidenceMock.VerifyWith with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.VerifyWithMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterVerifyWithCounter) < 1 {
		if m.VerifyWithMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to NodeStateHashEvidenceMock.VerifyWith")
		} else {
			m.t.Errorf("Expected call to NodeStateHashEvidenceMock.VerifyWith with params: %#v", *m.VerifyWithMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcVerifyWith != nil && mm_atomic.LoadUint64(&m.afterVerifyWithCounter) < 1 {
		m.t.Error("Expected call to NodeStateHashEvidenceMock.VerifyWith")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *NodeStateHashEvidenceMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCopyOfSignedDigestInspect()

		m.MinimockEqualsInspect()

		m.MinimockGetDigestHolderInspect()

		m.MinimockGetSignatureHolderInspect()

		m.MinimockGetSignatureMethodInspect()

		m.MinimockIsVerifiableByInspect()

		m.MinimockVerifyWithInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *NodeStateHashEvidenceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *NodeStateHashEvidenceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCopyOfSignedDigestDone() &&
		m.MinimockEqualsDone() &&
		m.MinimockGetDigestHolderDone() &&
		m.MinimockGetSignatureHolderDone() &&
		m.MinimockGetSignatureMethodDone() &&
		m.MinimockIsVerifiableByDone() &&
		m.MinimockVerifyWithDone()
}
