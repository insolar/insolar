package proofs

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	io "io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/longbits"
	"github.com/insolar/insolar/network/consensus/common/cryptkit"
)

// GlobulaStateHashMock implements GlobulaStateHash
type GlobulaStateHashMock struct {
	t minimock.Tester

	funcAsByteString          func() (b1 longbits.ByteString)
	inspectFuncAsByteString   func()
	afterAsByteStringCounter  uint64
	beforeAsByteStringCounter uint64
	AsByteStringMock          mGlobulaStateHashMockAsByteString

	funcAsBytes          func() (ba1 []byte)
	inspectFuncAsBytes   func()
	afterAsBytesCounter  uint64
	beforeAsBytesCounter uint64
	AsBytesMock          mGlobulaStateHashMockAsBytes

	funcCopyOfDigest          func() (d1 cryptkit.Digest)
	inspectFuncCopyOfDigest   func()
	afterCopyOfDigestCounter  uint64
	beforeCopyOfDigestCounter uint64
	CopyOfDigestMock          mGlobulaStateHashMockCopyOfDigest

	funcEquals          func(other cryptkit.DigestHolder) (b1 bool)
	inspectFuncEquals   func(other cryptkit.DigestHolder)
	afterEqualsCounter  uint64
	beforeEqualsCounter uint64
	EqualsMock          mGlobulaStateHashMockEquals

	funcFixedByteSize          func() (i1 int)
	inspectFuncFixedByteSize   func()
	afterFixedByteSizeCounter  uint64
	beforeFixedByteSizeCounter uint64
	FixedByteSizeMock          mGlobulaStateHashMockFixedByteSize

	funcFoldToUint64          func() (u1 uint64)
	inspectFuncFoldToUint64   func()
	afterFoldToUint64Counter  uint64
	beforeFoldToUint64Counter uint64
	FoldToUint64Mock          mGlobulaStateHashMockFoldToUint64

	funcGetDigestMethod          func() (d1 cryptkit.DigestMethod)
	inspectFuncGetDigestMethod   func()
	afterGetDigestMethodCounter  uint64
	beforeGetDigestMethodCounter uint64
	GetDigestMethodMock          mGlobulaStateHashMockGetDigestMethod

	funcRead          func(p []byte) (n int, err error)
	inspectFuncRead   func(p []byte)
	afterReadCounter  uint64
	beforeReadCounter uint64
	ReadMock          mGlobulaStateHashMockRead

	funcSignWith          func(signer cryptkit.DigestSigner) (s1 cryptkit.SignedDigestHolder)
	inspectFuncSignWith   func(signer cryptkit.DigestSigner)
	afterSignWithCounter  uint64
	beforeSignWithCounter uint64
	SignWithMock          mGlobulaStateHashMockSignWith

	funcWriteTo          func(w io.Writer) (n int64, err error)
	inspectFuncWriteTo   func(w io.Writer)
	afterWriteToCounter  uint64
	beforeWriteToCounter uint64
	WriteToMock          mGlobulaStateHashMockWriteTo
}

// NewGlobulaStateHashMock returns a mock for GlobulaStateHash
func NewGlobulaStateHashMock(t minimock.Tester) *GlobulaStateHashMock {
	m := &GlobulaStateHashMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AsByteStringMock = mGlobulaStateHashMockAsByteString{mock: m}

	m.AsBytesMock = mGlobulaStateHashMockAsBytes{mock: m}

	m.CopyOfDigestMock = mGlobulaStateHashMockCopyOfDigest{mock: m}

	m.EqualsMock = mGlobulaStateHashMockEquals{mock: m}
	m.EqualsMock.callArgs = []*GlobulaStateHashMockEqualsParams{}

	m.FixedByteSizeMock = mGlobulaStateHashMockFixedByteSize{mock: m}

	m.FoldToUint64Mock = mGlobulaStateHashMockFoldToUint64{mock: m}

	m.GetDigestMethodMock = mGlobulaStateHashMockGetDigestMethod{mock: m}

	m.ReadMock = mGlobulaStateHashMockRead{mock: m}
	m.ReadMock.callArgs = []*GlobulaStateHashMockReadParams{}

	m.SignWithMock = mGlobulaStateHashMockSignWith{mock: m}
	m.SignWithMock.callArgs = []*GlobulaStateHashMockSignWithParams{}

	m.WriteToMock = mGlobulaStateHashMockWriteTo{mock: m}
	m.WriteToMock.callArgs = []*GlobulaStateHashMockWriteToParams{}

	return m
}

type mGlobulaStateHashMockAsByteString struct {
	mock               *GlobulaStateHashMock
	defaultExpectation *GlobulaStateHashMockAsByteStringExpectation
	expectations       []*GlobulaStateHashMockAsByteStringExpectation
}

// GlobulaStateHashMockAsByteStringExpectation specifies expectation struct of the GlobulaStateHash.AsByteString
type GlobulaStateHashMockAsByteStringExpectation struct {
	mock *GlobulaStateHashMock

	results *GlobulaStateHashMockAsByteStringResults
	Counter uint64
}

// GlobulaStateHashMockAsByteStringResults contains results of the GlobulaStateHash.AsByteString
type GlobulaStateHashMockAsByteStringResults struct {
	b1 longbits.ByteString
}

// Expect sets up expected params for GlobulaStateHash.AsByteString
func (mmAsByteString *mGlobulaStateHashMockAsByteString) Expect() *mGlobulaStateHashMockAsByteString {
	if mmAsByteString.mock.funcAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("GlobulaStateHashMock.AsByteString mock is already set by Set")
	}

	if mmAsByteString.defaultExpectation == nil {
		mmAsByteString.defaultExpectation = &GlobulaStateHashMockAsByteStringExpectation{}
	}

	return mmAsByteString
}

// Inspect accepts an inspector function that has same arguments as the GlobulaStateHash.AsByteString
func (mmAsByteString *mGlobulaStateHashMockAsByteString) Inspect(f func()) *mGlobulaStateHashMockAsByteString {
	if mmAsByteString.mock.inspectFuncAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("Inspect function is already set for GlobulaStateHashMock.AsByteString")
	}

	mmAsByteString.mock.inspectFuncAsByteString = f

	return mmAsByteString
}

// Return sets up results that will be returned by GlobulaStateHash.AsByteString
func (mmAsByteString *mGlobulaStateHashMockAsByteString) Return(b1 longbits.ByteString) *GlobulaStateHashMock {
	if mmAsByteString.mock.funcAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("GlobulaStateHashMock.AsByteString mock is already set by Set")
	}

	if mmAsByteString.defaultExpectation == nil {
		mmAsByteString.defaultExpectation = &GlobulaStateHashMockAsByteStringExpectation{mock: mmAsByteString.mock}
	}
	mmAsByteString.defaultExpectation.results = &GlobulaStateHashMockAsByteStringResults{b1}
	return mmAsByteString.mock
}

//Set uses given function f to mock the GlobulaStateHash.AsByteString method
func (mmAsByteString *mGlobulaStateHashMockAsByteString) Set(f func() (b1 longbits.ByteString)) *GlobulaStateHashMock {
	if mmAsByteString.defaultExpectation != nil {
		mmAsByteString.mock.t.Fatalf("Default expectation is already set for the GlobulaStateHash.AsByteString method")
	}

	if len(mmAsByteString.expectations) > 0 {
		mmAsByteString.mock.t.Fatalf("Some expectations are already set for the GlobulaStateHash.AsByteString method")
	}

	mmAsByteString.mock.funcAsByteString = f
	return mmAsByteString.mock
}

// AsByteString implements GlobulaStateHash
func (mmAsByteString *GlobulaStateHashMock) AsByteString() (b1 longbits.ByteString) {
	mm_atomic.AddUint64(&mmAsByteString.beforeAsByteStringCounter, 1)
	defer mm_atomic.AddUint64(&mmAsByteString.afterAsByteStringCounter, 1)

	if mmAsByteString.inspectFuncAsByteString != nil {
		mmAsByteString.inspectFuncAsByteString()
	}

	if mmAsByteString.AsByteStringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAsByteString.AsByteStringMock.defaultExpectation.Counter, 1)

		results := mmAsByteString.AsByteStringMock.defaultExpectation.results
		if results == nil {
			mmAsByteString.t.Fatal("No results are set for the GlobulaStateHashMock.AsByteString")
		}
		return (*results).b1
	}
	if mmAsByteString.funcAsByteString != nil {
		return mmAsByteString.funcAsByteString()
	}
	mmAsByteString.t.Fatalf("Unexpected call to GlobulaStateHashMock.AsByteString.")
	return
}

// AsByteStringAfterCounter returns a count of finished GlobulaStateHashMock.AsByteString invocations
func (mmAsByteString *GlobulaStateHashMock) AsByteStringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsByteString.afterAsByteStringCounter)
}

// AsByteStringBeforeCounter returns a count of GlobulaStateHashMock.AsByteString invocations
func (mmAsByteString *GlobulaStateHashMock) AsByteStringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsByteString.beforeAsByteStringCounter)
}

// MinimockAsByteStringDone returns true if the count of the AsByteString invocations corresponds
// the number of defined expectations
func (m *GlobulaStateHashMock) MinimockAsByteStringDone() bool {
	for _, e := range m.AsByteStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsByteStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsByteString != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		return false
	}
	return true
}

// MinimockAsByteStringInspect logs each unmet expectation
func (m *GlobulaStateHashMock) MinimockAsByteStringInspect() {
	for _, e := range m.AsByteStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to GlobulaStateHashMock.AsByteString")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsByteStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		m.t.Error("Expected call to GlobulaStateHashMock.AsByteString")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsByteString != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		m.t.Error("Expected call to GlobulaStateHashMock.AsByteString")
	}
}

type mGlobulaStateHashMockAsBytes struct {
	mock               *GlobulaStateHashMock
	defaultExpectation *GlobulaStateHashMockAsBytesExpectation
	expectations       []*GlobulaStateHashMockAsBytesExpectation
}

// GlobulaStateHashMockAsBytesExpectation specifies expectation struct of the GlobulaStateHash.AsBytes
type GlobulaStateHashMockAsBytesExpectation struct {
	mock *GlobulaStateHashMock

	results *GlobulaStateHashMockAsBytesResults
	Counter uint64
}

// GlobulaStateHashMockAsBytesResults contains results of the GlobulaStateHash.AsBytes
type GlobulaStateHashMockAsBytesResults struct {
	ba1 []byte
}

// Expect sets up expected params for GlobulaStateHash.AsBytes
func (mmAsBytes *mGlobulaStateHashMockAsBytes) Expect() *mGlobulaStateHashMockAsBytes {
	if mmAsBytes.mock.funcAsBytes != nil {
		mmAsBytes.mock.t.Fatalf("GlobulaStateHashMock.AsBytes mock is already set by Set")
	}

	if mmAsBytes.defaultExpectation == nil {
		mmAsBytes.defaultExpectation = &GlobulaStateHashMockAsBytesExpectation{}
	}

	return mmAsBytes
}

// Inspect accepts an inspector function that has same arguments as the GlobulaStateHash.AsBytes
func (mmAsBytes *mGlobulaStateHashMockAsBytes) Inspect(f func()) *mGlobulaStateHashMockAsBytes {
	if mmAsBytes.mock.inspectFuncAsBytes != nil {
		mmAsBytes.mock.t.Fatalf("Inspect function is already set for GlobulaStateHashMock.AsBytes")
	}

	mmAsBytes.mock.inspectFuncAsBytes = f

	return mmAsBytes
}

// Return sets up results that will be returned by GlobulaStateHash.AsBytes
func (mmAsBytes *mGlobulaStateHashMockAsBytes) Return(ba1 []byte) *GlobulaStateHashMock {
	if mmAsBytes.mock.funcAsBytes != nil {
		mmAsBytes.mock.t.Fatalf("GlobulaStateHashMock.AsBytes mock is already set by Set")
	}

	if mmAsBytes.defaultExpectation == nil {
		mmAsBytes.defaultExpectation = &GlobulaStateHashMockAsBytesExpectation{mock: mmAsBytes.mock}
	}
	mmAsBytes.defaultExpectation.results = &GlobulaStateHashMockAsBytesResults{ba1}
	return mmAsBytes.mock
}

//Set uses given function f to mock the GlobulaStateHash.AsBytes method
func (mmAsBytes *mGlobulaStateHashMockAsBytes) Set(f func() (ba1 []byte)) *GlobulaStateHashMock {
	if mmAsBytes.defaultExpectation != nil {
		mmAsBytes.mock.t.Fatalf("Default expectation is already set for the GlobulaStateHash.AsBytes method")
	}

	if len(mmAsBytes.expectations) > 0 {
		mmAsBytes.mock.t.Fatalf("Some expectations are already set for the GlobulaStateHash.AsBytes method")
	}

	mmAsBytes.mock.funcAsBytes = f
	return mmAsBytes.mock
}

// AsBytes implements GlobulaStateHash
func (mmAsBytes *GlobulaStateHashMock) AsBytes() (ba1 []byte) {
	mm_atomic.AddUint64(&mmAsBytes.beforeAsBytesCounter, 1)
	defer mm_atomic.AddUint64(&mmAsBytes.afterAsBytesCounter, 1)

	if mmAsBytes.inspectFuncAsBytes != nil {
		mmAsBytes.inspectFuncAsBytes()
	}

	if mmAsBytes.AsBytesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAsBytes.AsBytesMock.defaultExpectation.Counter, 1)

		results := mmAsBytes.AsBytesMock.defaultExpectation.results
		if results == nil {
			mmAsBytes.t.Fatal("No results are set for the GlobulaStateHashMock.AsBytes")
		}
		return (*results).ba1
	}
	if mmAsBytes.funcAsBytes != nil {
		return mmAsBytes.funcAsBytes()
	}
	mmAsBytes.t.Fatalf("Unexpected call to GlobulaStateHashMock.AsBytes.")
	return
}

// AsBytesAfterCounter returns a count of finished GlobulaStateHashMock.AsBytes invocations
func (mmAsBytes *GlobulaStateHashMock) AsBytesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsBytes.afterAsBytesCounter)
}

// AsBytesBeforeCounter returns a count of GlobulaStateHashMock.AsBytes invocations
func (mmAsBytes *GlobulaStateHashMock) AsBytesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsBytes.beforeAsBytesCounter)
}

// MinimockAsBytesDone returns true if the count of the AsBytes invocations corresponds
// the number of defined expectations
func (m *GlobulaStateHashMock) MinimockAsBytesDone() bool {
	for _, e := range m.AsBytesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsBytesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsBytesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsBytes != nil && mm_atomic.LoadUint64(&m.afterAsBytesCounter) < 1 {
		return false
	}
	return true
}

// MinimockAsBytesInspect logs each unmet expectation
func (m *GlobulaStateHashMock) MinimockAsBytesInspect() {
	for _, e := range m.AsBytesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to GlobulaStateHashMock.AsBytes")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsBytesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsBytesCounter) < 1 {
		m.t.Error("Expected call to GlobulaStateHashMock.AsBytes")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsBytes != nil && mm_atomic.LoadUint64(&m.afterAsBytesCounter) < 1 {
		m.t.Error("Expected call to GlobulaStateHashMock.AsBytes")
	}
}

type mGlobulaStateHashMockCopyOfDigest struct {
	mock               *GlobulaStateHashMock
	defaultExpectation *GlobulaStateHashMockCopyOfDigestExpectation
	expectations       []*GlobulaStateHashMockCopyOfDigestExpectation
}

// GlobulaStateHashMockCopyOfDigestExpectation specifies expectation struct of the GlobulaStateHash.CopyOfDigest
type GlobulaStateHashMockCopyOfDigestExpectation struct {
	mock *GlobulaStateHashMock

	results *GlobulaStateHashMockCopyOfDigestResults
	Counter uint64
}

// GlobulaStateHashMockCopyOfDigestResults contains results of the GlobulaStateHash.CopyOfDigest
type GlobulaStateHashMockCopyOfDigestResults struct {
	d1 cryptkit.Digest
}

// Expect sets up expected params for GlobulaStateHash.CopyOfDigest
func (mmCopyOfDigest *mGlobulaStateHashMockCopyOfDigest) Expect() *mGlobulaStateHashMockCopyOfDigest {
	if mmCopyOfDigest.mock.funcCopyOfDigest != nil {
		mmCopyOfDigest.mock.t.Fatalf("GlobulaStateHashMock.CopyOfDigest mock is already set by Set")
	}

	if mmCopyOfDigest.defaultExpectation == nil {
		mmCopyOfDigest.defaultExpectation = &GlobulaStateHashMockCopyOfDigestExpectation{}
	}

	return mmCopyOfDigest
}

// Inspect accepts an inspector function that has same arguments as the GlobulaStateHash.CopyOfDigest
func (mmCopyOfDigest *mGlobulaStateHashMockCopyOfDigest) Inspect(f func()) *mGlobulaStateHashMockCopyOfDigest {
	if mmCopyOfDigest.mock.inspectFuncCopyOfDigest != nil {
		mmCopyOfDigest.mock.t.Fatalf("Inspect function is already set for GlobulaStateHashMock.CopyOfDigest")
	}

	mmCopyOfDigest.mock.inspectFuncCopyOfDigest = f

	return mmCopyOfDigest
}

// Return sets up results that will be returned by GlobulaStateHash.CopyOfDigest
func (mmCopyOfDigest *mGlobulaStateHashMockCopyOfDigest) Return(d1 cryptkit.Digest) *GlobulaStateHashMock {
	if mmCopyOfDigest.mock.funcCopyOfDigest != nil {
		mmCopyOfDigest.mock.t.Fatalf("GlobulaStateHashMock.CopyOfDigest mock is already set by Set")
	}

	if mmCopyOfDigest.defaultExpectation == nil {
		mmCopyOfDigest.defaultExpectation = &GlobulaStateHashMockCopyOfDigestExpectation{mock: mmCopyOfDigest.mock}
	}
	mmCopyOfDigest.defaultExpectation.results = &GlobulaStateHashMockCopyOfDigestResults{d1}
	return mmCopyOfDigest.mock
}

//Set uses given function f to mock the GlobulaStateHash.CopyOfDigest method
func (mmCopyOfDigest *mGlobulaStateHashMockCopyOfDigest) Set(f func() (d1 cryptkit.Digest)) *GlobulaStateHashMock {
	if mmCopyOfDigest.defaultExpectation != nil {
		mmCopyOfDigest.mock.t.Fatalf("Default expectation is already set for the GlobulaStateHash.CopyOfDigest method")
	}

	if len(mmCopyOfDigest.expectations) > 0 {
		mmCopyOfDigest.mock.t.Fatalf("Some expectations are already set for the GlobulaStateHash.CopyOfDigest method")
	}

	mmCopyOfDigest.mock.funcCopyOfDigest = f
	return mmCopyOfDigest.mock
}

// CopyOfDigest implements GlobulaStateHash
func (mmCopyOfDigest *GlobulaStateHashMock) CopyOfDigest() (d1 cryptkit.Digest) {
	mm_atomic.AddUint64(&mmCopyOfDigest.beforeCopyOfDigestCounter, 1)
	defer mm_atomic.AddUint64(&mmCopyOfDigest.afterCopyOfDigestCounter, 1)

	if mmCopyOfDigest.inspectFuncCopyOfDigest != nil {
		mmCopyOfDigest.inspectFuncCopyOfDigest()
	}

	if mmCopyOfDigest.CopyOfDigestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCopyOfDigest.CopyOfDigestMock.defaultExpectation.Counter, 1)

		results := mmCopyOfDigest.CopyOfDigestMock.defaultExpectation.results
		if results == nil {
			mmCopyOfDigest.t.Fatal("No results are set for the GlobulaStateHashMock.CopyOfDigest")
		}
		return (*results).d1
	}
	if mmCopyOfDigest.funcCopyOfDigest != nil {
		return mmCopyOfDigest.funcCopyOfDigest()
	}
	mmCopyOfDigest.t.Fatalf("Unexpected call to GlobulaStateHashMock.CopyOfDigest.")
	return
}

// CopyOfDigestAfterCounter returns a count of finished GlobulaStateHashMock.CopyOfDigest invocations
func (mmCopyOfDigest *GlobulaStateHashMock) CopyOfDigestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyOfDigest.afterCopyOfDigestCounter)
}

// CopyOfDigestBeforeCounter returns a count of GlobulaStateHashMock.CopyOfDigest invocations
func (mmCopyOfDigest *GlobulaStateHashMock) CopyOfDigestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyOfDigest.beforeCopyOfDigestCounter)
}

// MinimockCopyOfDigestDone returns true if the count of the CopyOfDigest invocations corresponds
// the number of defined expectations
func (m *GlobulaStateHashMock) MinimockCopyOfDigestDone() bool {
	for _, e := range m.CopyOfDigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyOfDigestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyOfDigestCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyOfDigest != nil && mm_atomic.LoadUint64(&m.afterCopyOfDigestCounter) < 1 {
		return false
	}
	return true
}

// MinimockCopyOfDigestInspect logs each unmet expectation
func (m *GlobulaStateHashMock) MinimockCopyOfDigestInspect() {
	for _, e := range m.CopyOfDigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to GlobulaStateHashMock.CopyOfDigest")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyOfDigestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyOfDigestCounter) < 1 {
		m.t.Error("Expected call to GlobulaStateHashMock.CopyOfDigest")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyOfDigest != nil && mm_atomic.LoadUint64(&m.afterCopyOfDigestCounter) < 1 {
		m.t.Error("Expected call to GlobulaStateHashMock.CopyOfDigest")
	}
}

type mGlobulaStateHashMockEquals struct {
	mock               *GlobulaStateHashMock
	defaultExpectation *GlobulaStateHashMockEqualsExpectation
	expectations       []*GlobulaStateHashMockEqualsExpectation

	callArgs []*GlobulaStateHashMockEqualsParams
	mutex    sync.RWMutex
}

// GlobulaStateHashMockEqualsExpectation specifies expectation struct of the GlobulaStateHash.Equals
type GlobulaStateHashMockEqualsExpectation struct {
	mock    *GlobulaStateHashMock
	params  *GlobulaStateHashMockEqualsParams
	results *GlobulaStateHashMockEqualsResults
	Counter uint64
}

// GlobulaStateHashMockEqualsParams contains parameters of the GlobulaStateHash.Equals
type GlobulaStateHashMockEqualsParams struct {
	other cryptkit.DigestHolder
}

// GlobulaStateHashMockEqualsResults contains results of the GlobulaStateHash.Equals
type GlobulaStateHashMockEqualsResults struct {
	b1 bool
}

// Expect sets up expected params for GlobulaStateHash.Equals
func (mmEquals *mGlobulaStateHashMockEquals) Expect(other cryptkit.DigestHolder) *mGlobulaStateHashMockEquals {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("GlobulaStateHashMock.Equals mock is already set by Set")
	}

	if mmEquals.defaultExpectation == nil {
		mmEquals.defaultExpectation = &GlobulaStateHashMockEqualsExpectation{}
	}

	mmEquals.defaultExpectation.params = &GlobulaStateHashMockEqualsParams{other}
	for _, e := range mmEquals.expectations {
		if minimock.Equal(e.params, mmEquals.defaultExpectation.params) {
			mmEquals.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEquals.defaultExpectation.params)
		}
	}

	return mmEquals
}

// Inspect accepts an inspector function that has same arguments as the GlobulaStateHash.Equals
func (mmEquals *mGlobulaStateHashMockEquals) Inspect(f func(other cryptkit.DigestHolder)) *mGlobulaStateHashMockEquals {
	if mmEquals.mock.inspectFuncEquals != nil {
		mmEquals.mock.t.Fatalf("Inspect function is already set for GlobulaStateHashMock.Equals")
	}

	mmEquals.mock.inspectFuncEquals = f

	return mmEquals
}

// Return sets up results that will be returned by GlobulaStateHash.Equals
func (mmEquals *mGlobulaStateHashMockEquals) Return(b1 bool) *GlobulaStateHashMock {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("GlobulaStateHashMock.Equals mock is already set by Set")
	}

	if mmEquals.defaultExpectation == nil {
		mmEquals.defaultExpectation = &GlobulaStateHashMockEqualsExpectation{mock: mmEquals.mock}
	}
	mmEquals.defaultExpectation.results = &GlobulaStateHashMockEqualsResults{b1}
	return mmEquals.mock
}

//Set uses given function f to mock the GlobulaStateHash.Equals method
func (mmEquals *mGlobulaStateHashMockEquals) Set(f func(other cryptkit.DigestHolder) (b1 bool)) *GlobulaStateHashMock {
	if mmEquals.defaultExpectation != nil {
		mmEquals.mock.t.Fatalf("Default expectation is already set for the GlobulaStateHash.Equals method")
	}

	if len(mmEquals.expectations) > 0 {
		mmEquals.mock.t.Fatalf("Some expectations are already set for the GlobulaStateHash.Equals method")
	}

	mmEquals.mock.funcEquals = f
	return mmEquals.mock
}

// When sets expectation for the GlobulaStateHash.Equals which will trigger the result defined by the following
// Then helper
func (mmEquals *mGlobulaStateHashMockEquals) When(other cryptkit.DigestHolder) *GlobulaStateHashMockEqualsExpectation {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("GlobulaStateHashMock.Equals mock is already set by Set")
	}

	expectation := &GlobulaStateHashMockEqualsExpectation{
		mock:   mmEquals.mock,
		params: &GlobulaStateHashMockEqualsParams{other},
	}
	mmEquals.expectations = append(mmEquals.expectations, expectation)
	return expectation
}

// Then sets up GlobulaStateHash.Equals return parameters for the expectation previously defined by the When method
func (e *GlobulaStateHashMockEqualsExpectation) Then(b1 bool) *GlobulaStateHashMock {
	e.results = &GlobulaStateHashMockEqualsResults{b1}
	return e.mock
}

// Equals implements GlobulaStateHash
func (mmEquals *GlobulaStateHashMock) Equals(other cryptkit.DigestHolder) (b1 bool) {
	mm_atomic.AddUint64(&mmEquals.beforeEqualsCounter, 1)
	defer mm_atomic.AddUint64(&mmEquals.afterEqualsCounter, 1)

	if mmEquals.inspectFuncEquals != nil {
		mmEquals.inspectFuncEquals(other)
	}

	params := &GlobulaStateHashMockEqualsParams{other}

	// Record call args
	mmEquals.EqualsMock.mutex.Lock()
	mmEquals.EqualsMock.callArgs = append(mmEquals.EqualsMock.callArgs, params)
	mmEquals.EqualsMock.mutex.Unlock()

	for _, e := range mmEquals.EqualsMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmEquals.EqualsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEquals.EqualsMock.defaultExpectation.Counter, 1)
		want := mmEquals.EqualsMock.defaultExpectation.params
		got := GlobulaStateHashMockEqualsParams{other}
		if want != nil && !minimock.Equal(*want, got) {
			mmEquals.t.Errorf("GlobulaStateHashMock.Equals got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmEquals.EqualsMock.defaultExpectation.results
		if results == nil {
			mmEquals.t.Fatal("No results are set for the GlobulaStateHashMock.Equals")
		}
		return (*results).b1
	}
	if mmEquals.funcEquals != nil {
		return mmEquals.funcEquals(other)
	}
	mmEquals.t.Fatalf("Unexpected call to GlobulaStateHashMock.Equals. %v", other)
	return
}

// EqualsAfterCounter returns a count of finished GlobulaStateHashMock.Equals invocations
func (mmEquals *GlobulaStateHashMock) EqualsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEquals.afterEqualsCounter)
}

// EqualsBeforeCounter returns a count of GlobulaStateHashMock.Equals invocations
func (mmEquals *GlobulaStateHashMock) EqualsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEquals.beforeEqualsCounter)
}

// Calls returns a list of arguments used in each call to GlobulaStateHashMock.Equals.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEquals *mGlobulaStateHashMockEquals) Calls() []*GlobulaStateHashMockEqualsParams {
	mmEquals.mutex.RLock()

	argCopy := make([]*GlobulaStateHashMockEqualsParams, len(mmEquals.callArgs))
	copy(argCopy, mmEquals.callArgs)

	mmEquals.mutex.RUnlock()

	return argCopy
}

// MinimockEqualsDone returns true if the count of the Equals invocations corresponds
// the number of defined expectations
func (m *GlobulaStateHashMock) MinimockEqualsDone() bool {
	for _, e := range m.EqualsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EqualsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEquals != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		return false
	}
	return true
}

// MinimockEqualsInspect logs each unmet expectation
func (m *GlobulaStateHashMock) MinimockEqualsInspect() {
	for _, e := range m.EqualsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GlobulaStateHashMock.Equals with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EqualsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		if m.EqualsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GlobulaStateHashMock.Equals")
		} else {
			m.t.Errorf("Expected call to GlobulaStateHashMock.Equals with params: %#v", *m.EqualsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEquals != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		m.t.Error("Expected call to GlobulaStateHashMock.Equals")
	}
}

type mGlobulaStateHashMockFixedByteSize struct {
	mock               *GlobulaStateHashMock
	defaultExpectation *GlobulaStateHashMockFixedByteSizeExpectation
	expectations       []*GlobulaStateHashMockFixedByteSizeExpectation
}

// GlobulaStateHashMockFixedByteSizeExpectation specifies expectation struct of the GlobulaStateHash.FixedByteSize
type GlobulaStateHashMockFixedByteSizeExpectation struct {
	mock *GlobulaStateHashMock

	results *GlobulaStateHashMockFixedByteSizeResults
	Counter uint64
}

// GlobulaStateHashMockFixedByteSizeResults contains results of the GlobulaStateHash.FixedByteSize
type GlobulaStateHashMockFixedByteSizeResults struct {
	i1 int
}

// Expect sets up expected params for GlobulaStateHash.FixedByteSize
func (mmFixedByteSize *mGlobulaStateHashMockFixedByteSize) Expect() *mGlobulaStateHashMockFixedByteSize {
	if mmFixedByteSize.mock.funcFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("GlobulaStateHashMock.FixedByteSize mock is already set by Set")
	}

	if mmFixedByteSize.defaultExpectation == nil {
		mmFixedByteSize.defaultExpectation = &GlobulaStateHashMockFixedByteSizeExpectation{}
	}

	return mmFixedByteSize
}

// Inspect accepts an inspector function that has same arguments as the GlobulaStateHash.FixedByteSize
func (mmFixedByteSize *mGlobulaStateHashMockFixedByteSize) Inspect(f func()) *mGlobulaStateHashMockFixedByteSize {
	if mmFixedByteSize.mock.inspectFuncFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("Inspect function is already set for GlobulaStateHashMock.FixedByteSize")
	}

	mmFixedByteSize.mock.inspectFuncFixedByteSize = f

	return mmFixedByteSize
}

// Return sets up results that will be returned by GlobulaStateHash.FixedByteSize
func (mmFixedByteSize *mGlobulaStateHashMockFixedByteSize) Return(i1 int) *GlobulaStateHashMock {
	if mmFixedByteSize.mock.funcFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("GlobulaStateHashMock.FixedByteSize mock is already set by Set")
	}

	if mmFixedByteSize.defaultExpectation == nil {
		mmFixedByteSize.defaultExpectation = &GlobulaStateHashMockFixedByteSizeExpectation{mock: mmFixedByteSize.mock}
	}
	mmFixedByteSize.defaultExpectation.results = &GlobulaStateHashMockFixedByteSizeResults{i1}
	return mmFixedByteSize.mock
}

//Set uses given function f to mock the GlobulaStateHash.FixedByteSize method
func (mmFixedByteSize *mGlobulaStateHashMockFixedByteSize) Set(f func() (i1 int)) *GlobulaStateHashMock {
	if mmFixedByteSize.defaultExpectation != nil {
		mmFixedByteSize.mock.t.Fatalf("Default expectation is already set for the GlobulaStateHash.FixedByteSize method")
	}

	if len(mmFixedByteSize.expectations) > 0 {
		mmFixedByteSize.mock.t.Fatalf("Some expectations are already set for the GlobulaStateHash.FixedByteSize method")
	}

	mmFixedByteSize.mock.funcFixedByteSize = f
	return mmFixedByteSize.mock
}

// FixedByteSize implements GlobulaStateHash
func (mmFixedByteSize *GlobulaStateHashMock) FixedByteSize() (i1 int) {
	mm_atomic.AddUint64(&mmFixedByteSize.beforeFixedByteSizeCounter, 1)
	defer mm_atomic.AddUint64(&mmFixedByteSize.afterFixedByteSizeCounter, 1)

	if mmFixedByteSize.inspectFuncFixedByteSize != nil {
		mmFixedByteSize.inspectFuncFixedByteSize()
	}

	if mmFixedByteSize.FixedByteSizeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFixedByteSize.FixedByteSizeMock.defaultExpectation.Counter, 1)

		results := mmFixedByteSize.FixedByteSizeMock.defaultExpectation.results
		if results == nil {
			mmFixedByteSize.t.Fatal("No results are set for the GlobulaStateHashMock.FixedByteSize")
		}
		return (*results).i1
	}
	if mmFixedByteSize.funcFixedByteSize != nil {
		return mmFixedByteSize.funcFixedByteSize()
	}
	mmFixedByteSize.t.Fatalf("Unexpected call to GlobulaStateHashMock.FixedByteSize.")
	return
}

// FixedByteSizeAfterCounter returns a count of finished GlobulaStateHashMock.FixedByteSize invocations
func (mmFixedByteSize *GlobulaStateHashMock) FixedByteSizeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFixedByteSize.afterFixedByteSizeCounter)
}

// FixedByteSizeBeforeCounter returns a count of GlobulaStateHashMock.FixedByteSize invocations
func (mmFixedByteSize *GlobulaStateHashMock) FixedByteSizeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFixedByteSize.beforeFixedByteSizeCounter)
}

// MinimockFixedByteSizeDone returns true if the count of the FixedByteSize invocations corresponds
// the number of defined expectations
func (m *GlobulaStateHashMock) MinimockFixedByteSizeDone() bool {
	for _, e := range m.FixedByteSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FixedByteSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFixedByteSize != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		return false
	}
	return true
}

// MinimockFixedByteSizeInspect logs each unmet expectation
func (m *GlobulaStateHashMock) MinimockFixedByteSizeInspect() {
	for _, e := range m.FixedByteSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to GlobulaStateHashMock.FixedByteSize")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FixedByteSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		m.t.Error("Expected call to GlobulaStateHashMock.FixedByteSize")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFixedByteSize != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		m.t.Error("Expected call to GlobulaStateHashMock.FixedByteSize")
	}
}

type mGlobulaStateHashMockFoldToUint64 struct {
	mock               *GlobulaStateHashMock
	defaultExpectation *GlobulaStateHashMockFoldToUint64Expectation
	expectations       []*GlobulaStateHashMockFoldToUint64Expectation
}

// GlobulaStateHashMockFoldToUint64Expectation specifies expectation struct of the GlobulaStateHash.FoldToUint64
type GlobulaStateHashMockFoldToUint64Expectation struct {
	mock *GlobulaStateHashMock

	results *GlobulaStateHashMockFoldToUint64Results
	Counter uint64
}

// GlobulaStateHashMockFoldToUint64Results contains results of the GlobulaStateHash.FoldToUint64
type GlobulaStateHashMockFoldToUint64Results struct {
	u1 uint64
}

// Expect sets up expected params for GlobulaStateHash.FoldToUint64
func (mmFoldToUint64 *mGlobulaStateHashMockFoldToUint64) Expect() *mGlobulaStateHashMockFoldToUint64 {
	if mmFoldToUint64.mock.funcFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("GlobulaStateHashMock.FoldToUint64 mock is already set by Set")
	}

	if mmFoldToUint64.defaultExpectation == nil {
		mmFoldToUint64.defaultExpectation = &GlobulaStateHashMockFoldToUint64Expectation{}
	}

	return mmFoldToUint64
}

// Inspect accepts an inspector function that has same arguments as the GlobulaStateHash.FoldToUint64
func (mmFoldToUint64 *mGlobulaStateHashMockFoldToUint64) Inspect(f func()) *mGlobulaStateHashMockFoldToUint64 {
	if mmFoldToUint64.mock.inspectFuncFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("Inspect function is already set for GlobulaStateHashMock.FoldToUint64")
	}

	mmFoldToUint64.mock.inspectFuncFoldToUint64 = f

	return mmFoldToUint64
}

// Return sets up results that will be returned by GlobulaStateHash.FoldToUint64
func (mmFoldToUint64 *mGlobulaStateHashMockFoldToUint64) Return(u1 uint64) *GlobulaStateHashMock {
	if mmFoldToUint64.mock.funcFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("GlobulaStateHashMock.FoldToUint64 mock is already set by Set")
	}

	if mmFoldToUint64.defaultExpectation == nil {
		mmFoldToUint64.defaultExpectation = &GlobulaStateHashMockFoldToUint64Expectation{mock: mmFoldToUint64.mock}
	}
	mmFoldToUint64.defaultExpectation.results = &GlobulaStateHashMockFoldToUint64Results{u1}
	return mmFoldToUint64.mock
}

//Set uses given function f to mock the GlobulaStateHash.FoldToUint64 method
func (mmFoldToUint64 *mGlobulaStateHashMockFoldToUint64) Set(f func() (u1 uint64)) *GlobulaStateHashMock {
	if mmFoldToUint64.defaultExpectation != nil {
		mmFoldToUint64.mock.t.Fatalf("Default expectation is already set for the GlobulaStateHash.FoldToUint64 method")
	}

	if len(mmFoldToUint64.expectations) > 0 {
		mmFoldToUint64.mock.t.Fatalf("Some expectations are already set for the GlobulaStateHash.FoldToUint64 method")
	}

	mmFoldToUint64.mock.funcFoldToUint64 = f
	return mmFoldToUint64.mock
}

// FoldToUint64 implements GlobulaStateHash
func (mmFoldToUint64 *GlobulaStateHashMock) FoldToUint64() (u1 uint64) {
	mm_atomic.AddUint64(&mmFoldToUint64.beforeFoldToUint64Counter, 1)
	defer mm_atomic.AddUint64(&mmFoldToUint64.afterFoldToUint64Counter, 1)

	if mmFoldToUint64.inspectFuncFoldToUint64 != nil {
		mmFoldToUint64.inspectFuncFoldToUint64()
	}

	if mmFoldToUint64.FoldToUint64Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFoldToUint64.FoldToUint64Mock.defaultExpectation.Counter, 1)

		results := mmFoldToUint64.FoldToUint64Mock.defaultExpectation.results
		if results == nil {
			mmFoldToUint64.t.Fatal("No results are set for the GlobulaStateHashMock.FoldToUint64")
		}
		return (*results).u1
	}
	if mmFoldToUint64.funcFoldToUint64 != nil {
		return mmFoldToUint64.funcFoldToUint64()
	}
	mmFoldToUint64.t.Fatalf("Unexpected call to GlobulaStateHashMock.FoldToUint64.")
	return
}

// FoldToUint64AfterCounter returns a count of finished GlobulaStateHashMock.FoldToUint64 invocations
func (mmFoldToUint64 *GlobulaStateHashMock) FoldToUint64AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFoldToUint64.afterFoldToUint64Counter)
}

// FoldToUint64BeforeCounter returns a count of GlobulaStateHashMock.FoldToUint64 invocations
func (mmFoldToUint64 *GlobulaStateHashMock) FoldToUint64BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFoldToUint64.beforeFoldToUint64Counter)
}

// MinimockFoldToUint64Done returns true if the count of the FoldToUint64 invocations corresponds
// the number of defined expectations
func (m *GlobulaStateHashMock) MinimockFoldToUint64Done() bool {
	for _, e := range m.FoldToUint64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FoldToUint64Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFoldToUint64 != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		return false
	}
	return true
}

// MinimockFoldToUint64Inspect logs each unmet expectation
func (m *GlobulaStateHashMock) MinimockFoldToUint64Inspect() {
	for _, e := range m.FoldToUint64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to GlobulaStateHashMock.FoldToUint64")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FoldToUint64Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		m.t.Error("Expected call to GlobulaStateHashMock.FoldToUint64")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFoldToUint64 != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		m.t.Error("Expected call to GlobulaStateHashMock.FoldToUint64")
	}
}

type mGlobulaStateHashMockGetDigestMethod struct {
	mock               *GlobulaStateHashMock
	defaultExpectation *GlobulaStateHashMockGetDigestMethodExpectation
	expectations       []*GlobulaStateHashMockGetDigestMethodExpectation
}

// GlobulaStateHashMockGetDigestMethodExpectation specifies expectation struct of the GlobulaStateHash.GetDigestMethod
type GlobulaStateHashMockGetDigestMethodExpectation struct {
	mock *GlobulaStateHashMock

	results *GlobulaStateHashMockGetDigestMethodResults
	Counter uint64
}

// GlobulaStateHashMockGetDigestMethodResults contains results of the GlobulaStateHash.GetDigestMethod
type GlobulaStateHashMockGetDigestMethodResults struct {
	d1 cryptkit.DigestMethod
}

// Expect sets up expected params for GlobulaStateHash.GetDigestMethod
func (mmGetDigestMethod *mGlobulaStateHashMockGetDigestMethod) Expect() *mGlobulaStateHashMockGetDigestMethod {
	if mmGetDigestMethod.mock.funcGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("GlobulaStateHashMock.GetDigestMethod mock is already set by Set")
	}

	if mmGetDigestMethod.defaultExpectation == nil {
		mmGetDigestMethod.defaultExpectation = &GlobulaStateHashMockGetDigestMethodExpectation{}
	}

	return mmGetDigestMethod
}

// Inspect accepts an inspector function that has same arguments as the GlobulaStateHash.GetDigestMethod
func (mmGetDigestMethod *mGlobulaStateHashMockGetDigestMethod) Inspect(f func()) *mGlobulaStateHashMockGetDigestMethod {
	if mmGetDigestMethod.mock.inspectFuncGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("Inspect function is already set for GlobulaStateHashMock.GetDigestMethod")
	}

	mmGetDigestMethod.mock.inspectFuncGetDigestMethod = f

	return mmGetDigestMethod
}

// Return sets up results that will be returned by GlobulaStateHash.GetDigestMethod
func (mmGetDigestMethod *mGlobulaStateHashMockGetDigestMethod) Return(d1 cryptkit.DigestMethod) *GlobulaStateHashMock {
	if mmGetDigestMethod.mock.funcGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("GlobulaStateHashMock.GetDigestMethod mock is already set by Set")
	}

	if mmGetDigestMethod.defaultExpectation == nil {
		mmGetDigestMethod.defaultExpectation = &GlobulaStateHashMockGetDigestMethodExpectation{mock: mmGetDigestMethod.mock}
	}
	mmGetDigestMethod.defaultExpectation.results = &GlobulaStateHashMockGetDigestMethodResults{d1}
	return mmGetDigestMethod.mock
}

//Set uses given function f to mock the GlobulaStateHash.GetDigestMethod method
func (mmGetDigestMethod *mGlobulaStateHashMockGetDigestMethod) Set(f func() (d1 cryptkit.DigestMethod)) *GlobulaStateHashMock {
	if mmGetDigestMethod.defaultExpectation != nil {
		mmGetDigestMethod.mock.t.Fatalf("Default expectation is already set for the GlobulaStateHash.GetDigestMethod method")
	}

	if len(mmGetDigestMethod.expectations) > 0 {
		mmGetDigestMethod.mock.t.Fatalf("Some expectations are already set for the GlobulaStateHash.GetDigestMethod method")
	}

	mmGetDigestMethod.mock.funcGetDigestMethod = f
	return mmGetDigestMethod.mock
}

// GetDigestMethod implements GlobulaStateHash
func (mmGetDigestMethod *GlobulaStateHashMock) GetDigestMethod() (d1 cryptkit.DigestMethod) {
	mm_atomic.AddUint64(&mmGetDigestMethod.beforeGetDigestMethodCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDigestMethod.afterGetDigestMethodCounter, 1)

	if mmGetDigestMethod.inspectFuncGetDigestMethod != nil {
		mmGetDigestMethod.inspectFuncGetDigestMethod()
	}

	if mmGetDigestMethod.GetDigestMethodMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDigestMethod.GetDigestMethodMock.defaultExpectation.Counter, 1)

		results := mmGetDigestMethod.GetDigestMethodMock.defaultExpectation.results
		if results == nil {
			mmGetDigestMethod.t.Fatal("No results are set for the GlobulaStateHashMock.GetDigestMethod")
		}
		return (*results).d1
	}
	if mmGetDigestMethod.funcGetDigestMethod != nil {
		return mmGetDigestMethod.funcGetDigestMethod()
	}
	mmGetDigestMethod.t.Fatalf("Unexpected call to GlobulaStateHashMock.GetDigestMethod.")
	return
}

// GetDigestMethodAfterCounter returns a count of finished GlobulaStateHashMock.GetDigestMethod invocations
func (mmGetDigestMethod *GlobulaStateHashMock) GetDigestMethodAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestMethod.afterGetDigestMethodCounter)
}

// GetDigestMethodBeforeCounter returns a count of GlobulaStateHashMock.GetDigestMethod invocations
func (mmGetDigestMethod *GlobulaStateHashMock) GetDigestMethodBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestMethod.beforeGetDigestMethodCounter)
}

// MinimockGetDigestMethodDone returns true if the count of the GetDigestMethod invocations corresponds
// the number of defined expectations
func (m *GlobulaStateHashMock) MinimockGetDigestMethodDone() bool {
	for _, e := range m.GetDigestMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestMethod != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetDigestMethodInspect logs each unmet expectation
func (m *GlobulaStateHashMock) MinimockGetDigestMethodInspect() {
	for _, e := range m.GetDigestMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to GlobulaStateHashMock.GetDigestMethod")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		m.t.Error("Expected call to GlobulaStateHashMock.GetDigestMethod")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestMethod != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		m.t.Error("Expected call to GlobulaStateHashMock.GetDigestMethod")
	}
}

type mGlobulaStateHashMockRead struct {
	mock               *GlobulaStateHashMock
	defaultExpectation *GlobulaStateHashMockReadExpectation
	expectations       []*GlobulaStateHashMockReadExpectation

	callArgs []*GlobulaStateHashMockReadParams
	mutex    sync.RWMutex
}

// GlobulaStateHashMockReadExpectation specifies expectation struct of the GlobulaStateHash.Read
type GlobulaStateHashMockReadExpectation struct {
	mock    *GlobulaStateHashMock
	params  *GlobulaStateHashMockReadParams
	results *GlobulaStateHashMockReadResults
	Counter uint64
}

// GlobulaStateHashMockReadParams contains parameters of the GlobulaStateHash.Read
type GlobulaStateHashMockReadParams struct {
	p []byte
}

// GlobulaStateHashMockReadResults contains results of the GlobulaStateHash.Read
type GlobulaStateHashMockReadResults struct {
	n   int
	err error
}

// Expect sets up expected params for GlobulaStateHash.Read
func (mmRead *mGlobulaStateHashMockRead) Expect(p []byte) *mGlobulaStateHashMockRead {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("GlobulaStateHashMock.Read mock is already set by Set")
	}

	if mmRead.defaultExpectation == nil {
		mmRead.defaultExpectation = &GlobulaStateHashMockReadExpectation{}
	}

	mmRead.defaultExpectation.params = &GlobulaStateHashMockReadParams{p}
	for _, e := range mmRead.expectations {
		if minimock.Equal(e.params, mmRead.defaultExpectation.params) {
			mmRead.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRead.defaultExpectation.params)
		}
	}

	return mmRead
}

// Inspect accepts an inspector function that has same arguments as the GlobulaStateHash.Read
func (mmRead *mGlobulaStateHashMockRead) Inspect(f func(p []byte)) *mGlobulaStateHashMockRead {
	if mmRead.mock.inspectFuncRead != nil {
		mmRead.mock.t.Fatalf("Inspect function is already set for GlobulaStateHashMock.Read")
	}

	mmRead.mock.inspectFuncRead = f

	return mmRead
}

// Return sets up results that will be returned by GlobulaStateHash.Read
func (mmRead *mGlobulaStateHashMockRead) Return(n int, err error) *GlobulaStateHashMock {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("GlobulaStateHashMock.Read mock is already set by Set")
	}

	if mmRead.defaultExpectation == nil {
		mmRead.defaultExpectation = &GlobulaStateHashMockReadExpectation{mock: mmRead.mock}
	}
	mmRead.defaultExpectation.results = &GlobulaStateHashMockReadResults{n, err}
	return mmRead.mock
}

//Set uses given function f to mock the GlobulaStateHash.Read method
func (mmRead *mGlobulaStateHashMockRead) Set(f func(p []byte) (n int, err error)) *GlobulaStateHashMock {
	if mmRead.defaultExpectation != nil {
		mmRead.mock.t.Fatalf("Default expectation is already set for the GlobulaStateHash.Read method")
	}

	if len(mmRead.expectations) > 0 {
		mmRead.mock.t.Fatalf("Some expectations are already set for the GlobulaStateHash.Read method")
	}

	mmRead.mock.funcRead = f
	return mmRead.mock
}

// When sets expectation for the GlobulaStateHash.Read which will trigger the result defined by the following
// Then helper
func (mmRead *mGlobulaStateHashMockRead) When(p []byte) *GlobulaStateHashMockReadExpectation {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("GlobulaStateHashMock.Read mock is already set by Set")
	}

	expectation := &GlobulaStateHashMockReadExpectation{
		mock:   mmRead.mock,
		params: &GlobulaStateHashMockReadParams{p},
	}
	mmRead.expectations = append(mmRead.expectations, expectation)
	return expectation
}

// Then sets up GlobulaStateHash.Read return parameters for the expectation previously defined by the When method
func (e *GlobulaStateHashMockReadExpectation) Then(n int, err error) *GlobulaStateHashMock {
	e.results = &GlobulaStateHashMockReadResults{n, err}
	return e.mock
}

// Read implements GlobulaStateHash
func (mmRead *GlobulaStateHashMock) Read(p []byte) (n int, err error) {
	mm_atomic.AddUint64(&mmRead.beforeReadCounter, 1)
	defer mm_atomic.AddUint64(&mmRead.afterReadCounter, 1)

	if mmRead.inspectFuncRead != nil {
		mmRead.inspectFuncRead(p)
	}

	params := &GlobulaStateHashMockReadParams{p}

	// Record call args
	mmRead.ReadMock.mutex.Lock()
	mmRead.ReadMock.callArgs = append(mmRead.ReadMock.callArgs, params)
	mmRead.ReadMock.mutex.Unlock()

	for _, e := range mmRead.ReadMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmRead.ReadMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRead.ReadMock.defaultExpectation.Counter, 1)
		want := mmRead.ReadMock.defaultExpectation.params
		got := GlobulaStateHashMockReadParams{p}
		if want != nil && !minimock.Equal(*want, got) {
			mmRead.t.Errorf("GlobulaStateHashMock.Read got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmRead.ReadMock.defaultExpectation.results
		if results == nil {
			mmRead.t.Fatal("No results are set for the GlobulaStateHashMock.Read")
		}
		return (*results).n, (*results).err
	}
	if mmRead.funcRead != nil {
		return mmRead.funcRead(p)
	}
	mmRead.t.Fatalf("Unexpected call to GlobulaStateHashMock.Read. %v", p)
	return
}

// ReadAfterCounter returns a count of finished GlobulaStateHashMock.Read invocations
func (mmRead *GlobulaStateHashMock) ReadAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRead.afterReadCounter)
}

// ReadBeforeCounter returns a count of GlobulaStateHashMock.Read invocations
func (mmRead *GlobulaStateHashMock) ReadBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRead.beforeReadCounter)
}

// Calls returns a list of arguments used in each call to GlobulaStateHashMock.Read.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRead *mGlobulaStateHashMockRead) Calls() []*GlobulaStateHashMockReadParams {
	mmRead.mutex.RLock()

	argCopy := make([]*GlobulaStateHashMockReadParams, len(mmRead.callArgs))
	copy(argCopy, mmRead.callArgs)

	mmRead.mutex.RUnlock()

	return argCopy
}

// MinimockReadDone returns true if the count of the Read invocations corresponds
// the number of defined expectations
func (m *GlobulaStateHashMock) MinimockReadDone() bool {
	for _, e := range m.ReadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRead != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		return false
	}
	return true
}

// MinimockReadInspect logs each unmet expectation
func (m *GlobulaStateHashMock) MinimockReadInspect() {
	for _, e := range m.ReadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GlobulaStateHashMock.Read with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		if m.ReadMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GlobulaStateHashMock.Read")
		} else {
			m.t.Errorf("Expected call to GlobulaStateHashMock.Read with params: %#v", *m.ReadMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRead != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		m.t.Error("Expected call to GlobulaStateHashMock.Read")
	}
}

type mGlobulaStateHashMockSignWith struct {
	mock               *GlobulaStateHashMock
	defaultExpectation *GlobulaStateHashMockSignWithExpectation
	expectations       []*GlobulaStateHashMockSignWithExpectation

	callArgs []*GlobulaStateHashMockSignWithParams
	mutex    sync.RWMutex
}

// GlobulaStateHashMockSignWithExpectation specifies expectation struct of the GlobulaStateHash.SignWith
type GlobulaStateHashMockSignWithExpectation struct {
	mock    *GlobulaStateHashMock
	params  *GlobulaStateHashMockSignWithParams
	results *GlobulaStateHashMockSignWithResults
	Counter uint64
}

// GlobulaStateHashMockSignWithParams contains parameters of the GlobulaStateHash.SignWith
type GlobulaStateHashMockSignWithParams struct {
	signer cryptkit.DigestSigner
}

// GlobulaStateHashMockSignWithResults contains results of the GlobulaStateHash.SignWith
type GlobulaStateHashMockSignWithResults struct {
	s1 cryptkit.SignedDigestHolder
}

// Expect sets up expected params for GlobulaStateHash.SignWith
func (mmSignWith *mGlobulaStateHashMockSignWith) Expect(signer cryptkit.DigestSigner) *mGlobulaStateHashMockSignWith {
	if mmSignWith.mock.funcSignWith != nil {
		mmSignWith.mock.t.Fatalf("GlobulaStateHashMock.SignWith mock is already set by Set")
	}

	if mmSignWith.defaultExpectation == nil {
		mmSignWith.defaultExpectation = &GlobulaStateHashMockSignWithExpectation{}
	}

	mmSignWith.defaultExpectation.params = &GlobulaStateHashMockSignWithParams{signer}
	for _, e := range mmSignWith.expectations {
		if minimock.Equal(e.params, mmSignWith.defaultExpectation.params) {
			mmSignWith.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSignWith.defaultExpectation.params)
		}
	}

	return mmSignWith
}

// Inspect accepts an inspector function that has same arguments as the GlobulaStateHash.SignWith
func (mmSignWith *mGlobulaStateHashMockSignWith) Inspect(f func(signer cryptkit.DigestSigner)) *mGlobulaStateHashMockSignWith {
	if mmSignWith.mock.inspectFuncSignWith != nil {
		mmSignWith.mock.t.Fatalf("Inspect function is already set for GlobulaStateHashMock.SignWith")
	}

	mmSignWith.mock.inspectFuncSignWith = f

	return mmSignWith
}

// Return sets up results that will be returned by GlobulaStateHash.SignWith
func (mmSignWith *mGlobulaStateHashMockSignWith) Return(s1 cryptkit.SignedDigestHolder) *GlobulaStateHashMock {
	if mmSignWith.mock.funcSignWith != nil {
		mmSignWith.mock.t.Fatalf("GlobulaStateHashMock.SignWith mock is already set by Set")
	}

	if mmSignWith.defaultExpectation == nil {
		mmSignWith.defaultExpectation = &GlobulaStateHashMockSignWithExpectation{mock: mmSignWith.mock}
	}
	mmSignWith.defaultExpectation.results = &GlobulaStateHashMockSignWithResults{s1}
	return mmSignWith.mock
}

//Set uses given function f to mock the GlobulaStateHash.SignWith method
func (mmSignWith *mGlobulaStateHashMockSignWith) Set(f func(signer cryptkit.DigestSigner) (s1 cryptkit.SignedDigestHolder)) *GlobulaStateHashMock {
	if mmSignWith.defaultExpectation != nil {
		mmSignWith.mock.t.Fatalf("Default expectation is already set for the GlobulaStateHash.SignWith method")
	}

	if len(mmSignWith.expectations) > 0 {
		mmSignWith.mock.t.Fatalf("Some expectations are already set for the GlobulaStateHash.SignWith method")
	}

	mmSignWith.mock.funcSignWith = f
	return mmSignWith.mock
}

// When sets expectation for the GlobulaStateHash.SignWith which will trigger the result defined by the following
// Then helper
func (mmSignWith *mGlobulaStateHashMockSignWith) When(signer cryptkit.DigestSigner) *GlobulaStateHashMockSignWithExpectation {
	if mmSignWith.mock.funcSignWith != nil {
		mmSignWith.mock.t.Fatalf("GlobulaStateHashMock.SignWith mock is already set by Set")
	}

	expectation := &GlobulaStateHashMockSignWithExpectation{
		mock:   mmSignWith.mock,
		params: &GlobulaStateHashMockSignWithParams{signer},
	}
	mmSignWith.expectations = append(mmSignWith.expectations, expectation)
	return expectation
}

// Then sets up GlobulaStateHash.SignWith return parameters for the expectation previously defined by the When method
func (e *GlobulaStateHashMockSignWithExpectation) Then(s1 cryptkit.SignedDigestHolder) *GlobulaStateHashMock {
	e.results = &GlobulaStateHashMockSignWithResults{s1}
	return e.mock
}

// SignWith implements GlobulaStateHash
func (mmSignWith *GlobulaStateHashMock) SignWith(signer cryptkit.DigestSigner) (s1 cryptkit.SignedDigestHolder) {
	mm_atomic.AddUint64(&mmSignWith.beforeSignWithCounter, 1)
	defer mm_atomic.AddUint64(&mmSignWith.afterSignWithCounter, 1)

	if mmSignWith.inspectFuncSignWith != nil {
		mmSignWith.inspectFuncSignWith(signer)
	}

	params := &GlobulaStateHashMockSignWithParams{signer}

	// Record call args
	mmSignWith.SignWithMock.mutex.Lock()
	mmSignWith.SignWithMock.callArgs = append(mmSignWith.SignWithMock.callArgs, params)
	mmSignWith.SignWithMock.mutex.Unlock()

	for _, e := range mmSignWith.SignWithMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmSignWith.SignWithMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSignWith.SignWithMock.defaultExpectation.Counter, 1)
		want := mmSignWith.SignWithMock.defaultExpectation.params
		got := GlobulaStateHashMockSignWithParams{signer}
		if want != nil && !minimock.Equal(*want, got) {
			mmSignWith.t.Errorf("GlobulaStateHashMock.SignWith got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmSignWith.SignWithMock.defaultExpectation.results
		if results == nil {
			mmSignWith.t.Fatal("No results are set for the GlobulaStateHashMock.SignWith")
		}
		return (*results).s1
	}
	if mmSignWith.funcSignWith != nil {
		return mmSignWith.funcSignWith(signer)
	}
	mmSignWith.t.Fatalf("Unexpected call to GlobulaStateHashMock.SignWith. %v", signer)
	return
}

// SignWithAfterCounter returns a count of finished GlobulaStateHashMock.SignWith invocations
func (mmSignWith *GlobulaStateHashMock) SignWithAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSignWith.afterSignWithCounter)
}

// SignWithBeforeCounter returns a count of GlobulaStateHashMock.SignWith invocations
func (mmSignWith *GlobulaStateHashMock) SignWithBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSignWith.beforeSignWithCounter)
}

// Calls returns a list of arguments used in each call to GlobulaStateHashMock.SignWith.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSignWith *mGlobulaStateHashMockSignWith) Calls() []*GlobulaStateHashMockSignWithParams {
	mmSignWith.mutex.RLock()

	argCopy := make([]*GlobulaStateHashMockSignWithParams, len(mmSignWith.callArgs))
	copy(argCopy, mmSignWith.callArgs)

	mmSignWith.mutex.RUnlock()

	return argCopy
}

// MinimockSignWithDone returns true if the count of the SignWith invocations corresponds
// the number of defined expectations
func (m *GlobulaStateHashMock) MinimockSignWithDone() bool {
	for _, e := range m.SignWithMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SignWithMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSignWithCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSignWith != nil && mm_atomic.LoadUint64(&m.afterSignWithCounter) < 1 {
		return false
	}
	return true
}

// MinimockSignWithInspect logs each unmet expectation
func (m *GlobulaStateHashMock) MinimockSignWithInspect() {
	for _, e := range m.SignWithMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GlobulaStateHashMock.SignWith with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SignWithMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSignWithCounter) < 1 {
		if m.SignWithMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GlobulaStateHashMock.SignWith")
		} else {
			m.t.Errorf("Expected call to GlobulaStateHashMock.SignWith with params: %#v", *m.SignWithMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSignWith != nil && mm_atomic.LoadUint64(&m.afterSignWithCounter) < 1 {
		m.t.Error("Expected call to GlobulaStateHashMock.SignWith")
	}
}

type mGlobulaStateHashMockWriteTo struct {
	mock               *GlobulaStateHashMock
	defaultExpectation *GlobulaStateHashMockWriteToExpectation
	expectations       []*GlobulaStateHashMockWriteToExpectation

	callArgs []*GlobulaStateHashMockWriteToParams
	mutex    sync.RWMutex
}

// GlobulaStateHashMockWriteToExpectation specifies expectation struct of the GlobulaStateHash.WriteTo
type GlobulaStateHashMockWriteToExpectation struct {
	mock    *GlobulaStateHashMock
	params  *GlobulaStateHashMockWriteToParams
	results *GlobulaStateHashMockWriteToResults
	Counter uint64
}

// GlobulaStateHashMockWriteToParams contains parameters of the GlobulaStateHash.WriteTo
type GlobulaStateHashMockWriteToParams struct {
	w io.Writer
}

// GlobulaStateHashMockWriteToResults contains results of the GlobulaStateHash.WriteTo
type GlobulaStateHashMockWriteToResults struct {
	n   int64
	err error
}

// Expect sets up expected params for GlobulaStateHash.WriteTo
func (mmWriteTo *mGlobulaStateHashMockWriteTo) Expect(w io.Writer) *mGlobulaStateHashMockWriteTo {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("GlobulaStateHashMock.WriteTo mock is already set by Set")
	}

	if mmWriteTo.defaultExpectation == nil {
		mmWriteTo.defaultExpectation = &GlobulaStateHashMockWriteToExpectation{}
	}

	mmWriteTo.defaultExpectation.params = &GlobulaStateHashMockWriteToParams{w}
	for _, e := range mmWriteTo.expectations {
		if minimock.Equal(e.params, mmWriteTo.defaultExpectation.params) {
			mmWriteTo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWriteTo.defaultExpectation.params)
		}
	}

	return mmWriteTo
}

// Inspect accepts an inspector function that has same arguments as the GlobulaStateHash.WriteTo
func (mmWriteTo *mGlobulaStateHashMockWriteTo) Inspect(f func(w io.Writer)) *mGlobulaStateHashMockWriteTo {
	if mmWriteTo.mock.inspectFuncWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("Inspect function is already set for GlobulaStateHashMock.WriteTo")
	}

	mmWriteTo.mock.inspectFuncWriteTo = f

	return mmWriteTo
}

// Return sets up results that will be returned by GlobulaStateHash.WriteTo
func (mmWriteTo *mGlobulaStateHashMockWriteTo) Return(n int64, err error) *GlobulaStateHashMock {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("GlobulaStateHashMock.WriteTo mock is already set by Set")
	}

	if mmWriteTo.defaultExpectation == nil {
		mmWriteTo.defaultExpectation = &GlobulaStateHashMockWriteToExpectation{mock: mmWriteTo.mock}
	}
	mmWriteTo.defaultExpectation.results = &GlobulaStateHashMockWriteToResults{n, err}
	return mmWriteTo.mock
}

//Set uses given function f to mock the GlobulaStateHash.WriteTo method
func (mmWriteTo *mGlobulaStateHashMockWriteTo) Set(f func(w io.Writer) (n int64, err error)) *GlobulaStateHashMock {
	if mmWriteTo.defaultExpectation != nil {
		mmWriteTo.mock.t.Fatalf("Default expectation is already set for the GlobulaStateHash.WriteTo method")
	}

	if len(mmWriteTo.expectations) > 0 {
		mmWriteTo.mock.t.Fatalf("Some expectations are already set for the GlobulaStateHash.WriteTo method")
	}

	mmWriteTo.mock.funcWriteTo = f
	return mmWriteTo.mock
}

// When sets expectation for the GlobulaStateHash.WriteTo which will trigger the result defined by the following
// Then helper
func (mmWriteTo *mGlobulaStateHashMockWriteTo) When(w io.Writer) *GlobulaStateHashMockWriteToExpectation {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("GlobulaStateHashMock.WriteTo mock is already set by Set")
	}

	expectation := &GlobulaStateHashMockWriteToExpectation{
		mock:   mmWriteTo.mock,
		params: &GlobulaStateHashMockWriteToParams{w},
	}
	mmWriteTo.expectations = append(mmWriteTo.expectations, expectation)
	return expectation
}

// Then sets up GlobulaStateHash.WriteTo return parameters for the expectation previously defined by the When method
func (e *GlobulaStateHashMockWriteToExpectation) Then(n int64, err error) *GlobulaStateHashMock {
	e.results = &GlobulaStateHashMockWriteToResults{n, err}
	return e.mock
}

// WriteTo implements GlobulaStateHash
func (mmWriteTo *GlobulaStateHashMock) WriteTo(w io.Writer) (n int64, err error) {
	mm_atomic.AddUint64(&mmWriteTo.beforeWriteToCounter, 1)
	defer mm_atomic.AddUint64(&mmWriteTo.afterWriteToCounter, 1)

	if mmWriteTo.inspectFuncWriteTo != nil {
		mmWriteTo.inspectFuncWriteTo(w)
	}

	params := &GlobulaStateHashMockWriteToParams{w}

	// Record call args
	mmWriteTo.WriteToMock.mutex.Lock()
	mmWriteTo.WriteToMock.callArgs = append(mmWriteTo.WriteToMock.callArgs, params)
	mmWriteTo.WriteToMock.mutex.Unlock()

	for _, e := range mmWriteTo.WriteToMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmWriteTo.WriteToMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWriteTo.WriteToMock.defaultExpectation.Counter, 1)
		want := mmWriteTo.WriteToMock.defaultExpectation.params
		got := GlobulaStateHashMockWriteToParams{w}
		if want != nil && !minimock.Equal(*want, got) {
			mmWriteTo.t.Errorf("GlobulaStateHashMock.WriteTo got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmWriteTo.WriteToMock.defaultExpectation.results
		if results == nil {
			mmWriteTo.t.Fatal("No results are set for the GlobulaStateHashMock.WriteTo")
		}
		return (*results).n, (*results).err
	}
	if mmWriteTo.funcWriteTo != nil {
		return mmWriteTo.funcWriteTo(w)
	}
	mmWriteTo.t.Fatalf("Unexpected call to GlobulaStateHashMock.WriteTo. %v", w)
	return
}

// WriteToAfterCounter returns a count of finished GlobulaStateHashMock.WriteTo invocations
func (mmWriteTo *GlobulaStateHashMock) WriteToAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteTo.afterWriteToCounter)
}

// WriteToBeforeCounter returns a count of GlobulaStateHashMock.WriteTo invocations
func (mmWriteTo *GlobulaStateHashMock) WriteToBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteTo.beforeWriteToCounter)
}

// Calls returns a list of arguments used in each call to GlobulaStateHashMock.WriteTo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWriteTo *mGlobulaStateHashMockWriteTo) Calls() []*GlobulaStateHashMockWriteToParams {
	mmWriteTo.mutex.RLock()

	argCopy := make([]*GlobulaStateHashMockWriteToParams, len(mmWriteTo.callArgs))
	copy(argCopy, mmWriteTo.callArgs)

	mmWriteTo.mutex.RUnlock()

	return argCopy
}

// MinimockWriteToDone returns true if the count of the WriteTo invocations corresponds
// the number of defined expectations
func (m *GlobulaStateHashMock) MinimockWriteToDone() bool {
	for _, e := range m.WriteToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteTo != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		return false
	}
	return true
}

// MinimockWriteToInspect logs each unmet expectation
func (m *GlobulaStateHashMock) MinimockWriteToInspect() {
	for _, e := range m.WriteToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GlobulaStateHashMock.WriteTo with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		if m.WriteToMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GlobulaStateHashMock.WriteTo")
		} else {
			m.t.Errorf("Expected call to GlobulaStateHashMock.WriteTo with params: %#v", *m.WriteToMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteTo != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		m.t.Error("Expected call to GlobulaStateHashMock.WriteTo")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *GlobulaStateHashMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAsByteStringInspect()

		m.MinimockAsBytesInspect()

		m.MinimockCopyOfDigestInspect()

		m.MinimockEqualsInspect()

		m.MinimockFixedByteSizeInspect()

		m.MinimockFoldToUint64Inspect()

		m.MinimockGetDigestMethodInspect()

		m.MinimockReadInspect()

		m.MinimockSignWithInspect()

		m.MinimockWriteToInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *GlobulaStateHashMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *GlobulaStateHashMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAsByteStringDone() &&
		m.MinimockAsBytesDone() &&
		m.MinimockCopyOfDigestDone() &&
		m.MinimockEqualsDone() &&
		m.MinimockFixedByteSizeDone() &&
		m.MinimockFoldToUint64Done() &&
		m.MinimockGetDigestMethodDone() &&
		m.MinimockReadDone() &&
		m.MinimockSignWithDone() &&
		m.MinimockWriteToDone()
}
