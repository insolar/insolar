package proofs

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	io "io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/longbits"
	"github.com/insolar/insolar/network/consensus/common/cryptkit"
)

// CloudStateHashMock implements CloudStateHash
type CloudStateHashMock struct {
	t minimock.Tester

	funcAsByteString          func() (b1 longbits.ByteString)
	inspectFuncAsByteString   func()
	afterAsByteStringCounter  uint64
	beforeAsByteStringCounter uint64
	AsByteStringMock          mCloudStateHashMockAsByteString

	funcAsBytes          func() (ba1 []byte)
	inspectFuncAsBytes   func()
	afterAsBytesCounter  uint64
	beforeAsBytesCounter uint64
	AsBytesMock          mCloudStateHashMockAsBytes

	funcCopyOfDigest          func() (d1 cryptkit.Digest)
	inspectFuncCopyOfDigest   func()
	afterCopyOfDigestCounter  uint64
	beforeCopyOfDigestCounter uint64
	CopyOfDigestMock          mCloudStateHashMockCopyOfDigest

	funcEquals          func(other cryptkit.DigestHolder) (b1 bool)
	inspectFuncEquals   func(other cryptkit.DigestHolder)
	afterEqualsCounter  uint64
	beforeEqualsCounter uint64
	EqualsMock          mCloudStateHashMockEquals

	funcFixedByteSize          func() (i1 int)
	inspectFuncFixedByteSize   func()
	afterFixedByteSizeCounter  uint64
	beforeFixedByteSizeCounter uint64
	FixedByteSizeMock          mCloudStateHashMockFixedByteSize

	funcFoldToUint64          func() (u1 uint64)
	inspectFuncFoldToUint64   func()
	afterFoldToUint64Counter  uint64
	beforeFoldToUint64Counter uint64
	FoldToUint64Mock          mCloudStateHashMockFoldToUint64

	funcGetDigestMethod          func() (d1 cryptkit.DigestMethod)
	inspectFuncGetDigestMethod   func()
	afterGetDigestMethodCounter  uint64
	beforeGetDigestMethodCounter uint64
	GetDigestMethodMock          mCloudStateHashMockGetDigestMethod

	funcRead          func(p []byte) (n int, err error)
	inspectFuncRead   func(p []byte)
	afterReadCounter  uint64
	beforeReadCounter uint64
	ReadMock          mCloudStateHashMockRead

	funcSignWith          func(signer cryptkit.DigestSigner) (s1 cryptkit.SignedDigestHolder)
	inspectFuncSignWith   func(signer cryptkit.DigestSigner)
	afterSignWithCounter  uint64
	beforeSignWithCounter uint64
	SignWithMock          mCloudStateHashMockSignWith

	funcWriteTo          func(w io.Writer) (n int64, err error)
	inspectFuncWriteTo   func(w io.Writer)
	afterWriteToCounter  uint64
	beforeWriteToCounter uint64
	WriteToMock          mCloudStateHashMockWriteTo
}

// NewCloudStateHashMock returns a mock for CloudStateHash
func NewCloudStateHashMock(t minimock.Tester) *CloudStateHashMock {
	m := &CloudStateHashMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AsByteStringMock = mCloudStateHashMockAsByteString{mock: m}

	m.AsBytesMock = mCloudStateHashMockAsBytes{mock: m}

	m.CopyOfDigestMock = mCloudStateHashMockCopyOfDigest{mock: m}

	m.EqualsMock = mCloudStateHashMockEquals{mock: m}
	m.EqualsMock.callArgs = []*CloudStateHashMockEqualsParams{}

	m.FixedByteSizeMock = mCloudStateHashMockFixedByteSize{mock: m}

	m.FoldToUint64Mock = mCloudStateHashMockFoldToUint64{mock: m}

	m.GetDigestMethodMock = mCloudStateHashMockGetDigestMethod{mock: m}

	m.ReadMock = mCloudStateHashMockRead{mock: m}
	m.ReadMock.callArgs = []*CloudStateHashMockReadParams{}

	m.SignWithMock = mCloudStateHashMockSignWith{mock: m}
	m.SignWithMock.callArgs = []*CloudStateHashMockSignWithParams{}

	m.WriteToMock = mCloudStateHashMockWriteTo{mock: m}
	m.WriteToMock.callArgs = []*CloudStateHashMockWriteToParams{}

	return m
}

type mCloudStateHashMockAsByteString struct {
	mock               *CloudStateHashMock
	defaultExpectation *CloudStateHashMockAsByteStringExpectation
	expectations       []*CloudStateHashMockAsByteStringExpectation
}

// CloudStateHashMockAsByteStringExpectation specifies expectation struct of the CloudStateHash.AsByteString
type CloudStateHashMockAsByteStringExpectation struct {
	mock *CloudStateHashMock

	results *CloudStateHashMockAsByteStringResults
	Counter uint64
}

// CloudStateHashMockAsByteStringResults contains results of the CloudStateHash.AsByteString
type CloudStateHashMockAsByteStringResults struct {
	b1 longbits.ByteString
}

// Expect sets up expected params for CloudStateHash.AsByteString
func (mmAsByteString *mCloudStateHashMockAsByteString) Expect() *mCloudStateHashMockAsByteString {
	if mmAsByteString.mock.funcAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("CloudStateHashMock.AsByteString mock is already set by Set")
	}

	if mmAsByteString.defaultExpectation == nil {
		mmAsByteString.defaultExpectation = &CloudStateHashMockAsByteStringExpectation{}
	}

	return mmAsByteString
}

// Inspect accepts an inspector function that has same arguments as the CloudStateHash.AsByteString
func (mmAsByteString *mCloudStateHashMockAsByteString) Inspect(f func()) *mCloudStateHashMockAsByteString {
	if mmAsByteString.mock.inspectFuncAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("Inspect function is already set for CloudStateHashMock.AsByteString")
	}

	mmAsByteString.mock.inspectFuncAsByteString = f

	return mmAsByteString
}

// Return sets up results that will be returned by CloudStateHash.AsByteString
func (mmAsByteString *mCloudStateHashMockAsByteString) Return(b1 longbits.ByteString) *CloudStateHashMock {
	if mmAsByteString.mock.funcAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("CloudStateHashMock.AsByteString mock is already set by Set")
	}

	if mmAsByteString.defaultExpectation == nil {
		mmAsByteString.defaultExpectation = &CloudStateHashMockAsByteStringExpectation{mock: mmAsByteString.mock}
	}
	mmAsByteString.defaultExpectation.results = &CloudStateHashMockAsByteStringResults{b1}
	return mmAsByteString.mock
}

//Set uses given function f to mock the CloudStateHash.AsByteString method
func (mmAsByteString *mCloudStateHashMockAsByteString) Set(f func() (b1 longbits.ByteString)) *CloudStateHashMock {
	if mmAsByteString.defaultExpectation != nil {
		mmAsByteString.mock.t.Fatalf("Default expectation is already set for the CloudStateHash.AsByteString method")
	}

	if len(mmAsByteString.expectations) > 0 {
		mmAsByteString.mock.t.Fatalf("Some expectations are already set for the CloudStateHash.AsByteString method")
	}

	mmAsByteString.mock.funcAsByteString = f
	return mmAsByteString.mock
}

// AsByteString implements CloudStateHash
func (mmAsByteString *CloudStateHashMock) AsByteString() (b1 longbits.ByteString) {
	mm_atomic.AddUint64(&mmAsByteString.beforeAsByteStringCounter, 1)
	defer mm_atomic.AddUint64(&mmAsByteString.afterAsByteStringCounter, 1)

	if mmAsByteString.inspectFuncAsByteString != nil {
		mmAsByteString.inspectFuncAsByteString()
	}

	if mmAsByteString.AsByteStringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAsByteString.AsByteStringMock.defaultExpectation.Counter, 1)

		results := mmAsByteString.AsByteStringMock.defaultExpectation.results
		if results == nil {
			mmAsByteString.t.Fatal("No results are set for the CloudStateHashMock.AsByteString")
		}
		return (*results).b1
	}
	if mmAsByteString.funcAsByteString != nil {
		return mmAsByteString.funcAsByteString()
	}
	mmAsByteString.t.Fatalf("Unexpected call to CloudStateHashMock.AsByteString.")
	return
}

// AsByteStringAfterCounter returns a count of finished CloudStateHashMock.AsByteString invocations
func (mmAsByteString *CloudStateHashMock) AsByteStringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsByteString.afterAsByteStringCounter)
}

// AsByteStringBeforeCounter returns a count of CloudStateHashMock.AsByteString invocations
func (mmAsByteString *CloudStateHashMock) AsByteStringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsByteString.beforeAsByteStringCounter)
}

// MinimockAsByteStringDone returns true if the count of the AsByteString invocations corresponds
// the number of defined expectations
func (m *CloudStateHashMock) MinimockAsByteStringDone() bool {
	for _, e := range m.AsByteStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsByteStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsByteString != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		return false
	}
	return true
}

// MinimockAsByteStringInspect logs each unmet expectation
func (m *CloudStateHashMock) MinimockAsByteStringInspect() {
	for _, e := range m.AsByteStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to CloudStateHashMock.AsByteString")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsByteStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		m.t.Error("Expected call to CloudStateHashMock.AsByteString")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsByteString != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		m.t.Error("Expected call to CloudStateHashMock.AsByteString")
	}
}

type mCloudStateHashMockAsBytes struct {
	mock               *CloudStateHashMock
	defaultExpectation *CloudStateHashMockAsBytesExpectation
	expectations       []*CloudStateHashMockAsBytesExpectation
}

// CloudStateHashMockAsBytesExpectation specifies expectation struct of the CloudStateHash.AsBytes
type CloudStateHashMockAsBytesExpectation struct {
	mock *CloudStateHashMock

	results *CloudStateHashMockAsBytesResults
	Counter uint64
}

// CloudStateHashMockAsBytesResults contains results of the CloudStateHash.AsBytes
type CloudStateHashMockAsBytesResults struct {
	ba1 []byte
}

// Expect sets up expected params for CloudStateHash.AsBytes
func (mmAsBytes *mCloudStateHashMockAsBytes) Expect() *mCloudStateHashMockAsBytes {
	if mmAsBytes.mock.funcAsBytes != nil {
		mmAsBytes.mock.t.Fatalf("CloudStateHashMock.AsBytes mock is already set by Set")
	}

	if mmAsBytes.defaultExpectation == nil {
		mmAsBytes.defaultExpectation = &CloudStateHashMockAsBytesExpectation{}
	}

	return mmAsBytes
}

// Inspect accepts an inspector function that has same arguments as the CloudStateHash.AsBytes
func (mmAsBytes *mCloudStateHashMockAsBytes) Inspect(f func()) *mCloudStateHashMockAsBytes {
	if mmAsBytes.mock.inspectFuncAsBytes != nil {
		mmAsBytes.mock.t.Fatalf("Inspect function is already set for CloudStateHashMock.AsBytes")
	}

	mmAsBytes.mock.inspectFuncAsBytes = f

	return mmAsBytes
}

// Return sets up results that will be returned by CloudStateHash.AsBytes
func (mmAsBytes *mCloudStateHashMockAsBytes) Return(ba1 []byte) *CloudStateHashMock {
	if mmAsBytes.mock.funcAsBytes != nil {
		mmAsBytes.mock.t.Fatalf("CloudStateHashMock.AsBytes mock is already set by Set")
	}

	if mmAsBytes.defaultExpectation == nil {
		mmAsBytes.defaultExpectation = &CloudStateHashMockAsBytesExpectation{mock: mmAsBytes.mock}
	}
	mmAsBytes.defaultExpectation.results = &CloudStateHashMockAsBytesResults{ba1}
	return mmAsBytes.mock
}

//Set uses given function f to mock the CloudStateHash.AsBytes method
func (mmAsBytes *mCloudStateHashMockAsBytes) Set(f func() (ba1 []byte)) *CloudStateHashMock {
	if mmAsBytes.defaultExpectation != nil {
		mmAsBytes.mock.t.Fatalf("Default expectation is already set for the CloudStateHash.AsBytes method")
	}

	if len(mmAsBytes.expectations) > 0 {
		mmAsBytes.mock.t.Fatalf("Some expectations are already set for the CloudStateHash.AsBytes method")
	}

	mmAsBytes.mock.funcAsBytes = f
	return mmAsBytes.mock
}

// AsBytes implements CloudStateHash
func (mmAsBytes *CloudStateHashMock) AsBytes() (ba1 []byte) {
	mm_atomic.AddUint64(&mmAsBytes.beforeAsBytesCounter, 1)
	defer mm_atomic.AddUint64(&mmAsBytes.afterAsBytesCounter, 1)

	if mmAsBytes.inspectFuncAsBytes != nil {
		mmAsBytes.inspectFuncAsBytes()
	}

	if mmAsBytes.AsBytesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAsBytes.AsBytesMock.defaultExpectation.Counter, 1)

		results := mmAsBytes.AsBytesMock.defaultExpectation.results
		if results == nil {
			mmAsBytes.t.Fatal("No results are set for the CloudStateHashMock.AsBytes")
		}
		return (*results).ba1
	}
	if mmAsBytes.funcAsBytes != nil {
		return mmAsBytes.funcAsBytes()
	}
	mmAsBytes.t.Fatalf("Unexpected call to CloudStateHashMock.AsBytes.")
	return
}

// AsBytesAfterCounter returns a count of finished CloudStateHashMock.AsBytes invocations
func (mmAsBytes *CloudStateHashMock) AsBytesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsBytes.afterAsBytesCounter)
}

// AsBytesBeforeCounter returns a count of CloudStateHashMock.AsBytes invocations
func (mmAsBytes *CloudStateHashMock) AsBytesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsBytes.beforeAsBytesCounter)
}

// MinimockAsBytesDone returns true if the count of the AsBytes invocations corresponds
// the number of defined expectations
func (m *CloudStateHashMock) MinimockAsBytesDone() bool {
	for _, e := range m.AsBytesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsBytesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsBytesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsBytes != nil && mm_atomic.LoadUint64(&m.afterAsBytesCounter) < 1 {
		return false
	}
	return true
}

// MinimockAsBytesInspect logs each unmet expectation
func (m *CloudStateHashMock) MinimockAsBytesInspect() {
	for _, e := range m.AsBytesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to CloudStateHashMock.AsBytes")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsBytesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsBytesCounter) < 1 {
		m.t.Error("Expected call to CloudStateHashMock.AsBytes")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsBytes != nil && mm_atomic.LoadUint64(&m.afterAsBytesCounter) < 1 {
		m.t.Error("Expected call to CloudStateHashMock.AsBytes")
	}
}

type mCloudStateHashMockCopyOfDigest struct {
	mock               *CloudStateHashMock
	defaultExpectation *CloudStateHashMockCopyOfDigestExpectation
	expectations       []*CloudStateHashMockCopyOfDigestExpectation
}

// CloudStateHashMockCopyOfDigestExpectation specifies expectation struct of the CloudStateHash.CopyOfDigest
type CloudStateHashMockCopyOfDigestExpectation struct {
	mock *CloudStateHashMock

	results *CloudStateHashMockCopyOfDigestResults
	Counter uint64
}

// CloudStateHashMockCopyOfDigestResults contains results of the CloudStateHash.CopyOfDigest
type CloudStateHashMockCopyOfDigestResults struct {
	d1 cryptkit.Digest
}

// Expect sets up expected params for CloudStateHash.CopyOfDigest
func (mmCopyOfDigest *mCloudStateHashMockCopyOfDigest) Expect() *mCloudStateHashMockCopyOfDigest {
	if mmCopyOfDigest.mock.funcCopyOfDigest != nil {
		mmCopyOfDigest.mock.t.Fatalf("CloudStateHashMock.CopyOfDigest mock is already set by Set")
	}

	if mmCopyOfDigest.defaultExpectation == nil {
		mmCopyOfDigest.defaultExpectation = &CloudStateHashMockCopyOfDigestExpectation{}
	}

	return mmCopyOfDigest
}

// Inspect accepts an inspector function that has same arguments as the CloudStateHash.CopyOfDigest
func (mmCopyOfDigest *mCloudStateHashMockCopyOfDigest) Inspect(f func()) *mCloudStateHashMockCopyOfDigest {
	if mmCopyOfDigest.mock.inspectFuncCopyOfDigest != nil {
		mmCopyOfDigest.mock.t.Fatalf("Inspect function is already set for CloudStateHashMock.CopyOfDigest")
	}

	mmCopyOfDigest.mock.inspectFuncCopyOfDigest = f

	return mmCopyOfDigest
}

// Return sets up results that will be returned by CloudStateHash.CopyOfDigest
func (mmCopyOfDigest *mCloudStateHashMockCopyOfDigest) Return(d1 cryptkit.Digest) *CloudStateHashMock {
	if mmCopyOfDigest.mock.funcCopyOfDigest != nil {
		mmCopyOfDigest.mock.t.Fatalf("CloudStateHashMock.CopyOfDigest mock is already set by Set")
	}

	if mmCopyOfDigest.defaultExpectation == nil {
		mmCopyOfDigest.defaultExpectation = &CloudStateHashMockCopyOfDigestExpectation{mock: mmCopyOfDigest.mock}
	}
	mmCopyOfDigest.defaultExpectation.results = &CloudStateHashMockCopyOfDigestResults{d1}
	return mmCopyOfDigest.mock
}

//Set uses given function f to mock the CloudStateHash.CopyOfDigest method
func (mmCopyOfDigest *mCloudStateHashMockCopyOfDigest) Set(f func() (d1 cryptkit.Digest)) *CloudStateHashMock {
	if mmCopyOfDigest.defaultExpectation != nil {
		mmCopyOfDigest.mock.t.Fatalf("Default expectation is already set for the CloudStateHash.CopyOfDigest method")
	}

	if len(mmCopyOfDigest.expectations) > 0 {
		mmCopyOfDigest.mock.t.Fatalf("Some expectations are already set for the CloudStateHash.CopyOfDigest method")
	}

	mmCopyOfDigest.mock.funcCopyOfDigest = f
	return mmCopyOfDigest.mock
}

// CopyOfDigest implements CloudStateHash
func (mmCopyOfDigest *CloudStateHashMock) CopyOfDigest() (d1 cryptkit.Digest) {
	mm_atomic.AddUint64(&mmCopyOfDigest.beforeCopyOfDigestCounter, 1)
	defer mm_atomic.AddUint64(&mmCopyOfDigest.afterCopyOfDigestCounter, 1)

	if mmCopyOfDigest.inspectFuncCopyOfDigest != nil {
		mmCopyOfDigest.inspectFuncCopyOfDigest()
	}

	if mmCopyOfDigest.CopyOfDigestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCopyOfDigest.CopyOfDigestMock.defaultExpectation.Counter, 1)

		results := mmCopyOfDigest.CopyOfDigestMock.defaultExpectation.results
		if results == nil {
			mmCopyOfDigest.t.Fatal("No results are set for the CloudStateHashMock.CopyOfDigest")
		}
		return (*results).d1
	}
	if mmCopyOfDigest.funcCopyOfDigest != nil {
		return mmCopyOfDigest.funcCopyOfDigest()
	}
	mmCopyOfDigest.t.Fatalf("Unexpected call to CloudStateHashMock.CopyOfDigest.")
	return
}

// CopyOfDigestAfterCounter returns a count of finished CloudStateHashMock.CopyOfDigest invocations
func (mmCopyOfDigest *CloudStateHashMock) CopyOfDigestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyOfDigest.afterCopyOfDigestCounter)
}

// CopyOfDigestBeforeCounter returns a count of CloudStateHashMock.CopyOfDigest invocations
func (mmCopyOfDigest *CloudStateHashMock) CopyOfDigestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyOfDigest.beforeCopyOfDigestCounter)
}

// MinimockCopyOfDigestDone returns true if the count of the CopyOfDigest invocations corresponds
// the number of defined expectations
func (m *CloudStateHashMock) MinimockCopyOfDigestDone() bool {
	for _, e := range m.CopyOfDigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyOfDigestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyOfDigestCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyOfDigest != nil && mm_atomic.LoadUint64(&m.afterCopyOfDigestCounter) < 1 {
		return false
	}
	return true
}

// MinimockCopyOfDigestInspect logs each unmet expectation
func (m *CloudStateHashMock) MinimockCopyOfDigestInspect() {
	for _, e := range m.CopyOfDigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to CloudStateHashMock.CopyOfDigest")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyOfDigestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyOfDigestCounter) < 1 {
		m.t.Error("Expected call to CloudStateHashMock.CopyOfDigest")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyOfDigest != nil && mm_atomic.LoadUint64(&m.afterCopyOfDigestCounter) < 1 {
		m.t.Error("Expected call to CloudStateHashMock.CopyOfDigest")
	}
}

type mCloudStateHashMockEquals struct {
	mock               *CloudStateHashMock
	defaultExpectation *CloudStateHashMockEqualsExpectation
	expectations       []*CloudStateHashMockEqualsExpectation

	callArgs []*CloudStateHashMockEqualsParams
	mutex    sync.RWMutex
}

// CloudStateHashMockEqualsExpectation specifies expectation struct of the CloudStateHash.Equals
type CloudStateHashMockEqualsExpectation struct {
	mock    *CloudStateHashMock
	params  *CloudStateHashMockEqualsParams
	results *CloudStateHashMockEqualsResults
	Counter uint64
}

// CloudStateHashMockEqualsParams contains parameters of the CloudStateHash.Equals
type CloudStateHashMockEqualsParams struct {
	other cryptkit.DigestHolder
}

// CloudStateHashMockEqualsResults contains results of the CloudStateHash.Equals
type CloudStateHashMockEqualsResults struct {
	b1 bool
}

// Expect sets up expected params for CloudStateHash.Equals
func (mmEquals *mCloudStateHashMockEquals) Expect(other cryptkit.DigestHolder) *mCloudStateHashMockEquals {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("CloudStateHashMock.Equals mock is already set by Set")
	}

	if mmEquals.defaultExpectation == nil {
		mmEquals.defaultExpectation = &CloudStateHashMockEqualsExpectation{}
	}

	mmEquals.defaultExpectation.params = &CloudStateHashMockEqualsParams{other}
	for _, e := range mmEquals.expectations {
		if minimock.Equal(e.params, mmEquals.defaultExpectation.params) {
			mmEquals.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEquals.defaultExpectation.params)
		}
	}

	return mmEquals
}

// Inspect accepts an inspector function that has same arguments as the CloudStateHash.Equals
func (mmEquals *mCloudStateHashMockEquals) Inspect(f func(other cryptkit.DigestHolder)) *mCloudStateHashMockEquals {
	if mmEquals.mock.inspectFuncEquals != nil {
		mmEquals.mock.t.Fatalf("Inspect function is already set for CloudStateHashMock.Equals")
	}

	mmEquals.mock.inspectFuncEquals = f

	return mmEquals
}

// Return sets up results that will be returned by CloudStateHash.Equals
func (mmEquals *mCloudStateHashMockEquals) Return(b1 bool) *CloudStateHashMock {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("CloudStateHashMock.Equals mock is already set by Set")
	}

	if mmEquals.defaultExpectation == nil {
		mmEquals.defaultExpectation = &CloudStateHashMockEqualsExpectation{mock: mmEquals.mock}
	}
	mmEquals.defaultExpectation.results = &CloudStateHashMockEqualsResults{b1}
	return mmEquals.mock
}

//Set uses given function f to mock the CloudStateHash.Equals method
func (mmEquals *mCloudStateHashMockEquals) Set(f func(other cryptkit.DigestHolder) (b1 bool)) *CloudStateHashMock {
	if mmEquals.defaultExpectation != nil {
		mmEquals.mock.t.Fatalf("Default expectation is already set for the CloudStateHash.Equals method")
	}

	if len(mmEquals.expectations) > 0 {
		mmEquals.mock.t.Fatalf("Some expectations are already set for the CloudStateHash.Equals method")
	}

	mmEquals.mock.funcEquals = f
	return mmEquals.mock
}

// When sets expectation for the CloudStateHash.Equals which will trigger the result defined by the following
// Then helper
func (mmEquals *mCloudStateHashMockEquals) When(other cryptkit.DigestHolder) *CloudStateHashMockEqualsExpectation {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("CloudStateHashMock.Equals mock is already set by Set")
	}

	expectation := &CloudStateHashMockEqualsExpectation{
		mock:   mmEquals.mock,
		params: &CloudStateHashMockEqualsParams{other},
	}
	mmEquals.expectations = append(mmEquals.expectations, expectation)
	return expectation
}

// Then sets up CloudStateHash.Equals return parameters for the expectation previously defined by the When method
func (e *CloudStateHashMockEqualsExpectation) Then(b1 bool) *CloudStateHashMock {
	e.results = &CloudStateHashMockEqualsResults{b1}
	return e.mock
}

// Equals implements CloudStateHash
func (mmEquals *CloudStateHashMock) Equals(other cryptkit.DigestHolder) (b1 bool) {
	mm_atomic.AddUint64(&mmEquals.beforeEqualsCounter, 1)
	defer mm_atomic.AddUint64(&mmEquals.afterEqualsCounter, 1)

	if mmEquals.inspectFuncEquals != nil {
		mmEquals.inspectFuncEquals(other)
	}

	params := &CloudStateHashMockEqualsParams{other}

	// Record call args
	mmEquals.EqualsMock.mutex.Lock()
	mmEquals.EqualsMock.callArgs = append(mmEquals.EqualsMock.callArgs, params)
	mmEquals.EqualsMock.mutex.Unlock()

	for _, e := range mmEquals.EqualsMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmEquals.EqualsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEquals.EqualsMock.defaultExpectation.Counter, 1)
		want := mmEquals.EqualsMock.defaultExpectation.params
		got := CloudStateHashMockEqualsParams{other}
		if want != nil && !minimock.Equal(*want, got) {
			mmEquals.t.Errorf("CloudStateHashMock.Equals got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmEquals.EqualsMock.defaultExpectation.results
		if results == nil {
			mmEquals.t.Fatal("No results are set for the CloudStateHashMock.Equals")
		}
		return (*results).b1
	}
	if mmEquals.funcEquals != nil {
		return mmEquals.funcEquals(other)
	}
	mmEquals.t.Fatalf("Unexpected call to CloudStateHashMock.Equals. %v", other)
	return
}

// EqualsAfterCounter returns a count of finished CloudStateHashMock.Equals invocations
func (mmEquals *CloudStateHashMock) EqualsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEquals.afterEqualsCounter)
}

// EqualsBeforeCounter returns a count of CloudStateHashMock.Equals invocations
func (mmEquals *CloudStateHashMock) EqualsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEquals.beforeEqualsCounter)
}

// Calls returns a list of arguments used in each call to CloudStateHashMock.Equals.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEquals *mCloudStateHashMockEquals) Calls() []*CloudStateHashMockEqualsParams {
	mmEquals.mutex.RLock()

	argCopy := make([]*CloudStateHashMockEqualsParams, len(mmEquals.callArgs))
	copy(argCopy, mmEquals.callArgs)

	mmEquals.mutex.RUnlock()

	return argCopy
}

// MinimockEqualsDone returns true if the count of the Equals invocations corresponds
// the number of defined expectations
func (m *CloudStateHashMock) MinimockEqualsDone() bool {
	for _, e := range m.EqualsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EqualsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEquals != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		return false
	}
	return true
}

// MinimockEqualsInspect logs each unmet expectation
func (m *CloudStateHashMock) MinimockEqualsInspect() {
	for _, e := range m.EqualsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CloudStateHashMock.Equals with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EqualsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		if m.EqualsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CloudStateHashMock.Equals")
		} else {
			m.t.Errorf("Expected call to CloudStateHashMock.Equals with params: %#v", *m.EqualsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEquals != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		m.t.Error("Expected call to CloudStateHashMock.Equals")
	}
}

type mCloudStateHashMockFixedByteSize struct {
	mock               *CloudStateHashMock
	defaultExpectation *CloudStateHashMockFixedByteSizeExpectation
	expectations       []*CloudStateHashMockFixedByteSizeExpectation
}

// CloudStateHashMockFixedByteSizeExpectation specifies expectation struct of the CloudStateHash.FixedByteSize
type CloudStateHashMockFixedByteSizeExpectation struct {
	mock *CloudStateHashMock

	results *CloudStateHashMockFixedByteSizeResults
	Counter uint64
}

// CloudStateHashMockFixedByteSizeResults contains results of the CloudStateHash.FixedByteSize
type CloudStateHashMockFixedByteSizeResults struct {
	i1 int
}

// Expect sets up expected params for CloudStateHash.FixedByteSize
func (mmFixedByteSize *mCloudStateHashMockFixedByteSize) Expect() *mCloudStateHashMockFixedByteSize {
	if mmFixedByteSize.mock.funcFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("CloudStateHashMock.FixedByteSize mock is already set by Set")
	}

	if mmFixedByteSize.defaultExpectation == nil {
		mmFixedByteSize.defaultExpectation = &CloudStateHashMockFixedByteSizeExpectation{}
	}

	return mmFixedByteSize
}

// Inspect accepts an inspector function that has same arguments as the CloudStateHash.FixedByteSize
func (mmFixedByteSize *mCloudStateHashMockFixedByteSize) Inspect(f func()) *mCloudStateHashMockFixedByteSize {
	if mmFixedByteSize.mock.inspectFuncFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("Inspect function is already set for CloudStateHashMock.FixedByteSize")
	}

	mmFixedByteSize.mock.inspectFuncFixedByteSize = f

	return mmFixedByteSize
}

// Return sets up results that will be returned by CloudStateHash.FixedByteSize
func (mmFixedByteSize *mCloudStateHashMockFixedByteSize) Return(i1 int) *CloudStateHashMock {
	if mmFixedByteSize.mock.funcFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("CloudStateHashMock.FixedByteSize mock is already set by Set")
	}

	if mmFixedByteSize.defaultExpectation == nil {
		mmFixedByteSize.defaultExpectation = &CloudStateHashMockFixedByteSizeExpectation{mock: mmFixedByteSize.mock}
	}
	mmFixedByteSize.defaultExpectation.results = &CloudStateHashMockFixedByteSizeResults{i1}
	return mmFixedByteSize.mock
}

//Set uses given function f to mock the CloudStateHash.FixedByteSize method
func (mmFixedByteSize *mCloudStateHashMockFixedByteSize) Set(f func() (i1 int)) *CloudStateHashMock {
	if mmFixedByteSize.defaultExpectation != nil {
		mmFixedByteSize.mock.t.Fatalf("Default expectation is already set for the CloudStateHash.FixedByteSize method")
	}

	if len(mmFixedByteSize.expectations) > 0 {
		mmFixedByteSize.mock.t.Fatalf("Some expectations are already set for the CloudStateHash.FixedByteSize method")
	}

	mmFixedByteSize.mock.funcFixedByteSize = f
	return mmFixedByteSize.mock
}

// FixedByteSize implements CloudStateHash
func (mmFixedByteSize *CloudStateHashMock) FixedByteSize() (i1 int) {
	mm_atomic.AddUint64(&mmFixedByteSize.beforeFixedByteSizeCounter, 1)
	defer mm_atomic.AddUint64(&mmFixedByteSize.afterFixedByteSizeCounter, 1)

	if mmFixedByteSize.inspectFuncFixedByteSize != nil {
		mmFixedByteSize.inspectFuncFixedByteSize()
	}

	if mmFixedByteSize.FixedByteSizeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFixedByteSize.FixedByteSizeMock.defaultExpectation.Counter, 1)

		results := mmFixedByteSize.FixedByteSizeMock.defaultExpectation.results
		if results == nil {
			mmFixedByteSize.t.Fatal("No results are set for the CloudStateHashMock.FixedByteSize")
		}
		return (*results).i1
	}
	if mmFixedByteSize.funcFixedByteSize != nil {
		return mmFixedByteSize.funcFixedByteSize()
	}
	mmFixedByteSize.t.Fatalf("Unexpected call to CloudStateHashMock.FixedByteSize.")
	return
}

// FixedByteSizeAfterCounter returns a count of finished CloudStateHashMock.FixedByteSize invocations
func (mmFixedByteSize *CloudStateHashMock) FixedByteSizeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFixedByteSize.afterFixedByteSizeCounter)
}

// FixedByteSizeBeforeCounter returns a count of CloudStateHashMock.FixedByteSize invocations
func (mmFixedByteSize *CloudStateHashMock) FixedByteSizeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFixedByteSize.beforeFixedByteSizeCounter)
}

// MinimockFixedByteSizeDone returns true if the count of the FixedByteSize invocations corresponds
// the number of defined expectations
func (m *CloudStateHashMock) MinimockFixedByteSizeDone() bool {
	for _, e := range m.FixedByteSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FixedByteSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFixedByteSize != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		return false
	}
	return true
}

// MinimockFixedByteSizeInspect logs each unmet expectation
func (m *CloudStateHashMock) MinimockFixedByteSizeInspect() {
	for _, e := range m.FixedByteSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to CloudStateHashMock.FixedByteSize")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FixedByteSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		m.t.Error("Expected call to CloudStateHashMock.FixedByteSize")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFixedByteSize != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		m.t.Error("Expected call to CloudStateHashMock.FixedByteSize")
	}
}

type mCloudStateHashMockFoldToUint64 struct {
	mock               *CloudStateHashMock
	defaultExpectation *CloudStateHashMockFoldToUint64Expectation
	expectations       []*CloudStateHashMockFoldToUint64Expectation
}

// CloudStateHashMockFoldToUint64Expectation specifies expectation struct of the CloudStateHash.FoldToUint64
type CloudStateHashMockFoldToUint64Expectation struct {
	mock *CloudStateHashMock

	results *CloudStateHashMockFoldToUint64Results
	Counter uint64
}

// CloudStateHashMockFoldToUint64Results contains results of the CloudStateHash.FoldToUint64
type CloudStateHashMockFoldToUint64Results struct {
	u1 uint64
}

// Expect sets up expected params for CloudStateHash.FoldToUint64
func (mmFoldToUint64 *mCloudStateHashMockFoldToUint64) Expect() *mCloudStateHashMockFoldToUint64 {
	if mmFoldToUint64.mock.funcFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("CloudStateHashMock.FoldToUint64 mock is already set by Set")
	}

	if mmFoldToUint64.defaultExpectation == nil {
		mmFoldToUint64.defaultExpectation = &CloudStateHashMockFoldToUint64Expectation{}
	}

	return mmFoldToUint64
}

// Inspect accepts an inspector function that has same arguments as the CloudStateHash.FoldToUint64
func (mmFoldToUint64 *mCloudStateHashMockFoldToUint64) Inspect(f func()) *mCloudStateHashMockFoldToUint64 {
	if mmFoldToUint64.mock.inspectFuncFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("Inspect function is already set for CloudStateHashMock.FoldToUint64")
	}

	mmFoldToUint64.mock.inspectFuncFoldToUint64 = f

	return mmFoldToUint64
}

// Return sets up results that will be returned by CloudStateHash.FoldToUint64
func (mmFoldToUint64 *mCloudStateHashMockFoldToUint64) Return(u1 uint64) *CloudStateHashMock {
	if mmFoldToUint64.mock.funcFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("CloudStateHashMock.FoldToUint64 mock is already set by Set")
	}

	if mmFoldToUint64.defaultExpectation == nil {
		mmFoldToUint64.defaultExpectation = &CloudStateHashMockFoldToUint64Expectation{mock: mmFoldToUint64.mock}
	}
	mmFoldToUint64.defaultExpectation.results = &CloudStateHashMockFoldToUint64Results{u1}
	return mmFoldToUint64.mock
}

//Set uses given function f to mock the CloudStateHash.FoldToUint64 method
func (mmFoldToUint64 *mCloudStateHashMockFoldToUint64) Set(f func() (u1 uint64)) *CloudStateHashMock {
	if mmFoldToUint64.defaultExpectation != nil {
		mmFoldToUint64.mock.t.Fatalf("Default expectation is already set for the CloudStateHash.FoldToUint64 method")
	}

	if len(mmFoldToUint64.expectations) > 0 {
		mmFoldToUint64.mock.t.Fatalf("Some expectations are already set for the CloudStateHash.FoldToUint64 method")
	}

	mmFoldToUint64.mock.funcFoldToUint64 = f
	return mmFoldToUint64.mock
}

// FoldToUint64 implements CloudStateHash
func (mmFoldToUint64 *CloudStateHashMock) FoldToUint64() (u1 uint64) {
	mm_atomic.AddUint64(&mmFoldToUint64.beforeFoldToUint64Counter, 1)
	defer mm_atomic.AddUint64(&mmFoldToUint64.afterFoldToUint64Counter, 1)

	if mmFoldToUint64.inspectFuncFoldToUint64 != nil {
		mmFoldToUint64.inspectFuncFoldToUint64()
	}

	if mmFoldToUint64.FoldToUint64Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFoldToUint64.FoldToUint64Mock.defaultExpectation.Counter, 1)

		results := mmFoldToUint64.FoldToUint64Mock.defaultExpectation.results
		if results == nil {
			mmFoldToUint64.t.Fatal("No results are set for the CloudStateHashMock.FoldToUint64")
		}
		return (*results).u1
	}
	if mmFoldToUint64.funcFoldToUint64 != nil {
		return mmFoldToUint64.funcFoldToUint64()
	}
	mmFoldToUint64.t.Fatalf("Unexpected call to CloudStateHashMock.FoldToUint64.")
	return
}

// FoldToUint64AfterCounter returns a count of finished CloudStateHashMock.FoldToUint64 invocations
func (mmFoldToUint64 *CloudStateHashMock) FoldToUint64AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFoldToUint64.afterFoldToUint64Counter)
}

// FoldToUint64BeforeCounter returns a count of CloudStateHashMock.FoldToUint64 invocations
func (mmFoldToUint64 *CloudStateHashMock) FoldToUint64BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFoldToUint64.beforeFoldToUint64Counter)
}

// MinimockFoldToUint64Done returns true if the count of the FoldToUint64 invocations corresponds
// the number of defined expectations
func (m *CloudStateHashMock) MinimockFoldToUint64Done() bool {
	for _, e := range m.FoldToUint64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FoldToUint64Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFoldToUint64 != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		return false
	}
	return true
}

// MinimockFoldToUint64Inspect logs each unmet expectation
func (m *CloudStateHashMock) MinimockFoldToUint64Inspect() {
	for _, e := range m.FoldToUint64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to CloudStateHashMock.FoldToUint64")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FoldToUint64Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		m.t.Error("Expected call to CloudStateHashMock.FoldToUint64")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFoldToUint64 != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		m.t.Error("Expected call to CloudStateHashMock.FoldToUint64")
	}
}

type mCloudStateHashMockGetDigestMethod struct {
	mock               *CloudStateHashMock
	defaultExpectation *CloudStateHashMockGetDigestMethodExpectation
	expectations       []*CloudStateHashMockGetDigestMethodExpectation
}

// CloudStateHashMockGetDigestMethodExpectation specifies expectation struct of the CloudStateHash.GetDigestMethod
type CloudStateHashMockGetDigestMethodExpectation struct {
	mock *CloudStateHashMock

	results *CloudStateHashMockGetDigestMethodResults
	Counter uint64
}

// CloudStateHashMockGetDigestMethodResults contains results of the CloudStateHash.GetDigestMethod
type CloudStateHashMockGetDigestMethodResults struct {
	d1 cryptkit.DigestMethod
}

// Expect sets up expected params for CloudStateHash.GetDigestMethod
func (mmGetDigestMethod *mCloudStateHashMockGetDigestMethod) Expect() *mCloudStateHashMockGetDigestMethod {
	if mmGetDigestMethod.mock.funcGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("CloudStateHashMock.GetDigestMethod mock is already set by Set")
	}

	if mmGetDigestMethod.defaultExpectation == nil {
		mmGetDigestMethod.defaultExpectation = &CloudStateHashMockGetDigestMethodExpectation{}
	}

	return mmGetDigestMethod
}

// Inspect accepts an inspector function that has same arguments as the CloudStateHash.GetDigestMethod
func (mmGetDigestMethod *mCloudStateHashMockGetDigestMethod) Inspect(f func()) *mCloudStateHashMockGetDigestMethod {
	if mmGetDigestMethod.mock.inspectFuncGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("Inspect function is already set for CloudStateHashMock.GetDigestMethod")
	}

	mmGetDigestMethod.mock.inspectFuncGetDigestMethod = f

	return mmGetDigestMethod
}

// Return sets up results that will be returned by CloudStateHash.GetDigestMethod
func (mmGetDigestMethod *mCloudStateHashMockGetDigestMethod) Return(d1 cryptkit.DigestMethod) *CloudStateHashMock {
	if mmGetDigestMethod.mock.funcGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("CloudStateHashMock.GetDigestMethod mock is already set by Set")
	}

	if mmGetDigestMethod.defaultExpectation == nil {
		mmGetDigestMethod.defaultExpectation = &CloudStateHashMockGetDigestMethodExpectation{mock: mmGetDigestMethod.mock}
	}
	mmGetDigestMethod.defaultExpectation.results = &CloudStateHashMockGetDigestMethodResults{d1}
	return mmGetDigestMethod.mock
}

//Set uses given function f to mock the CloudStateHash.GetDigestMethod method
func (mmGetDigestMethod *mCloudStateHashMockGetDigestMethod) Set(f func() (d1 cryptkit.DigestMethod)) *CloudStateHashMock {
	if mmGetDigestMethod.defaultExpectation != nil {
		mmGetDigestMethod.mock.t.Fatalf("Default expectation is already set for the CloudStateHash.GetDigestMethod method")
	}

	if len(mmGetDigestMethod.expectations) > 0 {
		mmGetDigestMethod.mock.t.Fatalf("Some expectations are already set for the CloudStateHash.GetDigestMethod method")
	}

	mmGetDigestMethod.mock.funcGetDigestMethod = f
	return mmGetDigestMethod.mock
}

// GetDigestMethod implements CloudStateHash
func (mmGetDigestMethod *CloudStateHashMock) GetDigestMethod() (d1 cryptkit.DigestMethod) {
	mm_atomic.AddUint64(&mmGetDigestMethod.beforeGetDigestMethodCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDigestMethod.afterGetDigestMethodCounter, 1)

	if mmGetDigestMethod.inspectFuncGetDigestMethod != nil {
		mmGetDigestMethod.inspectFuncGetDigestMethod()
	}

	if mmGetDigestMethod.GetDigestMethodMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDigestMethod.GetDigestMethodMock.defaultExpectation.Counter, 1)

		results := mmGetDigestMethod.GetDigestMethodMock.defaultExpectation.results
		if results == nil {
			mmGetDigestMethod.t.Fatal("No results are set for the CloudStateHashMock.GetDigestMethod")
		}
		return (*results).d1
	}
	if mmGetDigestMethod.funcGetDigestMethod != nil {
		return mmGetDigestMethod.funcGetDigestMethod()
	}
	mmGetDigestMethod.t.Fatalf("Unexpected call to CloudStateHashMock.GetDigestMethod.")
	return
}

// GetDigestMethodAfterCounter returns a count of finished CloudStateHashMock.GetDigestMethod invocations
func (mmGetDigestMethod *CloudStateHashMock) GetDigestMethodAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestMethod.afterGetDigestMethodCounter)
}

// GetDigestMethodBeforeCounter returns a count of CloudStateHashMock.GetDigestMethod invocations
func (mmGetDigestMethod *CloudStateHashMock) GetDigestMethodBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestMethod.beforeGetDigestMethodCounter)
}

// MinimockGetDigestMethodDone returns true if the count of the GetDigestMethod invocations corresponds
// the number of defined expectations
func (m *CloudStateHashMock) MinimockGetDigestMethodDone() bool {
	for _, e := range m.GetDigestMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestMethod != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetDigestMethodInspect logs each unmet expectation
func (m *CloudStateHashMock) MinimockGetDigestMethodInspect() {
	for _, e := range m.GetDigestMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to CloudStateHashMock.GetDigestMethod")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		m.t.Error("Expected call to CloudStateHashMock.GetDigestMethod")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestMethod != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		m.t.Error("Expected call to CloudStateHashMock.GetDigestMethod")
	}
}

type mCloudStateHashMockRead struct {
	mock               *CloudStateHashMock
	defaultExpectation *CloudStateHashMockReadExpectation
	expectations       []*CloudStateHashMockReadExpectation

	callArgs []*CloudStateHashMockReadParams
	mutex    sync.RWMutex
}

// CloudStateHashMockReadExpectation specifies expectation struct of the CloudStateHash.Read
type CloudStateHashMockReadExpectation struct {
	mock    *CloudStateHashMock
	params  *CloudStateHashMockReadParams
	results *CloudStateHashMockReadResults
	Counter uint64
}

// CloudStateHashMockReadParams contains parameters of the CloudStateHash.Read
type CloudStateHashMockReadParams struct {
	p []byte
}

// CloudStateHashMockReadResults contains results of the CloudStateHash.Read
type CloudStateHashMockReadResults struct {
	n   int
	err error
}

// Expect sets up expected params for CloudStateHash.Read
func (mmRead *mCloudStateHashMockRead) Expect(p []byte) *mCloudStateHashMockRead {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("CloudStateHashMock.Read mock is already set by Set")
	}

	if mmRead.defaultExpectation == nil {
		mmRead.defaultExpectation = &CloudStateHashMockReadExpectation{}
	}

	mmRead.defaultExpectation.params = &CloudStateHashMockReadParams{p}
	for _, e := range mmRead.expectations {
		if minimock.Equal(e.params, mmRead.defaultExpectation.params) {
			mmRead.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRead.defaultExpectation.params)
		}
	}

	return mmRead
}

// Inspect accepts an inspector function that has same arguments as the CloudStateHash.Read
func (mmRead *mCloudStateHashMockRead) Inspect(f func(p []byte)) *mCloudStateHashMockRead {
	if mmRead.mock.inspectFuncRead != nil {
		mmRead.mock.t.Fatalf("Inspect function is already set for CloudStateHashMock.Read")
	}

	mmRead.mock.inspectFuncRead = f

	return mmRead
}

// Return sets up results that will be returned by CloudStateHash.Read
func (mmRead *mCloudStateHashMockRead) Return(n int, err error) *CloudStateHashMock {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("CloudStateHashMock.Read mock is already set by Set")
	}

	if mmRead.defaultExpectation == nil {
		mmRead.defaultExpectation = &CloudStateHashMockReadExpectation{mock: mmRead.mock}
	}
	mmRead.defaultExpectation.results = &CloudStateHashMockReadResults{n, err}
	return mmRead.mock
}

//Set uses given function f to mock the CloudStateHash.Read method
func (mmRead *mCloudStateHashMockRead) Set(f func(p []byte) (n int, err error)) *CloudStateHashMock {
	if mmRead.defaultExpectation != nil {
		mmRead.mock.t.Fatalf("Default expectation is already set for the CloudStateHash.Read method")
	}

	if len(mmRead.expectations) > 0 {
		mmRead.mock.t.Fatalf("Some expectations are already set for the CloudStateHash.Read method")
	}

	mmRead.mock.funcRead = f
	return mmRead.mock
}

// When sets expectation for the CloudStateHash.Read which will trigger the result defined by the following
// Then helper
func (mmRead *mCloudStateHashMockRead) When(p []byte) *CloudStateHashMockReadExpectation {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("CloudStateHashMock.Read mock is already set by Set")
	}

	expectation := &CloudStateHashMockReadExpectation{
		mock:   mmRead.mock,
		params: &CloudStateHashMockReadParams{p},
	}
	mmRead.expectations = append(mmRead.expectations, expectation)
	return expectation
}

// Then sets up CloudStateHash.Read return parameters for the expectation previously defined by the When method
func (e *CloudStateHashMockReadExpectation) Then(n int, err error) *CloudStateHashMock {
	e.results = &CloudStateHashMockReadResults{n, err}
	return e.mock
}

// Read implements CloudStateHash
func (mmRead *CloudStateHashMock) Read(p []byte) (n int, err error) {
	mm_atomic.AddUint64(&mmRead.beforeReadCounter, 1)
	defer mm_atomic.AddUint64(&mmRead.afterReadCounter, 1)

	if mmRead.inspectFuncRead != nil {
		mmRead.inspectFuncRead(p)
	}

	params := &CloudStateHashMockReadParams{p}

	// Record call args
	mmRead.ReadMock.mutex.Lock()
	mmRead.ReadMock.callArgs = append(mmRead.ReadMock.callArgs, params)
	mmRead.ReadMock.mutex.Unlock()

	for _, e := range mmRead.ReadMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmRead.ReadMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRead.ReadMock.defaultExpectation.Counter, 1)
		want := mmRead.ReadMock.defaultExpectation.params
		got := CloudStateHashMockReadParams{p}
		if want != nil && !minimock.Equal(*want, got) {
			mmRead.t.Errorf("CloudStateHashMock.Read got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmRead.ReadMock.defaultExpectation.results
		if results == nil {
			mmRead.t.Fatal("No results are set for the CloudStateHashMock.Read")
		}
		return (*results).n, (*results).err
	}
	if mmRead.funcRead != nil {
		return mmRead.funcRead(p)
	}
	mmRead.t.Fatalf("Unexpected call to CloudStateHashMock.Read. %v", p)
	return
}

// ReadAfterCounter returns a count of finished CloudStateHashMock.Read invocations
func (mmRead *CloudStateHashMock) ReadAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRead.afterReadCounter)
}

// ReadBeforeCounter returns a count of CloudStateHashMock.Read invocations
func (mmRead *CloudStateHashMock) ReadBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRead.beforeReadCounter)
}

// Calls returns a list of arguments used in each call to CloudStateHashMock.Read.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRead *mCloudStateHashMockRead) Calls() []*CloudStateHashMockReadParams {
	mmRead.mutex.RLock()

	argCopy := make([]*CloudStateHashMockReadParams, len(mmRead.callArgs))
	copy(argCopy, mmRead.callArgs)

	mmRead.mutex.RUnlock()

	return argCopy
}

// MinimockReadDone returns true if the count of the Read invocations corresponds
// the number of defined expectations
func (m *CloudStateHashMock) MinimockReadDone() bool {
	for _, e := range m.ReadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRead != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		return false
	}
	return true
}

// MinimockReadInspect logs each unmet expectation
func (m *CloudStateHashMock) MinimockReadInspect() {
	for _, e := range m.ReadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CloudStateHashMock.Read with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		if m.ReadMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CloudStateHashMock.Read")
		} else {
			m.t.Errorf("Expected call to CloudStateHashMock.Read with params: %#v", *m.ReadMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRead != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		m.t.Error("Expected call to CloudStateHashMock.Read")
	}
}

type mCloudStateHashMockSignWith struct {
	mock               *CloudStateHashMock
	defaultExpectation *CloudStateHashMockSignWithExpectation
	expectations       []*CloudStateHashMockSignWithExpectation

	callArgs []*CloudStateHashMockSignWithParams
	mutex    sync.RWMutex
}

// CloudStateHashMockSignWithExpectation specifies expectation struct of the CloudStateHash.SignWith
type CloudStateHashMockSignWithExpectation struct {
	mock    *CloudStateHashMock
	params  *CloudStateHashMockSignWithParams
	results *CloudStateHashMockSignWithResults
	Counter uint64
}

// CloudStateHashMockSignWithParams contains parameters of the CloudStateHash.SignWith
type CloudStateHashMockSignWithParams struct {
	signer cryptkit.DigestSigner
}

// CloudStateHashMockSignWithResults contains results of the CloudStateHash.SignWith
type CloudStateHashMockSignWithResults struct {
	s1 cryptkit.SignedDigestHolder
}

// Expect sets up expected params for CloudStateHash.SignWith
func (mmSignWith *mCloudStateHashMockSignWith) Expect(signer cryptkit.DigestSigner) *mCloudStateHashMockSignWith {
	if mmSignWith.mock.funcSignWith != nil {
		mmSignWith.mock.t.Fatalf("CloudStateHashMock.SignWith mock is already set by Set")
	}

	if mmSignWith.defaultExpectation == nil {
		mmSignWith.defaultExpectation = &CloudStateHashMockSignWithExpectation{}
	}

	mmSignWith.defaultExpectation.params = &CloudStateHashMockSignWithParams{signer}
	for _, e := range mmSignWith.expectations {
		if minimock.Equal(e.params, mmSignWith.defaultExpectation.params) {
			mmSignWith.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSignWith.defaultExpectation.params)
		}
	}

	return mmSignWith
}

// Inspect accepts an inspector function that has same arguments as the CloudStateHash.SignWith
func (mmSignWith *mCloudStateHashMockSignWith) Inspect(f func(signer cryptkit.DigestSigner)) *mCloudStateHashMockSignWith {
	if mmSignWith.mock.inspectFuncSignWith != nil {
		mmSignWith.mock.t.Fatalf("Inspect function is already set for CloudStateHashMock.SignWith")
	}

	mmSignWith.mock.inspectFuncSignWith = f

	return mmSignWith
}

// Return sets up results that will be returned by CloudStateHash.SignWith
func (mmSignWith *mCloudStateHashMockSignWith) Return(s1 cryptkit.SignedDigestHolder) *CloudStateHashMock {
	if mmSignWith.mock.funcSignWith != nil {
		mmSignWith.mock.t.Fatalf("CloudStateHashMock.SignWith mock is already set by Set")
	}

	if mmSignWith.defaultExpectation == nil {
		mmSignWith.defaultExpectation = &CloudStateHashMockSignWithExpectation{mock: mmSignWith.mock}
	}
	mmSignWith.defaultExpectation.results = &CloudStateHashMockSignWithResults{s1}
	return mmSignWith.mock
}

//Set uses given function f to mock the CloudStateHash.SignWith method
func (mmSignWith *mCloudStateHashMockSignWith) Set(f func(signer cryptkit.DigestSigner) (s1 cryptkit.SignedDigestHolder)) *CloudStateHashMock {
	if mmSignWith.defaultExpectation != nil {
		mmSignWith.mock.t.Fatalf("Default expectation is already set for the CloudStateHash.SignWith method")
	}

	if len(mmSignWith.expectations) > 0 {
		mmSignWith.mock.t.Fatalf("Some expectations are already set for the CloudStateHash.SignWith method")
	}

	mmSignWith.mock.funcSignWith = f
	return mmSignWith.mock
}

// When sets expectation for the CloudStateHash.SignWith which will trigger the result defined by the following
// Then helper
func (mmSignWith *mCloudStateHashMockSignWith) When(signer cryptkit.DigestSigner) *CloudStateHashMockSignWithExpectation {
	if mmSignWith.mock.funcSignWith != nil {
		mmSignWith.mock.t.Fatalf("CloudStateHashMock.SignWith mock is already set by Set")
	}

	expectation := &CloudStateHashMockSignWithExpectation{
		mock:   mmSignWith.mock,
		params: &CloudStateHashMockSignWithParams{signer},
	}
	mmSignWith.expectations = append(mmSignWith.expectations, expectation)
	return expectation
}

// Then sets up CloudStateHash.SignWith return parameters for the expectation previously defined by the When method
func (e *CloudStateHashMockSignWithExpectation) Then(s1 cryptkit.SignedDigestHolder) *CloudStateHashMock {
	e.results = &CloudStateHashMockSignWithResults{s1}
	return e.mock
}

// SignWith implements CloudStateHash
func (mmSignWith *CloudStateHashMock) SignWith(signer cryptkit.DigestSigner) (s1 cryptkit.SignedDigestHolder) {
	mm_atomic.AddUint64(&mmSignWith.beforeSignWithCounter, 1)
	defer mm_atomic.AddUint64(&mmSignWith.afterSignWithCounter, 1)

	if mmSignWith.inspectFuncSignWith != nil {
		mmSignWith.inspectFuncSignWith(signer)
	}

	params := &CloudStateHashMockSignWithParams{signer}

	// Record call args
	mmSignWith.SignWithMock.mutex.Lock()
	mmSignWith.SignWithMock.callArgs = append(mmSignWith.SignWithMock.callArgs, params)
	mmSignWith.SignWithMock.mutex.Unlock()

	for _, e := range mmSignWith.SignWithMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmSignWith.SignWithMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSignWith.SignWithMock.defaultExpectation.Counter, 1)
		want := mmSignWith.SignWithMock.defaultExpectation.params
		got := CloudStateHashMockSignWithParams{signer}
		if want != nil && !minimock.Equal(*want, got) {
			mmSignWith.t.Errorf("CloudStateHashMock.SignWith got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmSignWith.SignWithMock.defaultExpectation.results
		if results == nil {
			mmSignWith.t.Fatal("No results are set for the CloudStateHashMock.SignWith")
		}
		return (*results).s1
	}
	if mmSignWith.funcSignWith != nil {
		return mmSignWith.funcSignWith(signer)
	}
	mmSignWith.t.Fatalf("Unexpected call to CloudStateHashMock.SignWith. %v", signer)
	return
}

// SignWithAfterCounter returns a count of finished CloudStateHashMock.SignWith invocations
func (mmSignWith *CloudStateHashMock) SignWithAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSignWith.afterSignWithCounter)
}

// SignWithBeforeCounter returns a count of CloudStateHashMock.SignWith invocations
func (mmSignWith *CloudStateHashMock) SignWithBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSignWith.beforeSignWithCounter)
}

// Calls returns a list of arguments used in each call to CloudStateHashMock.SignWith.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSignWith *mCloudStateHashMockSignWith) Calls() []*CloudStateHashMockSignWithParams {
	mmSignWith.mutex.RLock()

	argCopy := make([]*CloudStateHashMockSignWithParams, len(mmSignWith.callArgs))
	copy(argCopy, mmSignWith.callArgs)

	mmSignWith.mutex.RUnlock()

	return argCopy
}

// MinimockSignWithDone returns true if the count of the SignWith invocations corresponds
// the number of defined expectations
func (m *CloudStateHashMock) MinimockSignWithDone() bool {
	for _, e := range m.SignWithMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SignWithMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSignWithCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSignWith != nil && mm_atomic.LoadUint64(&m.afterSignWithCounter) < 1 {
		return false
	}
	return true
}

// MinimockSignWithInspect logs each unmet expectation
func (m *CloudStateHashMock) MinimockSignWithInspect() {
	for _, e := range m.SignWithMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CloudStateHashMock.SignWith with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SignWithMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSignWithCounter) < 1 {
		if m.SignWithMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CloudStateHashMock.SignWith")
		} else {
			m.t.Errorf("Expected call to CloudStateHashMock.SignWith with params: %#v", *m.SignWithMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSignWith != nil && mm_atomic.LoadUint64(&m.afterSignWithCounter) < 1 {
		m.t.Error("Expected call to CloudStateHashMock.SignWith")
	}
}

type mCloudStateHashMockWriteTo struct {
	mock               *CloudStateHashMock
	defaultExpectation *CloudStateHashMockWriteToExpectation
	expectations       []*CloudStateHashMockWriteToExpectation

	callArgs []*CloudStateHashMockWriteToParams
	mutex    sync.RWMutex
}

// CloudStateHashMockWriteToExpectation specifies expectation struct of the CloudStateHash.WriteTo
type CloudStateHashMockWriteToExpectation struct {
	mock    *CloudStateHashMock
	params  *CloudStateHashMockWriteToParams
	results *CloudStateHashMockWriteToResults
	Counter uint64
}

// CloudStateHashMockWriteToParams contains parameters of the CloudStateHash.WriteTo
type CloudStateHashMockWriteToParams struct {
	w io.Writer
}

// CloudStateHashMockWriteToResults contains results of the CloudStateHash.WriteTo
type CloudStateHashMockWriteToResults struct {
	n   int64
	err error
}

// Expect sets up expected params for CloudStateHash.WriteTo
func (mmWriteTo *mCloudStateHashMockWriteTo) Expect(w io.Writer) *mCloudStateHashMockWriteTo {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("CloudStateHashMock.WriteTo mock is already set by Set")
	}

	if mmWriteTo.defaultExpectation == nil {
		mmWriteTo.defaultExpectation = &CloudStateHashMockWriteToExpectation{}
	}

	mmWriteTo.defaultExpectation.params = &CloudStateHashMockWriteToParams{w}
	for _, e := range mmWriteTo.expectations {
		if minimock.Equal(e.params, mmWriteTo.defaultExpectation.params) {
			mmWriteTo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWriteTo.defaultExpectation.params)
		}
	}

	return mmWriteTo
}

// Inspect accepts an inspector function that has same arguments as the CloudStateHash.WriteTo
func (mmWriteTo *mCloudStateHashMockWriteTo) Inspect(f func(w io.Writer)) *mCloudStateHashMockWriteTo {
	if mmWriteTo.mock.inspectFuncWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("Inspect function is already set for CloudStateHashMock.WriteTo")
	}

	mmWriteTo.mock.inspectFuncWriteTo = f

	return mmWriteTo
}

// Return sets up results that will be returned by CloudStateHash.WriteTo
func (mmWriteTo *mCloudStateHashMockWriteTo) Return(n int64, err error) *CloudStateHashMock {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("CloudStateHashMock.WriteTo mock is already set by Set")
	}

	if mmWriteTo.defaultExpectation == nil {
		mmWriteTo.defaultExpectation = &CloudStateHashMockWriteToExpectation{mock: mmWriteTo.mock}
	}
	mmWriteTo.defaultExpectation.results = &CloudStateHashMockWriteToResults{n, err}
	return mmWriteTo.mock
}

//Set uses given function f to mock the CloudStateHash.WriteTo method
func (mmWriteTo *mCloudStateHashMockWriteTo) Set(f func(w io.Writer) (n int64, err error)) *CloudStateHashMock {
	if mmWriteTo.defaultExpectation != nil {
		mmWriteTo.mock.t.Fatalf("Default expectation is already set for the CloudStateHash.WriteTo method")
	}

	if len(mmWriteTo.expectations) > 0 {
		mmWriteTo.mock.t.Fatalf("Some expectations are already set for the CloudStateHash.WriteTo method")
	}

	mmWriteTo.mock.funcWriteTo = f
	return mmWriteTo.mock
}

// When sets expectation for the CloudStateHash.WriteTo which will trigger the result defined by the following
// Then helper
func (mmWriteTo *mCloudStateHashMockWriteTo) When(w io.Writer) *CloudStateHashMockWriteToExpectation {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("CloudStateHashMock.WriteTo mock is already set by Set")
	}

	expectation := &CloudStateHashMockWriteToExpectation{
		mock:   mmWriteTo.mock,
		params: &CloudStateHashMockWriteToParams{w},
	}
	mmWriteTo.expectations = append(mmWriteTo.expectations, expectation)
	return expectation
}

// Then sets up CloudStateHash.WriteTo return parameters for the expectation previously defined by the When method
func (e *CloudStateHashMockWriteToExpectation) Then(n int64, err error) *CloudStateHashMock {
	e.results = &CloudStateHashMockWriteToResults{n, err}
	return e.mock
}

// WriteTo implements CloudStateHash
func (mmWriteTo *CloudStateHashMock) WriteTo(w io.Writer) (n int64, err error) {
	mm_atomic.AddUint64(&mmWriteTo.beforeWriteToCounter, 1)
	defer mm_atomic.AddUint64(&mmWriteTo.afterWriteToCounter, 1)

	if mmWriteTo.inspectFuncWriteTo != nil {
		mmWriteTo.inspectFuncWriteTo(w)
	}

	params := &CloudStateHashMockWriteToParams{w}

	// Record call args
	mmWriteTo.WriteToMock.mutex.Lock()
	mmWriteTo.WriteToMock.callArgs = append(mmWriteTo.WriteToMock.callArgs, params)
	mmWriteTo.WriteToMock.mutex.Unlock()

	for _, e := range mmWriteTo.WriteToMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmWriteTo.WriteToMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWriteTo.WriteToMock.defaultExpectation.Counter, 1)
		want := mmWriteTo.WriteToMock.defaultExpectation.params
		got := CloudStateHashMockWriteToParams{w}
		if want != nil && !minimock.Equal(*want, got) {
			mmWriteTo.t.Errorf("CloudStateHashMock.WriteTo got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmWriteTo.WriteToMock.defaultExpectation.results
		if results == nil {
			mmWriteTo.t.Fatal("No results are set for the CloudStateHashMock.WriteTo")
		}
		return (*results).n, (*results).err
	}
	if mmWriteTo.funcWriteTo != nil {
		return mmWriteTo.funcWriteTo(w)
	}
	mmWriteTo.t.Fatalf("Unexpected call to CloudStateHashMock.WriteTo. %v", w)
	return
}

// WriteToAfterCounter returns a count of finished CloudStateHashMock.WriteTo invocations
func (mmWriteTo *CloudStateHashMock) WriteToAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteTo.afterWriteToCounter)
}

// WriteToBeforeCounter returns a count of CloudStateHashMock.WriteTo invocations
func (mmWriteTo *CloudStateHashMock) WriteToBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteTo.beforeWriteToCounter)
}

// Calls returns a list of arguments used in each call to CloudStateHashMock.WriteTo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWriteTo *mCloudStateHashMockWriteTo) Calls() []*CloudStateHashMockWriteToParams {
	mmWriteTo.mutex.RLock()

	argCopy := make([]*CloudStateHashMockWriteToParams, len(mmWriteTo.callArgs))
	copy(argCopy, mmWriteTo.callArgs)

	mmWriteTo.mutex.RUnlock()

	return argCopy
}

// MinimockWriteToDone returns true if the count of the WriteTo invocations corresponds
// the number of defined expectations
func (m *CloudStateHashMock) MinimockWriteToDone() bool {
	for _, e := range m.WriteToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteTo != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		return false
	}
	return true
}

// MinimockWriteToInspect logs each unmet expectation
func (m *CloudStateHashMock) MinimockWriteToInspect() {
	for _, e := range m.WriteToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CloudStateHashMock.WriteTo with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		if m.WriteToMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CloudStateHashMock.WriteTo")
		} else {
			m.t.Errorf("Expected call to CloudStateHashMock.WriteTo with params: %#v", *m.WriteToMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteTo != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		m.t.Error("Expected call to CloudStateHashMock.WriteTo")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CloudStateHashMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAsByteStringInspect()

		m.MinimockAsBytesInspect()

		m.MinimockCopyOfDigestInspect()

		m.MinimockEqualsInspect()

		m.MinimockFixedByteSizeInspect()

		m.MinimockFoldToUint64Inspect()

		m.MinimockGetDigestMethodInspect()

		m.MinimockReadInspect()

		m.MinimockSignWithInspect()

		m.MinimockWriteToInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CloudStateHashMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CloudStateHashMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAsByteStringDone() &&
		m.MinimockAsBytesDone() &&
		m.MinimockCopyOfDigestDone() &&
		m.MinimockEqualsDone() &&
		m.MinimockFixedByteSizeDone() &&
		m.MinimockFoldToUint64Done() &&
		m.MinimockGetDigestMethodDone() &&
		m.MinimockReadDone() &&
		m.MinimockSignWithDone() &&
		m.MinimockWriteToDone()
}
