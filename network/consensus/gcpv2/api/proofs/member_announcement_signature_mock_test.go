package proofs

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	io "io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/longbits"
	"github.com/insolar/insolar/network/consensus/common/cryptkit"
)

// MemberAnnouncementSignatureMock implements MemberAnnouncementSignature
type MemberAnnouncementSignatureMock struct {
	t minimock.Tester

	funcAsByteString          func() (b1 longbits.ByteString)
	inspectFuncAsByteString   func()
	afterAsByteStringCounter  uint64
	beforeAsByteStringCounter uint64
	AsByteStringMock          mMemberAnnouncementSignatureMockAsByteString

	funcAsBytes          func() (ba1 []byte)
	inspectFuncAsBytes   func()
	afterAsBytesCounter  uint64
	beforeAsBytesCounter uint64
	AsBytesMock          mMemberAnnouncementSignatureMockAsBytes

	funcCopyOfSignature          func() (s1 cryptkit.Signature)
	inspectFuncCopyOfSignature   func()
	afterCopyOfSignatureCounter  uint64
	beforeCopyOfSignatureCounter uint64
	CopyOfSignatureMock          mMemberAnnouncementSignatureMockCopyOfSignature

	funcEquals          func(other cryptkit.SignatureHolder) (b1 bool)
	inspectFuncEquals   func(other cryptkit.SignatureHolder)
	afterEqualsCounter  uint64
	beforeEqualsCounter uint64
	EqualsMock          mMemberAnnouncementSignatureMockEquals

	funcFixedByteSize          func() (i1 int)
	inspectFuncFixedByteSize   func()
	afterFixedByteSizeCounter  uint64
	beforeFixedByteSizeCounter uint64
	FixedByteSizeMock          mMemberAnnouncementSignatureMockFixedByteSize

	funcFoldToUint64          func() (u1 uint64)
	inspectFuncFoldToUint64   func()
	afterFoldToUint64Counter  uint64
	beforeFoldToUint64Counter uint64
	FoldToUint64Mock          mMemberAnnouncementSignatureMockFoldToUint64

	funcGetSignatureMethod          func() (s1 cryptkit.SignatureMethod)
	inspectFuncGetSignatureMethod   func()
	afterGetSignatureMethodCounter  uint64
	beforeGetSignatureMethodCounter uint64
	GetSignatureMethodMock          mMemberAnnouncementSignatureMockGetSignatureMethod

	funcRead          func(p []byte) (n int, err error)
	inspectFuncRead   func(p []byte)
	afterReadCounter  uint64
	beforeReadCounter uint64
	ReadMock          mMemberAnnouncementSignatureMockRead

	funcWriteTo          func(w io.Writer) (n int64, err error)
	inspectFuncWriteTo   func(w io.Writer)
	afterWriteToCounter  uint64
	beforeWriteToCounter uint64
	WriteToMock          mMemberAnnouncementSignatureMockWriteTo
}

// NewMemberAnnouncementSignatureMock returns a mock for MemberAnnouncementSignature
func NewMemberAnnouncementSignatureMock(t minimock.Tester) *MemberAnnouncementSignatureMock {
	m := &MemberAnnouncementSignatureMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AsByteStringMock = mMemberAnnouncementSignatureMockAsByteString{mock: m}

	m.AsBytesMock = mMemberAnnouncementSignatureMockAsBytes{mock: m}

	m.CopyOfSignatureMock = mMemberAnnouncementSignatureMockCopyOfSignature{mock: m}

	m.EqualsMock = mMemberAnnouncementSignatureMockEquals{mock: m}
	m.EqualsMock.callArgs = []*MemberAnnouncementSignatureMockEqualsParams{}

	m.FixedByteSizeMock = mMemberAnnouncementSignatureMockFixedByteSize{mock: m}

	m.FoldToUint64Mock = mMemberAnnouncementSignatureMockFoldToUint64{mock: m}

	m.GetSignatureMethodMock = mMemberAnnouncementSignatureMockGetSignatureMethod{mock: m}

	m.ReadMock = mMemberAnnouncementSignatureMockRead{mock: m}
	m.ReadMock.callArgs = []*MemberAnnouncementSignatureMockReadParams{}

	m.WriteToMock = mMemberAnnouncementSignatureMockWriteTo{mock: m}
	m.WriteToMock.callArgs = []*MemberAnnouncementSignatureMockWriteToParams{}

	return m
}

type mMemberAnnouncementSignatureMockAsByteString struct {
	mock               *MemberAnnouncementSignatureMock
	defaultExpectation *MemberAnnouncementSignatureMockAsByteStringExpectation
	expectations       []*MemberAnnouncementSignatureMockAsByteStringExpectation
}

// MemberAnnouncementSignatureMockAsByteStringExpectation specifies expectation struct of the MemberAnnouncementSignature.AsByteString
type MemberAnnouncementSignatureMockAsByteStringExpectation struct {
	mock *MemberAnnouncementSignatureMock

	results *MemberAnnouncementSignatureMockAsByteStringResults
	Counter uint64
}

// MemberAnnouncementSignatureMockAsByteStringResults contains results of the MemberAnnouncementSignature.AsByteString
type MemberAnnouncementSignatureMockAsByteStringResults struct {
	b1 longbits.ByteString
}

// Expect sets up expected params for MemberAnnouncementSignature.AsByteString
func (mmAsByteString *mMemberAnnouncementSignatureMockAsByteString) Expect() *mMemberAnnouncementSignatureMockAsByteString {
	if mmAsByteString.mock.funcAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("MemberAnnouncementSignatureMock.AsByteString mock is already set by Set")
	}

	if mmAsByteString.defaultExpectation == nil {
		mmAsByteString.defaultExpectation = &MemberAnnouncementSignatureMockAsByteStringExpectation{}
	}

	return mmAsByteString
}

// Inspect accepts an inspector function that has same arguments as the MemberAnnouncementSignature.AsByteString
func (mmAsByteString *mMemberAnnouncementSignatureMockAsByteString) Inspect(f func()) *mMemberAnnouncementSignatureMockAsByteString {
	if mmAsByteString.mock.inspectFuncAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("Inspect function is already set for MemberAnnouncementSignatureMock.AsByteString")
	}

	mmAsByteString.mock.inspectFuncAsByteString = f

	return mmAsByteString
}

// Return sets up results that will be returned by MemberAnnouncementSignature.AsByteString
func (mmAsByteString *mMemberAnnouncementSignatureMockAsByteString) Return(b1 longbits.ByteString) *MemberAnnouncementSignatureMock {
	if mmAsByteString.mock.funcAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("MemberAnnouncementSignatureMock.AsByteString mock is already set by Set")
	}

	if mmAsByteString.defaultExpectation == nil {
		mmAsByteString.defaultExpectation = &MemberAnnouncementSignatureMockAsByteStringExpectation{mock: mmAsByteString.mock}
	}
	mmAsByteString.defaultExpectation.results = &MemberAnnouncementSignatureMockAsByteStringResults{b1}
	return mmAsByteString.mock
}

//Set uses given function f to mock the MemberAnnouncementSignature.AsByteString method
func (mmAsByteString *mMemberAnnouncementSignatureMockAsByteString) Set(f func() (b1 longbits.ByteString)) *MemberAnnouncementSignatureMock {
	if mmAsByteString.defaultExpectation != nil {
		mmAsByteString.mock.t.Fatalf("Default expectation is already set for the MemberAnnouncementSignature.AsByteString method")
	}

	if len(mmAsByteString.expectations) > 0 {
		mmAsByteString.mock.t.Fatalf("Some expectations are already set for the MemberAnnouncementSignature.AsByteString method")
	}

	mmAsByteString.mock.funcAsByteString = f
	return mmAsByteString.mock
}

// AsByteString implements MemberAnnouncementSignature
func (mmAsByteString *MemberAnnouncementSignatureMock) AsByteString() (b1 longbits.ByteString) {
	mm_atomic.AddUint64(&mmAsByteString.beforeAsByteStringCounter, 1)
	defer mm_atomic.AddUint64(&mmAsByteString.afterAsByteStringCounter, 1)

	if mmAsByteString.inspectFuncAsByteString != nil {
		mmAsByteString.inspectFuncAsByteString()
	}

	if mmAsByteString.AsByteStringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAsByteString.AsByteStringMock.defaultExpectation.Counter, 1)

		results := mmAsByteString.AsByteStringMock.defaultExpectation.results
		if results == nil {
			mmAsByteString.t.Fatal("No results are set for the MemberAnnouncementSignatureMock.AsByteString")
		}
		return (*results).b1
	}
	if mmAsByteString.funcAsByteString != nil {
		return mmAsByteString.funcAsByteString()
	}
	mmAsByteString.t.Fatalf("Unexpected call to MemberAnnouncementSignatureMock.AsByteString.")
	return
}

// AsByteStringAfterCounter returns a count of finished MemberAnnouncementSignatureMock.AsByteString invocations
func (mmAsByteString *MemberAnnouncementSignatureMock) AsByteStringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsByteString.afterAsByteStringCounter)
}

// AsByteStringBeforeCounter returns a count of MemberAnnouncementSignatureMock.AsByteString invocations
func (mmAsByteString *MemberAnnouncementSignatureMock) AsByteStringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsByteString.beforeAsByteStringCounter)
}

// MinimockAsByteStringDone returns true if the count of the AsByteString invocations corresponds
// the number of defined expectations
func (m *MemberAnnouncementSignatureMock) MinimockAsByteStringDone() bool {
	for _, e := range m.AsByteStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsByteStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsByteString != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		return false
	}
	return true
}

// MinimockAsByteStringInspect logs each unmet expectation
func (m *MemberAnnouncementSignatureMock) MinimockAsByteStringInspect() {
	for _, e := range m.AsByteStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MemberAnnouncementSignatureMock.AsByteString")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsByteStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		m.t.Error("Expected call to MemberAnnouncementSignatureMock.AsByteString")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsByteString != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		m.t.Error("Expected call to MemberAnnouncementSignatureMock.AsByteString")
	}
}

type mMemberAnnouncementSignatureMockAsBytes struct {
	mock               *MemberAnnouncementSignatureMock
	defaultExpectation *MemberAnnouncementSignatureMockAsBytesExpectation
	expectations       []*MemberAnnouncementSignatureMockAsBytesExpectation
}

// MemberAnnouncementSignatureMockAsBytesExpectation specifies expectation struct of the MemberAnnouncementSignature.AsBytes
type MemberAnnouncementSignatureMockAsBytesExpectation struct {
	mock *MemberAnnouncementSignatureMock

	results *MemberAnnouncementSignatureMockAsBytesResults
	Counter uint64
}

// MemberAnnouncementSignatureMockAsBytesResults contains results of the MemberAnnouncementSignature.AsBytes
type MemberAnnouncementSignatureMockAsBytesResults struct {
	ba1 []byte
}

// Expect sets up expected params for MemberAnnouncementSignature.AsBytes
func (mmAsBytes *mMemberAnnouncementSignatureMockAsBytes) Expect() *mMemberAnnouncementSignatureMockAsBytes {
	if mmAsBytes.mock.funcAsBytes != nil {
		mmAsBytes.mock.t.Fatalf("MemberAnnouncementSignatureMock.AsBytes mock is already set by Set")
	}

	if mmAsBytes.defaultExpectation == nil {
		mmAsBytes.defaultExpectation = &MemberAnnouncementSignatureMockAsBytesExpectation{}
	}

	return mmAsBytes
}

// Inspect accepts an inspector function that has same arguments as the MemberAnnouncementSignature.AsBytes
func (mmAsBytes *mMemberAnnouncementSignatureMockAsBytes) Inspect(f func()) *mMemberAnnouncementSignatureMockAsBytes {
	if mmAsBytes.mock.inspectFuncAsBytes != nil {
		mmAsBytes.mock.t.Fatalf("Inspect function is already set for MemberAnnouncementSignatureMock.AsBytes")
	}

	mmAsBytes.mock.inspectFuncAsBytes = f

	return mmAsBytes
}

// Return sets up results that will be returned by MemberAnnouncementSignature.AsBytes
func (mmAsBytes *mMemberAnnouncementSignatureMockAsBytes) Return(ba1 []byte) *MemberAnnouncementSignatureMock {
	if mmAsBytes.mock.funcAsBytes != nil {
		mmAsBytes.mock.t.Fatalf("MemberAnnouncementSignatureMock.AsBytes mock is already set by Set")
	}

	if mmAsBytes.defaultExpectation == nil {
		mmAsBytes.defaultExpectation = &MemberAnnouncementSignatureMockAsBytesExpectation{mock: mmAsBytes.mock}
	}
	mmAsBytes.defaultExpectation.results = &MemberAnnouncementSignatureMockAsBytesResults{ba1}
	return mmAsBytes.mock
}

//Set uses given function f to mock the MemberAnnouncementSignature.AsBytes method
func (mmAsBytes *mMemberAnnouncementSignatureMockAsBytes) Set(f func() (ba1 []byte)) *MemberAnnouncementSignatureMock {
	if mmAsBytes.defaultExpectation != nil {
		mmAsBytes.mock.t.Fatalf("Default expectation is already set for the MemberAnnouncementSignature.AsBytes method")
	}

	if len(mmAsBytes.expectations) > 0 {
		mmAsBytes.mock.t.Fatalf("Some expectations are already set for the MemberAnnouncementSignature.AsBytes method")
	}

	mmAsBytes.mock.funcAsBytes = f
	return mmAsBytes.mock
}

// AsBytes implements MemberAnnouncementSignature
func (mmAsBytes *MemberAnnouncementSignatureMock) AsBytes() (ba1 []byte) {
	mm_atomic.AddUint64(&mmAsBytes.beforeAsBytesCounter, 1)
	defer mm_atomic.AddUint64(&mmAsBytes.afterAsBytesCounter, 1)

	if mmAsBytes.inspectFuncAsBytes != nil {
		mmAsBytes.inspectFuncAsBytes()
	}

	if mmAsBytes.AsBytesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAsBytes.AsBytesMock.defaultExpectation.Counter, 1)

		results := mmAsBytes.AsBytesMock.defaultExpectation.results
		if results == nil {
			mmAsBytes.t.Fatal("No results are set for the MemberAnnouncementSignatureMock.AsBytes")
		}
		return (*results).ba1
	}
	if mmAsBytes.funcAsBytes != nil {
		return mmAsBytes.funcAsBytes()
	}
	mmAsBytes.t.Fatalf("Unexpected call to MemberAnnouncementSignatureMock.AsBytes.")
	return
}

// AsBytesAfterCounter returns a count of finished MemberAnnouncementSignatureMock.AsBytes invocations
func (mmAsBytes *MemberAnnouncementSignatureMock) AsBytesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsBytes.afterAsBytesCounter)
}

// AsBytesBeforeCounter returns a count of MemberAnnouncementSignatureMock.AsBytes invocations
func (mmAsBytes *MemberAnnouncementSignatureMock) AsBytesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsBytes.beforeAsBytesCounter)
}

// MinimockAsBytesDone returns true if the count of the AsBytes invocations corresponds
// the number of defined expectations
func (m *MemberAnnouncementSignatureMock) MinimockAsBytesDone() bool {
	for _, e := range m.AsBytesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsBytesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsBytesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsBytes != nil && mm_atomic.LoadUint64(&m.afterAsBytesCounter) < 1 {
		return false
	}
	return true
}

// MinimockAsBytesInspect logs each unmet expectation
func (m *MemberAnnouncementSignatureMock) MinimockAsBytesInspect() {
	for _, e := range m.AsBytesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MemberAnnouncementSignatureMock.AsBytes")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsBytesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsBytesCounter) < 1 {
		m.t.Error("Expected call to MemberAnnouncementSignatureMock.AsBytes")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsBytes != nil && mm_atomic.LoadUint64(&m.afterAsBytesCounter) < 1 {
		m.t.Error("Expected call to MemberAnnouncementSignatureMock.AsBytes")
	}
}

type mMemberAnnouncementSignatureMockCopyOfSignature struct {
	mock               *MemberAnnouncementSignatureMock
	defaultExpectation *MemberAnnouncementSignatureMockCopyOfSignatureExpectation
	expectations       []*MemberAnnouncementSignatureMockCopyOfSignatureExpectation
}

// MemberAnnouncementSignatureMockCopyOfSignatureExpectation specifies expectation struct of the MemberAnnouncementSignature.CopyOfSignature
type MemberAnnouncementSignatureMockCopyOfSignatureExpectation struct {
	mock *MemberAnnouncementSignatureMock

	results *MemberAnnouncementSignatureMockCopyOfSignatureResults
	Counter uint64
}

// MemberAnnouncementSignatureMockCopyOfSignatureResults contains results of the MemberAnnouncementSignature.CopyOfSignature
type MemberAnnouncementSignatureMockCopyOfSignatureResults struct {
	s1 cryptkit.Signature
}

// Expect sets up expected params for MemberAnnouncementSignature.CopyOfSignature
func (mmCopyOfSignature *mMemberAnnouncementSignatureMockCopyOfSignature) Expect() *mMemberAnnouncementSignatureMockCopyOfSignature {
	if mmCopyOfSignature.mock.funcCopyOfSignature != nil {
		mmCopyOfSignature.mock.t.Fatalf("MemberAnnouncementSignatureMock.CopyOfSignature mock is already set by Set")
	}

	if mmCopyOfSignature.defaultExpectation == nil {
		mmCopyOfSignature.defaultExpectation = &MemberAnnouncementSignatureMockCopyOfSignatureExpectation{}
	}

	return mmCopyOfSignature
}

// Inspect accepts an inspector function that has same arguments as the MemberAnnouncementSignature.CopyOfSignature
func (mmCopyOfSignature *mMemberAnnouncementSignatureMockCopyOfSignature) Inspect(f func()) *mMemberAnnouncementSignatureMockCopyOfSignature {
	if mmCopyOfSignature.mock.inspectFuncCopyOfSignature != nil {
		mmCopyOfSignature.mock.t.Fatalf("Inspect function is already set for MemberAnnouncementSignatureMock.CopyOfSignature")
	}

	mmCopyOfSignature.mock.inspectFuncCopyOfSignature = f

	return mmCopyOfSignature
}

// Return sets up results that will be returned by MemberAnnouncementSignature.CopyOfSignature
func (mmCopyOfSignature *mMemberAnnouncementSignatureMockCopyOfSignature) Return(s1 cryptkit.Signature) *MemberAnnouncementSignatureMock {
	if mmCopyOfSignature.mock.funcCopyOfSignature != nil {
		mmCopyOfSignature.mock.t.Fatalf("MemberAnnouncementSignatureMock.CopyOfSignature mock is already set by Set")
	}

	if mmCopyOfSignature.defaultExpectation == nil {
		mmCopyOfSignature.defaultExpectation = &MemberAnnouncementSignatureMockCopyOfSignatureExpectation{mock: mmCopyOfSignature.mock}
	}
	mmCopyOfSignature.defaultExpectation.results = &MemberAnnouncementSignatureMockCopyOfSignatureResults{s1}
	return mmCopyOfSignature.mock
}

//Set uses given function f to mock the MemberAnnouncementSignature.CopyOfSignature method
func (mmCopyOfSignature *mMemberAnnouncementSignatureMockCopyOfSignature) Set(f func() (s1 cryptkit.Signature)) *MemberAnnouncementSignatureMock {
	if mmCopyOfSignature.defaultExpectation != nil {
		mmCopyOfSignature.mock.t.Fatalf("Default expectation is already set for the MemberAnnouncementSignature.CopyOfSignature method")
	}

	if len(mmCopyOfSignature.expectations) > 0 {
		mmCopyOfSignature.mock.t.Fatalf("Some expectations are already set for the MemberAnnouncementSignature.CopyOfSignature method")
	}

	mmCopyOfSignature.mock.funcCopyOfSignature = f
	return mmCopyOfSignature.mock
}

// CopyOfSignature implements MemberAnnouncementSignature
func (mmCopyOfSignature *MemberAnnouncementSignatureMock) CopyOfSignature() (s1 cryptkit.Signature) {
	mm_atomic.AddUint64(&mmCopyOfSignature.beforeCopyOfSignatureCounter, 1)
	defer mm_atomic.AddUint64(&mmCopyOfSignature.afterCopyOfSignatureCounter, 1)

	if mmCopyOfSignature.inspectFuncCopyOfSignature != nil {
		mmCopyOfSignature.inspectFuncCopyOfSignature()
	}

	if mmCopyOfSignature.CopyOfSignatureMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCopyOfSignature.CopyOfSignatureMock.defaultExpectation.Counter, 1)

		results := mmCopyOfSignature.CopyOfSignatureMock.defaultExpectation.results
		if results == nil {
			mmCopyOfSignature.t.Fatal("No results are set for the MemberAnnouncementSignatureMock.CopyOfSignature")
		}
		return (*results).s1
	}
	if mmCopyOfSignature.funcCopyOfSignature != nil {
		return mmCopyOfSignature.funcCopyOfSignature()
	}
	mmCopyOfSignature.t.Fatalf("Unexpected call to MemberAnnouncementSignatureMock.CopyOfSignature.")
	return
}

// CopyOfSignatureAfterCounter returns a count of finished MemberAnnouncementSignatureMock.CopyOfSignature invocations
func (mmCopyOfSignature *MemberAnnouncementSignatureMock) CopyOfSignatureAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyOfSignature.afterCopyOfSignatureCounter)
}

// CopyOfSignatureBeforeCounter returns a count of MemberAnnouncementSignatureMock.CopyOfSignature invocations
func (mmCopyOfSignature *MemberAnnouncementSignatureMock) CopyOfSignatureBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyOfSignature.beforeCopyOfSignatureCounter)
}

// MinimockCopyOfSignatureDone returns true if the count of the CopyOfSignature invocations corresponds
// the number of defined expectations
func (m *MemberAnnouncementSignatureMock) MinimockCopyOfSignatureDone() bool {
	for _, e := range m.CopyOfSignatureMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyOfSignatureMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyOfSignatureCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyOfSignature != nil && mm_atomic.LoadUint64(&m.afterCopyOfSignatureCounter) < 1 {
		return false
	}
	return true
}

// MinimockCopyOfSignatureInspect logs each unmet expectation
func (m *MemberAnnouncementSignatureMock) MinimockCopyOfSignatureInspect() {
	for _, e := range m.CopyOfSignatureMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MemberAnnouncementSignatureMock.CopyOfSignature")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyOfSignatureMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyOfSignatureCounter) < 1 {
		m.t.Error("Expected call to MemberAnnouncementSignatureMock.CopyOfSignature")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyOfSignature != nil && mm_atomic.LoadUint64(&m.afterCopyOfSignatureCounter) < 1 {
		m.t.Error("Expected call to MemberAnnouncementSignatureMock.CopyOfSignature")
	}
}

type mMemberAnnouncementSignatureMockEquals struct {
	mock               *MemberAnnouncementSignatureMock
	defaultExpectation *MemberAnnouncementSignatureMockEqualsExpectation
	expectations       []*MemberAnnouncementSignatureMockEqualsExpectation

	callArgs []*MemberAnnouncementSignatureMockEqualsParams
	mutex    sync.RWMutex
}

// MemberAnnouncementSignatureMockEqualsExpectation specifies expectation struct of the MemberAnnouncementSignature.Equals
type MemberAnnouncementSignatureMockEqualsExpectation struct {
	mock    *MemberAnnouncementSignatureMock
	params  *MemberAnnouncementSignatureMockEqualsParams
	results *MemberAnnouncementSignatureMockEqualsResults
	Counter uint64
}

// MemberAnnouncementSignatureMockEqualsParams contains parameters of the MemberAnnouncementSignature.Equals
type MemberAnnouncementSignatureMockEqualsParams struct {
	other cryptkit.SignatureHolder
}

// MemberAnnouncementSignatureMockEqualsResults contains results of the MemberAnnouncementSignature.Equals
type MemberAnnouncementSignatureMockEqualsResults struct {
	b1 bool
}

// Expect sets up expected params for MemberAnnouncementSignature.Equals
func (mmEquals *mMemberAnnouncementSignatureMockEquals) Expect(other cryptkit.SignatureHolder) *mMemberAnnouncementSignatureMockEquals {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("MemberAnnouncementSignatureMock.Equals mock is already set by Set")
	}

	if mmEquals.defaultExpectation == nil {
		mmEquals.defaultExpectation = &MemberAnnouncementSignatureMockEqualsExpectation{}
	}

	mmEquals.defaultExpectation.params = &MemberAnnouncementSignatureMockEqualsParams{other}
	for _, e := range mmEquals.expectations {
		if minimock.Equal(e.params, mmEquals.defaultExpectation.params) {
			mmEquals.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEquals.defaultExpectation.params)
		}
	}

	return mmEquals
}

// Inspect accepts an inspector function that has same arguments as the MemberAnnouncementSignature.Equals
func (mmEquals *mMemberAnnouncementSignatureMockEquals) Inspect(f func(other cryptkit.SignatureHolder)) *mMemberAnnouncementSignatureMockEquals {
	if mmEquals.mock.inspectFuncEquals != nil {
		mmEquals.mock.t.Fatalf("Inspect function is already set for MemberAnnouncementSignatureMock.Equals")
	}

	mmEquals.mock.inspectFuncEquals = f

	return mmEquals
}

// Return sets up results that will be returned by MemberAnnouncementSignature.Equals
func (mmEquals *mMemberAnnouncementSignatureMockEquals) Return(b1 bool) *MemberAnnouncementSignatureMock {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("MemberAnnouncementSignatureMock.Equals mock is already set by Set")
	}

	if mmEquals.defaultExpectation == nil {
		mmEquals.defaultExpectation = &MemberAnnouncementSignatureMockEqualsExpectation{mock: mmEquals.mock}
	}
	mmEquals.defaultExpectation.results = &MemberAnnouncementSignatureMockEqualsResults{b1}
	return mmEquals.mock
}

//Set uses given function f to mock the MemberAnnouncementSignature.Equals method
func (mmEquals *mMemberAnnouncementSignatureMockEquals) Set(f func(other cryptkit.SignatureHolder) (b1 bool)) *MemberAnnouncementSignatureMock {
	if mmEquals.defaultExpectation != nil {
		mmEquals.mock.t.Fatalf("Default expectation is already set for the MemberAnnouncementSignature.Equals method")
	}

	if len(mmEquals.expectations) > 0 {
		mmEquals.mock.t.Fatalf("Some expectations are already set for the MemberAnnouncementSignature.Equals method")
	}

	mmEquals.mock.funcEquals = f
	return mmEquals.mock
}

// When sets expectation for the MemberAnnouncementSignature.Equals which will trigger the result defined by the following
// Then helper
func (mmEquals *mMemberAnnouncementSignatureMockEquals) When(other cryptkit.SignatureHolder) *MemberAnnouncementSignatureMockEqualsExpectation {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("MemberAnnouncementSignatureMock.Equals mock is already set by Set")
	}

	expectation := &MemberAnnouncementSignatureMockEqualsExpectation{
		mock:   mmEquals.mock,
		params: &MemberAnnouncementSignatureMockEqualsParams{other},
	}
	mmEquals.expectations = append(mmEquals.expectations, expectation)
	return expectation
}

// Then sets up MemberAnnouncementSignature.Equals return parameters for the expectation previously defined by the When method
func (e *MemberAnnouncementSignatureMockEqualsExpectation) Then(b1 bool) *MemberAnnouncementSignatureMock {
	e.results = &MemberAnnouncementSignatureMockEqualsResults{b1}
	return e.mock
}

// Equals implements MemberAnnouncementSignature
func (mmEquals *MemberAnnouncementSignatureMock) Equals(other cryptkit.SignatureHolder) (b1 bool) {
	mm_atomic.AddUint64(&mmEquals.beforeEqualsCounter, 1)
	defer mm_atomic.AddUint64(&mmEquals.afterEqualsCounter, 1)

	if mmEquals.inspectFuncEquals != nil {
		mmEquals.inspectFuncEquals(other)
	}

	params := &MemberAnnouncementSignatureMockEqualsParams{other}

	// Record call args
	mmEquals.EqualsMock.mutex.Lock()
	mmEquals.EqualsMock.callArgs = append(mmEquals.EqualsMock.callArgs, params)
	mmEquals.EqualsMock.mutex.Unlock()

	for _, e := range mmEquals.EqualsMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmEquals.EqualsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEquals.EqualsMock.defaultExpectation.Counter, 1)
		want := mmEquals.EqualsMock.defaultExpectation.params
		got := MemberAnnouncementSignatureMockEqualsParams{other}
		if want != nil && !minimock.Equal(*want, got) {
			mmEquals.t.Errorf("MemberAnnouncementSignatureMock.Equals got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmEquals.EqualsMock.defaultExpectation.results
		if results == nil {
			mmEquals.t.Fatal("No results are set for the MemberAnnouncementSignatureMock.Equals")
		}
		return (*results).b1
	}
	if mmEquals.funcEquals != nil {
		return mmEquals.funcEquals(other)
	}
	mmEquals.t.Fatalf("Unexpected call to MemberAnnouncementSignatureMock.Equals. %v", other)
	return
}

// EqualsAfterCounter returns a count of finished MemberAnnouncementSignatureMock.Equals invocations
func (mmEquals *MemberAnnouncementSignatureMock) EqualsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEquals.afterEqualsCounter)
}

// EqualsBeforeCounter returns a count of MemberAnnouncementSignatureMock.Equals invocations
func (mmEquals *MemberAnnouncementSignatureMock) EqualsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEquals.beforeEqualsCounter)
}

// Calls returns a list of arguments used in each call to MemberAnnouncementSignatureMock.Equals.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEquals *mMemberAnnouncementSignatureMockEquals) Calls() []*MemberAnnouncementSignatureMockEqualsParams {
	mmEquals.mutex.RLock()

	argCopy := make([]*MemberAnnouncementSignatureMockEqualsParams, len(mmEquals.callArgs))
	copy(argCopy, mmEquals.callArgs)

	mmEquals.mutex.RUnlock()

	return argCopy
}

// MinimockEqualsDone returns true if the count of the Equals invocations corresponds
// the number of defined expectations
func (m *MemberAnnouncementSignatureMock) MinimockEqualsDone() bool {
	for _, e := range m.EqualsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EqualsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEquals != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		return false
	}
	return true
}

// MinimockEqualsInspect logs each unmet expectation
func (m *MemberAnnouncementSignatureMock) MinimockEqualsInspect() {
	for _, e := range m.EqualsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MemberAnnouncementSignatureMock.Equals with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EqualsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		if m.EqualsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MemberAnnouncementSignatureMock.Equals")
		} else {
			m.t.Errorf("Expected call to MemberAnnouncementSignatureMock.Equals with params: %#v", *m.EqualsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEquals != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		m.t.Error("Expected call to MemberAnnouncementSignatureMock.Equals")
	}
}

type mMemberAnnouncementSignatureMockFixedByteSize struct {
	mock               *MemberAnnouncementSignatureMock
	defaultExpectation *MemberAnnouncementSignatureMockFixedByteSizeExpectation
	expectations       []*MemberAnnouncementSignatureMockFixedByteSizeExpectation
}

// MemberAnnouncementSignatureMockFixedByteSizeExpectation specifies expectation struct of the MemberAnnouncementSignature.FixedByteSize
type MemberAnnouncementSignatureMockFixedByteSizeExpectation struct {
	mock *MemberAnnouncementSignatureMock

	results *MemberAnnouncementSignatureMockFixedByteSizeResults
	Counter uint64
}

// MemberAnnouncementSignatureMockFixedByteSizeResults contains results of the MemberAnnouncementSignature.FixedByteSize
type MemberAnnouncementSignatureMockFixedByteSizeResults struct {
	i1 int
}

// Expect sets up expected params for MemberAnnouncementSignature.FixedByteSize
func (mmFixedByteSize *mMemberAnnouncementSignatureMockFixedByteSize) Expect() *mMemberAnnouncementSignatureMockFixedByteSize {
	if mmFixedByteSize.mock.funcFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("MemberAnnouncementSignatureMock.FixedByteSize mock is already set by Set")
	}

	if mmFixedByteSize.defaultExpectation == nil {
		mmFixedByteSize.defaultExpectation = &MemberAnnouncementSignatureMockFixedByteSizeExpectation{}
	}

	return mmFixedByteSize
}

// Inspect accepts an inspector function that has same arguments as the MemberAnnouncementSignature.FixedByteSize
func (mmFixedByteSize *mMemberAnnouncementSignatureMockFixedByteSize) Inspect(f func()) *mMemberAnnouncementSignatureMockFixedByteSize {
	if mmFixedByteSize.mock.inspectFuncFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("Inspect function is already set for MemberAnnouncementSignatureMock.FixedByteSize")
	}

	mmFixedByteSize.mock.inspectFuncFixedByteSize = f

	return mmFixedByteSize
}

// Return sets up results that will be returned by MemberAnnouncementSignature.FixedByteSize
func (mmFixedByteSize *mMemberAnnouncementSignatureMockFixedByteSize) Return(i1 int) *MemberAnnouncementSignatureMock {
	if mmFixedByteSize.mock.funcFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("MemberAnnouncementSignatureMock.FixedByteSize mock is already set by Set")
	}

	if mmFixedByteSize.defaultExpectation == nil {
		mmFixedByteSize.defaultExpectation = &MemberAnnouncementSignatureMockFixedByteSizeExpectation{mock: mmFixedByteSize.mock}
	}
	mmFixedByteSize.defaultExpectation.results = &MemberAnnouncementSignatureMockFixedByteSizeResults{i1}
	return mmFixedByteSize.mock
}

//Set uses given function f to mock the MemberAnnouncementSignature.FixedByteSize method
func (mmFixedByteSize *mMemberAnnouncementSignatureMockFixedByteSize) Set(f func() (i1 int)) *MemberAnnouncementSignatureMock {
	if mmFixedByteSize.defaultExpectation != nil {
		mmFixedByteSize.mock.t.Fatalf("Default expectation is already set for the MemberAnnouncementSignature.FixedByteSize method")
	}

	if len(mmFixedByteSize.expectations) > 0 {
		mmFixedByteSize.mock.t.Fatalf("Some expectations are already set for the MemberAnnouncementSignature.FixedByteSize method")
	}

	mmFixedByteSize.mock.funcFixedByteSize = f
	return mmFixedByteSize.mock
}

// FixedByteSize implements MemberAnnouncementSignature
func (mmFixedByteSize *MemberAnnouncementSignatureMock) FixedByteSize() (i1 int) {
	mm_atomic.AddUint64(&mmFixedByteSize.beforeFixedByteSizeCounter, 1)
	defer mm_atomic.AddUint64(&mmFixedByteSize.afterFixedByteSizeCounter, 1)

	if mmFixedByteSize.inspectFuncFixedByteSize != nil {
		mmFixedByteSize.inspectFuncFixedByteSize()
	}

	if mmFixedByteSize.FixedByteSizeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFixedByteSize.FixedByteSizeMock.defaultExpectation.Counter, 1)

		results := mmFixedByteSize.FixedByteSizeMock.defaultExpectation.results
		if results == nil {
			mmFixedByteSize.t.Fatal("No results are set for the MemberAnnouncementSignatureMock.FixedByteSize")
		}
		return (*results).i1
	}
	if mmFixedByteSize.funcFixedByteSize != nil {
		return mmFixedByteSize.funcFixedByteSize()
	}
	mmFixedByteSize.t.Fatalf("Unexpected call to MemberAnnouncementSignatureMock.FixedByteSize.")
	return
}

// FixedByteSizeAfterCounter returns a count of finished MemberAnnouncementSignatureMock.FixedByteSize invocations
func (mmFixedByteSize *MemberAnnouncementSignatureMock) FixedByteSizeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFixedByteSize.afterFixedByteSizeCounter)
}

// FixedByteSizeBeforeCounter returns a count of MemberAnnouncementSignatureMock.FixedByteSize invocations
func (mmFixedByteSize *MemberAnnouncementSignatureMock) FixedByteSizeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFixedByteSize.beforeFixedByteSizeCounter)
}

// MinimockFixedByteSizeDone returns true if the count of the FixedByteSize invocations corresponds
// the number of defined expectations
func (m *MemberAnnouncementSignatureMock) MinimockFixedByteSizeDone() bool {
	for _, e := range m.FixedByteSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FixedByteSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFixedByteSize != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		return false
	}
	return true
}

// MinimockFixedByteSizeInspect logs each unmet expectation
func (m *MemberAnnouncementSignatureMock) MinimockFixedByteSizeInspect() {
	for _, e := range m.FixedByteSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MemberAnnouncementSignatureMock.FixedByteSize")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FixedByteSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		m.t.Error("Expected call to MemberAnnouncementSignatureMock.FixedByteSize")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFixedByteSize != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		m.t.Error("Expected call to MemberAnnouncementSignatureMock.FixedByteSize")
	}
}

type mMemberAnnouncementSignatureMockFoldToUint64 struct {
	mock               *MemberAnnouncementSignatureMock
	defaultExpectation *MemberAnnouncementSignatureMockFoldToUint64Expectation
	expectations       []*MemberAnnouncementSignatureMockFoldToUint64Expectation
}

// MemberAnnouncementSignatureMockFoldToUint64Expectation specifies expectation struct of the MemberAnnouncementSignature.FoldToUint64
type MemberAnnouncementSignatureMockFoldToUint64Expectation struct {
	mock *MemberAnnouncementSignatureMock

	results *MemberAnnouncementSignatureMockFoldToUint64Results
	Counter uint64
}

// MemberAnnouncementSignatureMockFoldToUint64Results contains results of the MemberAnnouncementSignature.FoldToUint64
type MemberAnnouncementSignatureMockFoldToUint64Results struct {
	u1 uint64
}

// Expect sets up expected params for MemberAnnouncementSignature.FoldToUint64
func (mmFoldToUint64 *mMemberAnnouncementSignatureMockFoldToUint64) Expect() *mMemberAnnouncementSignatureMockFoldToUint64 {
	if mmFoldToUint64.mock.funcFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("MemberAnnouncementSignatureMock.FoldToUint64 mock is already set by Set")
	}

	if mmFoldToUint64.defaultExpectation == nil {
		mmFoldToUint64.defaultExpectation = &MemberAnnouncementSignatureMockFoldToUint64Expectation{}
	}

	return mmFoldToUint64
}

// Inspect accepts an inspector function that has same arguments as the MemberAnnouncementSignature.FoldToUint64
func (mmFoldToUint64 *mMemberAnnouncementSignatureMockFoldToUint64) Inspect(f func()) *mMemberAnnouncementSignatureMockFoldToUint64 {
	if mmFoldToUint64.mock.inspectFuncFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("Inspect function is already set for MemberAnnouncementSignatureMock.FoldToUint64")
	}

	mmFoldToUint64.mock.inspectFuncFoldToUint64 = f

	return mmFoldToUint64
}

// Return sets up results that will be returned by MemberAnnouncementSignature.FoldToUint64
func (mmFoldToUint64 *mMemberAnnouncementSignatureMockFoldToUint64) Return(u1 uint64) *MemberAnnouncementSignatureMock {
	if mmFoldToUint64.mock.funcFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("MemberAnnouncementSignatureMock.FoldToUint64 mock is already set by Set")
	}

	if mmFoldToUint64.defaultExpectation == nil {
		mmFoldToUint64.defaultExpectation = &MemberAnnouncementSignatureMockFoldToUint64Expectation{mock: mmFoldToUint64.mock}
	}
	mmFoldToUint64.defaultExpectation.results = &MemberAnnouncementSignatureMockFoldToUint64Results{u1}
	return mmFoldToUint64.mock
}

//Set uses given function f to mock the MemberAnnouncementSignature.FoldToUint64 method
func (mmFoldToUint64 *mMemberAnnouncementSignatureMockFoldToUint64) Set(f func() (u1 uint64)) *MemberAnnouncementSignatureMock {
	if mmFoldToUint64.defaultExpectation != nil {
		mmFoldToUint64.mock.t.Fatalf("Default expectation is already set for the MemberAnnouncementSignature.FoldToUint64 method")
	}

	if len(mmFoldToUint64.expectations) > 0 {
		mmFoldToUint64.mock.t.Fatalf("Some expectations are already set for the MemberAnnouncementSignature.FoldToUint64 method")
	}

	mmFoldToUint64.mock.funcFoldToUint64 = f
	return mmFoldToUint64.mock
}

// FoldToUint64 implements MemberAnnouncementSignature
func (mmFoldToUint64 *MemberAnnouncementSignatureMock) FoldToUint64() (u1 uint64) {
	mm_atomic.AddUint64(&mmFoldToUint64.beforeFoldToUint64Counter, 1)
	defer mm_atomic.AddUint64(&mmFoldToUint64.afterFoldToUint64Counter, 1)

	if mmFoldToUint64.inspectFuncFoldToUint64 != nil {
		mmFoldToUint64.inspectFuncFoldToUint64()
	}

	if mmFoldToUint64.FoldToUint64Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFoldToUint64.FoldToUint64Mock.defaultExpectation.Counter, 1)

		results := mmFoldToUint64.FoldToUint64Mock.defaultExpectation.results
		if results == nil {
			mmFoldToUint64.t.Fatal("No results are set for the MemberAnnouncementSignatureMock.FoldToUint64")
		}
		return (*results).u1
	}
	if mmFoldToUint64.funcFoldToUint64 != nil {
		return mmFoldToUint64.funcFoldToUint64()
	}
	mmFoldToUint64.t.Fatalf("Unexpected call to MemberAnnouncementSignatureMock.FoldToUint64.")
	return
}

// FoldToUint64AfterCounter returns a count of finished MemberAnnouncementSignatureMock.FoldToUint64 invocations
func (mmFoldToUint64 *MemberAnnouncementSignatureMock) FoldToUint64AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFoldToUint64.afterFoldToUint64Counter)
}

// FoldToUint64BeforeCounter returns a count of MemberAnnouncementSignatureMock.FoldToUint64 invocations
func (mmFoldToUint64 *MemberAnnouncementSignatureMock) FoldToUint64BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFoldToUint64.beforeFoldToUint64Counter)
}

// MinimockFoldToUint64Done returns true if the count of the FoldToUint64 invocations corresponds
// the number of defined expectations
func (m *MemberAnnouncementSignatureMock) MinimockFoldToUint64Done() bool {
	for _, e := range m.FoldToUint64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FoldToUint64Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFoldToUint64 != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		return false
	}
	return true
}

// MinimockFoldToUint64Inspect logs each unmet expectation
func (m *MemberAnnouncementSignatureMock) MinimockFoldToUint64Inspect() {
	for _, e := range m.FoldToUint64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MemberAnnouncementSignatureMock.FoldToUint64")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FoldToUint64Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		m.t.Error("Expected call to MemberAnnouncementSignatureMock.FoldToUint64")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFoldToUint64 != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		m.t.Error("Expected call to MemberAnnouncementSignatureMock.FoldToUint64")
	}
}

type mMemberAnnouncementSignatureMockGetSignatureMethod struct {
	mock               *MemberAnnouncementSignatureMock
	defaultExpectation *MemberAnnouncementSignatureMockGetSignatureMethodExpectation
	expectations       []*MemberAnnouncementSignatureMockGetSignatureMethodExpectation
}

// MemberAnnouncementSignatureMockGetSignatureMethodExpectation specifies expectation struct of the MemberAnnouncementSignature.GetSignatureMethod
type MemberAnnouncementSignatureMockGetSignatureMethodExpectation struct {
	mock *MemberAnnouncementSignatureMock

	results *MemberAnnouncementSignatureMockGetSignatureMethodResults
	Counter uint64
}

// MemberAnnouncementSignatureMockGetSignatureMethodResults contains results of the MemberAnnouncementSignature.GetSignatureMethod
type MemberAnnouncementSignatureMockGetSignatureMethodResults struct {
	s1 cryptkit.SignatureMethod
}

// Expect sets up expected params for MemberAnnouncementSignature.GetSignatureMethod
func (mmGetSignatureMethod *mMemberAnnouncementSignatureMockGetSignatureMethod) Expect() *mMemberAnnouncementSignatureMockGetSignatureMethod {
	if mmGetSignatureMethod.mock.funcGetSignatureMethod != nil {
		mmGetSignatureMethod.mock.t.Fatalf("MemberAnnouncementSignatureMock.GetSignatureMethod mock is already set by Set")
	}

	if mmGetSignatureMethod.defaultExpectation == nil {
		mmGetSignatureMethod.defaultExpectation = &MemberAnnouncementSignatureMockGetSignatureMethodExpectation{}
	}

	return mmGetSignatureMethod
}

// Inspect accepts an inspector function that has same arguments as the MemberAnnouncementSignature.GetSignatureMethod
func (mmGetSignatureMethod *mMemberAnnouncementSignatureMockGetSignatureMethod) Inspect(f func()) *mMemberAnnouncementSignatureMockGetSignatureMethod {
	if mmGetSignatureMethod.mock.inspectFuncGetSignatureMethod != nil {
		mmGetSignatureMethod.mock.t.Fatalf("Inspect function is already set for MemberAnnouncementSignatureMock.GetSignatureMethod")
	}

	mmGetSignatureMethod.mock.inspectFuncGetSignatureMethod = f

	return mmGetSignatureMethod
}

// Return sets up results that will be returned by MemberAnnouncementSignature.GetSignatureMethod
func (mmGetSignatureMethod *mMemberAnnouncementSignatureMockGetSignatureMethod) Return(s1 cryptkit.SignatureMethod) *MemberAnnouncementSignatureMock {
	if mmGetSignatureMethod.mock.funcGetSignatureMethod != nil {
		mmGetSignatureMethod.mock.t.Fatalf("MemberAnnouncementSignatureMock.GetSignatureMethod mock is already set by Set")
	}

	if mmGetSignatureMethod.defaultExpectation == nil {
		mmGetSignatureMethod.defaultExpectation = &MemberAnnouncementSignatureMockGetSignatureMethodExpectation{mock: mmGetSignatureMethod.mock}
	}
	mmGetSignatureMethod.defaultExpectation.results = &MemberAnnouncementSignatureMockGetSignatureMethodResults{s1}
	return mmGetSignatureMethod.mock
}

//Set uses given function f to mock the MemberAnnouncementSignature.GetSignatureMethod method
func (mmGetSignatureMethod *mMemberAnnouncementSignatureMockGetSignatureMethod) Set(f func() (s1 cryptkit.SignatureMethod)) *MemberAnnouncementSignatureMock {
	if mmGetSignatureMethod.defaultExpectation != nil {
		mmGetSignatureMethod.mock.t.Fatalf("Default expectation is already set for the MemberAnnouncementSignature.GetSignatureMethod method")
	}

	if len(mmGetSignatureMethod.expectations) > 0 {
		mmGetSignatureMethod.mock.t.Fatalf("Some expectations are already set for the MemberAnnouncementSignature.GetSignatureMethod method")
	}

	mmGetSignatureMethod.mock.funcGetSignatureMethod = f
	return mmGetSignatureMethod.mock
}

// GetSignatureMethod implements MemberAnnouncementSignature
func (mmGetSignatureMethod *MemberAnnouncementSignatureMock) GetSignatureMethod() (s1 cryptkit.SignatureMethod) {
	mm_atomic.AddUint64(&mmGetSignatureMethod.beforeGetSignatureMethodCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSignatureMethod.afterGetSignatureMethodCounter, 1)

	if mmGetSignatureMethod.inspectFuncGetSignatureMethod != nil {
		mmGetSignatureMethod.inspectFuncGetSignatureMethod()
	}

	if mmGetSignatureMethod.GetSignatureMethodMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSignatureMethod.GetSignatureMethodMock.defaultExpectation.Counter, 1)

		results := mmGetSignatureMethod.GetSignatureMethodMock.defaultExpectation.results
		if results == nil {
			mmGetSignatureMethod.t.Fatal("No results are set for the MemberAnnouncementSignatureMock.GetSignatureMethod")
		}
		return (*results).s1
	}
	if mmGetSignatureMethod.funcGetSignatureMethod != nil {
		return mmGetSignatureMethod.funcGetSignatureMethod()
	}
	mmGetSignatureMethod.t.Fatalf("Unexpected call to MemberAnnouncementSignatureMock.GetSignatureMethod.")
	return
}

// GetSignatureMethodAfterCounter returns a count of finished MemberAnnouncementSignatureMock.GetSignatureMethod invocations
func (mmGetSignatureMethod *MemberAnnouncementSignatureMock) GetSignatureMethodAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSignatureMethod.afterGetSignatureMethodCounter)
}

// GetSignatureMethodBeforeCounter returns a count of MemberAnnouncementSignatureMock.GetSignatureMethod invocations
func (mmGetSignatureMethod *MemberAnnouncementSignatureMock) GetSignatureMethodBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSignatureMethod.beforeGetSignatureMethodCounter)
}

// MinimockGetSignatureMethodDone returns true if the count of the GetSignatureMethod invocations corresponds
// the number of defined expectations
func (m *MemberAnnouncementSignatureMock) MinimockGetSignatureMethodDone() bool {
	for _, e := range m.GetSignatureMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSignatureMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSignatureMethodCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSignatureMethod != nil && mm_atomic.LoadUint64(&m.afterGetSignatureMethodCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSignatureMethodInspect logs each unmet expectation
func (m *MemberAnnouncementSignatureMock) MinimockGetSignatureMethodInspect() {
	for _, e := range m.GetSignatureMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MemberAnnouncementSignatureMock.GetSignatureMethod")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSignatureMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSignatureMethodCounter) < 1 {
		m.t.Error("Expected call to MemberAnnouncementSignatureMock.GetSignatureMethod")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSignatureMethod != nil && mm_atomic.LoadUint64(&m.afterGetSignatureMethodCounter) < 1 {
		m.t.Error("Expected call to MemberAnnouncementSignatureMock.GetSignatureMethod")
	}
}

type mMemberAnnouncementSignatureMockRead struct {
	mock               *MemberAnnouncementSignatureMock
	defaultExpectation *MemberAnnouncementSignatureMockReadExpectation
	expectations       []*MemberAnnouncementSignatureMockReadExpectation

	callArgs []*MemberAnnouncementSignatureMockReadParams
	mutex    sync.RWMutex
}

// MemberAnnouncementSignatureMockReadExpectation specifies expectation struct of the MemberAnnouncementSignature.Read
type MemberAnnouncementSignatureMockReadExpectation struct {
	mock    *MemberAnnouncementSignatureMock
	params  *MemberAnnouncementSignatureMockReadParams
	results *MemberAnnouncementSignatureMockReadResults
	Counter uint64
}

// MemberAnnouncementSignatureMockReadParams contains parameters of the MemberAnnouncementSignature.Read
type MemberAnnouncementSignatureMockReadParams struct {
	p []byte
}

// MemberAnnouncementSignatureMockReadResults contains results of the MemberAnnouncementSignature.Read
type MemberAnnouncementSignatureMockReadResults struct {
	n   int
	err error
}

// Expect sets up expected params for MemberAnnouncementSignature.Read
func (mmRead *mMemberAnnouncementSignatureMockRead) Expect(p []byte) *mMemberAnnouncementSignatureMockRead {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("MemberAnnouncementSignatureMock.Read mock is already set by Set")
	}

	if mmRead.defaultExpectation == nil {
		mmRead.defaultExpectation = &MemberAnnouncementSignatureMockReadExpectation{}
	}

	mmRead.defaultExpectation.params = &MemberAnnouncementSignatureMockReadParams{p}
	for _, e := range mmRead.expectations {
		if minimock.Equal(e.params, mmRead.defaultExpectation.params) {
			mmRead.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRead.defaultExpectation.params)
		}
	}

	return mmRead
}

// Inspect accepts an inspector function that has same arguments as the MemberAnnouncementSignature.Read
func (mmRead *mMemberAnnouncementSignatureMockRead) Inspect(f func(p []byte)) *mMemberAnnouncementSignatureMockRead {
	if mmRead.mock.inspectFuncRead != nil {
		mmRead.mock.t.Fatalf("Inspect function is already set for MemberAnnouncementSignatureMock.Read")
	}

	mmRead.mock.inspectFuncRead = f

	return mmRead
}

// Return sets up results that will be returned by MemberAnnouncementSignature.Read
func (mmRead *mMemberAnnouncementSignatureMockRead) Return(n int, err error) *MemberAnnouncementSignatureMock {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("MemberAnnouncementSignatureMock.Read mock is already set by Set")
	}

	if mmRead.defaultExpectation == nil {
		mmRead.defaultExpectation = &MemberAnnouncementSignatureMockReadExpectation{mock: mmRead.mock}
	}
	mmRead.defaultExpectation.results = &MemberAnnouncementSignatureMockReadResults{n, err}
	return mmRead.mock
}

//Set uses given function f to mock the MemberAnnouncementSignature.Read method
func (mmRead *mMemberAnnouncementSignatureMockRead) Set(f func(p []byte) (n int, err error)) *MemberAnnouncementSignatureMock {
	if mmRead.defaultExpectation != nil {
		mmRead.mock.t.Fatalf("Default expectation is already set for the MemberAnnouncementSignature.Read method")
	}

	if len(mmRead.expectations) > 0 {
		mmRead.mock.t.Fatalf("Some expectations are already set for the MemberAnnouncementSignature.Read method")
	}

	mmRead.mock.funcRead = f
	return mmRead.mock
}

// When sets expectation for the MemberAnnouncementSignature.Read which will trigger the result defined by the following
// Then helper
func (mmRead *mMemberAnnouncementSignatureMockRead) When(p []byte) *MemberAnnouncementSignatureMockReadExpectation {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("MemberAnnouncementSignatureMock.Read mock is already set by Set")
	}

	expectation := &MemberAnnouncementSignatureMockReadExpectation{
		mock:   mmRead.mock,
		params: &MemberAnnouncementSignatureMockReadParams{p},
	}
	mmRead.expectations = append(mmRead.expectations, expectation)
	return expectation
}

// Then sets up MemberAnnouncementSignature.Read return parameters for the expectation previously defined by the When method
func (e *MemberAnnouncementSignatureMockReadExpectation) Then(n int, err error) *MemberAnnouncementSignatureMock {
	e.results = &MemberAnnouncementSignatureMockReadResults{n, err}
	return e.mock
}

// Read implements MemberAnnouncementSignature
func (mmRead *MemberAnnouncementSignatureMock) Read(p []byte) (n int, err error) {
	mm_atomic.AddUint64(&mmRead.beforeReadCounter, 1)
	defer mm_atomic.AddUint64(&mmRead.afterReadCounter, 1)

	if mmRead.inspectFuncRead != nil {
		mmRead.inspectFuncRead(p)
	}

	params := &MemberAnnouncementSignatureMockReadParams{p}

	// Record call args
	mmRead.ReadMock.mutex.Lock()
	mmRead.ReadMock.callArgs = append(mmRead.ReadMock.callArgs, params)
	mmRead.ReadMock.mutex.Unlock()

	for _, e := range mmRead.ReadMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmRead.ReadMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRead.ReadMock.defaultExpectation.Counter, 1)
		want := mmRead.ReadMock.defaultExpectation.params
		got := MemberAnnouncementSignatureMockReadParams{p}
		if want != nil && !minimock.Equal(*want, got) {
			mmRead.t.Errorf("MemberAnnouncementSignatureMock.Read got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmRead.ReadMock.defaultExpectation.results
		if results == nil {
			mmRead.t.Fatal("No results are set for the MemberAnnouncementSignatureMock.Read")
		}
		return (*results).n, (*results).err
	}
	if mmRead.funcRead != nil {
		return mmRead.funcRead(p)
	}
	mmRead.t.Fatalf("Unexpected call to MemberAnnouncementSignatureMock.Read. %v", p)
	return
}

// ReadAfterCounter returns a count of finished MemberAnnouncementSignatureMock.Read invocations
func (mmRead *MemberAnnouncementSignatureMock) ReadAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRead.afterReadCounter)
}

// ReadBeforeCounter returns a count of MemberAnnouncementSignatureMock.Read invocations
func (mmRead *MemberAnnouncementSignatureMock) ReadBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRead.beforeReadCounter)
}

// Calls returns a list of arguments used in each call to MemberAnnouncementSignatureMock.Read.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRead *mMemberAnnouncementSignatureMockRead) Calls() []*MemberAnnouncementSignatureMockReadParams {
	mmRead.mutex.RLock()

	argCopy := make([]*MemberAnnouncementSignatureMockReadParams, len(mmRead.callArgs))
	copy(argCopy, mmRead.callArgs)

	mmRead.mutex.RUnlock()

	return argCopy
}

// MinimockReadDone returns true if the count of the Read invocations corresponds
// the number of defined expectations
func (m *MemberAnnouncementSignatureMock) MinimockReadDone() bool {
	for _, e := range m.ReadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRead != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		return false
	}
	return true
}

// MinimockReadInspect logs each unmet expectation
func (m *MemberAnnouncementSignatureMock) MinimockReadInspect() {
	for _, e := range m.ReadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MemberAnnouncementSignatureMock.Read with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		if m.ReadMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MemberAnnouncementSignatureMock.Read")
		} else {
			m.t.Errorf("Expected call to MemberAnnouncementSignatureMock.Read with params: %#v", *m.ReadMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRead != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		m.t.Error("Expected call to MemberAnnouncementSignatureMock.Read")
	}
}

type mMemberAnnouncementSignatureMockWriteTo struct {
	mock               *MemberAnnouncementSignatureMock
	defaultExpectation *MemberAnnouncementSignatureMockWriteToExpectation
	expectations       []*MemberAnnouncementSignatureMockWriteToExpectation

	callArgs []*MemberAnnouncementSignatureMockWriteToParams
	mutex    sync.RWMutex
}

// MemberAnnouncementSignatureMockWriteToExpectation specifies expectation struct of the MemberAnnouncementSignature.WriteTo
type MemberAnnouncementSignatureMockWriteToExpectation struct {
	mock    *MemberAnnouncementSignatureMock
	params  *MemberAnnouncementSignatureMockWriteToParams
	results *MemberAnnouncementSignatureMockWriteToResults
	Counter uint64
}

// MemberAnnouncementSignatureMockWriteToParams contains parameters of the MemberAnnouncementSignature.WriteTo
type MemberAnnouncementSignatureMockWriteToParams struct {
	w io.Writer
}

// MemberAnnouncementSignatureMockWriteToResults contains results of the MemberAnnouncementSignature.WriteTo
type MemberAnnouncementSignatureMockWriteToResults struct {
	n   int64
	err error
}

// Expect sets up expected params for MemberAnnouncementSignature.WriteTo
func (mmWriteTo *mMemberAnnouncementSignatureMockWriteTo) Expect(w io.Writer) *mMemberAnnouncementSignatureMockWriteTo {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("MemberAnnouncementSignatureMock.WriteTo mock is already set by Set")
	}

	if mmWriteTo.defaultExpectation == nil {
		mmWriteTo.defaultExpectation = &MemberAnnouncementSignatureMockWriteToExpectation{}
	}

	mmWriteTo.defaultExpectation.params = &MemberAnnouncementSignatureMockWriteToParams{w}
	for _, e := range mmWriteTo.expectations {
		if minimock.Equal(e.params, mmWriteTo.defaultExpectation.params) {
			mmWriteTo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWriteTo.defaultExpectation.params)
		}
	}

	return mmWriteTo
}

// Inspect accepts an inspector function that has same arguments as the MemberAnnouncementSignature.WriteTo
func (mmWriteTo *mMemberAnnouncementSignatureMockWriteTo) Inspect(f func(w io.Writer)) *mMemberAnnouncementSignatureMockWriteTo {
	if mmWriteTo.mock.inspectFuncWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("Inspect function is already set for MemberAnnouncementSignatureMock.WriteTo")
	}

	mmWriteTo.mock.inspectFuncWriteTo = f

	return mmWriteTo
}

// Return sets up results that will be returned by MemberAnnouncementSignature.WriteTo
func (mmWriteTo *mMemberAnnouncementSignatureMockWriteTo) Return(n int64, err error) *MemberAnnouncementSignatureMock {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("MemberAnnouncementSignatureMock.WriteTo mock is already set by Set")
	}

	if mmWriteTo.defaultExpectation == nil {
		mmWriteTo.defaultExpectation = &MemberAnnouncementSignatureMockWriteToExpectation{mock: mmWriteTo.mock}
	}
	mmWriteTo.defaultExpectation.results = &MemberAnnouncementSignatureMockWriteToResults{n, err}
	return mmWriteTo.mock
}

//Set uses given function f to mock the MemberAnnouncementSignature.WriteTo method
func (mmWriteTo *mMemberAnnouncementSignatureMockWriteTo) Set(f func(w io.Writer) (n int64, err error)) *MemberAnnouncementSignatureMock {
	if mmWriteTo.defaultExpectation != nil {
		mmWriteTo.mock.t.Fatalf("Default expectation is already set for the MemberAnnouncementSignature.WriteTo method")
	}

	if len(mmWriteTo.expectations) > 0 {
		mmWriteTo.mock.t.Fatalf("Some expectations are already set for the MemberAnnouncementSignature.WriteTo method")
	}

	mmWriteTo.mock.funcWriteTo = f
	return mmWriteTo.mock
}

// When sets expectation for the MemberAnnouncementSignature.WriteTo which will trigger the result defined by the following
// Then helper
func (mmWriteTo *mMemberAnnouncementSignatureMockWriteTo) When(w io.Writer) *MemberAnnouncementSignatureMockWriteToExpectation {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("MemberAnnouncementSignatureMock.WriteTo mock is already set by Set")
	}

	expectation := &MemberAnnouncementSignatureMockWriteToExpectation{
		mock:   mmWriteTo.mock,
		params: &MemberAnnouncementSignatureMockWriteToParams{w},
	}
	mmWriteTo.expectations = append(mmWriteTo.expectations, expectation)
	return expectation
}

// Then sets up MemberAnnouncementSignature.WriteTo return parameters for the expectation previously defined by the When method
func (e *MemberAnnouncementSignatureMockWriteToExpectation) Then(n int64, err error) *MemberAnnouncementSignatureMock {
	e.results = &MemberAnnouncementSignatureMockWriteToResults{n, err}
	return e.mock
}

// WriteTo implements MemberAnnouncementSignature
func (mmWriteTo *MemberAnnouncementSignatureMock) WriteTo(w io.Writer) (n int64, err error) {
	mm_atomic.AddUint64(&mmWriteTo.beforeWriteToCounter, 1)
	defer mm_atomic.AddUint64(&mmWriteTo.afterWriteToCounter, 1)

	if mmWriteTo.inspectFuncWriteTo != nil {
		mmWriteTo.inspectFuncWriteTo(w)
	}

	params := &MemberAnnouncementSignatureMockWriteToParams{w}

	// Record call args
	mmWriteTo.WriteToMock.mutex.Lock()
	mmWriteTo.WriteToMock.callArgs = append(mmWriteTo.WriteToMock.callArgs, params)
	mmWriteTo.WriteToMock.mutex.Unlock()

	for _, e := range mmWriteTo.WriteToMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmWriteTo.WriteToMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWriteTo.WriteToMock.defaultExpectation.Counter, 1)
		want := mmWriteTo.WriteToMock.defaultExpectation.params
		got := MemberAnnouncementSignatureMockWriteToParams{w}
		if want != nil && !minimock.Equal(*want, got) {
			mmWriteTo.t.Errorf("MemberAnnouncementSignatureMock.WriteTo got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmWriteTo.WriteToMock.defaultExpectation.results
		if results == nil {
			mmWriteTo.t.Fatal("No results are set for the MemberAnnouncementSignatureMock.WriteTo")
		}
		return (*results).n, (*results).err
	}
	if mmWriteTo.funcWriteTo != nil {
		return mmWriteTo.funcWriteTo(w)
	}
	mmWriteTo.t.Fatalf("Unexpected call to MemberAnnouncementSignatureMock.WriteTo. %v", w)
	return
}

// WriteToAfterCounter returns a count of finished MemberAnnouncementSignatureMock.WriteTo invocations
func (mmWriteTo *MemberAnnouncementSignatureMock) WriteToAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteTo.afterWriteToCounter)
}

// WriteToBeforeCounter returns a count of MemberAnnouncementSignatureMock.WriteTo invocations
func (mmWriteTo *MemberAnnouncementSignatureMock) WriteToBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteTo.beforeWriteToCounter)
}

// Calls returns a list of arguments used in each call to MemberAnnouncementSignatureMock.WriteTo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWriteTo *mMemberAnnouncementSignatureMockWriteTo) Calls() []*MemberAnnouncementSignatureMockWriteToParams {
	mmWriteTo.mutex.RLock()

	argCopy := make([]*MemberAnnouncementSignatureMockWriteToParams, len(mmWriteTo.callArgs))
	copy(argCopy, mmWriteTo.callArgs)

	mmWriteTo.mutex.RUnlock()

	return argCopy
}

// MinimockWriteToDone returns true if the count of the WriteTo invocations corresponds
// the number of defined expectations
func (m *MemberAnnouncementSignatureMock) MinimockWriteToDone() bool {
	for _, e := range m.WriteToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteTo != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		return false
	}
	return true
}

// MinimockWriteToInspect logs each unmet expectation
func (m *MemberAnnouncementSignatureMock) MinimockWriteToInspect() {
	for _, e := range m.WriteToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MemberAnnouncementSignatureMock.WriteTo with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		if m.WriteToMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MemberAnnouncementSignatureMock.WriteTo")
		} else {
			m.t.Errorf("Expected call to MemberAnnouncementSignatureMock.WriteTo with params: %#v", *m.WriteToMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteTo != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		m.t.Error("Expected call to MemberAnnouncementSignatureMock.WriteTo")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *MemberAnnouncementSignatureMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAsByteStringInspect()

		m.MinimockAsBytesInspect()

		m.MinimockCopyOfSignatureInspect()

		m.MinimockEqualsInspect()

		m.MinimockFixedByteSizeInspect()

		m.MinimockFoldToUint64Inspect()

		m.MinimockGetSignatureMethodInspect()

		m.MinimockReadInspect()

		m.MinimockWriteToInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *MemberAnnouncementSignatureMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *MemberAnnouncementSignatureMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAsByteStringDone() &&
		m.MinimockAsBytesDone() &&
		m.MinimockCopyOfSignatureDone() &&
		m.MinimockEqualsDone() &&
		m.MinimockFixedByteSizeDone() &&
		m.MinimockFoldToUint64Done() &&
		m.MinimockGetSignatureMethodDone() &&
		m.MinimockReadDone() &&
		m.MinimockWriteToDone()
}
