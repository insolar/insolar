package proofs

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	io "io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/longbits"
	"github.com/insolar/insolar/network/consensus/common/cryptkit"
)

// NodeStateHashMock implements NodeStateHash
type NodeStateHashMock struct {
	t minimock.Tester

	funcAsByteString          func() (b1 longbits.ByteString)
	inspectFuncAsByteString   func()
	afterAsByteStringCounter  uint64
	beforeAsByteStringCounter uint64
	AsByteStringMock          mNodeStateHashMockAsByteString

	funcAsBytes          func() (ba1 []byte)
	inspectFuncAsBytes   func()
	afterAsBytesCounter  uint64
	beforeAsBytesCounter uint64
	AsBytesMock          mNodeStateHashMockAsBytes

	funcCopyOfDigest          func() (d1 cryptkit.Digest)
	inspectFuncCopyOfDigest   func()
	afterCopyOfDigestCounter  uint64
	beforeCopyOfDigestCounter uint64
	CopyOfDigestMock          mNodeStateHashMockCopyOfDigest

	funcEquals          func(other cryptkit.DigestHolder) (b1 bool)
	inspectFuncEquals   func(other cryptkit.DigestHolder)
	afterEqualsCounter  uint64
	beforeEqualsCounter uint64
	EqualsMock          mNodeStateHashMockEquals

	funcFixedByteSize          func() (i1 int)
	inspectFuncFixedByteSize   func()
	afterFixedByteSizeCounter  uint64
	beforeFixedByteSizeCounter uint64
	FixedByteSizeMock          mNodeStateHashMockFixedByteSize

	funcFoldToUint64          func() (u1 uint64)
	inspectFuncFoldToUint64   func()
	afterFoldToUint64Counter  uint64
	beforeFoldToUint64Counter uint64
	FoldToUint64Mock          mNodeStateHashMockFoldToUint64

	funcGetDigestMethod          func() (d1 cryptkit.DigestMethod)
	inspectFuncGetDigestMethod   func()
	afterGetDigestMethodCounter  uint64
	beforeGetDigestMethodCounter uint64
	GetDigestMethodMock          mNodeStateHashMockGetDigestMethod

	funcRead          func(p []byte) (n int, err error)
	inspectFuncRead   func(p []byte)
	afterReadCounter  uint64
	beforeReadCounter uint64
	ReadMock          mNodeStateHashMockRead

	funcSignWith          func(signer cryptkit.DigestSigner) (s1 cryptkit.SignedDigestHolder)
	inspectFuncSignWith   func(signer cryptkit.DigestSigner)
	afterSignWithCounter  uint64
	beforeSignWithCounter uint64
	SignWithMock          mNodeStateHashMockSignWith

	funcWriteTo          func(w io.Writer) (n int64, err error)
	inspectFuncWriteTo   func(w io.Writer)
	afterWriteToCounter  uint64
	beforeWriteToCounter uint64
	WriteToMock          mNodeStateHashMockWriteTo
}

// NewNodeStateHashMock returns a mock for NodeStateHash
func NewNodeStateHashMock(t minimock.Tester) *NodeStateHashMock {
	m := &NodeStateHashMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AsByteStringMock = mNodeStateHashMockAsByteString{mock: m}

	m.AsBytesMock = mNodeStateHashMockAsBytes{mock: m}

	m.CopyOfDigestMock = mNodeStateHashMockCopyOfDigest{mock: m}

	m.EqualsMock = mNodeStateHashMockEquals{mock: m}
	m.EqualsMock.callArgs = []*NodeStateHashMockEqualsParams{}

	m.FixedByteSizeMock = mNodeStateHashMockFixedByteSize{mock: m}

	m.FoldToUint64Mock = mNodeStateHashMockFoldToUint64{mock: m}

	m.GetDigestMethodMock = mNodeStateHashMockGetDigestMethod{mock: m}

	m.ReadMock = mNodeStateHashMockRead{mock: m}
	m.ReadMock.callArgs = []*NodeStateHashMockReadParams{}

	m.SignWithMock = mNodeStateHashMockSignWith{mock: m}
	m.SignWithMock.callArgs = []*NodeStateHashMockSignWithParams{}

	m.WriteToMock = mNodeStateHashMockWriteTo{mock: m}
	m.WriteToMock.callArgs = []*NodeStateHashMockWriteToParams{}

	return m
}

type mNodeStateHashMockAsByteString struct {
	mock               *NodeStateHashMock
	defaultExpectation *NodeStateHashMockAsByteStringExpectation
	expectations       []*NodeStateHashMockAsByteStringExpectation
}

// NodeStateHashMockAsByteStringExpectation specifies expectation struct of the NodeStateHash.AsByteString
type NodeStateHashMockAsByteStringExpectation struct {
	mock *NodeStateHashMock

	results *NodeStateHashMockAsByteStringResults
	Counter uint64
}

// NodeStateHashMockAsByteStringResults contains results of the NodeStateHash.AsByteString
type NodeStateHashMockAsByteStringResults struct {
	b1 longbits.ByteString
}

// Expect sets up expected params for NodeStateHash.AsByteString
func (mmAsByteString *mNodeStateHashMockAsByteString) Expect() *mNodeStateHashMockAsByteString {
	if mmAsByteString.mock.funcAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("NodeStateHashMock.AsByteString mock is already set by Set")
	}

	if mmAsByteString.defaultExpectation == nil {
		mmAsByteString.defaultExpectation = &NodeStateHashMockAsByteStringExpectation{}
	}

	return mmAsByteString
}

// Inspect accepts an inspector function that has same arguments as the NodeStateHash.AsByteString
func (mmAsByteString *mNodeStateHashMockAsByteString) Inspect(f func()) *mNodeStateHashMockAsByteString {
	if mmAsByteString.mock.inspectFuncAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("Inspect function is already set for NodeStateHashMock.AsByteString")
	}

	mmAsByteString.mock.inspectFuncAsByteString = f

	return mmAsByteString
}

// Return sets up results that will be returned by NodeStateHash.AsByteString
func (mmAsByteString *mNodeStateHashMockAsByteString) Return(b1 longbits.ByteString) *NodeStateHashMock {
	if mmAsByteString.mock.funcAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("NodeStateHashMock.AsByteString mock is already set by Set")
	}

	if mmAsByteString.defaultExpectation == nil {
		mmAsByteString.defaultExpectation = &NodeStateHashMockAsByteStringExpectation{mock: mmAsByteString.mock}
	}
	mmAsByteString.defaultExpectation.results = &NodeStateHashMockAsByteStringResults{b1}
	return mmAsByteString.mock
}

//Set uses given function f to mock the NodeStateHash.AsByteString method
func (mmAsByteString *mNodeStateHashMockAsByteString) Set(f func() (b1 longbits.ByteString)) *NodeStateHashMock {
	if mmAsByteString.defaultExpectation != nil {
		mmAsByteString.mock.t.Fatalf("Default expectation is already set for the NodeStateHash.AsByteString method")
	}

	if len(mmAsByteString.expectations) > 0 {
		mmAsByteString.mock.t.Fatalf("Some expectations are already set for the NodeStateHash.AsByteString method")
	}

	mmAsByteString.mock.funcAsByteString = f
	return mmAsByteString.mock
}

// AsByteString implements NodeStateHash
func (mmAsByteString *NodeStateHashMock) AsByteString() (b1 longbits.ByteString) {
	mm_atomic.AddUint64(&mmAsByteString.beforeAsByteStringCounter, 1)
	defer mm_atomic.AddUint64(&mmAsByteString.afterAsByteStringCounter, 1)

	if mmAsByteString.inspectFuncAsByteString != nil {
		mmAsByteString.inspectFuncAsByteString()
	}

	if mmAsByteString.AsByteStringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAsByteString.AsByteStringMock.defaultExpectation.Counter, 1)

		results := mmAsByteString.AsByteStringMock.defaultExpectation.results
		if results == nil {
			mmAsByteString.t.Fatal("No results are set for the NodeStateHashMock.AsByteString")
		}
		return (*results).b1
	}
	if mmAsByteString.funcAsByteString != nil {
		return mmAsByteString.funcAsByteString()
	}
	mmAsByteString.t.Fatalf("Unexpected call to NodeStateHashMock.AsByteString.")
	return
}

// AsByteStringAfterCounter returns a count of finished NodeStateHashMock.AsByteString invocations
func (mmAsByteString *NodeStateHashMock) AsByteStringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsByteString.afterAsByteStringCounter)
}

// AsByteStringBeforeCounter returns a count of NodeStateHashMock.AsByteString invocations
func (mmAsByteString *NodeStateHashMock) AsByteStringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsByteString.beforeAsByteStringCounter)
}

// MinimockAsByteStringDone returns true if the count of the AsByteString invocations corresponds
// the number of defined expectations
func (m *NodeStateHashMock) MinimockAsByteStringDone() bool {
	for _, e := range m.AsByteStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsByteStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsByteString != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		return false
	}
	return true
}

// MinimockAsByteStringInspect logs each unmet expectation
func (m *NodeStateHashMock) MinimockAsByteStringInspect() {
	for _, e := range m.AsByteStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NodeStateHashMock.AsByteString")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsByteStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		m.t.Error("Expected call to NodeStateHashMock.AsByteString")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsByteString != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		m.t.Error("Expected call to NodeStateHashMock.AsByteString")
	}
}

type mNodeStateHashMockAsBytes struct {
	mock               *NodeStateHashMock
	defaultExpectation *NodeStateHashMockAsBytesExpectation
	expectations       []*NodeStateHashMockAsBytesExpectation
}

// NodeStateHashMockAsBytesExpectation specifies expectation struct of the NodeStateHash.AsBytes
type NodeStateHashMockAsBytesExpectation struct {
	mock *NodeStateHashMock

	results *NodeStateHashMockAsBytesResults
	Counter uint64
}

// NodeStateHashMockAsBytesResults contains results of the NodeStateHash.AsBytes
type NodeStateHashMockAsBytesResults struct {
	ba1 []byte
}

// Expect sets up expected params for NodeStateHash.AsBytes
func (mmAsBytes *mNodeStateHashMockAsBytes) Expect() *mNodeStateHashMockAsBytes {
	if mmAsBytes.mock.funcAsBytes != nil {
		mmAsBytes.mock.t.Fatalf("NodeStateHashMock.AsBytes mock is already set by Set")
	}

	if mmAsBytes.defaultExpectation == nil {
		mmAsBytes.defaultExpectation = &NodeStateHashMockAsBytesExpectation{}
	}

	return mmAsBytes
}

// Inspect accepts an inspector function that has same arguments as the NodeStateHash.AsBytes
func (mmAsBytes *mNodeStateHashMockAsBytes) Inspect(f func()) *mNodeStateHashMockAsBytes {
	if mmAsBytes.mock.inspectFuncAsBytes != nil {
		mmAsBytes.mock.t.Fatalf("Inspect function is already set for NodeStateHashMock.AsBytes")
	}

	mmAsBytes.mock.inspectFuncAsBytes = f

	return mmAsBytes
}

// Return sets up results that will be returned by NodeStateHash.AsBytes
func (mmAsBytes *mNodeStateHashMockAsBytes) Return(ba1 []byte) *NodeStateHashMock {
	if mmAsBytes.mock.funcAsBytes != nil {
		mmAsBytes.mock.t.Fatalf("NodeStateHashMock.AsBytes mock is already set by Set")
	}

	if mmAsBytes.defaultExpectation == nil {
		mmAsBytes.defaultExpectation = &NodeStateHashMockAsBytesExpectation{mock: mmAsBytes.mock}
	}
	mmAsBytes.defaultExpectation.results = &NodeStateHashMockAsBytesResults{ba1}
	return mmAsBytes.mock
}

//Set uses given function f to mock the NodeStateHash.AsBytes method
func (mmAsBytes *mNodeStateHashMockAsBytes) Set(f func() (ba1 []byte)) *NodeStateHashMock {
	if mmAsBytes.defaultExpectation != nil {
		mmAsBytes.mock.t.Fatalf("Default expectation is already set for the NodeStateHash.AsBytes method")
	}

	if len(mmAsBytes.expectations) > 0 {
		mmAsBytes.mock.t.Fatalf("Some expectations are already set for the NodeStateHash.AsBytes method")
	}

	mmAsBytes.mock.funcAsBytes = f
	return mmAsBytes.mock
}

// AsBytes implements NodeStateHash
func (mmAsBytes *NodeStateHashMock) AsBytes() (ba1 []byte) {
	mm_atomic.AddUint64(&mmAsBytes.beforeAsBytesCounter, 1)
	defer mm_atomic.AddUint64(&mmAsBytes.afterAsBytesCounter, 1)

	if mmAsBytes.inspectFuncAsBytes != nil {
		mmAsBytes.inspectFuncAsBytes()
	}

	if mmAsBytes.AsBytesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAsBytes.AsBytesMock.defaultExpectation.Counter, 1)

		results := mmAsBytes.AsBytesMock.defaultExpectation.results
		if results == nil {
			mmAsBytes.t.Fatal("No results are set for the NodeStateHashMock.AsBytes")
		}
		return (*results).ba1
	}
	if mmAsBytes.funcAsBytes != nil {
		return mmAsBytes.funcAsBytes()
	}
	mmAsBytes.t.Fatalf("Unexpected call to NodeStateHashMock.AsBytes.")
	return
}

// AsBytesAfterCounter returns a count of finished NodeStateHashMock.AsBytes invocations
func (mmAsBytes *NodeStateHashMock) AsBytesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsBytes.afterAsBytesCounter)
}

// AsBytesBeforeCounter returns a count of NodeStateHashMock.AsBytes invocations
func (mmAsBytes *NodeStateHashMock) AsBytesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsBytes.beforeAsBytesCounter)
}

// MinimockAsBytesDone returns true if the count of the AsBytes invocations corresponds
// the number of defined expectations
func (m *NodeStateHashMock) MinimockAsBytesDone() bool {
	for _, e := range m.AsBytesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsBytesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsBytesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsBytes != nil && mm_atomic.LoadUint64(&m.afterAsBytesCounter) < 1 {
		return false
	}
	return true
}

// MinimockAsBytesInspect logs each unmet expectation
func (m *NodeStateHashMock) MinimockAsBytesInspect() {
	for _, e := range m.AsBytesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NodeStateHashMock.AsBytes")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsBytesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsBytesCounter) < 1 {
		m.t.Error("Expected call to NodeStateHashMock.AsBytes")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsBytes != nil && mm_atomic.LoadUint64(&m.afterAsBytesCounter) < 1 {
		m.t.Error("Expected call to NodeStateHashMock.AsBytes")
	}
}

type mNodeStateHashMockCopyOfDigest struct {
	mock               *NodeStateHashMock
	defaultExpectation *NodeStateHashMockCopyOfDigestExpectation
	expectations       []*NodeStateHashMockCopyOfDigestExpectation
}

// NodeStateHashMockCopyOfDigestExpectation specifies expectation struct of the NodeStateHash.CopyOfDigest
type NodeStateHashMockCopyOfDigestExpectation struct {
	mock *NodeStateHashMock

	results *NodeStateHashMockCopyOfDigestResults
	Counter uint64
}

// NodeStateHashMockCopyOfDigestResults contains results of the NodeStateHash.CopyOfDigest
type NodeStateHashMockCopyOfDigestResults struct {
	d1 cryptkit.Digest
}

// Expect sets up expected params for NodeStateHash.CopyOfDigest
func (mmCopyOfDigest *mNodeStateHashMockCopyOfDigest) Expect() *mNodeStateHashMockCopyOfDigest {
	if mmCopyOfDigest.mock.funcCopyOfDigest != nil {
		mmCopyOfDigest.mock.t.Fatalf("NodeStateHashMock.CopyOfDigest mock is already set by Set")
	}

	if mmCopyOfDigest.defaultExpectation == nil {
		mmCopyOfDigest.defaultExpectation = &NodeStateHashMockCopyOfDigestExpectation{}
	}

	return mmCopyOfDigest
}

// Inspect accepts an inspector function that has same arguments as the NodeStateHash.CopyOfDigest
func (mmCopyOfDigest *mNodeStateHashMockCopyOfDigest) Inspect(f func()) *mNodeStateHashMockCopyOfDigest {
	if mmCopyOfDigest.mock.inspectFuncCopyOfDigest != nil {
		mmCopyOfDigest.mock.t.Fatalf("Inspect function is already set for NodeStateHashMock.CopyOfDigest")
	}

	mmCopyOfDigest.mock.inspectFuncCopyOfDigest = f

	return mmCopyOfDigest
}

// Return sets up results that will be returned by NodeStateHash.CopyOfDigest
func (mmCopyOfDigest *mNodeStateHashMockCopyOfDigest) Return(d1 cryptkit.Digest) *NodeStateHashMock {
	if mmCopyOfDigest.mock.funcCopyOfDigest != nil {
		mmCopyOfDigest.mock.t.Fatalf("NodeStateHashMock.CopyOfDigest mock is already set by Set")
	}

	if mmCopyOfDigest.defaultExpectation == nil {
		mmCopyOfDigest.defaultExpectation = &NodeStateHashMockCopyOfDigestExpectation{mock: mmCopyOfDigest.mock}
	}
	mmCopyOfDigest.defaultExpectation.results = &NodeStateHashMockCopyOfDigestResults{d1}
	return mmCopyOfDigest.mock
}

//Set uses given function f to mock the NodeStateHash.CopyOfDigest method
func (mmCopyOfDigest *mNodeStateHashMockCopyOfDigest) Set(f func() (d1 cryptkit.Digest)) *NodeStateHashMock {
	if mmCopyOfDigest.defaultExpectation != nil {
		mmCopyOfDigest.mock.t.Fatalf("Default expectation is already set for the NodeStateHash.CopyOfDigest method")
	}

	if len(mmCopyOfDigest.expectations) > 0 {
		mmCopyOfDigest.mock.t.Fatalf("Some expectations are already set for the NodeStateHash.CopyOfDigest method")
	}

	mmCopyOfDigest.mock.funcCopyOfDigest = f
	return mmCopyOfDigest.mock
}

// CopyOfDigest implements NodeStateHash
func (mmCopyOfDigest *NodeStateHashMock) CopyOfDigest() (d1 cryptkit.Digest) {
	mm_atomic.AddUint64(&mmCopyOfDigest.beforeCopyOfDigestCounter, 1)
	defer mm_atomic.AddUint64(&mmCopyOfDigest.afterCopyOfDigestCounter, 1)

	if mmCopyOfDigest.inspectFuncCopyOfDigest != nil {
		mmCopyOfDigest.inspectFuncCopyOfDigest()
	}

	if mmCopyOfDigest.CopyOfDigestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCopyOfDigest.CopyOfDigestMock.defaultExpectation.Counter, 1)

		results := mmCopyOfDigest.CopyOfDigestMock.defaultExpectation.results
		if results == nil {
			mmCopyOfDigest.t.Fatal("No results are set for the NodeStateHashMock.CopyOfDigest")
		}
		return (*results).d1
	}
	if mmCopyOfDigest.funcCopyOfDigest != nil {
		return mmCopyOfDigest.funcCopyOfDigest()
	}
	mmCopyOfDigest.t.Fatalf("Unexpected call to NodeStateHashMock.CopyOfDigest.")
	return
}

// CopyOfDigestAfterCounter returns a count of finished NodeStateHashMock.CopyOfDigest invocations
func (mmCopyOfDigest *NodeStateHashMock) CopyOfDigestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyOfDigest.afterCopyOfDigestCounter)
}

// CopyOfDigestBeforeCounter returns a count of NodeStateHashMock.CopyOfDigest invocations
func (mmCopyOfDigest *NodeStateHashMock) CopyOfDigestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyOfDigest.beforeCopyOfDigestCounter)
}

// MinimockCopyOfDigestDone returns true if the count of the CopyOfDigest invocations corresponds
// the number of defined expectations
func (m *NodeStateHashMock) MinimockCopyOfDigestDone() bool {
	for _, e := range m.CopyOfDigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyOfDigestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyOfDigestCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyOfDigest != nil && mm_atomic.LoadUint64(&m.afterCopyOfDigestCounter) < 1 {
		return false
	}
	return true
}

// MinimockCopyOfDigestInspect logs each unmet expectation
func (m *NodeStateHashMock) MinimockCopyOfDigestInspect() {
	for _, e := range m.CopyOfDigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NodeStateHashMock.CopyOfDigest")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyOfDigestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyOfDigestCounter) < 1 {
		m.t.Error("Expected call to NodeStateHashMock.CopyOfDigest")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyOfDigest != nil && mm_atomic.LoadUint64(&m.afterCopyOfDigestCounter) < 1 {
		m.t.Error("Expected call to NodeStateHashMock.CopyOfDigest")
	}
}

type mNodeStateHashMockEquals struct {
	mock               *NodeStateHashMock
	defaultExpectation *NodeStateHashMockEqualsExpectation
	expectations       []*NodeStateHashMockEqualsExpectation

	callArgs []*NodeStateHashMockEqualsParams
	mutex    sync.RWMutex
}

// NodeStateHashMockEqualsExpectation specifies expectation struct of the NodeStateHash.Equals
type NodeStateHashMockEqualsExpectation struct {
	mock    *NodeStateHashMock
	params  *NodeStateHashMockEqualsParams
	results *NodeStateHashMockEqualsResults
	Counter uint64
}

// NodeStateHashMockEqualsParams contains parameters of the NodeStateHash.Equals
type NodeStateHashMockEqualsParams struct {
	other cryptkit.DigestHolder
}

// NodeStateHashMockEqualsResults contains results of the NodeStateHash.Equals
type NodeStateHashMockEqualsResults struct {
	b1 bool
}

// Expect sets up expected params for NodeStateHash.Equals
func (mmEquals *mNodeStateHashMockEquals) Expect(other cryptkit.DigestHolder) *mNodeStateHashMockEquals {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("NodeStateHashMock.Equals mock is already set by Set")
	}

	if mmEquals.defaultExpectation == nil {
		mmEquals.defaultExpectation = &NodeStateHashMockEqualsExpectation{}
	}

	mmEquals.defaultExpectation.params = &NodeStateHashMockEqualsParams{other}
	for _, e := range mmEquals.expectations {
		if minimock.Equal(e.params, mmEquals.defaultExpectation.params) {
			mmEquals.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEquals.defaultExpectation.params)
		}
	}

	return mmEquals
}

// Inspect accepts an inspector function that has same arguments as the NodeStateHash.Equals
func (mmEquals *mNodeStateHashMockEquals) Inspect(f func(other cryptkit.DigestHolder)) *mNodeStateHashMockEquals {
	if mmEquals.mock.inspectFuncEquals != nil {
		mmEquals.mock.t.Fatalf("Inspect function is already set for NodeStateHashMock.Equals")
	}

	mmEquals.mock.inspectFuncEquals = f

	return mmEquals
}

// Return sets up results that will be returned by NodeStateHash.Equals
func (mmEquals *mNodeStateHashMockEquals) Return(b1 bool) *NodeStateHashMock {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("NodeStateHashMock.Equals mock is already set by Set")
	}

	if mmEquals.defaultExpectation == nil {
		mmEquals.defaultExpectation = &NodeStateHashMockEqualsExpectation{mock: mmEquals.mock}
	}
	mmEquals.defaultExpectation.results = &NodeStateHashMockEqualsResults{b1}
	return mmEquals.mock
}

//Set uses given function f to mock the NodeStateHash.Equals method
func (mmEquals *mNodeStateHashMockEquals) Set(f func(other cryptkit.DigestHolder) (b1 bool)) *NodeStateHashMock {
	if mmEquals.defaultExpectation != nil {
		mmEquals.mock.t.Fatalf("Default expectation is already set for the NodeStateHash.Equals method")
	}

	if len(mmEquals.expectations) > 0 {
		mmEquals.mock.t.Fatalf("Some expectations are already set for the NodeStateHash.Equals method")
	}

	mmEquals.mock.funcEquals = f
	return mmEquals.mock
}

// When sets expectation for the NodeStateHash.Equals which will trigger the result defined by the following
// Then helper
func (mmEquals *mNodeStateHashMockEquals) When(other cryptkit.DigestHolder) *NodeStateHashMockEqualsExpectation {
	if mmEquals.mock.funcEquals != nil {
		mmEquals.mock.t.Fatalf("NodeStateHashMock.Equals mock is already set by Set")
	}

	expectation := &NodeStateHashMockEqualsExpectation{
		mock:   mmEquals.mock,
		params: &NodeStateHashMockEqualsParams{other},
	}
	mmEquals.expectations = append(mmEquals.expectations, expectation)
	return expectation
}

// Then sets up NodeStateHash.Equals return parameters for the expectation previously defined by the When method
func (e *NodeStateHashMockEqualsExpectation) Then(b1 bool) *NodeStateHashMock {
	e.results = &NodeStateHashMockEqualsResults{b1}
	return e.mock
}

// Equals implements NodeStateHash
func (mmEquals *NodeStateHashMock) Equals(other cryptkit.DigestHolder) (b1 bool) {
	mm_atomic.AddUint64(&mmEquals.beforeEqualsCounter, 1)
	defer mm_atomic.AddUint64(&mmEquals.afterEqualsCounter, 1)

	if mmEquals.inspectFuncEquals != nil {
		mmEquals.inspectFuncEquals(other)
	}

	params := &NodeStateHashMockEqualsParams{other}

	// Record call args
	mmEquals.EqualsMock.mutex.Lock()
	mmEquals.EqualsMock.callArgs = append(mmEquals.EqualsMock.callArgs, params)
	mmEquals.EqualsMock.mutex.Unlock()

	for _, e := range mmEquals.EqualsMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmEquals.EqualsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEquals.EqualsMock.defaultExpectation.Counter, 1)
		want := mmEquals.EqualsMock.defaultExpectation.params
		got := NodeStateHashMockEqualsParams{other}
		if want != nil && !minimock.Equal(*want, got) {
			mmEquals.t.Errorf("NodeStateHashMock.Equals got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmEquals.EqualsMock.defaultExpectation.results
		if results == nil {
			mmEquals.t.Fatal("No results are set for the NodeStateHashMock.Equals")
		}
		return (*results).b1
	}
	if mmEquals.funcEquals != nil {
		return mmEquals.funcEquals(other)
	}
	mmEquals.t.Fatalf("Unexpected call to NodeStateHashMock.Equals. %v", other)
	return
}

// EqualsAfterCounter returns a count of finished NodeStateHashMock.Equals invocations
func (mmEquals *NodeStateHashMock) EqualsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEquals.afterEqualsCounter)
}

// EqualsBeforeCounter returns a count of NodeStateHashMock.Equals invocations
func (mmEquals *NodeStateHashMock) EqualsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEquals.beforeEqualsCounter)
}

// Calls returns a list of arguments used in each call to NodeStateHashMock.Equals.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEquals *mNodeStateHashMockEquals) Calls() []*NodeStateHashMockEqualsParams {
	mmEquals.mutex.RLock()

	argCopy := make([]*NodeStateHashMockEqualsParams, len(mmEquals.callArgs))
	copy(argCopy, mmEquals.callArgs)

	mmEquals.mutex.RUnlock()

	return argCopy
}

// MinimockEqualsDone returns true if the count of the Equals invocations corresponds
// the number of defined expectations
func (m *NodeStateHashMock) MinimockEqualsDone() bool {
	for _, e := range m.EqualsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EqualsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEquals != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		return false
	}
	return true
}

// MinimockEqualsInspect logs each unmet expectation
func (m *NodeStateHashMock) MinimockEqualsInspect() {
	for _, e := range m.EqualsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NodeStateHashMock.Equals with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EqualsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		if m.EqualsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to NodeStateHashMock.Equals")
		} else {
			m.t.Errorf("Expected call to NodeStateHashMock.Equals with params: %#v", *m.EqualsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEquals != nil && mm_atomic.LoadUint64(&m.afterEqualsCounter) < 1 {
		m.t.Error("Expected call to NodeStateHashMock.Equals")
	}
}

type mNodeStateHashMockFixedByteSize struct {
	mock               *NodeStateHashMock
	defaultExpectation *NodeStateHashMockFixedByteSizeExpectation
	expectations       []*NodeStateHashMockFixedByteSizeExpectation
}

// NodeStateHashMockFixedByteSizeExpectation specifies expectation struct of the NodeStateHash.FixedByteSize
type NodeStateHashMockFixedByteSizeExpectation struct {
	mock *NodeStateHashMock

	results *NodeStateHashMockFixedByteSizeResults
	Counter uint64
}

// NodeStateHashMockFixedByteSizeResults contains results of the NodeStateHash.FixedByteSize
type NodeStateHashMockFixedByteSizeResults struct {
	i1 int
}

// Expect sets up expected params for NodeStateHash.FixedByteSize
func (mmFixedByteSize *mNodeStateHashMockFixedByteSize) Expect() *mNodeStateHashMockFixedByteSize {
	if mmFixedByteSize.mock.funcFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("NodeStateHashMock.FixedByteSize mock is already set by Set")
	}

	if mmFixedByteSize.defaultExpectation == nil {
		mmFixedByteSize.defaultExpectation = &NodeStateHashMockFixedByteSizeExpectation{}
	}

	return mmFixedByteSize
}

// Inspect accepts an inspector function that has same arguments as the NodeStateHash.FixedByteSize
func (mmFixedByteSize *mNodeStateHashMockFixedByteSize) Inspect(f func()) *mNodeStateHashMockFixedByteSize {
	if mmFixedByteSize.mock.inspectFuncFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("Inspect function is already set for NodeStateHashMock.FixedByteSize")
	}

	mmFixedByteSize.mock.inspectFuncFixedByteSize = f

	return mmFixedByteSize
}

// Return sets up results that will be returned by NodeStateHash.FixedByteSize
func (mmFixedByteSize *mNodeStateHashMockFixedByteSize) Return(i1 int) *NodeStateHashMock {
	if mmFixedByteSize.mock.funcFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("NodeStateHashMock.FixedByteSize mock is already set by Set")
	}

	if mmFixedByteSize.defaultExpectation == nil {
		mmFixedByteSize.defaultExpectation = &NodeStateHashMockFixedByteSizeExpectation{mock: mmFixedByteSize.mock}
	}
	mmFixedByteSize.defaultExpectation.results = &NodeStateHashMockFixedByteSizeResults{i1}
	return mmFixedByteSize.mock
}

//Set uses given function f to mock the NodeStateHash.FixedByteSize method
func (mmFixedByteSize *mNodeStateHashMockFixedByteSize) Set(f func() (i1 int)) *NodeStateHashMock {
	if mmFixedByteSize.defaultExpectation != nil {
		mmFixedByteSize.mock.t.Fatalf("Default expectation is already set for the NodeStateHash.FixedByteSize method")
	}

	if len(mmFixedByteSize.expectations) > 0 {
		mmFixedByteSize.mock.t.Fatalf("Some expectations are already set for the NodeStateHash.FixedByteSize method")
	}

	mmFixedByteSize.mock.funcFixedByteSize = f
	return mmFixedByteSize.mock
}

// FixedByteSize implements NodeStateHash
func (mmFixedByteSize *NodeStateHashMock) FixedByteSize() (i1 int) {
	mm_atomic.AddUint64(&mmFixedByteSize.beforeFixedByteSizeCounter, 1)
	defer mm_atomic.AddUint64(&mmFixedByteSize.afterFixedByteSizeCounter, 1)

	if mmFixedByteSize.inspectFuncFixedByteSize != nil {
		mmFixedByteSize.inspectFuncFixedByteSize()
	}

	if mmFixedByteSize.FixedByteSizeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFixedByteSize.FixedByteSizeMock.defaultExpectation.Counter, 1)

		results := mmFixedByteSize.FixedByteSizeMock.defaultExpectation.results
		if results == nil {
			mmFixedByteSize.t.Fatal("No results are set for the NodeStateHashMock.FixedByteSize")
		}
		return (*results).i1
	}
	if mmFixedByteSize.funcFixedByteSize != nil {
		return mmFixedByteSize.funcFixedByteSize()
	}
	mmFixedByteSize.t.Fatalf("Unexpected call to NodeStateHashMock.FixedByteSize.")
	return
}

// FixedByteSizeAfterCounter returns a count of finished NodeStateHashMock.FixedByteSize invocations
func (mmFixedByteSize *NodeStateHashMock) FixedByteSizeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFixedByteSize.afterFixedByteSizeCounter)
}

// FixedByteSizeBeforeCounter returns a count of NodeStateHashMock.FixedByteSize invocations
func (mmFixedByteSize *NodeStateHashMock) FixedByteSizeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFixedByteSize.beforeFixedByteSizeCounter)
}

// MinimockFixedByteSizeDone returns true if the count of the FixedByteSize invocations corresponds
// the number of defined expectations
func (m *NodeStateHashMock) MinimockFixedByteSizeDone() bool {
	for _, e := range m.FixedByteSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FixedByteSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFixedByteSize != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		return false
	}
	return true
}

// MinimockFixedByteSizeInspect logs each unmet expectation
func (m *NodeStateHashMock) MinimockFixedByteSizeInspect() {
	for _, e := range m.FixedByteSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NodeStateHashMock.FixedByteSize")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FixedByteSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		m.t.Error("Expected call to NodeStateHashMock.FixedByteSize")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFixedByteSize != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		m.t.Error("Expected call to NodeStateHashMock.FixedByteSize")
	}
}

type mNodeStateHashMockFoldToUint64 struct {
	mock               *NodeStateHashMock
	defaultExpectation *NodeStateHashMockFoldToUint64Expectation
	expectations       []*NodeStateHashMockFoldToUint64Expectation
}

// NodeStateHashMockFoldToUint64Expectation specifies expectation struct of the NodeStateHash.FoldToUint64
type NodeStateHashMockFoldToUint64Expectation struct {
	mock *NodeStateHashMock

	results *NodeStateHashMockFoldToUint64Results
	Counter uint64
}

// NodeStateHashMockFoldToUint64Results contains results of the NodeStateHash.FoldToUint64
type NodeStateHashMockFoldToUint64Results struct {
	u1 uint64
}

// Expect sets up expected params for NodeStateHash.FoldToUint64
func (mmFoldToUint64 *mNodeStateHashMockFoldToUint64) Expect() *mNodeStateHashMockFoldToUint64 {
	if mmFoldToUint64.mock.funcFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("NodeStateHashMock.FoldToUint64 mock is already set by Set")
	}

	if mmFoldToUint64.defaultExpectation == nil {
		mmFoldToUint64.defaultExpectation = &NodeStateHashMockFoldToUint64Expectation{}
	}

	return mmFoldToUint64
}

// Inspect accepts an inspector function that has same arguments as the NodeStateHash.FoldToUint64
func (mmFoldToUint64 *mNodeStateHashMockFoldToUint64) Inspect(f func()) *mNodeStateHashMockFoldToUint64 {
	if mmFoldToUint64.mock.inspectFuncFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("Inspect function is already set for NodeStateHashMock.FoldToUint64")
	}

	mmFoldToUint64.mock.inspectFuncFoldToUint64 = f

	return mmFoldToUint64
}

// Return sets up results that will be returned by NodeStateHash.FoldToUint64
func (mmFoldToUint64 *mNodeStateHashMockFoldToUint64) Return(u1 uint64) *NodeStateHashMock {
	if mmFoldToUint64.mock.funcFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("NodeStateHashMock.FoldToUint64 mock is already set by Set")
	}

	if mmFoldToUint64.defaultExpectation == nil {
		mmFoldToUint64.defaultExpectation = &NodeStateHashMockFoldToUint64Expectation{mock: mmFoldToUint64.mock}
	}
	mmFoldToUint64.defaultExpectation.results = &NodeStateHashMockFoldToUint64Results{u1}
	return mmFoldToUint64.mock
}

//Set uses given function f to mock the NodeStateHash.FoldToUint64 method
func (mmFoldToUint64 *mNodeStateHashMockFoldToUint64) Set(f func() (u1 uint64)) *NodeStateHashMock {
	if mmFoldToUint64.defaultExpectation != nil {
		mmFoldToUint64.mock.t.Fatalf("Default expectation is already set for the NodeStateHash.FoldToUint64 method")
	}

	if len(mmFoldToUint64.expectations) > 0 {
		mmFoldToUint64.mock.t.Fatalf("Some expectations are already set for the NodeStateHash.FoldToUint64 method")
	}

	mmFoldToUint64.mock.funcFoldToUint64 = f
	return mmFoldToUint64.mock
}

// FoldToUint64 implements NodeStateHash
func (mmFoldToUint64 *NodeStateHashMock) FoldToUint64() (u1 uint64) {
	mm_atomic.AddUint64(&mmFoldToUint64.beforeFoldToUint64Counter, 1)
	defer mm_atomic.AddUint64(&mmFoldToUint64.afterFoldToUint64Counter, 1)

	if mmFoldToUint64.inspectFuncFoldToUint64 != nil {
		mmFoldToUint64.inspectFuncFoldToUint64()
	}

	if mmFoldToUint64.FoldToUint64Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFoldToUint64.FoldToUint64Mock.defaultExpectation.Counter, 1)

		results := mmFoldToUint64.FoldToUint64Mock.defaultExpectation.results
		if results == nil {
			mmFoldToUint64.t.Fatal("No results are set for the NodeStateHashMock.FoldToUint64")
		}
		return (*results).u1
	}
	if mmFoldToUint64.funcFoldToUint64 != nil {
		return mmFoldToUint64.funcFoldToUint64()
	}
	mmFoldToUint64.t.Fatalf("Unexpected call to NodeStateHashMock.FoldToUint64.")
	return
}

// FoldToUint64AfterCounter returns a count of finished NodeStateHashMock.FoldToUint64 invocations
func (mmFoldToUint64 *NodeStateHashMock) FoldToUint64AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFoldToUint64.afterFoldToUint64Counter)
}

// FoldToUint64BeforeCounter returns a count of NodeStateHashMock.FoldToUint64 invocations
func (mmFoldToUint64 *NodeStateHashMock) FoldToUint64BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFoldToUint64.beforeFoldToUint64Counter)
}

// MinimockFoldToUint64Done returns true if the count of the FoldToUint64 invocations corresponds
// the number of defined expectations
func (m *NodeStateHashMock) MinimockFoldToUint64Done() bool {
	for _, e := range m.FoldToUint64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FoldToUint64Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFoldToUint64 != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		return false
	}
	return true
}

// MinimockFoldToUint64Inspect logs each unmet expectation
func (m *NodeStateHashMock) MinimockFoldToUint64Inspect() {
	for _, e := range m.FoldToUint64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NodeStateHashMock.FoldToUint64")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FoldToUint64Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		m.t.Error("Expected call to NodeStateHashMock.FoldToUint64")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFoldToUint64 != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		m.t.Error("Expected call to NodeStateHashMock.FoldToUint64")
	}
}

type mNodeStateHashMockGetDigestMethod struct {
	mock               *NodeStateHashMock
	defaultExpectation *NodeStateHashMockGetDigestMethodExpectation
	expectations       []*NodeStateHashMockGetDigestMethodExpectation
}

// NodeStateHashMockGetDigestMethodExpectation specifies expectation struct of the NodeStateHash.GetDigestMethod
type NodeStateHashMockGetDigestMethodExpectation struct {
	mock *NodeStateHashMock

	results *NodeStateHashMockGetDigestMethodResults
	Counter uint64
}

// NodeStateHashMockGetDigestMethodResults contains results of the NodeStateHash.GetDigestMethod
type NodeStateHashMockGetDigestMethodResults struct {
	d1 cryptkit.DigestMethod
}

// Expect sets up expected params for NodeStateHash.GetDigestMethod
func (mmGetDigestMethod *mNodeStateHashMockGetDigestMethod) Expect() *mNodeStateHashMockGetDigestMethod {
	if mmGetDigestMethod.mock.funcGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("NodeStateHashMock.GetDigestMethod mock is already set by Set")
	}

	if mmGetDigestMethod.defaultExpectation == nil {
		mmGetDigestMethod.defaultExpectation = &NodeStateHashMockGetDigestMethodExpectation{}
	}

	return mmGetDigestMethod
}

// Inspect accepts an inspector function that has same arguments as the NodeStateHash.GetDigestMethod
func (mmGetDigestMethod *mNodeStateHashMockGetDigestMethod) Inspect(f func()) *mNodeStateHashMockGetDigestMethod {
	if mmGetDigestMethod.mock.inspectFuncGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("Inspect function is already set for NodeStateHashMock.GetDigestMethod")
	}

	mmGetDigestMethod.mock.inspectFuncGetDigestMethod = f

	return mmGetDigestMethod
}

// Return sets up results that will be returned by NodeStateHash.GetDigestMethod
func (mmGetDigestMethod *mNodeStateHashMockGetDigestMethod) Return(d1 cryptkit.DigestMethod) *NodeStateHashMock {
	if mmGetDigestMethod.mock.funcGetDigestMethod != nil {
		mmGetDigestMethod.mock.t.Fatalf("NodeStateHashMock.GetDigestMethod mock is already set by Set")
	}

	if mmGetDigestMethod.defaultExpectation == nil {
		mmGetDigestMethod.defaultExpectation = &NodeStateHashMockGetDigestMethodExpectation{mock: mmGetDigestMethod.mock}
	}
	mmGetDigestMethod.defaultExpectation.results = &NodeStateHashMockGetDigestMethodResults{d1}
	return mmGetDigestMethod.mock
}

//Set uses given function f to mock the NodeStateHash.GetDigestMethod method
func (mmGetDigestMethod *mNodeStateHashMockGetDigestMethod) Set(f func() (d1 cryptkit.DigestMethod)) *NodeStateHashMock {
	if mmGetDigestMethod.defaultExpectation != nil {
		mmGetDigestMethod.mock.t.Fatalf("Default expectation is already set for the NodeStateHash.GetDigestMethod method")
	}

	if len(mmGetDigestMethod.expectations) > 0 {
		mmGetDigestMethod.mock.t.Fatalf("Some expectations are already set for the NodeStateHash.GetDigestMethod method")
	}

	mmGetDigestMethod.mock.funcGetDigestMethod = f
	return mmGetDigestMethod.mock
}

// GetDigestMethod implements NodeStateHash
func (mmGetDigestMethod *NodeStateHashMock) GetDigestMethod() (d1 cryptkit.DigestMethod) {
	mm_atomic.AddUint64(&mmGetDigestMethod.beforeGetDigestMethodCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDigestMethod.afterGetDigestMethodCounter, 1)

	if mmGetDigestMethod.inspectFuncGetDigestMethod != nil {
		mmGetDigestMethod.inspectFuncGetDigestMethod()
	}

	if mmGetDigestMethod.GetDigestMethodMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDigestMethod.GetDigestMethodMock.defaultExpectation.Counter, 1)

		results := mmGetDigestMethod.GetDigestMethodMock.defaultExpectation.results
		if results == nil {
			mmGetDigestMethod.t.Fatal("No results are set for the NodeStateHashMock.GetDigestMethod")
		}
		return (*results).d1
	}
	if mmGetDigestMethod.funcGetDigestMethod != nil {
		return mmGetDigestMethod.funcGetDigestMethod()
	}
	mmGetDigestMethod.t.Fatalf("Unexpected call to NodeStateHashMock.GetDigestMethod.")
	return
}

// GetDigestMethodAfterCounter returns a count of finished NodeStateHashMock.GetDigestMethod invocations
func (mmGetDigestMethod *NodeStateHashMock) GetDigestMethodAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestMethod.afterGetDigestMethodCounter)
}

// GetDigestMethodBeforeCounter returns a count of NodeStateHashMock.GetDigestMethod invocations
func (mmGetDigestMethod *NodeStateHashMock) GetDigestMethodBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigestMethod.beforeGetDigestMethodCounter)
}

// MinimockGetDigestMethodDone returns true if the count of the GetDigestMethod invocations corresponds
// the number of defined expectations
func (m *NodeStateHashMock) MinimockGetDigestMethodDone() bool {
	for _, e := range m.GetDigestMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestMethod != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetDigestMethodInspect logs each unmet expectation
func (m *NodeStateHashMock) MinimockGetDigestMethodInspect() {
	for _, e := range m.GetDigestMethodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to NodeStateHashMock.GetDigestMethod")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestMethodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		m.t.Error("Expected call to NodeStateHashMock.GetDigestMethod")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigestMethod != nil && mm_atomic.LoadUint64(&m.afterGetDigestMethodCounter) < 1 {
		m.t.Error("Expected call to NodeStateHashMock.GetDigestMethod")
	}
}

type mNodeStateHashMockRead struct {
	mock               *NodeStateHashMock
	defaultExpectation *NodeStateHashMockReadExpectation
	expectations       []*NodeStateHashMockReadExpectation

	callArgs []*NodeStateHashMockReadParams
	mutex    sync.RWMutex
}

// NodeStateHashMockReadExpectation specifies expectation struct of the NodeStateHash.Read
type NodeStateHashMockReadExpectation struct {
	mock    *NodeStateHashMock
	params  *NodeStateHashMockReadParams
	results *NodeStateHashMockReadResults
	Counter uint64
}

// NodeStateHashMockReadParams contains parameters of the NodeStateHash.Read
type NodeStateHashMockReadParams struct {
	p []byte
}

// NodeStateHashMockReadResults contains results of the NodeStateHash.Read
type NodeStateHashMockReadResults struct {
	n   int
	err error
}

// Expect sets up expected params for NodeStateHash.Read
func (mmRead *mNodeStateHashMockRead) Expect(p []byte) *mNodeStateHashMockRead {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("NodeStateHashMock.Read mock is already set by Set")
	}

	if mmRead.defaultExpectation == nil {
		mmRead.defaultExpectation = &NodeStateHashMockReadExpectation{}
	}

	mmRead.defaultExpectation.params = &NodeStateHashMockReadParams{p}
	for _, e := range mmRead.expectations {
		if minimock.Equal(e.params, mmRead.defaultExpectation.params) {
			mmRead.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRead.defaultExpectation.params)
		}
	}

	return mmRead
}

// Inspect accepts an inspector function that has same arguments as the NodeStateHash.Read
func (mmRead *mNodeStateHashMockRead) Inspect(f func(p []byte)) *mNodeStateHashMockRead {
	if mmRead.mock.inspectFuncRead != nil {
		mmRead.mock.t.Fatalf("Inspect function is already set for NodeStateHashMock.Read")
	}

	mmRead.mock.inspectFuncRead = f

	return mmRead
}

// Return sets up results that will be returned by NodeStateHash.Read
func (mmRead *mNodeStateHashMockRead) Return(n int, err error) *NodeStateHashMock {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("NodeStateHashMock.Read mock is already set by Set")
	}

	if mmRead.defaultExpectation == nil {
		mmRead.defaultExpectation = &NodeStateHashMockReadExpectation{mock: mmRead.mock}
	}
	mmRead.defaultExpectation.results = &NodeStateHashMockReadResults{n, err}
	return mmRead.mock
}

//Set uses given function f to mock the NodeStateHash.Read method
func (mmRead *mNodeStateHashMockRead) Set(f func(p []byte) (n int, err error)) *NodeStateHashMock {
	if mmRead.defaultExpectation != nil {
		mmRead.mock.t.Fatalf("Default expectation is already set for the NodeStateHash.Read method")
	}

	if len(mmRead.expectations) > 0 {
		mmRead.mock.t.Fatalf("Some expectations are already set for the NodeStateHash.Read method")
	}

	mmRead.mock.funcRead = f
	return mmRead.mock
}

// When sets expectation for the NodeStateHash.Read which will trigger the result defined by the following
// Then helper
func (mmRead *mNodeStateHashMockRead) When(p []byte) *NodeStateHashMockReadExpectation {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("NodeStateHashMock.Read mock is already set by Set")
	}

	expectation := &NodeStateHashMockReadExpectation{
		mock:   mmRead.mock,
		params: &NodeStateHashMockReadParams{p},
	}
	mmRead.expectations = append(mmRead.expectations, expectation)
	return expectation
}

// Then sets up NodeStateHash.Read return parameters for the expectation previously defined by the When method
func (e *NodeStateHashMockReadExpectation) Then(n int, err error) *NodeStateHashMock {
	e.results = &NodeStateHashMockReadResults{n, err}
	return e.mock
}

// Read implements NodeStateHash
func (mmRead *NodeStateHashMock) Read(p []byte) (n int, err error) {
	mm_atomic.AddUint64(&mmRead.beforeReadCounter, 1)
	defer mm_atomic.AddUint64(&mmRead.afterReadCounter, 1)

	if mmRead.inspectFuncRead != nil {
		mmRead.inspectFuncRead(p)
	}

	params := &NodeStateHashMockReadParams{p}

	// Record call args
	mmRead.ReadMock.mutex.Lock()
	mmRead.ReadMock.callArgs = append(mmRead.ReadMock.callArgs, params)
	mmRead.ReadMock.mutex.Unlock()

	for _, e := range mmRead.ReadMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmRead.ReadMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRead.ReadMock.defaultExpectation.Counter, 1)
		want := mmRead.ReadMock.defaultExpectation.params
		got := NodeStateHashMockReadParams{p}
		if want != nil && !minimock.Equal(*want, got) {
			mmRead.t.Errorf("NodeStateHashMock.Read got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmRead.ReadMock.defaultExpectation.results
		if results == nil {
			mmRead.t.Fatal("No results are set for the NodeStateHashMock.Read")
		}
		return (*results).n, (*results).err
	}
	if mmRead.funcRead != nil {
		return mmRead.funcRead(p)
	}
	mmRead.t.Fatalf("Unexpected call to NodeStateHashMock.Read. %v", p)
	return
}

// ReadAfterCounter returns a count of finished NodeStateHashMock.Read invocations
func (mmRead *NodeStateHashMock) ReadAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRead.afterReadCounter)
}

// ReadBeforeCounter returns a count of NodeStateHashMock.Read invocations
func (mmRead *NodeStateHashMock) ReadBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRead.beforeReadCounter)
}

// Calls returns a list of arguments used in each call to NodeStateHashMock.Read.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRead *mNodeStateHashMockRead) Calls() []*NodeStateHashMockReadParams {
	mmRead.mutex.RLock()

	argCopy := make([]*NodeStateHashMockReadParams, len(mmRead.callArgs))
	copy(argCopy, mmRead.callArgs)

	mmRead.mutex.RUnlock()

	return argCopy
}

// MinimockReadDone returns true if the count of the Read invocations corresponds
// the number of defined expectations
func (m *NodeStateHashMock) MinimockReadDone() bool {
	for _, e := range m.ReadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRead != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		return false
	}
	return true
}

// MinimockReadInspect logs each unmet expectation
func (m *NodeStateHashMock) MinimockReadInspect() {
	for _, e := range m.ReadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NodeStateHashMock.Read with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		if m.ReadMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to NodeStateHashMock.Read")
		} else {
			m.t.Errorf("Expected call to NodeStateHashMock.Read with params: %#v", *m.ReadMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRead != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		m.t.Error("Expected call to NodeStateHashMock.Read")
	}
}

type mNodeStateHashMockSignWith struct {
	mock               *NodeStateHashMock
	defaultExpectation *NodeStateHashMockSignWithExpectation
	expectations       []*NodeStateHashMockSignWithExpectation

	callArgs []*NodeStateHashMockSignWithParams
	mutex    sync.RWMutex
}

// NodeStateHashMockSignWithExpectation specifies expectation struct of the NodeStateHash.SignWith
type NodeStateHashMockSignWithExpectation struct {
	mock    *NodeStateHashMock
	params  *NodeStateHashMockSignWithParams
	results *NodeStateHashMockSignWithResults
	Counter uint64
}

// NodeStateHashMockSignWithParams contains parameters of the NodeStateHash.SignWith
type NodeStateHashMockSignWithParams struct {
	signer cryptkit.DigestSigner
}

// NodeStateHashMockSignWithResults contains results of the NodeStateHash.SignWith
type NodeStateHashMockSignWithResults struct {
	s1 cryptkit.SignedDigestHolder
}

// Expect sets up expected params for NodeStateHash.SignWith
func (mmSignWith *mNodeStateHashMockSignWith) Expect(signer cryptkit.DigestSigner) *mNodeStateHashMockSignWith {
	if mmSignWith.mock.funcSignWith != nil {
		mmSignWith.mock.t.Fatalf("NodeStateHashMock.SignWith mock is already set by Set")
	}

	if mmSignWith.defaultExpectation == nil {
		mmSignWith.defaultExpectation = &NodeStateHashMockSignWithExpectation{}
	}

	mmSignWith.defaultExpectation.params = &NodeStateHashMockSignWithParams{signer}
	for _, e := range mmSignWith.expectations {
		if minimock.Equal(e.params, mmSignWith.defaultExpectation.params) {
			mmSignWith.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSignWith.defaultExpectation.params)
		}
	}

	return mmSignWith
}

// Inspect accepts an inspector function that has same arguments as the NodeStateHash.SignWith
func (mmSignWith *mNodeStateHashMockSignWith) Inspect(f func(signer cryptkit.DigestSigner)) *mNodeStateHashMockSignWith {
	if mmSignWith.mock.inspectFuncSignWith != nil {
		mmSignWith.mock.t.Fatalf("Inspect function is already set for NodeStateHashMock.SignWith")
	}

	mmSignWith.mock.inspectFuncSignWith = f

	return mmSignWith
}

// Return sets up results that will be returned by NodeStateHash.SignWith
func (mmSignWith *mNodeStateHashMockSignWith) Return(s1 cryptkit.SignedDigestHolder) *NodeStateHashMock {
	if mmSignWith.mock.funcSignWith != nil {
		mmSignWith.mock.t.Fatalf("NodeStateHashMock.SignWith mock is already set by Set")
	}

	if mmSignWith.defaultExpectation == nil {
		mmSignWith.defaultExpectation = &NodeStateHashMockSignWithExpectation{mock: mmSignWith.mock}
	}
	mmSignWith.defaultExpectation.results = &NodeStateHashMockSignWithResults{s1}
	return mmSignWith.mock
}

//Set uses given function f to mock the NodeStateHash.SignWith method
func (mmSignWith *mNodeStateHashMockSignWith) Set(f func(signer cryptkit.DigestSigner) (s1 cryptkit.SignedDigestHolder)) *NodeStateHashMock {
	if mmSignWith.defaultExpectation != nil {
		mmSignWith.mock.t.Fatalf("Default expectation is already set for the NodeStateHash.SignWith method")
	}

	if len(mmSignWith.expectations) > 0 {
		mmSignWith.mock.t.Fatalf("Some expectations are already set for the NodeStateHash.SignWith method")
	}

	mmSignWith.mock.funcSignWith = f
	return mmSignWith.mock
}

// When sets expectation for the NodeStateHash.SignWith which will trigger the result defined by the following
// Then helper
func (mmSignWith *mNodeStateHashMockSignWith) When(signer cryptkit.DigestSigner) *NodeStateHashMockSignWithExpectation {
	if mmSignWith.mock.funcSignWith != nil {
		mmSignWith.mock.t.Fatalf("NodeStateHashMock.SignWith mock is already set by Set")
	}

	expectation := &NodeStateHashMockSignWithExpectation{
		mock:   mmSignWith.mock,
		params: &NodeStateHashMockSignWithParams{signer},
	}
	mmSignWith.expectations = append(mmSignWith.expectations, expectation)
	return expectation
}

// Then sets up NodeStateHash.SignWith return parameters for the expectation previously defined by the When method
func (e *NodeStateHashMockSignWithExpectation) Then(s1 cryptkit.SignedDigestHolder) *NodeStateHashMock {
	e.results = &NodeStateHashMockSignWithResults{s1}
	return e.mock
}

// SignWith implements NodeStateHash
func (mmSignWith *NodeStateHashMock) SignWith(signer cryptkit.DigestSigner) (s1 cryptkit.SignedDigestHolder) {
	mm_atomic.AddUint64(&mmSignWith.beforeSignWithCounter, 1)
	defer mm_atomic.AddUint64(&mmSignWith.afterSignWithCounter, 1)

	if mmSignWith.inspectFuncSignWith != nil {
		mmSignWith.inspectFuncSignWith(signer)
	}

	params := &NodeStateHashMockSignWithParams{signer}

	// Record call args
	mmSignWith.SignWithMock.mutex.Lock()
	mmSignWith.SignWithMock.callArgs = append(mmSignWith.SignWithMock.callArgs, params)
	mmSignWith.SignWithMock.mutex.Unlock()

	for _, e := range mmSignWith.SignWithMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmSignWith.SignWithMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSignWith.SignWithMock.defaultExpectation.Counter, 1)
		want := mmSignWith.SignWithMock.defaultExpectation.params
		got := NodeStateHashMockSignWithParams{signer}
		if want != nil && !minimock.Equal(*want, got) {
			mmSignWith.t.Errorf("NodeStateHashMock.SignWith got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmSignWith.SignWithMock.defaultExpectation.results
		if results == nil {
			mmSignWith.t.Fatal("No results are set for the NodeStateHashMock.SignWith")
		}
		return (*results).s1
	}
	if mmSignWith.funcSignWith != nil {
		return mmSignWith.funcSignWith(signer)
	}
	mmSignWith.t.Fatalf("Unexpected call to NodeStateHashMock.SignWith. %v", signer)
	return
}

// SignWithAfterCounter returns a count of finished NodeStateHashMock.SignWith invocations
func (mmSignWith *NodeStateHashMock) SignWithAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSignWith.afterSignWithCounter)
}

// SignWithBeforeCounter returns a count of NodeStateHashMock.SignWith invocations
func (mmSignWith *NodeStateHashMock) SignWithBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSignWith.beforeSignWithCounter)
}

// Calls returns a list of arguments used in each call to NodeStateHashMock.SignWith.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSignWith *mNodeStateHashMockSignWith) Calls() []*NodeStateHashMockSignWithParams {
	mmSignWith.mutex.RLock()

	argCopy := make([]*NodeStateHashMockSignWithParams, len(mmSignWith.callArgs))
	copy(argCopy, mmSignWith.callArgs)

	mmSignWith.mutex.RUnlock()

	return argCopy
}

// MinimockSignWithDone returns true if the count of the SignWith invocations corresponds
// the number of defined expectations
func (m *NodeStateHashMock) MinimockSignWithDone() bool {
	for _, e := range m.SignWithMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SignWithMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSignWithCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSignWith != nil && mm_atomic.LoadUint64(&m.afterSignWithCounter) < 1 {
		return false
	}
	return true
}

// MinimockSignWithInspect logs each unmet expectation
func (m *NodeStateHashMock) MinimockSignWithInspect() {
	for _, e := range m.SignWithMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NodeStateHashMock.SignWith with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SignWithMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSignWithCounter) < 1 {
		if m.SignWithMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to NodeStateHashMock.SignWith")
		} else {
			m.t.Errorf("Expected call to NodeStateHashMock.SignWith with params: %#v", *m.SignWithMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSignWith != nil && mm_atomic.LoadUint64(&m.afterSignWithCounter) < 1 {
		m.t.Error("Expected call to NodeStateHashMock.SignWith")
	}
}

type mNodeStateHashMockWriteTo struct {
	mock               *NodeStateHashMock
	defaultExpectation *NodeStateHashMockWriteToExpectation
	expectations       []*NodeStateHashMockWriteToExpectation

	callArgs []*NodeStateHashMockWriteToParams
	mutex    sync.RWMutex
}

// NodeStateHashMockWriteToExpectation specifies expectation struct of the NodeStateHash.WriteTo
type NodeStateHashMockWriteToExpectation struct {
	mock    *NodeStateHashMock
	params  *NodeStateHashMockWriteToParams
	results *NodeStateHashMockWriteToResults
	Counter uint64
}

// NodeStateHashMockWriteToParams contains parameters of the NodeStateHash.WriteTo
type NodeStateHashMockWriteToParams struct {
	w io.Writer
}

// NodeStateHashMockWriteToResults contains results of the NodeStateHash.WriteTo
type NodeStateHashMockWriteToResults struct {
	n   int64
	err error
}

// Expect sets up expected params for NodeStateHash.WriteTo
func (mmWriteTo *mNodeStateHashMockWriteTo) Expect(w io.Writer) *mNodeStateHashMockWriteTo {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("NodeStateHashMock.WriteTo mock is already set by Set")
	}

	if mmWriteTo.defaultExpectation == nil {
		mmWriteTo.defaultExpectation = &NodeStateHashMockWriteToExpectation{}
	}

	mmWriteTo.defaultExpectation.params = &NodeStateHashMockWriteToParams{w}
	for _, e := range mmWriteTo.expectations {
		if minimock.Equal(e.params, mmWriteTo.defaultExpectation.params) {
			mmWriteTo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWriteTo.defaultExpectation.params)
		}
	}

	return mmWriteTo
}

// Inspect accepts an inspector function that has same arguments as the NodeStateHash.WriteTo
func (mmWriteTo *mNodeStateHashMockWriteTo) Inspect(f func(w io.Writer)) *mNodeStateHashMockWriteTo {
	if mmWriteTo.mock.inspectFuncWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("Inspect function is already set for NodeStateHashMock.WriteTo")
	}

	mmWriteTo.mock.inspectFuncWriteTo = f

	return mmWriteTo
}

// Return sets up results that will be returned by NodeStateHash.WriteTo
func (mmWriteTo *mNodeStateHashMockWriteTo) Return(n int64, err error) *NodeStateHashMock {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("NodeStateHashMock.WriteTo mock is already set by Set")
	}

	if mmWriteTo.defaultExpectation == nil {
		mmWriteTo.defaultExpectation = &NodeStateHashMockWriteToExpectation{mock: mmWriteTo.mock}
	}
	mmWriteTo.defaultExpectation.results = &NodeStateHashMockWriteToResults{n, err}
	return mmWriteTo.mock
}

//Set uses given function f to mock the NodeStateHash.WriteTo method
func (mmWriteTo *mNodeStateHashMockWriteTo) Set(f func(w io.Writer) (n int64, err error)) *NodeStateHashMock {
	if mmWriteTo.defaultExpectation != nil {
		mmWriteTo.mock.t.Fatalf("Default expectation is already set for the NodeStateHash.WriteTo method")
	}

	if len(mmWriteTo.expectations) > 0 {
		mmWriteTo.mock.t.Fatalf("Some expectations are already set for the NodeStateHash.WriteTo method")
	}

	mmWriteTo.mock.funcWriteTo = f
	return mmWriteTo.mock
}

// When sets expectation for the NodeStateHash.WriteTo which will trigger the result defined by the following
// Then helper
func (mmWriteTo *mNodeStateHashMockWriteTo) When(w io.Writer) *NodeStateHashMockWriteToExpectation {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("NodeStateHashMock.WriteTo mock is already set by Set")
	}

	expectation := &NodeStateHashMockWriteToExpectation{
		mock:   mmWriteTo.mock,
		params: &NodeStateHashMockWriteToParams{w},
	}
	mmWriteTo.expectations = append(mmWriteTo.expectations, expectation)
	return expectation
}

// Then sets up NodeStateHash.WriteTo return parameters for the expectation previously defined by the When method
func (e *NodeStateHashMockWriteToExpectation) Then(n int64, err error) *NodeStateHashMock {
	e.results = &NodeStateHashMockWriteToResults{n, err}
	return e.mock
}

// WriteTo implements NodeStateHash
func (mmWriteTo *NodeStateHashMock) WriteTo(w io.Writer) (n int64, err error) {
	mm_atomic.AddUint64(&mmWriteTo.beforeWriteToCounter, 1)
	defer mm_atomic.AddUint64(&mmWriteTo.afterWriteToCounter, 1)

	if mmWriteTo.inspectFuncWriteTo != nil {
		mmWriteTo.inspectFuncWriteTo(w)
	}

	params := &NodeStateHashMockWriteToParams{w}

	// Record call args
	mmWriteTo.WriteToMock.mutex.Lock()
	mmWriteTo.WriteToMock.callArgs = append(mmWriteTo.WriteToMock.callArgs, params)
	mmWriteTo.WriteToMock.mutex.Unlock()

	for _, e := range mmWriteTo.WriteToMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmWriteTo.WriteToMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWriteTo.WriteToMock.defaultExpectation.Counter, 1)
		want := mmWriteTo.WriteToMock.defaultExpectation.params
		got := NodeStateHashMockWriteToParams{w}
		if want != nil && !minimock.Equal(*want, got) {
			mmWriteTo.t.Errorf("NodeStateHashMock.WriteTo got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmWriteTo.WriteToMock.defaultExpectation.results
		if results == nil {
			mmWriteTo.t.Fatal("No results are set for the NodeStateHashMock.WriteTo")
		}
		return (*results).n, (*results).err
	}
	if mmWriteTo.funcWriteTo != nil {
		return mmWriteTo.funcWriteTo(w)
	}
	mmWriteTo.t.Fatalf("Unexpected call to NodeStateHashMock.WriteTo. %v", w)
	return
}

// WriteToAfterCounter returns a count of finished NodeStateHashMock.WriteTo invocations
func (mmWriteTo *NodeStateHashMock) WriteToAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteTo.afterWriteToCounter)
}

// WriteToBeforeCounter returns a count of NodeStateHashMock.WriteTo invocations
func (mmWriteTo *NodeStateHashMock) WriteToBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteTo.beforeWriteToCounter)
}

// Calls returns a list of arguments used in each call to NodeStateHashMock.WriteTo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWriteTo *mNodeStateHashMockWriteTo) Calls() []*NodeStateHashMockWriteToParams {
	mmWriteTo.mutex.RLock()

	argCopy := make([]*NodeStateHashMockWriteToParams, len(mmWriteTo.callArgs))
	copy(argCopy, mmWriteTo.callArgs)

	mmWriteTo.mutex.RUnlock()

	return argCopy
}

// MinimockWriteToDone returns true if the count of the WriteTo invocations corresponds
// the number of defined expectations
func (m *NodeStateHashMock) MinimockWriteToDone() bool {
	for _, e := range m.WriteToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteTo != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		return false
	}
	return true
}

// MinimockWriteToInspect logs each unmet expectation
func (m *NodeStateHashMock) MinimockWriteToInspect() {
	for _, e := range m.WriteToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NodeStateHashMock.WriteTo with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		if m.WriteToMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to NodeStateHashMock.WriteTo")
		} else {
			m.t.Errorf("Expected call to NodeStateHashMock.WriteTo with params: %#v", *m.WriteToMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteTo != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		m.t.Error("Expected call to NodeStateHashMock.WriteTo")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *NodeStateHashMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAsByteStringInspect()

		m.MinimockAsBytesInspect()

		m.MinimockCopyOfDigestInspect()

		m.MinimockEqualsInspect()

		m.MinimockFixedByteSizeInspect()

		m.MinimockFoldToUint64Inspect()

		m.MinimockGetDigestMethodInspect()

		m.MinimockReadInspect()

		m.MinimockSignWithInspect()

		m.MinimockWriteToInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *NodeStateHashMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *NodeStateHashMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAsByteStringDone() &&
		m.MinimockAsBytesDone() &&
		m.MinimockCopyOfDigestDone() &&
		m.MinimockEqualsDone() &&
		m.MinimockFixedByteSizeDone() &&
		m.MinimockFoldToUint64Done() &&
		m.MinimockGetDigestMethodDone() &&
		m.MinimockReadDone() &&
		m.MinimockSignWithDone() &&
		m.MinimockWriteToDone()
}
