package longbits

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
)

// FoldableReaderMock implements FoldableReader
type FoldableReaderMock struct {
	t minimock.Tester

	funcAsByteString          func() (b1 ByteString)
	inspectFuncAsByteString   func()
	afterAsByteStringCounter  uint64
	beforeAsByteStringCounter uint64
	AsByteStringMock          mFoldableReaderMockAsByteString

	funcAsBytes          func() (ba1 []byte)
	inspectFuncAsBytes   func()
	afterAsBytesCounter  uint64
	beforeAsBytesCounter uint64
	AsBytesMock          mFoldableReaderMockAsBytes

	funcFixedByteSize          func() (i1 int)
	inspectFuncFixedByteSize   func()
	afterFixedByteSizeCounter  uint64
	beforeFixedByteSizeCounter uint64
	FixedByteSizeMock          mFoldableReaderMockFixedByteSize

	funcFoldToUint64          func() (u1 uint64)
	inspectFuncFoldToUint64   func()
	afterFoldToUint64Counter  uint64
	beforeFoldToUint64Counter uint64
	FoldToUint64Mock          mFoldableReaderMockFoldToUint64

	funcRead          func(p []byte) (n int, err error)
	inspectFuncRead   func(p []byte)
	afterReadCounter  uint64
	beforeReadCounter uint64
	ReadMock          mFoldableReaderMockRead

	funcWriteTo          func(w io.Writer) (n int64, err error)
	inspectFuncWriteTo   func(w io.Writer)
	afterWriteToCounter  uint64
	beforeWriteToCounter uint64
	WriteToMock          mFoldableReaderMockWriteTo
}

// NewFoldableReaderMock returns a mock for FoldableReader
func NewFoldableReaderMock(t minimock.Tester) *FoldableReaderMock {
	m := &FoldableReaderMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AsByteStringMock = mFoldableReaderMockAsByteString{mock: m}

	m.AsBytesMock = mFoldableReaderMockAsBytes{mock: m}

	m.FixedByteSizeMock = mFoldableReaderMockFixedByteSize{mock: m}

	m.FoldToUint64Mock = mFoldableReaderMockFoldToUint64{mock: m}

	m.ReadMock = mFoldableReaderMockRead{mock: m}
	m.ReadMock.callArgs = []*FoldableReaderMockReadParams{}

	m.WriteToMock = mFoldableReaderMockWriteTo{mock: m}
	m.WriteToMock.callArgs = []*FoldableReaderMockWriteToParams{}

	return m
}

type mFoldableReaderMockAsByteString struct {
	mock               *FoldableReaderMock
	defaultExpectation *FoldableReaderMockAsByteStringExpectation
	expectations       []*FoldableReaderMockAsByteStringExpectation
}

// FoldableReaderMockAsByteStringExpectation specifies expectation struct of the FoldableReader.AsByteString
type FoldableReaderMockAsByteStringExpectation struct {
	mock *FoldableReaderMock

	results *FoldableReaderMockAsByteStringResults
	Counter uint64
}

// FoldableReaderMockAsByteStringResults contains results of the FoldableReader.AsByteString
type FoldableReaderMockAsByteStringResults struct {
	b1 ByteString
}

// Expect sets up expected params for FoldableReader.AsByteString
func (mmAsByteString *mFoldableReaderMockAsByteString) Expect() *mFoldableReaderMockAsByteString {
	if mmAsByteString.mock.funcAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("FoldableReaderMock.AsByteString mock is already set by Set")
	}

	if mmAsByteString.defaultExpectation == nil {
		mmAsByteString.defaultExpectation = &FoldableReaderMockAsByteStringExpectation{}
	}

	return mmAsByteString
}

// Inspect accepts an inspector function that has same arguments as the FoldableReader.AsByteString
func (mmAsByteString *mFoldableReaderMockAsByteString) Inspect(f func()) *mFoldableReaderMockAsByteString {
	if mmAsByteString.mock.inspectFuncAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("Inspect function is already set for FoldableReaderMock.AsByteString")
	}

	mmAsByteString.mock.inspectFuncAsByteString = f

	return mmAsByteString
}

// Return sets up results that will be returned by FoldableReader.AsByteString
func (mmAsByteString *mFoldableReaderMockAsByteString) Return(b1 ByteString) *FoldableReaderMock {
	if mmAsByteString.mock.funcAsByteString != nil {
		mmAsByteString.mock.t.Fatalf("FoldableReaderMock.AsByteString mock is already set by Set")
	}

	if mmAsByteString.defaultExpectation == nil {
		mmAsByteString.defaultExpectation = &FoldableReaderMockAsByteStringExpectation{mock: mmAsByteString.mock}
	}
	mmAsByteString.defaultExpectation.results = &FoldableReaderMockAsByteStringResults{b1}
	return mmAsByteString.mock
}

//Set uses given function f to mock the FoldableReader.AsByteString method
func (mmAsByteString *mFoldableReaderMockAsByteString) Set(f func() (b1 ByteString)) *FoldableReaderMock {
	if mmAsByteString.defaultExpectation != nil {
		mmAsByteString.mock.t.Fatalf("Default expectation is already set for the FoldableReader.AsByteString method")
	}

	if len(mmAsByteString.expectations) > 0 {
		mmAsByteString.mock.t.Fatalf("Some expectations are already set for the FoldableReader.AsByteString method")
	}

	mmAsByteString.mock.funcAsByteString = f
	return mmAsByteString.mock
}

// AsByteString implements FoldableReader
func (mmAsByteString *FoldableReaderMock) AsByteString() (b1 ByteString) {
	mm_atomic.AddUint64(&mmAsByteString.beforeAsByteStringCounter, 1)
	defer mm_atomic.AddUint64(&mmAsByteString.afterAsByteStringCounter, 1)

	if mmAsByteString.inspectFuncAsByteString != nil {
		mmAsByteString.inspectFuncAsByteString()
	}

	if mmAsByteString.AsByteStringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAsByteString.AsByteStringMock.defaultExpectation.Counter, 1)

		results := mmAsByteString.AsByteStringMock.defaultExpectation.results
		if results == nil {
			mmAsByteString.t.Fatal("No results are set for the FoldableReaderMock.AsByteString")
		}
		return (*results).b1
	}
	if mmAsByteString.funcAsByteString != nil {
		return mmAsByteString.funcAsByteString()
	}
	mmAsByteString.t.Fatalf("Unexpected call to FoldableReaderMock.AsByteString.")
	return
}

// AsByteStringAfterCounter returns a count of finished FoldableReaderMock.AsByteString invocations
func (mmAsByteString *FoldableReaderMock) AsByteStringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsByteString.afterAsByteStringCounter)
}

// AsByteStringBeforeCounter returns a count of FoldableReaderMock.AsByteString invocations
func (mmAsByteString *FoldableReaderMock) AsByteStringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsByteString.beforeAsByteStringCounter)
}

// MinimockAsByteStringDone returns true if the count of the AsByteString invocations corresponds
// the number of defined expectations
func (m *FoldableReaderMock) MinimockAsByteStringDone() bool {
	for _, e := range m.AsByteStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsByteStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsByteString != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		return false
	}
	return true
}

// MinimockAsByteStringInspect logs each unmet expectation
func (m *FoldableReaderMock) MinimockAsByteStringInspect() {
	for _, e := range m.AsByteStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to FoldableReaderMock.AsByteString")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsByteStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		m.t.Error("Expected call to FoldableReaderMock.AsByteString")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsByteString != nil && mm_atomic.LoadUint64(&m.afterAsByteStringCounter) < 1 {
		m.t.Error("Expected call to FoldableReaderMock.AsByteString")
	}
}

type mFoldableReaderMockAsBytes struct {
	mock               *FoldableReaderMock
	defaultExpectation *FoldableReaderMockAsBytesExpectation
	expectations       []*FoldableReaderMockAsBytesExpectation
}

// FoldableReaderMockAsBytesExpectation specifies expectation struct of the FoldableReader.AsBytes
type FoldableReaderMockAsBytesExpectation struct {
	mock *FoldableReaderMock

	results *FoldableReaderMockAsBytesResults
	Counter uint64
}

// FoldableReaderMockAsBytesResults contains results of the FoldableReader.AsBytes
type FoldableReaderMockAsBytesResults struct {
	ba1 []byte
}

// Expect sets up expected params for FoldableReader.AsBytes
func (mmAsBytes *mFoldableReaderMockAsBytes) Expect() *mFoldableReaderMockAsBytes {
	if mmAsBytes.mock.funcAsBytes != nil {
		mmAsBytes.mock.t.Fatalf("FoldableReaderMock.AsBytes mock is already set by Set")
	}

	if mmAsBytes.defaultExpectation == nil {
		mmAsBytes.defaultExpectation = &FoldableReaderMockAsBytesExpectation{}
	}

	return mmAsBytes
}

// Inspect accepts an inspector function that has same arguments as the FoldableReader.AsBytes
func (mmAsBytes *mFoldableReaderMockAsBytes) Inspect(f func()) *mFoldableReaderMockAsBytes {
	if mmAsBytes.mock.inspectFuncAsBytes != nil {
		mmAsBytes.mock.t.Fatalf("Inspect function is already set for FoldableReaderMock.AsBytes")
	}

	mmAsBytes.mock.inspectFuncAsBytes = f

	return mmAsBytes
}

// Return sets up results that will be returned by FoldableReader.AsBytes
func (mmAsBytes *mFoldableReaderMockAsBytes) Return(ba1 []byte) *FoldableReaderMock {
	if mmAsBytes.mock.funcAsBytes != nil {
		mmAsBytes.mock.t.Fatalf("FoldableReaderMock.AsBytes mock is already set by Set")
	}

	if mmAsBytes.defaultExpectation == nil {
		mmAsBytes.defaultExpectation = &FoldableReaderMockAsBytesExpectation{mock: mmAsBytes.mock}
	}
	mmAsBytes.defaultExpectation.results = &FoldableReaderMockAsBytesResults{ba1}
	return mmAsBytes.mock
}

//Set uses given function f to mock the FoldableReader.AsBytes method
func (mmAsBytes *mFoldableReaderMockAsBytes) Set(f func() (ba1 []byte)) *FoldableReaderMock {
	if mmAsBytes.defaultExpectation != nil {
		mmAsBytes.mock.t.Fatalf("Default expectation is already set for the FoldableReader.AsBytes method")
	}

	if len(mmAsBytes.expectations) > 0 {
		mmAsBytes.mock.t.Fatalf("Some expectations are already set for the FoldableReader.AsBytes method")
	}

	mmAsBytes.mock.funcAsBytes = f
	return mmAsBytes.mock
}

// AsBytes implements FoldableReader
func (mmAsBytes *FoldableReaderMock) AsBytes() (ba1 []byte) {
	mm_atomic.AddUint64(&mmAsBytes.beforeAsBytesCounter, 1)
	defer mm_atomic.AddUint64(&mmAsBytes.afterAsBytesCounter, 1)

	if mmAsBytes.inspectFuncAsBytes != nil {
		mmAsBytes.inspectFuncAsBytes()
	}

	if mmAsBytes.AsBytesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAsBytes.AsBytesMock.defaultExpectation.Counter, 1)

		results := mmAsBytes.AsBytesMock.defaultExpectation.results
		if results == nil {
			mmAsBytes.t.Fatal("No results are set for the FoldableReaderMock.AsBytes")
		}
		return (*results).ba1
	}
	if mmAsBytes.funcAsBytes != nil {
		return mmAsBytes.funcAsBytes()
	}
	mmAsBytes.t.Fatalf("Unexpected call to FoldableReaderMock.AsBytes.")
	return
}

// AsBytesAfterCounter returns a count of finished FoldableReaderMock.AsBytes invocations
func (mmAsBytes *FoldableReaderMock) AsBytesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsBytes.afterAsBytesCounter)
}

// AsBytesBeforeCounter returns a count of FoldableReaderMock.AsBytes invocations
func (mmAsBytes *FoldableReaderMock) AsBytesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsBytes.beforeAsBytesCounter)
}

// MinimockAsBytesDone returns true if the count of the AsBytes invocations corresponds
// the number of defined expectations
func (m *FoldableReaderMock) MinimockAsBytesDone() bool {
	for _, e := range m.AsBytesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsBytesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsBytesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsBytes != nil && mm_atomic.LoadUint64(&m.afterAsBytesCounter) < 1 {
		return false
	}
	return true
}

// MinimockAsBytesInspect logs each unmet expectation
func (m *FoldableReaderMock) MinimockAsBytesInspect() {
	for _, e := range m.AsBytesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to FoldableReaderMock.AsBytes")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AsBytesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAsBytesCounter) < 1 {
		m.t.Error("Expected call to FoldableReaderMock.AsBytes")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsBytes != nil && mm_atomic.LoadUint64(&m.afterAsBytesCounter) < 1 {
		m.t.Error("Expected call to FoldableReaderMock.AsBytes")
	}
}

type mFoldableReaderMockFixedByteSize struct {
	mock               *FoldableReaderMock
	defaultExpectation *FoldableReaderMockFixedByteSizeExpectation
	expectations       []*FoldableReaderMockFixedByteSizeExpectation
}

// FoldableReaderMockFixedByteSizeExpectation specifies expectation struct of the FoldableReader.FixedByteSize
type FoldableReaderMockFixedByteSizeExpectation struct {
	mock *FoldableReaderMock

	results *FoldableReaderMockFixedByteSizeResults
	Counter uint64
}

// FoldableReaderMockFixedByteSizeResults contains results of the FoldableReader.FixedByteSize
type FoldableReaderMockFixedByteSizeResults struct {
	i1 int
}

// Expect sets up expected params for FoldableReader.FixedByteSize
func (mmFixedByteSize *mFoldableReaderMockFixedByteSize) Expect() *mFoldableReaderMockFixedByteSize {
	if mmFixedByteSize.mock.funcFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("FoldableReaderMock.FixedByteSize mock is already set by Set")
	}

	if mmFixedByteSize.defaultExpectation == nil {
		mmFixedByteSize.defaultExpectation = &FoldableReaderMockFixedByteSizeExpectation{}
	}

	return mmFixedByteSize
}

// Inspect accepts an inspector function that has same arguments as the FoldableReader.FixedByteSize
func (mmFixedByteSize *mFoldableReaderMockFixedByteSize) Inspect(f func()) *mFoldableReaderMockFixedByteSize {
	if mmFixedByteSize.mock.inspectFuncFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("Inspect function is already set for FoldableReaderMock.FixedByteSize")
	}

	mmFixedByteSize.mock.inspectFuncFixedByteSize = f

	return mmFixedByteSize
}

// Return sets up results that will be returned by FoldableReader.FixedByteSize
func (mmFixedByteSize *mFoldableReaderMockFixedByteSize) Return(i1 int) *FoldableReaderMock {
	if mmFixedByteSize.mock.funcFixedByteSize != nil {
		mmFixedByteSize.mock.t.Fatalf("FoldableReaderMock.FixedByteSize mock is already set by Set")
	}

	if mmFixedByteSize.defaultExpectation == nil {
		mmFixedByteSize.defaultExpectation = &FoldableReaderMockFixedByteSizeExpectation{mock: mmFixedByteSize.mock}
	}
	mmFixedByteSize.defaultExpectation.results = &FoldableReaderMockFixedByteSizeResults{i1}
	return mmFixedByteSize.mock
}

//Set uses given function f to mock the FoldableReader.FixedByteSize method
func (mmFixedByteSize *mFoldableReaderMockFixedByteSize) Set(f func() (i1 int)) *FoldableReaderMock {
	if mmFixedByteSize.defaultExpectation != nil {
		mmFixedByteSize.mock.t.Fatalf("Default expectation is already set for the FoldableReader.FixedByteSize method")
	}

	if len(mmFixedByteSize.expectations) > 0 {
		mmFixedByteSize.mock.t.Fatalf("Some expectations are already set for the FoldableReader.FixedByteSize method")
	}

	mmFixedByteSize.mock.funcFixedByteSize = f
	return mmFixedByteSize.mock
}

// FixedByteSize implements FoldableReader
func (mmFixedByteSize *FoldableReaderMock) FixedByteSize() (i1 int) {
	mm_atomic.AddUint64(&mmFixedByteSize.beforeFixedByteSizeCounter, 1)
	defer mm_atomic.AddUint64(&mmFixedByteSize.afterFixedByteSizeCounter, 1)

	if mmFixedByteSize.inspectFuncFixedByteSize != nil {
		mmFixedByteSize.inspectFuncFixedByteSize()
	}

	if mmFixedByteSize.FixedByteSizeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFixedByteSize.FixedByteSizeMock.defaultExpectation.Counter, 1)

		results := mmFixedByteSize.FixedByteSizeMock.defaultExpectation.results
		if results == nil {
			mmFixedByteSize.t.Fatal("No results are set for the FoldableReaderMock.FixedByteSize")
		}
		return (*results).i1
	}
	if mmFixedByteSize.funcFixedByteSize != nil {
		return mmFixedByteSize.funcFixedByteSize()
	}
	mmFixedByteSize.t.Fatalf("Unexpected call to FoldableReaderMock.FixedByteSize.")
	return
}

// FixedByteSizeAfterCounter returns a count of finished FoldableReaderMock.FixedByteSize invocations
func (mmFixedByteSize *FoldableReaderMock) FixedByteSizeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFixedByteSize.afterFixedByteSizeCounter)
}

// FixedByteSizeBeforeCounter returns a count of FoldableReaderMock.FixedByteSize invocations
func (mmFixedByteSize *FoldableReaderMock) FixedByteSizeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFixedByteSize.beforeFixedByteSizeCounter)
}

// MinimockFixedByteSizeDone returns true if the count of the FixedByteSize invocations corresponds
// the number of defined expectations
func (m *FoldableReaderMock) MinimockFixedByteSizeDone() bool {
	for _, e := range m.FixedByteSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FixedByteSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFixedByteSize != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		return false
	}
	return true
}

// MinimockFixedByteSizeInspect logs each unmet expectation
func (m *FoldableReaderMock) MinimockFixedByteSizeInspect() {
	for _, e := range m.FixedByteSizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to FoldableReaderMock.FixedByteSize")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FixedByteSizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		m.t.Error("Expected call to FoldableReaderMock.FixedByteSize")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFixedByteSize != nil && mm_atomic.LoadUint64(&m.afterFixedByteSizeCounter) < 1 {
		m.t.Error("Expected call to FoldableReaderMock.FixedByteSize")
	}
}

type mFoldableReaderMockFoldToUint64 struct {
	mock               *FoldableReaderMock
	defaultExpectation *FoldableReaderMockFoldToUint64Expectation
	expectations       []*FoldableReaderMockFoldToUint64Expectation
}

// FoldableReaderMockFoldToUint64Expectation specifies expectation struct of the FoldableReader.FoldToUint64
type FoldableReaderMockFoldToUint64Expectation struct {
	mock *FoldableReaderMock

	results *FoldableReaderMockFoldToUint64Results
	Counter uint64
}

// FoldableReaderMockFoldToUint64Results contains results of the FoldableReader.FoldToUint64
type FoldableReaderMockFoldToUint64Results struct {
	u1 uint64
}

// Expect sets up expected params for FoldableReader.FoldToUint64
func (mmFoldToUint64 *mFoldableReaderMockFoldToUint64) Expect() *mFoldableReaderMockFoldToUint64 {
	if mmFoldToUint64.mock.funcFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("FoldableReaderMock.FoldToUint64 mock is already set by Set")
	}

	if mmFoldToUint64.defaultExpectation == nil {
		mmFoldToUint64.defaultExpectation = &FoldableReaderMockFoldToUint64Expectation{}
	}

	return mmFoldToUint64
}

// Inspect accepts an inspector function that has same arguments as the FoldableReader.FoldToUint64
func (mmFoldToUint64 *mFoldableReaderMockFoldToUint64) Inspect(f func()) *mFoldableReaderMockFoldToUint64 {
	if mmFoldToUint64.mock.inspectFuncFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("Inspect function is already set for FoldableReaderMock.FoldToUint64")
	}

	mmFoldToUint64.mock.inspectFuncFoldToUint64 = f

	return mmFoldToUint64
}

// Return sets up results that will be returned by FoldableReader.FoldToUint64
func (mmFoldToUint64 *mFoldableReaderMockFoldToUint64) Return(u1 uint64) *FoldableReaderMock {
	if mmFoldToUint64.mock.funcFoldToUint64 != nil {
		mmFoldToUint64.mock.t.Fatalf("FoldableReaderMock.FoldToUint64 mock is already set by Set")
	}

	if mmFoldToUint64.defaultExpectation == nil {
		mmFoldToUint64.defaultExpectation = &FoldableReaderMockFoldToUint64Expectation{mock: mmFoldToUint64.mock}
	}
	mmFoldToUint64.defaultExpectation.results = &FoldableReaderMockFoldToUint64Results{u1}
	return mmFoldToUint64.mock
}

//Set uses given function f to mock the FoldableReader.FoldToUint64 method
func (mmFoldToUint64 *mFoldableReaderMockFoldToUint64) Set(f func() (u1 uint64)) *FoldableReaderMock {
	if mmFoldToUint64.defaultExpectation != nil {
		mmFoldToUint64.mock.t.Fatalf("Default expectation is already set for the FoldableReader.FoldToUint64 method")
	}

	if len(mmFoldToUint64.expectations) > 0 {
		mmFoldToUint64.mock.t.Fatalf("Some expectations are already set for the FoldableReader.FoldToUint64 method")
	}

	mmFoldToUint64.mock.funcFoldToUint64 = f
	return mmFoldToUint64.mock
}

// FoldToUint64 implements FoldableReader
func (mmFoldToUint64 *FoldableReaderMock) FoldToUint64() (u1 uint64) {
	mm_atomic.AddUint64(&mmFoldToUint64.beforeFoldToUint64Counter, 1)
	defer mm_atomic.AddUint64(&mmFoldToUint64.afterFoldToUint64Counter, 1)

	if mmFoldToUint64.inspectFuncFoldToUint64 != nil {
		mmFoldToUint64.inspectFuncFoldToUint64()
	}

	if mmFoldToUint64.FoldToUint64Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFoldToUint64.FoldToUint64Mock.defaultExpectation.Counter, 1)

		results := mmFoldToUint64.FoldToUint64Mock.defaultExpectation.results
		if results == nil {
			mmFoldToUint64.t.Fatal("No results are set for the FoldableReaderMock.FoldToUint64")
		}
		return (*results).u1
	}
	if mmFoldToUint64.funcFoldToUint64 != nil {
		return mmFoldToUint64.funcFoldToUint64()
	}
	mmFoldToUint64.t.Fatalf("Unexpected call to FoldableReaderMock.FoldToUint64.")
	return
}

// FoldToUint64AfterCounter returns a count of finished FoldableReaderMock.FoldToUint64 invocations
func (mmFoldToUint64 *FoldableReaderMock) FoldToUint64AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFoldToUint64.afterFoldToUint64Counter)
}

// FoldToUint64BeforeCounter returns a count of FoldableReaderMock.FoldToUint64 invocations
func (mmFoldToUint64 *FoldableReaderMock) FoldToUint64BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFoldToUint64.beforeFoldToUint64Counter)
}

// MinimockFoldToUint64Done returns true if the count of the FoldToUint64 invocations corresponds
// the number of defined expectations
func (m *FoldableReaderMock) MinimockFoldToUint64Done() bool {
	for _, e := range m.FoldToUint64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FoldToUint64Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFoldToUint64 != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		return false
	}
	return true
}

// MinimockFoldToUint64Inspect logs each unmet expectation
func (m *FoldableReaderMock) MinimockFoldToUint64Inspect() {
	for _, e := range m.FoldToUint64Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to FoldableReaderMock.FoldToUint64")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FoldToUint64Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		m.t.Error("Expected call to FoldableReaderMock.FoldToUint64")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFoldToUint64 != nil && mm_atomic.LoadUint64(&m.afterFoldToUint64Counter) < 1 {
		m.t.Error("Expected call to FoldableReaderMock.FoldToUint64")
	}
}

type mFoldableReaderMockRead struct {
	mock               *FoldableReaderMock
	defaultExpectation *FoldableReaderMockReadExpectation
	expectations       []*FoldableReaderMockReadExpectation

	callArgs []*FoldableReaderMockReadParams
	mutex    sync.RWMutex
}

// FoldableReaderMockReadExpectation specifies expectation struct of the FoldableReader.Read
type FoldableReaderMockReadExpectation struct {
	mock    *FoldableReaderMock
	params  *FoldableReaderMockReadParams
	results *FoldableReaderMockReadResults
	Counter uint64
}

// FoldableReaderMockReadParams contains parameters of the FoldableReader.Read
type FoldableReaderMockReadParams struct {
	p []byte
}

// FoldableReaderMockReadResults contains results of the FoldableReader.Read
type FoldableReaderMockReadResults struct {
	n   int
	err error
}

// Expect sets up expected params for FoldableReader.Read
func (mmRead *mFoldableReaderMockRead) Expect(p []byte) *mFoldableReaderMockRead {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("FoldableReaderMock.Read mock is already set by Set")
	}

	if mmRead.defaultExpectation == nil {
		mmRead.defaultExpectation = &FoldableReaderMockReadExpectation{}
	}

	mmRead.defaultExpectation.params = &FoldableReaderMockReadParams{p}
	for _, e := range mmRead.expectations {
		if minimock.Equal(e.params, mmRead.defaultExpectation.params) {
			mmRead.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRead.defaultExpectation.params)
		}
	}

	return mmRead
}

// Inspect accepts an inspector function that has same arguments as the FoldableReader.Read
func (mmRead *mFoldableReaderMockRead) Inspect(f func(p []byte)) *mFoldableReaderMockRead {
	if mmRead.mock.inspectFuncRead != nil {
		mmRead.mock.t.Fatalf("Inspect function is already set for FoldableReaderMock.Read")
	}

	mmRead.mock.inspectFuncRead = f

	return mmRead
}

// Return sets up results that will be returned by FoldableReader.Read
func (mmRead *mFoldableReaderMockRead) Return(n int, err error) *FoldableReaderMock {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("FoldableReaderMock.Read mock is already set by Set")
	}

	if mmRead.defaultExpectation == nil {
		mmRead.defaultExpectation = &FoldableReaderMockReadExpectation{mock: mmRead.mock}
	}
	mmRead.defaultExpectation.results = &FoldableReaderMockReadResults{n, err}
	return mmRead.mock
}

//Set uses given function f to mock the FoldableReader.Read method
func (mmRead *mFoldableReaderMockRead) Set(f func(p []byte) (n int, err error)) *FoldableReaderMock {
	if mmRead.defaultExpectation != nil {
		mmRead.mock.t.Fatalf("Default expectation is already set for the FoldableReader.Read method")
	}

	if len(mmRead.expectations) > 0 {
		mmRead.mock.t.Fatalf("Some expectations are already set for the FoldableReader.Read method")
	}

	mmRead.mock.funcRead = f
	return mmRead.mock
}

// When sets expectation for the FoldableReader.Read which will trigger the result defined by the following
// Then helper
func (mmRead *mFoldableReaderMockRead) When(p []byte) *FoldableReaderMockReadExpectation {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("FoldableReaderMock.Read mock is already set by Set")
	}

	expectation := &FoldableReaderMockReadExpectation{
		mock:   mmRead.mock,
		params: &FoldableReaderMockReadParams{p},
	}
	mmRead.expectations = append(mmRead.expectations, expectation)
	return expectation
}

// Then sets up FoldableReader.Read return parameters for the expectation previously defined by the When method
func (e *FoldableReaderMockReadExpectation) Then(n int, err error) *FoldableReaderMock {
	e.results = &FoldableReaderMockReadResults{n, err}
	return e.mock
}

// Read implements FoldableReader
func (mmRead *FoldableReaderMock) Read(p []byte) (n int, err error) {
	mm_atomic.AddUint64(&mmRead.beforeReadCounter, 1)
	defer mm_atomic.AddUint64(&mmRead.afterReadCounter, 1)

	if mmRead.inspectFuncRead != nil {
		mmRead.inspectFuncRead(p)
	}

	params := &FoldableReaderMockReadParams{p}

	// Record call args
	mmRead.ReadMock.mutex.Lock()
	mmRead.ReadMock.callArgs = append(mmRead.ReadMock.callArgs, params)
	mmRead.ReadMock.mutex.Unlock()

	for _, e := range mmRead.ReadMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmRead.ReadMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRead.ReadMock.defaultExpectation.Counter, 1)
		want := mmRead.ReadMock.defaultExpectation.params
		got := FoldableReaderMockReadParams{p}
		if want != nil && !minimock.Equal(*want, got) {
			mmRead.t.Errorf("FoldableReaderMock.Read got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmRead.ReadMock.defaultExpectation.results
		if results == nil {
			mmRead.t.Fatal("No results are set for the FoldableReaderMock.Read")
		}
		return (*results).n, (*results).err
	}
	if mmRead.funcRead != nil {
		return mmRead.funcRead(p)
	}
	mmRead.t.Fatalf("Unexpected call to FoldableReaderMock.Read. %v", p)
	return
}

// ReadAfterCounter returns a count of finished FoldableReaderMock.Read invocations
func (mmRead *FoldableReaderMock) ReadAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRead.afterReadCounter)
}

// ReadBeforeCounter returns a count of FoldableReaderMock.Read invocations
func (mmRead *FoldableReaderMock) ReadBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRead.beforeReadCounter)
}

// Calls returns a list of arguments used in each call to FoldableReaderMock.Read.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRead *mFoldableReaderMockRead) Calls() []*FoldableReaderMockReadParams {
	mmRead.mutex.RLock()

	argCopy := make([]*FoldableReaderMockReadParams, len(mmRead.callArgs))
	copy(argCopy, mmRead.callArgs)

	mmRead.mutex.RUnlock()

	return argCopy
}

// MinimockReadDone returns true if the count of the Read invocations corresponds
// the number of defined expectations
func (m *FoldableReaderMock) MinimockReadDone() bool {
	for _, e := range m.ReadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRead != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		return false
	}
	return true
}

// MinimockReadInspect logs each unmet expectation
func (m *FoldableReaderMock) MinimockReadInspect() {
	for _, e := range m.ReadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FoldableReaderMock.Read with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		if m.ReadMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FoldableReaderMock.Read")
		} else {
			m.t.Errorf("Expected call to FoldableReaderMock.Read with params: %#v", *m.ReadMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRead != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		m.t.Error("Expected call to FoldableReaderMock.Read")
	}
}

type mFoldableReaderMockWriteTo struct {
	mock               *FoldableReaderMock
	defaultExpectation *FoldableReaderMockWriteToExpectation
	expectations       []*FoldableReaderMockWriteToExpectation

	callArgs []*FoldableReaderMockWriteToParams
	mutex    sync.RWMutex
}

// FoldableReaderMockWriteToExpectation specifies expectation struct of the FoldableReader.WriteTo
type FoldableReaderMockWriteToExpectation struct {
	mock    *FoldableReaderMock
	params  *FoldableReaderMockWriteToParams
	results *FoldableReaderMockWriteToResults
	Counter uint64
}

// FoldableReaderMockWriteToParams contains parameters of the FoldableReader.WriteTo
type FoldableReaderMockWriteToParams struct {
	w io.Writer
}

// FoldableReaderMockWriteToResults contains results of the FoldableReader.WriteTo
type FoldableReaderMockWriteToResults struct {
	n   int64
	err error
}

// Expect sets up expected params for FoldableReader.WriteTo
func (mmWriteTo *mFoldableReaderMockWriteTo) Expect(w io.Writer) *mFoldableReaderMockWriteTo {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("FoldableReaderMock.WriteTo mock is already set by Set")
	}

	if mmWriteTo.defaultExpectation == nil {
		mmWriteTo.defaultExpectation = &FoldableReaderMockWriteToExpectation{}
	}

	mmWriteTo.defaultExpectation.params = &FoldableReaderMockWriteToParams{w}
	for _, e := range mmWriteTo.expectations {
		if minimock.Equal(e.params, mmWriteTo.defaultExpectation.params) {
			mmWriteTo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWriteTo.defaultExpectation.params)
		}
	}

	return mmWriteTo
}

// Inspect accepts an inspector function that has same arguments as the FoldableReader.WriteTo
func (mmWriteTo *mFoldableReaderMockWriteTo) Inspect(f func(w io.Writer)) *mFoldableReaderMockWriteTo {
	if mmWriteTo.mock.inspectFuncWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("Inspect function is already set for FoldableReaderMock.WriteTo")
	}

	mmWriteTo.mock.inspectFuncWriteTo = f

	return mmWriteTo
}

// Return sets up results that will be returned by FoldableReader.WriteTo
func (mmWriteTo *mFoldableReaderMockWriteTo) Return(n int64, err error) *FoldableReaderMock {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("FoldableReaderMock.WriteTo mock is already set by Set")
	}

	if mmWriteTo.defaultExpectation == nil {
		mmWriteTo.defaultExpectation = &FoldableReaderMockWriteToExpectation{mock: mmWriteTo.mock}
	}
	mmWriteTo.defaultExpectation.results = &FoldableReaderMockWriteToResults{n, err}
	return mmWriteTo.mock
}

//Set uses given function f to mock the FoldableReader.WriteTo method
func (mmWriteTo *mFoldableReaderMockWriteTo) Set(f func(w io.Writer) (n int64, err error)) *FoldableReaderMock {
	if mmWriteTo.defaultExpectation != nil {
		mmWriteTo.mock.t.Fatalf("Default expectation is already set for the FoldableReader.WriteTo method")
	}

	if len(mmWriteTo.expectations) > 0 {
		mmWriteTo.mock.t.Fatalf("Some expectations are already set for the FoldableReader.WriteTo method")
	}

	mmWriteTo.mock.funcWriteTo = f
	return mmWriteTo.mock
}

// When sets expectation for the FoldableReader.WriteTo which will trigger the result defined by the following
// Then helper
func (mmWriteTo *mFoldableReaderMockWriteTo) When(w io.Writer) *FoldableReaderMockWriteToExpectation {
	if mmWriteTo.mock.funcWriteTo != nil {
		mmWriteTo.mock.t.Fatalf("FoldableReaderMock.WriteTo mock is already set by Set")
	}

	expectation := &FoldableReaderMockWriteToExpectation{
		mock:   mmWriteTo.mock,
		params: &FoldableReaderMockWriteToParams{w},
	}
	mmWriteTo.expectations = append(mmWriteTo.expectations, expectation)
	return expectation
}

// Then sets up FoldableReader.WriteTo return parameters for the expectation previously defined by the When method
func (e *FoldableReaderMockWriteToExpectation) Then(n int64, err error) *FoldableReaderMock {
	e.results = &FoldableReaderMockWriteToResults{n, err}
	return e.mock
}

// WriteTo implements FoldableReader
func (mmWriteTo *FoldableReaderMock) WriteTo(w io.Writer) (n int64, err error) {
	mm_atomic.AddUint64(&mmWriteTo.beforeWriteToCounter, 1)
	defer mm_atomic.AddUint64(&mmWriteTo.afterWriteToCounter, 1)

	if mmWriteTo.inspectFuncWriteTo != nil {
		mmWriteTo.inspectFuncWriteTo(w)
	}

	params := &FoldableReaderMockWriteToParams{w}

	// Record call args
	mmWriteTo.WriteToMock.mutex.Lock()
	mmWriteTo.WriteToMock.callArgs = append(mmWriteTo.WriteToMock.callArgs, params)
	mmWriteTo.WriteToMock.mutex.Unlock()

	for _, e := range mmWriteTo.WriteToMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmWriteTo.WriteToMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWriteTo.WriteToMock.defaultExpectation.Counter, 1)
		want := mmWriteTo.WriteToMock.defaultExpectation.params
		got := FoldableReaderMockWriteToParams{w}
		if want != nil && !minimock.Equal(*want, got) {
			mmWriteTo.t.Errorf("FoldableReaderMock.WriteTo got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmWriteTo.WriteToMock.defaultExpectation.results
		if results == nil {
			mmWriteTo.t.Fatal("No results are set for the FoldableReaderMock.WriteTo")
		}
		return (*results).n, (*results).err
	}
	if mmWriteTo.funcWriteTo != nil {
		return mmWriteTo.funcWriteTo(w)
	}
	mmWriteTo.t.Fatalf("Unexpected call to FoldableReaderMock.WriteTo. %v", w)
	return
}

// WriteToAfterCounter returns a count of finished FoldableReaderMock.WriteTo invocations
func (mmWriteTo *FoldableReaderMock) WriteToAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteTo.afterWriteToCounter)
}

// WriteToBeforeCounter returns a count of FoldableReaderMock.WriteTo invocations
func (mmWriteTo *FoldableReaderMock) WriteToBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteTo.beforeWriteToCounter)
}

// Calls returns a list of arguments used in each call to FoldableReaderMock.WriteTo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWriteTo *mFoldableReaderMockWriteTo) Calls() []*FoldableReaderMockWriteToParams {
	mmWriteTo.mutex.RLock()

	argCopy := make([]*FoldableReaderMockWriteToParams, len(mmWriteTo.callArgs))
	copy(argCopy, mmWriteTo.callArgs)

	mmWriteTo.mutex.RUnlock()

	return argCopy
}

// MinimockWriteToDone returns true if the count of the WriteTo invocations corresponds
// the number of defined expectations
func (m *FoldableReaderMock) MinimockWriteToDone() bool {
	for _, e := range m.WriteToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteTo != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		return false
	}
	return true
}

// MinimockWriteToInspect logs each unmet expectation
func (m *FoldableReaderMock) MinimockWriteToInspect() {
	for _, e := range m.WriteToMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FoldableReaderMock.WriteTo with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteToMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		if m.WriteToMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FoldableReaderMock.WriteTo")
		} else {
			m.t.Errorf("Expected call to FoldableReaderMock.WriteTo with params: %#v", *m.WriteToMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteTo != nil && mm_atomic.LoadUint64(&m.afterWriteToCounter) < 1 {
		m.t.Error("Expected call to FoldableReaderMock.WriteTo")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *FoldableReaderMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAsByteStringInspect()

		m.MinimockAsBytesInspect()

		m.MinimockFixedByteSizeInspect()

		m.MinimockFoldToUint64Inspect()

		m.MinimockReadInspect()

		m.MinimockWriteToInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *FoldableReaderMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *FoldableReaderMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAsByteStringDone() &&
		m.MinimockAsBytesDone() &&
		m.MinimockFixedByteSizeDone() &&
		m.MinimockFoldToUint64Done() &&
		m.MinimockReadDone() &&
		m.MinimockWriteToDone()
}
