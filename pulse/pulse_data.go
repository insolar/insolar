//
// Copyright 2019 Insolar Technologies GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package pulse

import (
	"fmt"
	"sort"
	"strings"
	"time"

	"github.com/insolar/insolar/longbits"
	"github.com/insolar/insolar/network/consensus/common/cryptkit"
)

var _ DataReader = &Data{}

type Data struct {
	PulseNumber Number
	DataExt
}

type DataHolder interface {
	GetPulseNumber() Number
	GetPulseData() Data
	GetPulseDataDigest() cryptkit.DigestHolder
}

type DataExt struct {
	// ByteSize=44
	PulseEpoch     Epoch
	NextPulseDelta uint16
	PrevPulseDelta uint16
	// Unix millis when the pulse was generated by a Pulsar. MUST be zero otherwise.
	Timestamp    uint32
	PulseEntropy longbits.Bits256
}

type DataReader interface {
	GetPulseNumber() Number
	GetStartOfEpoch() Number
	GetPulseEntropy() longbits.Bits256
	GetNextPulseNumber() (Number, bool)
	GetPrevPulseNumber() (Number, bool)

	GetTimestamp() int64
	IsExpectedPulse() bool
	IsFromEphemeral() bool

	AsPulseData() Data
}

func NewFirstPulsarData(delta uint16, entropy longbits.Bits256) Data {
	return newPulsarData(OfNow(), delta, entropy)
}

func NewPulsarData(pn Number, deltaNext uint16, deltaPrev uint16, entropy longbits.Bits256) Data {
	r := newPulsarData(pn, deltaNext, entropy)
	r.PrevPulseDelta = deltaPrev
	return r
}

func NewFirstEphemeralData() Data {
	return newEphemeralData(MinTimePulse)
}

type EntropyFunc func() longbits.Bits256

func (r Data) String() string {
	buf := strings.Builder{}
	buf.WriteString(fmt.Sprint(r.PulseNumber))

	ep := r.PulseEpoch
	if uint32(ep) != uint32(r.PulseNumber) && ep != 0 {
		buf.WriteString(fmt.Sprintf("(%v)", ep))
	}
	if r.NextPulseDelta == r.PrevPulseDelta {
		buf.WriteString(fmt.Sprintf("Â±%d", r.NextPulseDelta))
	} else {
		if r.PrevPulseDelta > 0 {
			buf.WriteString(fmt.Sprintf("-%d", r.PrevPulseDelta))
		}
		if r.NextPulseDelta > 0 {
			buf.WriteString(fmt.Sprintf("+%d", r.NextPulseDelta))
		}
	}
	return buf.String()
}

func newPulsarData(pn Number, delta uint16, entropy longbits.Bits256) Data {
	if delta == 0 {
		panic("delta cant be zero")
	}
	return Data{
		PulseNumber: pn,
		DataExt: DataExt{
			PulseEpoch:     pn.AsEpoch(),
			PulseEntropy:   entropy,
			Timestamp:      uint32(time.Now().Unix()),
			NextPulseDelta: delta,
			PrevPulseDelta: 0,
		},
	}
}

func newEphemeralData(pn Number) Data {
	s := Data{
		PulseNumber: pn,
		DataExt: DataExt{
			PulseEpoch:     EphemeralPulseEpoch,
			Timestamp:      0,
			NextPulseDelta: 1,
			PrevPulseDelta: 0,
		},
	}
	fixedPulseEntropy(&s.PulseEntropy, s.PulseNumber)
	return s
}

/* This function has a fixed implementation and MUST remain unchanged as some elements of Consensus rely on identical behavior of this functions. */
func fixedPulseEntropy(v *longbits.Bits256, pn Number) {
	longbits.FillBitsWithStaticNoise(uint32(pn), (*v)[:])
}

func (r Data) EnsurePulseData() {
	switch {
	case r.isExpected():
		panic("next delta can't be zero")
	case !r.PulseNumber.IsTimePulse():
		panic("incorrect pulse number")
	case !r.HasValidEpoch():
		panic("incorrect pulse epoch")
	default:
		r.PulseNumber.Prev(r.PrevPulseDelta)
	}
}

func (r Data) HasValidEpoch() bool {
	switch isValid, isSpecial := r.PulseEpoch.Classify(); {
	case !isValid:
		return false
	case isSpecial:
		return true
	default:
		return r.PulseEpoch <= Epoch(r.PulseNumber)
	}
}

func (r Data) HasValidTimeEpoch() bool {
	return r.PulseEpoch <= Epoch(r.PulseNumber) && r.PulseEpoch.IsTimeEpoch()
}

func (r Data) isExpected() bool {
	return r.NextPulseDelta == 0
}

func (r Data) isFirst() bool {
	return r.PrevPulseDelta == 0
}

func (r Data) IsValidPulseData() bool {
	switch {
	case r.isExpected():
	case !r.PulseNumber.IsTimePulse():
	case !r.HasValidEpoch():
	default:
		return true
	}
	return false
}

func (r Data) IsEmpty() bool {
	return r.PulseNumber.IsUnknown()
}

func (r Data) IsEmptyCompatibleWith(epoch Epoch) bool {
	return r.PulseNumber.IsUnknown() && r.PulseEpoch.IsCompatible(epoch)
}

func (r Data) IsValidExpectedPulseData() bool {
	return r.isExpected() && r.PulseNumber.IsTimePulse() && r.HasValidEpoch()
}

func (r Data) IsValidExpectedPulsarData() bool {
	return r.isExpected() && r.PulseNumber.IsTimePulse() && r.HasValidTimeEpoch()
}

func (r Data) EnsurePulsarData() {
	if !r.PulseEpoch.IsTimeEpoch() {
		panic("incorrect pulse epoch by pulsar")
	}
	r.EnsurePulseData()
}

func (r Data) IsValidPulsarData() bool {
	if !r.PulseEpoch.IsTimeEpoch() {
		return false
	}
	return r.IsValidPulseData()
}

func (r Data) EnsureEphemeralData() {
	if !r.PulseEpoch.IsEphemeral() {
		panic("incorrect pulse epoch")
	}
	r.EnsurePulseData()
}

func (r Data) IsValidEphemeralData() bool {
	if !r.PulseEpoch.IsEphemeral() {
		return false
	}
	return r.IsValidPulseData()
}

func (r Data) IsFromPulsar() bool {
	return r.PulseEpoch.IsTimeEpoch() && r.PulseNumber.IsTimePulse()
}

func (r Data) IsFromEphemeral() bool {
	return r.PulseEpoch.IsEphemeral() && r.PulseNumber.IsTimePulse()
}

func (r Data) GetStartOfEpoch() Number {
	switch {
	case !r.PulseNumber.IsTimePulse():
		return Unknown
	case r.HasValidTimeEpoch():
		return OfUint32(uint32(r.PulseEpoch))
	}
	return r.PulseNumber
}

func (r Data) GetPulseEntropy() longbits.Bits256 {
	return r.PulseEntropy
}

func (r Data) CreateNextPulse(entropyGen EntropyFunc) Data {
	switch {
	case r.PulseEpoch.IsEphemeral():
		return r.createNextEphemeralPulse()
	case r.PulseEpoch.IsTimeEpoch():
		return r.createNextPulsarPulse(r.NextPulseDelta, entropyGen)
	case r.PulseEpoch.IsArticulation():
		panic("articulation pulse")
	default:
		panic("unknown pulse type")
	}
}

func (r Data) IsValidNext(n Data) bool {
	switch {
	case r.NextPulseDelta != n.PrevPulseDelta || r.isExpected() || n.isExpected():
	case !r.PulseNumber.IsTimePulse():
	case r.PulseNumber+Number(r.NextPulseDelta) != n.PulseNumber:
	case !r.PulseEpoch.IsCompatible(n.PulseEpoch):
	default:
		return true
	}
	return false
}

func (r Data) IsValidPrev(p Data) bool {
	switch {
	case p.NextPulseDelta != r.PrevPulseDelta || r.isFirst():
	case !r.PulseNumber.IsTimePulse():
	case p.PulseNumber+Number(p.NextPulseDelta) != r.PulseNumber:
	case !r.PulseEpoch.IsCompatible(p.PulseEpoch):
	default:
		return true
	}
	return false
}

func (r Data) GetNextPulseNumber() (Number, bool) {
	if r.isExpected() {
		return r.PulseNumber, false
	}
	return r.PulseNumber.TryNext(r.NextPulseDelta)
}

func (r Data) GetPrevPulseNumber() (Number, bool) {
	if r.isFirst() {
		return r.PulseNumber, false
	}
	return r.PulseNumber.TryPrev(r.PrevPulseDelta)
}

func (r Data) NextPulseNumber() Number {
	if r.isExpected() {
		panic("illegal state")
	}
	return r.PulseNumber.Next(r.NextPulseDelta)
}

func (r Data) PrevPulseNumber() Number {
	if r.isFirst() {
		panic("illegal state")
	}
	return r.PulseNumber.Prev(r.PrevPulseDelta)
}

func (r Data) CreateNextExpected() Data {
	s := Data{
		PulseNumber: r.NextPulseNumber(),
		DataExt: DataExt{
			PulseEpoch:     r.PulseEpoch,
			PrevPulseDelta: r.NextPulseDelta,
			NextPulseDelta: 0,
		},
	}
	if r.PulseEpoch.IsTimeEpoch() {
		s.PulseEpoch = s.PulseNumber.AsEpoch()
	}
	return s
}

func (r Data) CreateNextEphemeralPulse() Data {
	if !r.IsFromEphemeral() {
		panic("prev is not ephemeral")
	}
	return r.createNextEphemeralPulse()
}

func (r Data) createNextEphemeralPulse() Data {
	s := newEphemeralData(r.NextPulseNumber())
	s.PrevPulseDelta = r.NextPulseDelta
	return s
}

func (r Data) CreateNextPulsarPulse(delta uint16, entropyGen EntropyFunc) Data {
	if !r.PulseEpoch.IsTimeEpoch() {
		panic("not time pulse")
	}
	return r.createNextPulsarPulse(delta, entropyGen)
}

func (r Data) createNextPulsarPulse(delta uint16, entropyGen EntropyFunc) Data {
	s := newPulsarData(r.NextPulseNumber(), delta, entropyGen())
	s.PrevPulseDelta = r.NextPulseDelta
	return s
}

func (r Data) GetPulseNumber() Number {
	return r.PulseNumber
}

func (r Data) GetNextPulseDelta() uint16 {
	return r.NextPulseDelta
}

func (r Data) GetPrevPulseDelta() uint16 {
	return r.PrevPulseDelta
}

func (r Data) GetTimestamp() int64 {
	return int64(r.Timestamp)
}

func (r Data) IsExpectedPulse() bool {
	return r.isExpected() && r.PulseNumber.IsTimePulse()
}

func (r Data) IsFirstPulse() bool {
	return r.isFirst() && r.PulseNumber.IsTimePulse()
}

func (r Data) AsPulseData() Data {
	return r
}

func (r Data) AsRange() Range {
	r.EnsurePulseData()
	return onePulseRange{r}
}

func SortData(data []Data) {
	sort.Sort(DataSorter{data})
}

type DataSorter struct {
	Data []Data
}

func (d DataSorter) Len() int {
	return len(d.Data)
}

func (d DataSorter) Less(i, j int) bool {
	return d.Data[i].PulseNumber < d.Data[j].PulseNumber
}

func (d DataSorter) Swap(i, j int) {
	d.Data[i], d.Data[j] = d.Data[j], d.Data[i]
}
