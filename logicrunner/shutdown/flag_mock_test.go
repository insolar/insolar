package shutdown

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
)

// FlagMock implements Flag
type FlagMock struct {
	t minimock.Tester

	funcDone          func(ctx context.Context, isDone func() bool)
	inspectFuncDone   func(ctx context.Context, isDone func() bool)
	afterDoneCounter  uint64
	beforeDoneCounter uint64
	DoneMock          mFlagMockDone

	funcIsStopped          func() (b1 bool)
	inspectFuncIsStopped   func()
	afterIsStoppedCounter  uint64
	beforeIsStoppedCounter uint64
	IsStoppedMock          mFlagMockIsStopped

	funcStop          func(ctx context.Context) (f1 func())
	inspectFuncStop   func(ctx context.Context)
	afterStopCounter  uint64
	beforeStopCounter uint64
	StopMock          mFlagMockStop
}

// NewFlagMock returns a mock for Flag
func NewFlagMock(t minimock.Tester) *FlagMock {
	m := &FlagMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DoneMock = mFlagMockDone{mock: m}
	m.DoneMock.callArgs = []*FlagMockDoneParams{}

	m.IsStoppedMock = mFlagMockIsStopped{mock: m}

	m.StopMock = mFlagMockStop{mock: m}
	m.StopMock.callArgs = []*FlagMockStopParams{}

	return m
}

type mFlagMockDone struct {
	mock               *FlagMock
	defaultExpectation *FlagMockDoneExpectation
	expectations       []*FlagMockDoneExpectation

	callArgs []*FlagMockDoneParams
	mutex    sync.RWMutex
}

// FlagMockDoneExpectation specifies expectation struct of the Flag.Done
type FlagMockDoneExpectation struct {
	mock   *FlagMock
	params *FlagMockDoneParams

	Counter uint64
}

// FlagMockDoneParams contains parameters of the Flag.Done
type FlagMockDoneParams struct {
	ctx    context.Context
	isDone func() bool
}

// Expect sets up expected params for Flag.Done
func (mmDone *mFlagMockDone) Expect(ctx context.Context, isDone func() bool) *mFlagMockDone {
	if mmDone.mock.funcDone != nil {
		mmDone.mock.t.Fatalf("FlagMock.Done mock is already set by Set")
	}

	if mmDone.defaultExpectation == nil {
		mmDone.defaultExpectation = &FlagMockDoneExpectation{}
	}

	mmDone.defaultExpectation.params = &FlagMockDoneParams{ctx, isDone}
	for _, e := range mmDone.expectations {
		if minimock.Equal(e.params, mmDone.defaultExpectation.params) {
			mmDone.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDone.defaultExpectation.params)
		}
	}

	return mmDone
}

// Inspect accepts an inspector function that has same arguments as the Flag.Done
func (mmDone *mFlagMockDone) Inspect(f func(ctx context.Context, isDone func() bool)) *mFlagMockDone {
	if mmDone.mock.inspectFuncDone != nil {
		mmDone.mock.t.Fatalf("Inspect function is already set for FlagMock.Done")
	}

	mmDone.mock.inspectFuncDone = f

	return mmDone
}

// Return sets up results that will be returned by Flag.Done
func (mmDone *mFlagMockDone) Return() *FlagMock {
	if mmDone.mock.funcDone != nil {
		mmDone.mock.t.Fatalf("FlagMock.Done mock is already set by Set")
	}

	if mmDone.defaultExpectation == nil {
		mmDone.defaultExpectation = &FlagMockDoneExpectation{mock: mmDone.mock}
	}

	return mmDone.mock
}

//Set uses given function f to mock the Flag.Done method
func (mmDone *mFlagMockDone) Set(f func(ctx context.Context, isDone func() bool)) *FlagMock {
	if mmDone.defaultExpectation != nil {
		mmDone.mock.t.Fatalf("Default expectation is already set for the Flag.Done method")
	}

	if len(mmDone.expectations) > 0 {
		mmDone.mock.t.Fatalf("Some expectations are already set for the Flag.Done method")
	}

	mmDone.mock.funcDone = f
	return mmDone.mock
}

// Done implements Flag
func (mmDone *FlagMock) Done(ctx context.Context, isDone func() bool) {
	mm_atomic.AddUint64(&mmDone.beforeDoneCounter, 1)
	defer mm_atomic.AddUint64(&mmDone.afterDoneCounter, 1)

	if mmDone.inspectFuncDone != nil {
		mmDone.inspectFuncDone(ctx, isDone)
	}

	params := &FlagMockDoneParams{ctx, isDone}

	// Record call args
	mmDone.DoneMock.mutex.Lock()
	mmDone.DoneMock.callArgs = append(mmDone.DoneMock.callArgs, params)
	mmDone.DoneMock.mutex.Unlock()

	for _, e := range mmDone.DoneMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDone.DoneMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDone.DoneMock.defaultExpectation.Counter, 1)
		want := mmDone.DoneMock.defaultExpectation.params
		got := FlagMockDoneParams{ctx, isDone}
		if want != nil && !minimock.Equal(*want, got) {
			mmDone.t.Errorf("FlagMock.Done got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmDone.funcDone != nil {
		mmDone.funcDone(ctx, isDone)
		return
	}
	mmDone.t.Fatalf("Unexpected call to FlagMock.Done. %v %v", ctx, isDone)

}

// DoneAfterCounter returns a count of finished FlagMock.Done invocations
func (mmDone *FlagMock) DoneAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDone.afterDoneCounter)
}

// DoneBeforeCounter returns a count of FlagMock.Done invocations
func (mmDone *FlagMock) DoneBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDone.beforeDoneCounter)
}

// Calls returns a list of arguments used in each call to FlagMock.Done.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDone *mFlagMockDone) Calls() []*FlagMockDoneParams {
	mmDone.mutex.RLock()

	argCopy := make([]*FlagMockDoneParams, len(mmDone.callArgs))
	copy(argCopy, mmDone.callArgs)

	mmDone.mutex.RUnlock()

	return argCopy
}

// MinimockDoneDone returns true if the count of the Done invocations corresponds
// the number of defined expectations
func (m *FlagMock) MinimockDoneDone() bool {
	for _, e := range m.DoneMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DoneMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDoneCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDone != nil && mm_atomic.LoadUint64(&m.afterDoneCounter) < 1 {
		return false
	}
	return true
}

// MinimockDoneInspect logs each unmet expectation
func (m *FlagMock) MinimockDoneInspect() {
	for _, e := range m.DoneMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FlagMock.Done with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DoneMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDoneCounter) < 1 {
		if m.DoneMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FlagMock.Done")
		} else {
			m.t.Errorf("Expected call to FlagMock.Done with params: %#v", *m.DoneMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDone != nil && mm_atomic.LoadUint64(&m.afterDoneCounter) < 1 {
		m.t.Error("Expected call to FlagMock.Done")
	}
}

type mFlagMockIsStopped struct {
	mock               *FlagMock
	defaultExpectation *FlagMockIsStoppedExpectation
	expectations       []*FlagMockIsStoppedExpectation
}

// FlagMockIsStoppedExpectation specifies expectation struct of the Flag.IsStopped
type FlagMockIsStoppedExpectation struct {
	mock *FlagMock

	results *FlagMockIsStoppedResults
	Counter uint64
}

// FlagMockIsStoppedResults contains results of the Flag.IsStopped
type FlagMockIsStoppedResults struct {
	b1 bool
}

// Expect sets up expected params for Flag.IsStopped
func (mmIsStopped *mFlagMockIsStopped) Expect() *mFlagMockIsStopped {
	if mmIsStopped.mock.funcIsStopped != nil {
		mmIsStopped.mock.t.Fatalf("FlagMock.IsStopped mock is already set by Set")
	}

	if mmIsStopped.defaultExpectation == nil {
		mmIsStopped.defaultExpectation = &FlagMockIsStoppedExpectation{}
	}

	return mmIsStopped
}

// Inspect accepts an inspector function that has same arguments as the Flag.IsStopped
func (mmIsStopped *mFlagMockIsStopped) Inspect(f func()) *mFlagMockIsStopped {
	if mmIsStopped.mock.inspectFuncIsStopped != nil {
		mmIsStopped.mock.t.Fatalf("Inspect function is already set for FlagMock.IsStopped")
	}

	mmIsStopped.mock.inspectFuncIsStopped = f

	return mmIsStopped
}

// Return sets up results that will be returned by Flag.IsStopped
func (mmIsStopped *mFlagMockIsStopped) Return(b1 bool) *FlagMock {
	if mmIsStopped.mock.funcIsStopped != nil {
		mmIsStopped.mock.t.Fatalf("FlagMock.IsStopped mock is already set by Set")
	}

	if mmIsStopped.defaultExpectation == nil {
		mmIsStopped.defaultExpectation = &FlagMockIsStoppedExpectation{mock: mmIsStopped.mock}
	}
	mmIsStopped.defaultExpectation.results = &FlagMockIsStoppedResults{b1}
	return mmIsStopped.mock
}

//Set uses given function f to mock the Flag.IsStopped method
func (mmIsStopped *mFlagMockIsStopped) Set(f func() (b1 bool)) *FlagMock {
	if mmIsStopped.defaultExpectation != nil {
		mmIsStopped.mock.t.Fatalf("Default expectation is already set for the Flag.IsStopped method")
	}

	if len(mmIsStopped.expectations) > 0 {
		mmIsStopped.mock.t.Fatalf("Some expectations are already set for the Flag.IsStopped method")
	}

	mmIsStopped.mock.funcIsStopped = f
	return mmIsStopped.mock
}

// IsStopped implements Flag
func (mmIsStopped *FlagMock) IsStopped() (b1 bool) {
	mm_atomic.AddUint64(&mmIsStopped.beforeIsStoppedCounter, 1)
	defer mm_atomic.AddUint64(&mmIsStopped.afterIsStoppedCounter, 1)

	if mmIsStopped.inspectFuncIsStopped != nil {
		mmIsStopped.inspectFuncIsStopped()
	}

	if mmIsStopped.IsStoppedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsStopped.IsStoppedMock.defaultExpectation.Counter, 1)

		results := mmIsStopped.IsStoppedMock.defaultExpectation.results
		if results == nil {
			mmIsStopped.t.Fatal("No results are set for the FlagMock.IsStopped")
		}
		return (*results).b1
	}
	if mmIsStopped.funcIsStopped != nil {
		return mmIsStopped.funcIsStopped()
	}
	mmIsStopped.t.Fatalf("Unexpected call to FlagMock.IsStopped.")
	return
}

// IsStoppedAfterCounter returns a count of finished FlagMock.IsStopped invocations
func (mmIsStopped *FlagMock) IsStoppedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsStopped.afterIsStoppedCounter)
}

// IsStoppedBeforeCounter returns a count of FlagMock.IsStopped invocations
func (mmIsStopped *FlagMock) IsStoppedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsStopped.beforeIsStoppedCounter)
}

// MinimockIsStoppedDone returns true if the count of the IsStopped invocations corresponds
// the number of defined expectations
func (m *FlagMock) MinimockIsStoppedDone() bool {
	for _, e := range m.IsStoppedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsStoppedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsStoppedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsStopped != nil && mm_atomic.LoadUint64(&m.afterIsStoppedCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsStoppedInspect logs each unmet expectation
func (m *FlagMock) MinimockIsStoppedInspect() {
	for _, e := range m.IsStoppedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to FlagMock.IsStopped")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsStoppedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsStoppedCounter) < 1 {
		m.t.Error("Expected call to FlagMock.IsStopped")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsStopped != nil && mm_atomic.LoadUint64(&m.afterIsStoppedCounter) < 1 {
		m.t.Error("Expected call to FlagMock.IsStopped")
	}
}

type mFlagMockStop struct {
	mock               *FlagMock
	defaultExpectation *FlagMockStopExpectation
	expectations       []*FlagMockStopExpectation

	callArgs []*FlagMockStopParams
	mutex    sync.RWMutex
}

// FlagMockStopExpectation specifies expectation struct of the Flag.Stop
type FlagMockStopExpectation struct {
	mock    *FlagMock
	params  *FlagMockStopParams
	results *FlagMockStopResults
	Counter uint64
}

// FlagMockStopParams contains parameters of the Flag.Stop
type FlagMockStopParams struct {
	ctx context.Context
}

// FlagMockStopResults contains results of the Flag.Stop
type FlagMockStopResults struct {
	f1 func()
}

// Expect sets up expected params for Flag.Stop
func (mmStop *mFlagMockStop) Expect(ctx context.Context) *mFlagMockStop {
	if mmStop.mock.funcStop != nil {
		mmStop.mock.t.Fatalf("FlagMock.Stop mock is already set by Set")
	}

	if mmStop.defaultExpectation == nil {
		mmStop.defaultExpectation = &FlagMockStopExpectation{}
	}

	mmStop.defaultExpectation.params = &FlagMockStopParams{ctx}
	for _, e := range mmStop.expectations {
		if minimock.Equal(e.params, mmStop.defaultExpectation.params) {
			mmStop.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStop.defaultExpectation.params)
		}
	}

	return mmStop
}

// Inspect accepts an inspector function that has same arguments as the Flag.Stop
func (mmStop *mFlagMockStop) Inspect(f func(ctx context.Context)) *mFlagMockStop {
	if mmStop.mock.inspectFuncStop != nil {
		mmStop.mock.t.Fatalf("Inspect function is already set for FlagMock.Stop")
	}

	mmStop.mock.inspectFuncStop = f

	return mmStop
}

// Return sets up results that will be returned by Flag.Stop
func (mmStop *mFlagMockStop) Return(f1 func()) *FlagMock {
	if mmStop.mock.funcStop != nil {
		mmStop.mock.t.Fatalf("FlagMock.Stop mock is already set by Set")
	}

	if mmStop.defaultExpectation == nil {
		mmStop.defaultExpectation = &FlagMockStopExpectation{mock: mmStop.mock}
	}
	mmStop.defaultExpectation.results = &FlagMockStopResults{f1}
	return mmStop.mock
}

//Set uses given function f to mock the Flag.Stop method
func (mmStop *mFlagMockStop) Set(f func(ctx context.Context) (f1 func())) *FlagMock {
	if mmStop.defaultExpectation != nil {
		mmStop.mock.t.Fatalf("Default expectation is already set for the Flag.Stop method")
	}

	if len(mmStop.expectations) > 0 {
		mmStop.mock.t.Fatalf("Some expectations are already set for the Flag.Stop method")
	}

	mmStop.mock.funcStop = f
	return mmStop.mock
}

// When sets expectation for the Flag.Stop which will trigger the result defined by the following
// Then helper
func (mmStop *mFlagMockStop) When(ctx context.Context) *FlagMockStopExpectation {
	if mmStop.mock.funcStop != nil {
		mmStop.mock.t.Fatalf("FlagMock.Stop mock is already set by Set")
	}

	expectation := &FlagMockStopExpectation{
		mock:   mmStop.mock,
		params: &FlagMockStopParams{ctx},
	}
	mmStop.expectations = append(mmStop.expectations, expectation)
	return expectation
}

// Then sets up Flag.Stop return parameters for the expectation previously defined by the When method
func (e *FlagMockStopExpectation) Then(f1 func()) *FlagMock {
	e.results = &FlagMockStopResults{f1}
	return e.mock
}

// Stop implements Flag
func (mmStop *FlagMock) Stop(ctx context.Context) (f1 func()) {
	mm_atomic.AddUint64(&mmStop.beforeStopCounter, 1)
	defer mm_atomic.AddUint64(&mmStop.afterStopCounter, 1)

	if mmStop.inspectFuncStop != nil {
		mmStop.inspectFuncStop(ctx)
	}

	params := &FlagMockStopParams{ctx}

	// Record call args
	mmStop.StopMock.mutex.Lock()
	mmStop.StopMock.callArgs = append(mmStop.StopMock.callArgs, params)
	mmStop.StopMock.mutex.Unlock()

	for _, e := range mmStop.StopMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.f1
		}
	}

	if mmStop.StopMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStop.StopMock.defaultExpectation.Counter, 1)
		want := mmStop.StopMock.defaultExpectation.params
		got := FlagMockStopParams{ctx}
		if want != nil && !minimock.Equal(*want, got) {
			mmStop.t.Errorf("FlagMock.Stop got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmStop.StopMock.defaultExpectation.results
		if results == nil {
			mmStop.t.Fatal("No results are set for the FlagMock.Stop")
		}
		return (*results).f1
	}
	if mmStop.funcStop != nil {
		return mmStop.funcStop(ctx)
	}
	mmStop.t.Fatalf("Unexpected call to FlagMock.Stop. %v", ctx)
	return
}

// StopAfterCounter returns a count of finished FlagMock.Stop invocations
func (mmStop *FlagMock) StopAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStop.afterStopCounter)
}

// StopBeforeCounter returns a count of FlagMock.Stop invocations
func (mmStop *FlagMock) StopBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStop.beforeStopCounter)
}

// Calls returns a list of arguments used in each call to FlagMock.Stop.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStop *mFlagMockStop) Calls() []*FlagMockStopParams {
	mmStop.mutex.RLock()

	argCopy := make([]*FlagMockStopParams, len(mmStop.callArgs))
	copy(argCopy, mmStop.callArgs)

	mmStop.mutex.RUnlock()

	return argCopy
}

// MinimockStopDone returns true if the count of the Stop invocations corresponds
// the number of defined expectations
func (m *FlagMock) MinimockStopDone() bool {
	for _, e := range m.StopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStop != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		return false
	}
	return true
}

// MinimockStopInspect logs each unmet expectation
func (m *FlagMock) MinimockStopInspect() {
	for _, e := range m.StopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FlagMock.Stop with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		if m.StopMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FlagMock.Stop")
		} else {
			m.t.Errorf("Expected call to FlagMock.Stop with params: %#v", *m.StopMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStop != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		m.t.Error("Expected call to FlagMock.Stop")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *FlagMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockDoneInspect()

		m.MinimockIsStoppedInspect()

		m.MinimockStopInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *FlagMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *FlagMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDoneDone() &&
		m.MinimockIsStoppedDone() &&
		m.MinimockStopDone()
}
