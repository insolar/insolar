package requestsqueue

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/logicrunner/common"
)

// RequestsQueueMock implements RequestsQueue
type RequestsQueueMock struct {
	t minimock.Tester

	funcAppend          func(ctx context.Context, from RequestSource, transcripts ...*common.Transcript)
	inspectFuncAppend   func(ctx context.Context, from RequestSource, transcripts ...*common.Transcript)
	afterAppendCounter  uint64
	beforeAppendCounter uint64
	AppendMock          mRequestsQueueMockAppend

	funcClean          func(ctx context.Context) (tpa1 []*common.Transcript)
	inspectFuncClean   func(ctx context.Context)
	afterCleanCounter  uint64
	beforeCleanCounter uint64
	CleanMock          mRequestsQueueMockClean

	funcLength          func() (i1 int)
	inspectFuncLength   func()
	afterLengthCounter  uint64
	beforeLengthCounter uint64
	LengthMock          mRequestsQueueMockLength

	funcNumberOfOld          func(ctx context.Context) (i1 int)
	inspectFuncNumberOfOld   func(ctx context.Context)
	afterNumberOfOldCounter  uint64
	beforeNumberOfOldCounter uint64
	NumberOfOldMock          mRequestsQueueMockNumberOfOld

	funcTakeAllOriginatedFrom          func(ctx context.Context, from RequestSource) (tpa1 []*common.Transcript)
	inspectFuncTakeAllOriginatedFrom   func(ctx context.Context, from RequestSource)
	afterTakeAllOriginatedFromCounter  uint64
	beforeTakeAllOriginatedFromCounter uint64
	TakeAllOriginatedFromMock          mRequestsQueueMockTakeAllOriginatedFrom

	funcTakeFirst          func(ctx context.Context) (tp1 *common.Transcript)
	inspectFuncTakeFirst   func(ctx context.Context)
	afterTakeFirstCounter  uint64
	beforeTakeFirstCounter uint64
	TakeFirstMock          mRequestsQueueMockTakeFirst
}

// NewRequestsQueueMock returns a mock for RequestsQueue
func NewRequestsQueueMock(t minimock.Tester) *RequestsQueueMock {
	m := &RequestsQueueMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AppendMock = mRequestsQueueMockAppend{mock: m}
	m.AppendMock.callArgs = []*RequestsQueueMockAppendParams{}

	m.CleanMock = mRequestsQueueMockClean{mock: m}
	m.CleanMock.callArgs = []*RequestsQueueMockCleanParams{}

	m.LengthMock = mRequestsQueueMockLength{mock: m}

	m.NumberOfOldMock = mRequestsQueueMockNumberOfOld{mock: m}
	m.NumberOfOldMock.callArgs = []*RequestsQueueMockNumberOfOldParams{}

	m.TakeAllOriginatedFromMock = mRequestsQueueMockTakeAllOriginatedFrom{mock: m}
	m.TakeAllOriginatedFromMock.callArgs = []*RequestsQueueMockTakeAllOriginatedFromParams{}

	m.TakeFirstMock = mRequestsQueueMockTakeFirst{mock: m}
	m.TakeFirstMock.callArgs = []*RequestsQueueMockTakeFirstParams{}

	return m
}

type mRequestsQueueMockAppend struct {
	mock               *RequestsQueueMock
	defaultExpectation *RequestsQueueMockAppendExpectation
	expectations       []*RequestsQueueMockAppendExpectation

	callArgs []*RequestsQueueMockAppendParams
	mutex    sync.RWMutex
}

// RequestsQueueMockAppendExpectation specifies expectation struct of the RequestsQueue.Append
type RequestsQueueMockAppendExpectation struct {
	mock   *RequestsQueueMock
	params *RequestsQueueMockAppendParams

	Counter uint64
}

// RequestsQueueMockAppendParams contains parameters of the RequestsQueue.Append
type RequestsQueueMockAppendParams struct {
	ctx         context.Context
	from        RequestSource
	transcripts []*common.Transcript
}

// Expect sets up expected params for RequestsQueue.Append
func (mmAppend *mRequestsQueueMockAppend) Expect(ctx context.Context, from RequestSource, transcripts ...*common.Transcript) *mRequestsQueueMockAppend {
	if mmAppend.mock.funcAppend != nil {
		mmAppend.mock.t.Fatalf("RequestsQueueMock.Append mock is already set by Set")
	}

	if mmAppend.defaultExpectation == nil {
		mmAppend.defaultExpectation = &RequestsQueueMockAppendExpectation{}
	}

	mmAppend.defaultExpectation.params = &RequestsQueueMockAppendParams{ctx, from, transcripts}
	for _, e := range mmAppend.expectations {
		if minimock.Equal(e.params, mmAppend.defaultExpectation.params) {
			mmAppend.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAppend.defaultExpectation.params)
		}
	}

	return mmAppend
}

// Inspect accepts an inspector function that has same arguments as the RequestsQueue.Append
func (mmAppend *mRequestsQueueMockAppend) Inspect(f func(ctx context.Context, from RequestSource, transcripts ...*common.Transcript)) *mRequestsQueueMockAppend {
	if mmAppend.mock.inspectFuncAppend != nil {
		mmAppend.mock.t.Fatalf("Inspect function is already set for RequestsQueueMock.Append")
	}

	mmAppend.mock.inspectFuncAppend = f

	return mmAppend
}

// Return sets up results that will be returned by RequestsQueue.Append
func (mmAppend *mRequestsQueueMockAppend) Return() *RequestsQueueMock {
	if mmAppend.mock.funcAppend != nil {
		mmAppend.mock.t.Fatalf("RequestsQueueMock.Append mock is already set by Set")
	}

	if mmAppend.defaultExpectation == nil {
		mmAppend.defaultExpectation = &RequestsQueueMockAppendExpectation{mock: mmAppend.mock}
	}

	return mmAppend.mock
}

//Set uses given function f to mock the RequestsQueue.Append method
func (mmAppend *mRequestsQueueMockAppend) Set(f func(ctx context.Context, from RequestSource, transcripts ...*common.Transcript)) *RequestsQueueMock {
	if mmAppend.defaultExpectation != nil {
		mmAppend.mock.t.Fatalf("Default expectation is already set for the RequestsQueue.Append method")
	}

	if len(mmAppend.expectations) > 0 {
		mmAppend.mock.t.Fatalf("Some expectations are already set for the RequestsQueue.Append method")
	}

	mmAppend.mock.funcAppend = f
	return mmAppend.mock
}

// Append implements RequestsQueue
func (mmAppend *RequestsQueueMock) Append(ctx context.Context, from RequestSource, transcripts ...*common.Transcript) {
	mm_atomic.AddUint64(&mmAppend.beforeAppendCounter, 1)
	defer mm_atomic.AddUint64(&mmAppend.afterAppendCounter, 1)

	if mmAppend.inspectFuncAppend != nil {
		mmAppend.inspectFuncAppend(ctx, from, transcripts...)
	}

	params := &RequestsQueueMockAppendParams{ctx, from, transcripts}

	// Record call args
	mmAppend.AppendMock.mutex.Lock()
	mmAppend.AppendMock.callArgs = append(mmAppend.AppendMock.callArgs, params)
	mmAppend.AppendMock.mutex.Unlock()

	for _, e := range mmAppend.AppendMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAppend.AppendMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAppend.AppendMock.defaultExpectation.Counter, 1)
		want := mmAppend.AppendMock.defaultExpectation.params
		got := RequestsQueueMockAppendParams{ctx, from, transcripts}
		if want != nil && !minimock.Equal(*want, got) {
			mmAppend.t.Errorf("RequestsQueueMock.Append got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmAppend.funcAppend != nil {
		mmAppend.funcAppend(ctx, from, transcripts...)
		return
	}
	mmAppend.t.Fatalf("Unexpected call to RequestsQueueMock.Append. %v %v %v", ctx, from, transcripts)

}

// AppendAfterCounter returns a count of finished RequestsQueueMock.Append invocations
func (mmAppend *RequestsQueueMock) AppendAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAppend.afterAppendCounter)
}

// AppendBeforeCounter returns a count of RequestsQueueMock.Append invocations
func (mmAppend *RequestsQueueMock) AppendBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAppend.beforeAppendCounter)
}

// Calls returns a list of arguments used in each call to RequestsQueueMock.Append.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAppend *mRequestsQueueMockAppend) Calls() []*RequestsQueueMockAppendParams {
	mmAppend.mutex.RLock()

	argCopy := make([]*RequestsQueueMockAppendParams, len(mmAppend.callArgs))
	copy(argCopy, mmAppend.callArgs)

	mmAppend.mutex.RUnlock()

	return argCopy
}

// MinimockAppendDone returns true if the count of the Append invocations corresponds
// the number of defined expectations
func (m *RequestsQueueMock) MinimockAppendDone() bool {
	for _, e := range m.AppendMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AppendMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAppendCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAppend != nil && mm_atomic.LoadUint64(&m.afterAppendCounter) < 1 {
		return false
	}
	return true
}

// MinimockAppendInspect logs each unmet expectation
func (m *RequestsQueueMock) MinimockAppendInspect() {
	for _, e := range m.AppendMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RequestsQueueMock.Append with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AppendMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAppendCounter) < 1 {
		if m.AppendMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RequestsQueueMock.Append")
		} else {
			m.t.Errorf("Expected call to RequestsQueueMock.Append with params: %#v", *m.AppendMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAppend != nil && mm_atomic.LoadUint64(&m.afterAppendCounter) < 1 {
		m.t.Error("Expected call to RequestsQueueMock.Append")
	}
}

type mRequestsQueueMockClean struct {
	mock               *RequestsQueueMock
	defaultExpectation *RequestsQueueMockCleanExpectation
	expectations       []*RequestsQueueMockCleanExpectation

	callArgs []*RequestsQueueMockCleanParams
	mutex    sync.RWMutex
}

// RequestsQueueMockCleanExpectation specifies expectation struct of the RequestsQueue.Clean
type RequestsQueueMockCleanExpectation struct {
	mock    *RequestsQueueMock
	params  *RequestsQueueMockCleanParams
	results *RequestsQueueMockCleanResults
	Counter uint64
}

// RequestsQueueMockCleanParams contains parameters of the RequestsQueue.Clean
type RequestsQueueMockCleanParams struct {
	ctx context.Context
}

// RequestsQueueMockCleanResults contains results of the RequestsQueue.Clean
type RequestsQueueMockCleanResults struct {
	tpa1 []*common.Transcript
}

// Expect sets up expected params for RequestsQueue.Clean
func (mmClean *mRequestsQueueMockClean) Expect(ctx context.Context) *mRequestsQueueMockClean {
	if mmClean.mock.funcClean != nil {
		mmClean.mock.t.Fatalf("RequestsQueueMock.Clean mock is already set by Set")
	}

	if mmClean.defaultExpectation == nil {
		mmClean.defaultExpectation = &RequestsQueueMockCleanExpectation{}
	}

	mmClean.defaultExpectation.params = &RequestsQueueMockCleanParams{ctx}
	for _, e := range mmClean.expectations {
		if minimock.Equal(e.params, mmClean.defaultExpectation.params) {
			mmClean.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmClean.defaultExpectation.params)
		}
	}

	return mmClean
}

// Inspect accepts an inspector function that has same arguments as the RequestsQueue.Clean
func (mmClean *mRequestsQueueMockClean) Inspect(f func(ctx context.Context)) *mRequestsQueueMockClean {
	if mmClean.mock.inspectFuncClean != nil {
		mmClean.mock.t.Fatalf("Inspect function is already set for RequestsQueueMock.Clean")
	}

	mmClean.mock.inspectFuncClean = f

	return mmClean
}

// Return sets up results that will be returned by RequestsQueue.Clean
func (mmClean *mRequestsQueueMockClean) Return(tpa1 []*common.Transcript) *RequestsQueueMock {
	if mmClean.mock.funcClean != nil {
		mmClean.mock.t.Fatalf("RequestsQueueMock.Clean mock is already set by Set")
	}

	if mmClean.defaultExpectation == nil {
		mmClean.defaultExpectation = &RequestsQueueMockCleanExpectation{mock: mmClean.mock}
	}
	mmClean.defaultExpectation.results = &RequestsQueueMockCleanResults{tpa1}
	return mmClean.mock
}

//Set uses given function f to mock the RequestsQueue.Clean method
func (mmClean *mRequestsQueueMockClean) Set(f func(ctx context.Context) (tpa1 []*common.Transcript)) *RequestsQueueMock {
	if mmClean.defaultExpectation != nil {
		mmClean.mock.t.Fatalf("Default expectation is already set for the RequestsQueue.Clean method")
	}

	if len(mmClean.expectations) > 0 {
		mmClean.mock.t.Fatalf("Some expectations are already set for the RequestsQueue.Clean method")
	}

	mmClean.mock.funcClean = f
	return mmClean.mock
}

// When sets expectation for the RequestsQueue.Clean which will trigger the result defined by the following
// Then helper
func (mmClean *mRequestsQueueMockClean) When(ctx context.Context) *RequestsQueueMockCleanExpectation {
	if mmClean.mock.funcClean != nil {
		mmClean.mock.t.Fatalf("RequestsQueueMock.Clean mock is already set by Set")
	}

	expectation := &RequestsQueueMockCleanExpectation{
		mock:   mmClean.mock,
		params: &RequestsQueueMockCleanParams{ctx},
	}
	mmClean.expectations = append(mmClean.expectations, expectation)
	return expectation
}

// Then sets up RequestsQueue.Clean return parameters for the expectation previously defined by the When method
func (e *RequestsQueueMockCleanExpectation) Then(tpa1 []*common.Transcript) *RequestsQueueMock {
	e.results = &RequestsQueueMockCleanResults{tpa1}
	return e.mock
}

// Clean implements RequestsQueue
func (mmClean *RequestsQueueMock) Clean(ctx context.Context) (tpa1 []*common.Transcript) {
	mm_atomic.AddUint64(&mmClean.beforeCleanCounter, 1)
	defer mm_atomic.AddUint64(&mmClean.afterCleanCounter, 1)

	if mmClean.inspectFuncClean != nil {
		mmClean.inspectFuncClean(ctx)
	}

	params := &RequestsQueueMockCleanParams{ctx}

	// Record call args
	mmClean.CleanMock.mutex.Lock()
	mmClean.CleanMock.callArgs = append(mmClean.CleanMock.callArgs, params)
	mmClean.CleanMock.mutex.Unlock()

	for _, e := range mmClean.CleanMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tpa1
		}
	}

	if mmClean.CleanMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClean.CleanMock.defaultExpectation.Counter, 1)
		want := mmClean.CleanMock.defaultExpectation.params
		got := RequestsQueueMockCleanParams{ctx}
		if want != nil && !minimock.Equal(*want, got) {
			mmClean.t.Errorf("RequestsQueueMock.Clean got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmClean.CleanMock.defaultExpectation.results
		if results == nil {
			mmClean.t.Fatal("No results are set for the RequestsQueueMock.Clean")
		}
		return (*results).tpa1
	}
	if mmClean.funcClean != nil {
		return mmClean.funcClean(ctx)
	}
	mmClean.t.Fatalf("Unexpected call to RequestsQueueMock.Clean. %v", ctx)
	return
}

// CleanAfterCounter returns a count of finished RequestsQueueMock.Clean invocations
func (mmClean *RequestsQueueMock) CleanAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClean.afterCleanCounter)
}

// CleanBeforeCounter returns a count of RequestsQueueMock.Clean invocations
func (mmClean *RequestsQueueMock) CleanBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClean.beforeCleanCounter)
}

// Calls returns a list of arguments used in each call to RequestsQueueMock.Clean.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmClean *mRequestsQueueMockClean) Calls() []*RequestsQueueMockCleanParams {
	mmClean.mutex.RLock()

	argCopy := make([]*RequestsQueueMockCleanParams, len(mmClean.callArgs))
	copy(argCopy, mmClean.callArgs)

	mmClean.mutex.RUnlock()

	return argCopy
}

// MinimockCleanDone returns true if the count of the Clean invocations corresponds
// the number of defined expectations
func (m *RequestsQueueMock) MinimockCleanDone() bool {
	for _, e := range m.CleanMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CleanMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCleanCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClean != nil && mm_atomic.LoadUint64(&m.afterCleanCounter) < 1 {
		return false
	}
	return true
}

// MinimockCleanInspect logs each unmet expectation
func (m *RequestsQueueMock) MinimockCleanInspect() {
	for _, e := range m.CleanMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RequestsQueueMock.Clean with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CleanMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCleanCounter) < 1 {
		if m.CleanMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RequestsQueueMock.Clean")
		} else {
			m.t.Errorf("Expected call to RequestsQueueMock.Clean with params: %#v", *m.CleanMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClean != nil && mm_atomic.LoadUint64(&m.afterCleanCounter) < 1 {
		m.t.Error("Expected call to RequestsQueueMock.Clean")
	}
}

type mRequestsQueueMockLength struct {
	mock               *RequestsQueueMock
	defaultExpectation *RequestsQueueMockLengthExpectation
	expectations       []*RequestsQueueMockLengthExpectation
}

// RequestsQueueMockLengthExpectation specifies expectation struct of the RequestsQueue.Length
type RequestsQueueMockLengthExpectation struct {
	mock *RequestsQueueMock

	results *RequestsQueueMockLengthResults
	Counter uint64
}

// RequestsQueueMockLengthResults contains results of the RequestsQueue.Length
type RequestsQueueMockLengthResults struct {
	i1 int
}

// Expect sets up expected params for RequestsQueue.Length
func (mmLength *mRequestsQueueMockLength) Expect() *mRequestsQueueMockLength {
	if mmLength.mock.funcLength != nil {
		mmLength.mock.t.Fatalf("RequestsQueueMock.Length mock is already set by Set")
	}

	if mmLength.defaultExpectation == nil {
		mmLength.defaultExpectation = &RequestsQueueMockLengthExpectation{}
	}

	return mmLength
}

// Inspect accepts an inspector function that has same arguments as the RequestsQueue.Length
func (mmLength *mRequestsQueueMockLength) Inspect(f func()) *mRequestsQueueMockLength {
	if mmLength.mock.inspectFuncLength != nil {
		mmLength.mock.t.Fatalf("Inspect function is already set for RequestsQueueMock.Length")
	}

	mmLength.mock.inspectFuncLength = f

	return mmLength
}

// Return sets up results that will be returned by RequestsQueue.Length
func (mmLength *mRequestsQueueMockLength) Return(i1 int) *RequestsQueueMock {
	if mmLength.mock.funcLength != nil {
		mmLength.mock.t.Fatalf("RequestsQueueMock.Length mock is already set by Set")
	}

	if mmLength.defaultExpectation == nil {
		mmLength.defaultExpectation = &RequestsQueueMockLengthExpectation{mock: mmLength.mock}
	}
	mmLength.defaultExpectation.results = &RequestsQueueMockLengthResults{i1}
	return mmLength.mock
}

//Set uses given function f to mock the RequestsQueue.Length method
func (mmLength *mRequestsQueueMockLength) Set(f func() (i1 int)) *RequestsQueueMock {
	if mmLength.defaultExpectation != nil {
		mmLength.mock.t.Fatalf("Default expectation is already set for the RequestsQueue.Length method")
	}

	if len(mmLength.expectations) > 0 {
		mmLength.mock.t.Fatalf("Some expectations are already set for the RequestsQueue.Length method")
	}

	mmLength.mock.funcLength = f
	return mmLength.mock
}

// Length implements RequestsQueue
func (mmLength *RequestsQueueMock) Length() (i1 int) {
	mm_atomic.AddUint64(&mmLength.beforeLengthCounter, 1)
	defer mm_atomic.AddUint64(&mmLength.afterLengthCounter, 1)

	if mmLength.inspectFuncLength != nil {
		mmLength.inspectFuncLength()
	}

	if mmLength.LengthMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLength.LengthMock.defaultExpectation.Counter, 1)

		results := mmLength.LengthMock.defaultExpectation.results
		if results == nil {
			mmLength.t.Fatal("No results are set for the RequestsQueueMock.Length")
		}
		return (*results).i1
	}
	if mmLength.funcLength != nil {
		return mmLength.funcLength()
	}
	mmLength.t.Fatalf("Unexpected call to RequestsQueueMock.Length.")
	return
}

// LengthAfterCounter returns a count of finished RequestsQueueMock.Length invocations
func (mmLength *RequestsQueueMock) LengthAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLength.afterLengthCounter)
}

// LengthBeforeCounter returns a count of RequestsQueueMock.Length invocations
func (mmLength *RequestsQueueMock) LengthBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLength.beforeLengthCounter)
}

// MinimockLengthDone returns true if the count of the Length invocations corresponds
// the number of defined expectations
func (m *RequestsQueueMock) MinimockLengthDone() bool {
	for _, e := range m.LengthMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LengthMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLengthCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLength != nil && mm_atomic.LoadUint64(&m.afterLengthCounter) < 1 {
		return false
	}
	return true
}

// MinimockLengthInspect logs each unmet expectation
func (m *RequestsQueueMock) MinimockLengthInspect() {
	for _, e := range m.LengthMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RequestsQueueMock.Length")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LengthMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLengthCounter) < 1 {
		m.t.Error("Expected call to RequestsQueueMock.Length")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLength != nil && mm_atomic.LoadUint64(&m.afterLengthCounter) < 1 {
		m.t.Error("Expected call to RequestsQueueMock.Length")
	}
}

type mRequestsQueueMockNumberOfOld struct {
	mock               *RequestsQueueMock
	defaultExpectation *RequestsQueueMockNumberOfOldExpectation
	expectations       []*RequestsQueueMockNumberOfOldExpectation

	callArgs []*RequestsQueueMockNumberOfOldParams
	mutex    sync.RWMutex
}

// RequestsQueueMockNumberOfOldExpectation specifies expectation struct of the RequestsQueue.NumberOfOld
type RequestsQueueMockNumberOfOldExpectation struct {
	mock    *RequestsQueueMock
	params  *RequestsQueueMockNumberOfOldParams
	results *RequestsQueueMockNumberOfOldResults
	Counter uint64
}

// RequestsQueueMockNumberOfOldParams contains parameters of the RequestsQueue.NumberOfOld
type RequestsQueueMockNumberOfOldParams struct {
	ctx context.Context
}

// RequestsQueueMockNumberOfOldResults contains results of the RequestsQueue.NumberOfOld
type RequestsQueueMockNumberOfOldResults struct {
	i1 int
}

// Expect sets up expected params for RequestsQueue.NumberOfOld
func (mmNumberOfOld *mRequestsQueueMockNumberOfOld) Expect(ctx context.Context) *mRequestsQueueMockNumberOfOld {
	if mmNumberOfOld.mock.funcNumberOfOld != nil {
		mmNumberOfOld.mock.t.Fatalf("RequestsQueueMock.NumberOfOld mock is already set by Set")
	}

	if mmNumberOfOld.defaultExpectation == nil {
		mmNumberOfOld.defaultExpectation = &RequestsQueueMockNumberOfOldExpectation{}
	}

	mmNumberOfOld.defaultExpectation.params = &RequestsQueueMockNumberOfOldParams{ctx}
	for _, e := range mmNumberOfOld.expectations {
		if minimock.Equal(e.params, mmNumberOfOld.defaultExpectation.params) {
			mmNumberOfOld.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmNumberOfOld.defaultExpectation.params)
		}
	}

	return mmNumberOfOld
}

// Inspect accepts an inspector function that has same arguments as the RequestsQueue.NumberOfOld
func (mmNumberOfOld *mRequestsQueueMockNumberOfOld) Inspect(f func(ctx context.Context)) *mRequestsQueueMockNumberOfOld {
	if mmNumberOfOld.mock.inspectFuncNumberOfOld != nil {
		mmNumberOfOld.mock.t.Fatalf("Inspect function is already set for RequestsQueueMock.NumberOfOld")
	}

	mmNumberOfOld.mock.inspectFuncNumberOfOld = f

	return mmNumberOfOld
}

// Return sets up results that will be returned by RequestsQueue.NumberOfOld
func (mmNumberOfOld *mRequestsQueueMockNumberOfOld) Return(i1 int) *RequestsQueueMock {
	if mmNumberOfOld.mock.funcNumberOfOld != nil {
		mmNumberOfOld.mock.t.Fatalf("RequestsQueueMock.NumberOfOld mock is already set by Set")
	}

	if mmNumberOfOld.defaultExpectation == nil {
		mmNumberOfOld.defaultExpectation = &RequestsQueueMockNumberOfOldExpectation{mock: mmNumberOfOld.mock}
	}
	mmNumberOfOld.defaultExpectation.results = &RequestsQueueMockNumberOfOldResults{i1}
	return mmNumberOfOld.mock
}

//Set uses given function f to mock the RequestsQueue.NumberOfOld method
func (mmNumberOfOld *mRequestsQueueMockNumberOfOld) Set(f func(ctx context.Context) (i1 int)) *RequestsQueueMock {
	if mmNumberOfOld.defaultExpectation != nil {
		mmNumberOfOld.mock.t.Fatalf("Default expectation is already set for the RequestsQueue.NumberOfOld method")
	}

	if len(mmNumberOfOld.expectations) > 0 {
		mmNumberOfOld.mock.t.Fatalf("Some expectations are already set for the RequestsQueue.NumberOfOld method")
	}

	mmNumberOfOld.mock.funcNumberOfOld = f
	return mmNumberOfOld.mock
}

// When sets expectation for the RequestsQueue.NumberOfOld which will trigger the result defined by the following
// Then helper
func (mmNumberOfOld *mRequestsQueueMockNumberOfOld) When(ctx context.Context) *RequestsQueueMockNumberOfOldExpectation {
	if mmNumberOfOld.mock.funcNumberOfOld != nil {
		mmNumberOfOld.mock.t.Fatalf("RequestsQueueMock.NumberOfOld mock is already set by Set")
	}

	expectation := &RequestsQueueMockNumberOfOldExpectation{
		mock:   mmNumberOfOld.mock,
		params: &RequestsQueueMockNumberOfOldParams{ctx},
	}
	mmNumberOfOld.expectations = append(mmNumberOfOld.expectations, expectation)
	return expectation
}

// Then sets up RequestsQueue.NumberOfOld return parameters for the expectation previously defined by the When method
func (e *RequestsQueueMockNumberOfOldExpectation) Then(i1 int) *RequestsQueueMock {
	e.results = &RequestsQueueMockNumberOfOldResults{i1}
	return e.mock
}

// NumberOfOld implements RequestsQueue
func (mmNumberOfOld *RequestsQueueMock) NumberOfOld(ctx context.Context) (i1 int) {
	mm_atomic.AddUint64(&mmNumberOfOld.beforeNumberOfOldCounter, 1)
	defer mm_atomic.AddUint64(&mmNumberOfOld.afterNumberOfOldCounter, 1)

	if mmNumberOfOld.inspectFuncNumberOfOld != nil {
		mmNumberOfOld.inspectFuncNumberOfOld(ctx)
	}

	params := &RequestsQueueMockNumberOfOldParams{ctx}

	// Record call args
	mmNumberOfOld.NumberOfOldMock.mutex.Lock()
	mmNumberOfOld.NumberOfOldMock.callArgs = append(mmNumberOfOld.NumberOfOldMock.callArgs, params)
	mmNumberOfOld.NumberOfOldMock.mutex.Unlock()

	for _, e := range mmNumberOfOld.NumberOfOldMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1
		}
	}

	if mmNumberOfOld.NumberOfOldMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNumberOfOld.NumberOfOldMock.defaultExpectation.Counter, 1)
		want := mmNumberOfOld.NumberOfOldMock.defaultExpectation.params
		got := RequestsQueueMockNumberOfOldParams{ctx}
		if want != nil && !minimock.Equal(*want, got) {
			mmNumberOfOld.t.Errorf("RequestsQueueMock.NumberOfOld got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmNumberOfOld.NumberOfOldMock.defaultExpectation.results
		if results == nil {
			mmNumberOfOld.t.Fatal("No results are set for the RequestsQueueMock.NumberOfOld")
		}
		return (*results).i1
	}
	if mmNumberOfOld.funcNumberOfOld != nil {
		return mmNumberOfOld.funcNumberOfOld(ctx)
	}
	mmNumberOfOld.t.Fatalf("Unexpected call to RequestsQueueMock.NumberOfOld. %v", ctx)
	return
}

// NumberOfOldAfterCounter returns a count of finished RequestsQueueMock.NumberOfOld invocations
func (mmNumberOfOld *RequestsQueueMock) NumberOfOldAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNumberOfOld.afterNumberOfOldCounter)
}

// NumberOfOldBeforeCounter returns a count of RequestsQueueMock.NumberOfOld invocations
func (mmNumberOfOld *RequestsQueueMock) NumberOfOldBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNumberOfOld.beforeNumberOfOldCounter)
}

// Calls returns a list of arguments used in each call to RequestsQueueMock.NumberOfOld.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmNumberOfOld *mRequestsQueueMockNumberOfOld) Calls() []*RequestsQueueMockNumberOfOldParams {
	mmNumberOfOld.mutex.RLock()

	argCopy := make([]*RequestsQueueMockNumberOfOldParams, len(mmNumberOfOld.callArgs))
	copy(argCopy, mmNumberOfOld.callArgs)

	mmNumberOfOld.mutex.RUnlock()

	return argCopy
}

// MinimockNumberOfOldDone returns true if the count of the NumberOfOld invocations corresponds
// the number of defined expectations
func (m *RequestsQueueMock) MinimockNumberOfOldDone() bool {
	for _, e := range m.NumberOfOldMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NumberOfOldMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNumberOfOldCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNumberOfOld != nil && mm_atomic.LoadUint64(&m.afterNumberOfOldCounter) < 1 {
		return false
	}
	return true
}

// MinimockNumberOfOldInspect logs each unmet expectation
func (m *RequestsQueueMock) MinimockNumberOfOldInspect() {
	for _, e := range m.NumberOfOldMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RequestsQueueMock.NumberOfOld with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NumberOfOldMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNumberOfOldCounter) < 1 {
		if m.NumberOfOldMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RequestsQueueMock.NumberOfOld")
		} else {
			m.t.Errorf("Expected call to RequestsQueueMock.NumberOfOld with params: %#v", *m.NumberOfOldMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNumberOfOld != nil && mm_atomic.LoadUint64(&m.afterNumberOfOldCounter) < 1 {
		m.t.Error("Expected call to RequestsQueueMock.NumberOfOld")
	}
}

type mRequestsQueueMockTakeAllOriginatedFrom struct {
	mock               *RequestsQueueMock
	defaultExpectation *RequestsQueueMockTakeAllOriginatedFromExpectation
	expectations       []*RequestsQueueMockTakeAllOriginatedFromExpectation

	callArgs []*RequestsQueueMockTakeAllOriginatedFromParams
	mutex    sync.RWMutex
}

// RequestsQueueMockTakeAllOriginatedFromExpectation specifies expectation struct of the RequestsQueue.TakeAllOriginatedFrom
type RequestsQueueMockTakeAllOriginatedFromExpectation struct {
	mock    *RequestsQueueMock
	params  *RequestsQueueMockTakeAllOriginatedFromParams
	results *RequestsQueueMockTakeAllOriginatedFromResults
	Counter uint64
}

// RequestsQueueMockTakeAllOriginatedFromParams contains parameters of the RequestsQueue.TakeAllOriginatedFrom
type RequestsQueueMockTakeAllOriginatedFromParams struct {
	ctx  context.Context
	from RequestSource
}

// RequestsQueueMockTakeAllOriginatedFromResults contains results of the RequestsQueue.TakeAllOriginatedFrom
type RequestsQueueMockTakeAllOriginatedFromResults struct {
	tpa1 []*common.Transcript
}

// Expect sets up expected params for RequestsQueue.TakeAllOriginatedFrom
func (mmTakeAllOriginatedFrom *mRequestsQueueMockTakeAllOriginatedFrom) Expect(ctx context.Context, from RequestSource) *mRequestsQueueMockTakeAllOriginatedFrom {
	if mmTakeAllOriginatedFrom.mock.funcTakeAllOriginatedFrom != nil {
		mmTakeAllOriginatedFrom.mock.t.Fatalf("RequestsQueueMock.TakeAllOriginatedFrom mock is already set by Set")
	}

	if mmTakeAllOriginatedFrom.defaultExpectation == nil {
		mmTakeAllOriginatedFrom.defaultExpectation = &RequestsQueueMockTakeAllOriginatedFromExpectation{}
	}

	mmTakeAllOriginatedFrom.defaultExpectation.params = &RequestsQueueMockTakeAllOriginatedFromParams{ctx, from}
	for _, e := range mmTakeAllOriginatedFrom.expectations {
		if minimock.Equal(e.params, mmTakeAllOriginatedFrom.defaultExpectation.params) {
			mmTakeAllOriginatedFrom.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTakeAllOriginatedFrom.defaultExpectation.params)
		}
	}

	return mmTakeAllOriginatedFrom
}

// Inspect accepts an inspector function that has same arguments as the RequestsQueue.TakeAllOriginatedFrom
func (mmTakeAllOriginatedFrom *mRequestsQueueMockTakeAllOriginatedFrom) Inspect(f func(ctx context.Context, from RequestSource)) *mRequestsQueueMockTakeAllOriginatedFrom {
	if mmTakeAllOriginatedFrom.mock.inspectFuncTakeAllOriginatedFrom != nil {
		mmTakeAllOriginatedFrom.mock.t.Fatalf("Inspect function is already set for RequestsQueueMock.TakeAllOriginatedFrom")
	}

	mmTakeAllOriginatedFrom.mock.inspectFuncTakeAllOriginatedFrom = f

	return mmTakeAllOriginatedFrom
}

// Return sets up results that will be returned by RequestsQueue.TakeAllOriginatedFrom
func (mmTakeAllOriginatedFrom *mRequestsQueueMockTakeAllOriginatedFrom) Return(tpa1 []*common.Transcript) *RequestsQueueMock {
	if mmTakeAllOriginatedFrom.mock.funcTakeAllOriginatedFrom != nil {
		mmTakeAllOriginatedFrom.mock.t.Fatalf("RequestsQueueMock.TakeAllOriginatedFrom mock is already set by Set")
	}

	if mmTakeAllOriginatedFrom.defaultExpectation == nil {
		mmTakeAllOriginatedFrom.defaultExpectation = &RequestsQueueMockTakeAllOriginatedFromExpectation{mock: mmTakeAllOriginatedFrom.mock}
	}
	mmTakeAllOriginatedFrom.defaultExpectation.results = &RequestsQueueMockTakeAllOriginatedFromResults{tpa1}
	return mmTakeAllOriginatedFrom.mock
}

//Set uses given function f to mock the RequestsQueue.TakeAllOriginatedFrom method
func (mmTakeAllOriginatedFrom *mRequestsQueueMockTakeAllOriginatedFrom) Set(f func(ctx context.Context, from RequestSource) (tpa1 []*common.Transcript)) *RequestsQueueMock {
	if mmTakeAllOriginatedFrom.defaultExpectation != nil {
		mmTakeAllOriginatedFrom.mock.t.Fatalf("Default expectation is already set for the RequestsQueue.TakeAllOriginatedFrom method")
	}

	if len(mmTakeAllOriginatedFrom.expectations) > 0 {
		mmTakeAllOriginatedFrom.mock.t.Fatalf("Some expectations are already set for the RequestsQueue.TakeAllOriginatedFrom method")
	}

	mmTakeAllOriginatedFrom.mock.funcTakeAllOriginatedFrom = f
	return mmTakeAllOriginatedFrom.mock
}

// When sets expectation for the RequestsQueue.TakeAllOriginatedFrom which will trigger the result defined by the following
// Then helper
func (mmTakeAllOriginatedFrom *mRequestsQueueMockTakeAllOriginatedFrom) When(ctx context.Context, from RequestSource) *RequestsQueueMockTakeAllOriginatedFromExpectation {
	if mmTakeAllOriginatedFrom.mock.funcTakeAllOriginatedFrom != nil {
		mmTakeAllOriginatedFrom.mock.t.Fatalf("RequestsQueueMock.TakeAllOriginatedFrom mock is already set by Set")
	}

	expectation := &RequestsQueueMockTakeAllOriginatedFromExpectation{
		mock:   mmTakeAllOriginatedFrom.mock,
		params: &RequestsQueueMockTakeAllOriginatedFromParams{ctx, from},
	}
	mmTakeAllOriginatedFrom.expectations = append(mmTakeAllOriginatedFrom.expectations, expectation)
	return expectation
}

// Then sets up RequestsQueue.TakeAllOriginatedFrom return parameters for the expectation previously defined by the When method
func (e *RequestsQueueMockTakeAllOriginatedFromExpectation) Then(tpa1 []*common.Transcript) *RequestsQueueMock {
	e.results = &RequestsQueueMockTakeAllOriginatedFromResults{tpa1}
	return e.mock
}

// TakeAllOriginatedFrom implements RequestsQueue
func (mmTakeAllOriginatedFrom *RequestsQueueMock) TakeAllOriginatedFrom(ctx context.Context, from RequestSource) (tpa1 []*common.Transcript) {
	mm_atomic.AddUint64(&mmTakeAllOriginatedFrom.beforeTakeAllOriginatedFromCounter, 1)
	defer mm_atomic.AddUint64(&mmTakeAllOriginatedFrom.afterTakeAllOriginatedFromCounter, 1)

	if mmTakeAllOriginatedFrom.inspectFuncTakeAllOriginatedFrom != nil {
		mmTakeAllOriginatedFrom.inspectFuncTakeAllOriginatedFrom(ctx, from)
	}

	params := &RequestsQueueMockTakeAllOriginatedFromParams{ctx, from}

	// Record call args
	mmTakeAllOriginatedFrom.TakeAllOriginatedFromMock.mutex.Lock()
	mmTakeAllOriginatedFrom.TakeAllOriginatedFromMock.callArgs = append(mmTakeAllOriginatedFrom.TakeAllOriginatedFromMock.callArgs, params)
	mmTakeAllOriginatedFrom.TakeAllOriginatedFromMock.mutex.Unlock()

	for _, e := range mmTakeAllOriginatedFrom.TakeAllOriginatedFromMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tpa1
		}
	}

	if mmTakeAllOriginatedFrom.TakeAllOriginatedFromMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTakeAllOriginatedFrom.TakeAllOriginatedFromMock.defaultExpectation.Counter, 1)
		want := mmTakeAllOriginatedFrom.TakeAllOriginatedFromMock.defaultExpectation.params
		got := RequestsQueueMockTakeAllOriginatedFromParams{ctx, from}
		if want != nil && !minimock.Equal(*want, got) {
			mmTakeAllOriginatedFrom.t.Errorf("RequestsQueueMock.TakeAllOriginatedFrom got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmTakeAllOriginatedFrom.TakeAllOriginatedFromMock.defaultExpectation.results
		if results == nil {
			mmTakeAllOriginatedFrom.t.Fatal("No results are set for the RequestsQueueMock.TakeAllOriginatedFrom")
		}
		return (*results).tpa1
	}
	if mmTakeAllOriginatedFrom.funcTakeAllOriginatedFrom != nil {
		return mmTakeAllOriginatedFrom.funcTakeAllOriginatedFrom(ctx, from)
	}
	mmTakeAllOriginatedFrom.t.Fatalf("Unexpected call to RequestsQueueMock.TakeAllOriginatedFrom. %v %v", ctx, from)
	return
}

// TakeAllOriginatedFromAfterCounter returns a count of finished RequestsQueueMock.TakeAllOriginatedFrom invocations
func (mmTakeAllOriginatedFrom *RequestsQueueMock) TakeAllOriginatedFromAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTakeAllOriginatedFrom.afterTakeAllOriginatedFromCounter)
}

// TakeAllOriginatedFromBeforeCounter returns a count of RequestsQueueMock.TakeAllOriginatedFrom invocations
func (mmTakeAllOriginatedFrom *RequestsQueueMock) TakeAllOriginatedFromBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTakeAllOriginatedFrom.beforeTakeAllOriginatedFromCounter)
}

// Calls returns a list of arguments used in each call to RequestsQueueMock.TakeAllOriginatedFrom.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTakeAllOriginatedFrom *mRequestsQueueMockTakeAllOriginatedFrom) Calls() []*RequestsQueueMockTakeAllOriginatedFromParams {
	mmTakeAllOriginatedFrom.mutex.RLock()

	argCopy := make([]*RequestsQueueMockTakeAllOriginatedFromParams, len(mmTakeAllOriginatedFrom.callArgs))
	copy(argCopy, mmTakeAllOriginatedFrom.callArgs)

	mmTakeAllOriginatedFrom.mutex.RUnlock()

	return argCopy
}

// MinimockTakeAllOriginatedFromDone returns true if the count of the TakeAllOriginatedFrom invocations corresponds
// the number of defined expectations
func (m *RequestsQueueMock) MinimockTakeAllOriginatedFromDone() bool {
	for _, e := range m.TakeAllOriginatedFromMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TakeAllOriginatedFromMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTakeAllOriginatedFromCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTakeAllOriginatedFrom != nil && mm_atomic.LoadUint64(&m.afterTakeAllOriginatedFromCounter) < 1 {
		return false
	}
	return true
}

// MinimockTakeAllOriginatedFromInspect logs each unmet expectation
func (m *RequestsQueueMock) MinimockTakeAllOriginatedFromInspect() {
	for _, e := range m.TakeAllOriginatedFromMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RequestsQueueMock.TakeAllOriginatedFrom with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TakeAllOriginatedFromMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTakeAllOriginatedFromCounter) < 1 {
		if m.TakeAllOriginatedFromMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RequestsQueueMock.TakeAllOriginatedFrom")
		} else {
			m.t.Errorf("Expected call to RequestsQueueMock.TakeAllOriginatedFrom with params: %#v", *m.TakeAllOriginatedFromMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTakeAllOriginatedFrom != nil && mm_atomic.LoadUint64(&m.afterTakeAllOriginatedFromCounter) < 1 {
		m.t.Error("Expected call to RequestsQueueMock.TakeAllOriginatedFrom")
	}
}

type mRequestsQueueMockTakeFirst struct {
	mock               *RequestsQueueMock
	defaultExpectation *RequestsQueueMockTakeFirstExpectation
	expectations       []*RequestsQueueMockTakeFirstExpectation

	callArgs []*RequestsQueueMockTakeFirstParams
	mutex    sync.RWMutex
}

// RequestsQueueMockTakeFirstExpectation specifies expectation struct of the RequestsQueue.TakeFirst
type RequestsQueueMockTakeFirstExpectation struct {
	mock    *RequestsQueueMock
	params  *RequestsQueueMockTakeFirstParams
	results *RequestsQueueMockTakeFirstResults
	Counter uint64
}

// RequestsQueueMockTakeFirstParams contains parameters of the RequestsQueue.TakeFirst
type RequestsQueueMockTakeFirstParams struct {
	ctx context.Context
}

// RequestsQueueMockTakeFirstResults contains results of the RequestsQueue.TakeFirst
type RequestsQueueMockTakeFirstResults struct {
	tp1 *common.Transcript
}

// Expect sets up expected params for RequestsQueue.TakeFirst
func (mmTakeFirst *mRequestsQueueMockTakeFirst) Expect(ctx context.Context) *mRequestsQueueMockTakeFirst {
	if mmTakeFirst.mock.funcTakeFirst != nil {
		mmTakeFirst.mock.t.Fatalf("RequestsQueueMock.TakeFirst mock is already set by Set")
	}

	if mmTakeFirst.defaultExpectation == nil {
		mmTakeFirst.defaultExpectation = &RequestsQueueMockTakeFirstExpectation{}
	}

	mmTakeFirst.defaultExpectation.params = &RequestsQueueMockTakeFirstParams{ctx}
	for _, e := range mmTakeFirst.expectations {
		if minimock.Equal(e.params, mmTakeFirst.defaultExpectation.params) {
			mmTakeFirst.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTakeFirst.defaultExpectation.params)
		}
	}

	return mmTakeFirst
}

// Inspect accepts an inspector function that has same arguments as the RequestsQueue.TakeFirst
func (mmTakeFirst *mRequestsQueueMockTakeFirst) Inspect(f func(ctx context.Context)) *mRequestsQueueMockTakeFirst {
	if mmTakeFirst.mock.inspectFuncTakeFirst != nil {
		mmTakeFirst.mock.t.Fatalf("Inspect function is already set for RequestsQueueMock.TakeFirst")
	}

	mmTakeFirst.mock.inspectFuncTakeFirst = f

	return mmTakeFirst
}

// Return sets up results that will be returned by RequestsQueue.TakeFirst
func (mmTakeFirst *mRequestsQueueMockTakeFirst) Return(tp1 *common.Transcript) *RequestsQueueMock {
	if mmTakeFirst.mock.funcTakeFirst != nil {
		mmTakeFirst.mock.t.Fatalf("RequestsQueueMock.TakeFirst mock is already set by Set")
	}

	if mmTakeFirst.defaultExpectation == nil {
		mmTakeFirst.defaultExpectation = &RequestsQueueMockTakeFirstExpectation{mock: mmTakeFirst.mock}
	}
	mmTakeFirst.defaultExpectation.results = &RequestsQueueMockTakeFirstResults{tp1}
	return mmTakeFirst.mock
}

//Set uses given function f to mock the RequestsQueue.TakeFirst method
func (mmTakeFirst *mRequestsQueueMockTakeFirst) Set(f func(ctx context.Context) (tp1 *common.Transcript)) *RequestsQueueMock {
	if mmTakeFirst.defaultExpectation != nil {
		mmTakeFirst.mock.t.Fatalf("Default expectation is already set for the RequestsQueue.TakeFirst method")
	}

	if len(mmTakeFirst.expectations) > 0 {
		mmTakeFirst.mock.t.Fatalf("Some expectations are already set for the RequestsQueue.TakeFirst method")
	}

	mmTakeFirst.mock.funcTakeFirst = f
	return mmTakeFirst.mock
}

// When sets expectation for the RequestsQueue.TakeFirst which will trigger the result defined by the following
// Then helper
func (mmTakeFirst *mRequestsQueueMockTakeFirst) When(ctx context.Context) *RequestsQueueMockTakeFirstExpectation {
	if mmTakeFirst.mock.funcTakeFirst != nil {
		mmTakeFirst.mock.t.Fatalf("RequestsQueueMock.TakeFirst mock is already set by Set")
	}

	expectation := &RequestsQueueMockTakeFirstExpectation{
		mock:   mmTakeFirst.mock,
		params: &RequestsQueueMockTakeFirstParams{ctx},
	}
	mmTakeFirst.expectations = append(mmTakeFirst.expectations, expectation)
	return expectation
}

// Then sets up RequestsQueue.TakeFirst return parameters for the expectation previously defined by the When method
func (e *RequestsQueueMockTakeFirstExpectation) Then(tp1 *common.Transcript) *RequestsQueueMock {
	e.results = &RequestsQueueMockTakeFirstResults{tp1}
	return e.mock
}

// TakeFirst implements RequestsQueue
func (mmTakeFirst *RequestsQueueMock) TakeFirst(ctx context.Context) (tp1 *common.Transcript) {
	mm_atomic.AddUint64(&mmTakeFirst.beforeTakeFirstCounter, 1)
	defer mm_atomic.AddUint64(&mmTakeFirst.afterTakeFirstCounter, 1)

	if mmTakeFirst.inspectFuncTakeFirst != nil {
		mmTakeFirst.inspectFuncTakeFirst(ctx)
	}

	params := &RequestsQueueMockTakeFirstParams{ctx}

	// Record call args
	mmTakeFirst.TakeFirstMock.mutex.Lock()
	mmTakeFirst.TakeFirstMock.callArgs = append(mmTakeFirst.TakeFirstMock.callArgs, params)
	mmTakeFirst.TakeFirstMock.mutex.Unlock()

	for _, e := range mmTakeFirst.TakeFirstMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp1
		}
	}

	if mmTakeFirst.TakeFirstMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTakeFirst.TakeFirstMock.defaultExpectation.Counter, 1)
		want := mmTakeFirst.TakeFirstMock.defaultExpectation.params
		got := RequestsQueueMockTakeFirstParams{ctx}
		if want != nil && !minimock.Equal(*want, got) {
			mmTakeFirst.t.Errorf("RequestsQueueMock.TakeFirst got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmTakeFirst.TakeFirstMock.defaultExpectation.results
		if results == nil {
			mmTakeFirst.t.Fatal("No results are set for the RequestsQueueMock.TakeFirst")
		}
		return (*results).tp1
	}
	if mmTakeFirst.funcTakeFirst != nil {
		return mmTakeFirst.funcTakeFirst(ctx)
	}
	mmTakeFirst.t.Fatalf("Unexpected call to RequestsQueueMock.TakeFirst. %v", ctx)
	return
}

// TakeFirstAfterCounter returns a count of finished RequestsQueueMock.TakeFirst invocations
func (mmTakeFirst *RequestsQueueMock) TakeFirstAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTakeFirst.afterTakeFirstCounter)
}

// TakeFirstBeforeCounter returns a count of RequestsQueueMock.TakeFirst invocations
func (mmTakeFirst *RequestsQueueMock) TakeFirstBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTakeFirst.beforeTakeFirstCounter)
}

// Calls returns a list of arguments used in each call to RequestsQueueMock.TakeFirst.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTakeFirst *mRequestsQueueMockTakeFirst) Calls() []*RequestsQueueMockTakeFirstParams {
	mmTakeFirst.mutex.RLock()

	argCopy := make([]*RequestsQueueMockTakeFirstParams, len(mmTakeFirst.callArgs))
	copy(argCopy, mmTakeFirst.callArgs)

	mmTakeFirst.mutex.RUnlock()

	return argCopy
}

// MinimockTakeFirstDone returns true if the count of the TakeFirst invocations corresponds
// the number of defined expectations
func (m *RequestsQueueMock) MinimockTakeFirstDone() bool {
	for _, e := range m.TakeFirstMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TakeFirstMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTakeFirstCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTakeFirst != nil && mm_atomic.LoadUint64(&m.afterTakeFirstCounter) < 1 {
		return false
	}
	return true
}

// MinimockTakeFirstInspect logs each unmet expectation
func (m *RequestsQueueMock) MinimockTakeFirstInspect() {
	for _, e := range m.TakeFirstMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RequestsQueueMock.TakeFirst with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TakeFirstMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTakeFirstCounter) < 1 {
		if m.TakeFirstMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RequestsQueueMock.TakeFirst")
		} else {
			m.t.Errorf("Expected call to RequestsQueueMock.TakeFirst with params: %#v", *m.TakeFirstMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTakeFirst != nil && mm_atomic.LoadUint64(&m.afterTakeFirstCounter) < 1 {
		m.t.Error("Expected call to RequestsQueueMock.TakeFirst")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RequestsQueueMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAppendInspect()

		m.MinimockCleanInspect()

		m.MinimockLengthInspect()

		m.MinimockNumberOfOldInspect()

		m.MinimockTakeAllOriginatedFromInspect()

		m.MinimockTakeFirstInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RequestsQueueMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RequestsQueueMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAppendDone() &&
		m.MinimockCleanDone() &&
		m.MinimockLengthDone() &&
		m.MinimockNumberOfOldDone() &&
		m.MinimockTakeAllOriginatedFromDone() &&
		m.MinimockTakeFirstDone()
}
