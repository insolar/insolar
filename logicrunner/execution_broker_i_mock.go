package logicrunner

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/insolar"
	"github.com/insolar/insolar/insolar/payload"
	"github.com/insolar/insolar/logicrunner/common"
)

// ExecutionBrokerIMock implements ExecutionBrokerI
type ExecutionBrokerIMock struct {
	t minimock.Tester

	funcAbandonedRequestsOnLedger          func(ctx context.Context)
	inspectFuncAbandonedRequestsOnLedger   func(ctx context.Context)
	afterAbandonedRequestsOnLedgerCounter  uint64
	beforeAbandonedRequestsOnLedgerCounter uint64
	AbandonedRequestsOnLedgerMock          mExecutionBrokerIMockAbandonedRequestsOnLedger

	funcAddAdditionalRequestFromPrevExecutor          func(ctx context.Context, transcript *common.Transcript)
	inspectFuncAddAdditionalRequestFromPrevExecutor   func(ctx context.Context, transcript *common.Transcript)
	afterAddAdditionalRequestFromPrevExecutorCounter  uint64
	beforeAddAdditionalRequestFromPrevExecutorCounter uint64
	AddAdditionalRequestFromPrevExecutorMock          mExecutionBrokerIMockAddAdditionalRequestFromPrevExecutor

	funcAddFreshRequest          func(ctx context.Context, transcript *common.Transcript)
	inspectFuncAddFreshRequest   func(ctx context.Context, transcript *common.Transcript)
	afterAddFreshRequestCounter  uint64
	beforeAddFreshRequestCounter uint64
	AddFreshRequestMock          mExecutionBrokerIMockAddFreshRequest

	funcAddRequestsFromLedger          func(ctx context.Context, transcripts ...*common.Transcript)
	inspectFuncAddRequestsFromLedger   func(ctx context.Context, transcripts ...*common.Transcript)
	afterAddRequestsFromLedgerCounter  uint64
	beforeAddRequestsFromLedgerCounter uint64
	AddRequestsFromLedgerMock          mExecutionBrokerIMockAddRequestsFromLedger

	funcAddRequestsFromPrevExecutor          func(ctx context.Context, transcripts ...*common.Transcript)
	inspectFuncAddRequestsFromPrevExecutor   func(ctx context.Context, transcripts ...*common.Transcript)
	afterAddRequestsFromPrevExecutorCounter  uint64
	beforeAddRequestsFromPrevExecutorCounter uint64
	AddRequestsFromPrevExecutorMock          mExecutionBrokerIMockAddRequestsFromPrevExecutor

	funcIsKnownRequest          func(ctx context.Context, req insolar.Reference) (b1 bool)
	inspectFuncIsKnownRequest   func(ctx context.Context, req insolar.Reference)
	afterIsKnownRequestCounter  uint64
	beforeIsKnownRequestCounter uint64
	IsKnownRequestMock          mExecutionBrokerIMockIsKnownRequest

	funcMoreRequestsOnLedger          func(ctx context.Context)
	inspectFuncMoreRequestsOnLedger   func(ctx context.Context)
	afterMoreRequestsOnLedgerCounter  uint64
	beforeMoreRequestsOnLedgerCounter uint64
	MoreRequestsOnLedgerMock          mExecutionBrokerIMockMoreRequestsOnLedger

	funcNoMoreRequestsOnLedger          func(ctx context.Context)
	inspectFuncNoMoreRequestsOnLedger   func(ctx context.Context)
	afterNoMoreRequestsOnLedgerCounter  uint64
	beforeNoMoreRequestsOnLedgerCounter uint64
	NoMoreRequestsOnLedgerMock          mExecutionBrokerIMockNoMoreRequestsOnLedger

	funcOnPulse          func(ctx context.Context) (pa1 []payload.Payload)
	inspectFuncOnPulse   func(ctx context.Context)
	afterOnPulseCounter  uint64
	beforeOnPulseCounter uint64
	OnPulseMock          mExecutionBrokerIMockOnPulse

	funcPendingState          func() (p1 insolar.PendingState)
	inspectFuncPendingState   func()
	afterPendingStateCounter  uint64
	beforePendingStateCounter uint64
	PendingStateMock          mExecutionBrokerIMockPendingState

	funcPrevExecutorPendingResult          func(ctx context.Context, prevExecState insolar.PendingState)
	inspectFuncPrevExecutorPendingResult   func(ctx context.Context, prevExecState insolar.PendingState)
	afterPrevExecutorPendingResultCounter  uint64
	beforePrevExecutorPendingResultCounter uint64
	PrevExecutorPendingResultMock          mExecutionBrokerIMockPrevExecutorPendingResult

	funcPrevExecutorSentPendingFinished          func(ctx context.Context) (err error)
	inspectFuncPrevExecutorSentPendingFinished   func(ctx context.Context)
	afterPrevExecutorSentPendingFinishedCounter  uint64
	beforePrevExecutorSentPendingFinishedCounter uint64
	PrevExecutorSentPendingFinishedMock          mExecutionBrokerIMockPrevExecutorSentPendingFinished

	funcPrevExecutorStillExecuting          func(ctx context.Context)
	inspectFuncPrevExecutorStillExecuting   func(ctx context.Context)
	afterPrevExecutorStillExecutingCounter  uint64
	beforePrevExecutorStillExecutingCounter uint64
	PrevExecutorStillExecutingMock          mExecutionBrokerIMockPrevExecutorStillExecuting

	funcSetNotPending          func(ctx context.Context)
	inspectFuncSetNotPending   func(ctx context.Context)
	afterSetNotPendingCounter  uint64
	beforeSetNotPendingCounter uint64
	SetNotPendingMock          mExecutionBrokerIMockSetNotPending
}

// NewExecutionBrokerIMock returns a mock for ExecutionBrokerI
func NewExecutionBrokerIMock(t minimock.Tester) *ExecutionBrokerIMock {
	m := &ExecutionBrokerIMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AbandonedRequestsOnLedgerMock = mExecutionBrokerIMockAbandonedRequestsOnLedger{mock: m}
	m.AbandonedRequestsOnLedgerMock.callArgs = []*ExecutionBrokerIMockAbandonedRequestsOnLedgerParams{}

	m.AddAdditionalRequestFromPrevExecutorMock = mExecutionBrokerIMockAddAdditionalRequestFromPrevExecutor{mock: m}
	m.AddAdditionalRequestFromPrevExecutorMock.callArgs = []*ExecutionBrokerIMockAddAdditionalRequestFromPrevExecutorParams{}

	m.AddFreshRequestMock = mExecutionBrokerIMockAddFreshRequest{mock: m}
	m.AddFreshRequestMock.callArgs = []*ExecutionBrokerIMockAddFreshRequestParams{}

	m.AddRequestsFromLedgerMock = mExecutionBrokerIMockAddRequestsFromLedger{mock: m}
	m.AddRequestsFromLedgerMock.callArgs = []*ExecutionBrokerIMockAddRequestsFromLedgerParams{}

	m.AddRequestsFromPrevExecutorMock = mExecutionBrokerIMockAddRequestsFromPrevExecutor{mock: m}
	m.AddRequestsFromPrevExecutorMock.callArgs = []*ExecutionBrokerIMockAddRequestsFromPrevExecutorParams{}

	m.IsKnownRequestMock = mExecutionBrokerIMockIsKnownRequest{mock: m}
	m.IsKnownRequestMock.callArgs = []*ExecutionBrokerIMockIsKnownRequestParams{}

	m.MoreRequestsOnLedgerMock = mExecutionBrokerIMockMoreRequestsOnLedger{mock: m}
	m.MoreRequestsOnLedgerMock.callArgs = []*ExecutionBrokerIMockMoreRequestsOnLedgerParams{}

	m.NoMoreRequestsOnLedgerMock = mExecutionBrokerIMockNoMoreRequestsOnLedger{mock: m}
	m.NoMoreRequestsOnLedgerMock.callArgs = []*ExecutionBrokerIMockNoMoreRequestsOnLedgerParams{}

	m.OnPulseMock = mExecutionBrokerIMockOnPulse{mock: m}
	m.OnPulseMock.callArgs = []*ExecutionBrokerIMockOnPulseParams{}

	m.PendingStateMock = mExecutionBrokerIMockPendingState{mock: m}

	m.PrevExecutorPendingResultMock = mExecutionBrokerIMockPrevExecutorPendingResult{mock: m}
	m.PrevExecutorPendingResultMock.callArgs = []*ExecutionBrokerIMockPrevExecutorPendingResultParams{}

	m.PrevExecutorSentPendingFinishedMock = mExecutionBrokerIMockPrevExecutorSentPendingFinished{mock: m}
	m.PrevExecutorSentPendingFinishedMock.callArgs = []*ExecutionBrokerIMockPrevExecutorSentPendingFinishedParams{}

	m.PrevExecutorStillExecutingMock = mExecutionBrokerIMockPrevExecutorStillExecuting{mock: m}
	m.PrevExecutorStillExecutingMock.callArgs = []*ExecutionBrokerIMockPrevExecutorStillExecutingParams{}

	m.SetNotPendingMock = mExecutionBrokerIMockSetNotPending{mock: m}
	m.SetNotPendingMock.callArgs = []*ExecutionBrokerIMockSetNotPendingParams{}

	return m
}

type mExecutionBrokerIMockAbandonedRequestsOnLedger struct {
	mock               *ExecutionBrokerIMock
	defaultExpectation *ExecutionBrokerIMockAbandonedRequestsOnLedgerExpectation
	expectations       []*ExecutionBrokerIMockAbandonedRequestsOnLedgerExpectation

	callArgs []*ExecutionBrokerIMockAbandonedRequestsOnLedgerParams
	mutex    sync.RWMutex
}

// ExecutionBrokerIMockAbandonedRequestsOnLedgerExpectation specifies expectation struct of the ExecutionBrokerI.AbandonedRequestsOnLedger
type ExecutionBrokerIMockAbandonedRequestsOnLedgerExpectation struct {
	mock   *ExecutionBrokerIMock
	params *ExecutionBrokerIMockAbandonedRequestsOnLedgerParams

	Counter uint64
}

// ExecutionBrokerIMockAbandonedRequestsOnLedgerParams contains parameters of the ExecutionBrokerI.AbandonedRequestsOnLedger
type ExecutionBrokerIMockAbandonedRequestsOnLedgerParams struct {
	ctx context.Context
}

// Expect sets up expected params for ExecutionBrokerI.AbandonedRequestsOnLedger
func (mmAbandonedRequestsOnLedger *mExecutionBrokerIMockAbandonedRequestsOnLedger) Expect(ctx context.Context) *mExecutionBrokerIMockAbandonedRequestsOnLedger {
	if mmAbandonedRequestsOnLedger.mock.funcAbandonedRequestsOnLedger != nil {
		mmAbandonedRequestsOnLedger.mock.t.Fatalf("ExecutionBrokerIMock.AbandonedRequestsOnLedger mock is already set by Set")
	}

	if mmAbandonedRequestsOnLedger.defaultExpectation == nil {
		mmAbandonedRequestsOnLedger.defaultExpectation = &ExecutionBrokerIMockAbandonedRequestsOnLedgerExpectation{}
	}

	mmAbandonedRequestsOnLedger.defaultExpectation.params = &ExecutionBrokerIMockAbandonedRequestsOnLedgerParams{ctx}
	for _, e := range mmAbandonedRequestsOnLedger.expectations {
		if minimock.Equal(e.params, mmAbandonedRequestsOnLedger.defaultExpectation.params) {
			mmAbandonedRequestsOnLedger.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAbandonedRequestsOnLedger.defaultExpectation.params)
		}
	}

	return mmAbandonedRequestsOnLedger
}

// Inspect accepts an inspector function that has same arguments as the ExecutionBrokerI.AbandonedRequestsOnLedger
func (mmAbandonedRequestsOnLedger *mExecutionBrokerIMockAbandonedRequestsOnLedger) Inspect(f func(ctx context.Context)) *mExecutionBrokerIMockAbandonedRequestsOnLedger {
	if mmAbandonedRequestsOnLedger.mock.inspectFuncAbandonedRequestsOnLedger != nil {
		mmAbandonedRequestsOnLedger.mock.t.Fatalf("Inspect function is already set for ExecutionBrokerIMock.AbandonedRequestsOnLedger")
	}

	mmAbandonedRequestsOnLedger.mock.inspectFuncAbandonedRequestsOnLedger = f

	return mmAbandonedRequestsOnLedger
}

// Return sets up results that will be returned by ExecutionBrokerI.AbandonedRequestsOnLedger
func (mmAbandonedRequestsOnLedger *mExecutionBrokerIMockAbandonedRequestsOnLedger) Return() *ExecutionBrokerIMock {
	if mmAbandonedRequestsOnLedger.mock.funcAbandonedRequestsOnLedger != nil {
		mmAbandonedRequestsOnLedger.mock.t.Fatalf("ExecutionBrokerIMock.AbandonedRequestsOnLedger mock is already set by Set")
	}

	if mmAbandonedRequestsOnLedger.defaultExpectation == nil {
		mmAbandonedRequestsOnLedger.defaultExpectation = &ExecutionBrokerIMockAbandonedRequestsOnLedgerExpectation{mock: mmAbandonedRequestsOnLedger.mock}
	}

	return mmAbandonedRequestsOnLedger.mock
}

//Set uses given function f to mock the ExecutionBrokerI.AbandonedRequestsOnLedger method
func (mmAbandonedRequestsOnLedger *mExecutionBrokerIMockAbandonedRequestsOnLedger) Set(f func(ctx context.Context)) *ExecutionBrokerIMock {
	if mmAbandonedRequestsOnLedger.defaultExpectation != nil {
		mmAbandonedRequestsOnLedger.mock.t.Fatalf("Default expectation is already set for the ExecutionBrokerI.AbandonedRequestsOnLedger method")
	}

	if len(mmAbandonedRequestsOnLedger.expectations) > 0 {
		mmAbandonedRequestsOnLedger.mock.t.Fatalf("Some expectations are already set for the ExecutionBrokerI.AbandonedRequestsOnLedger method")
	}

	mmAbandonedRequestsOnLedger.mock.funcAbandonedRequestsOnLedger = f
	return mmAbandonedRequestsOnLedger.mock
}

// AbandonedRequestsOnLedger implements ExecutionBrokerI
func (mmAbandonedRequestsOnLedger *ExecutionBrokerIMock) AbandonedRequestsOnLedger(ctx context.Context) {
	mm_atomic.AddUint64(&mmAbandonedRequestsOnLedger.beforeAbandonedRequestsOnLedgerCounter, 1)
	defer mm_atomic.AddUint64(&mmAbandonedRequestsOnLedger.afterAbandonedRequestsOnLedgerCounter, 1)

	if mmAbandonedRequestsOnLedger.inspectFuncAbandonedRequestsOnLedger != nil {
		mmAbandonedRequestsOnLedger.inspectFuncAbandonedRequestsOnLedger(ctx)
	}

	params := &ExecutionBrokerIMockAbandonedRequestsOnLedgerParams{ctx}

	// Record call args
	mmAbandonedRequestsOnLedger.AbandonedRequestsOnLedgerMock.mutex.Lock()
	mmAbandonedRequestsOnLedger.AbandonedRequestsOnLedgerMock.callArgs = append(mmAbandonedRequestsOnLedger.AbandonedRequestsOnLedgerMock.callArgs, params)
	mmAbandonedRequestsOnLedger.AbandonedRequestsOnLedgerMock.mutex.Unlock()

	for _, e := range mmAbandonedRequestsOnLedger.AbandonedRequestsOnLedgerMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAbandonedRequestsOnLedger.AbandonedRequestsOnLedgerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAbandonedRequestsOnLedger.AbandonedRequestsOnLedgerMock.defaultExpectation.Counter, 1)
		want := mmAbandonedRequestsOnLedger.AbandonedRequestsOnLedgerMock.defaultExpectation.params
		got := ExecutionBrokerIMockAbandonedRequestsOnLedgerParams{ctx}
		if want != nil && !minimock.Equal(*want, got) {
			mmAbandonedRequestsOnLedger.t.Errorf("ExecutionBrokerIMock.AbandonedRequestsOnLedger got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmAbandonedRequestsOnLedger.funcAbandonedRequestsOnLedger != nil {
		mmAbandonedRequestsOnLedger.funcAbandonedRequestsOnLedger(ctx)
		return
	}
	mmAbandonedRequestsOnLedger.t.Fatalf("Unexpected call to ExecutionBrokerIMock.AbandonedRequestsOnLedger. %v", ctx)

}

// AbandonedRequestsOnLedgerAfterCounter returns a count of finished ExecutionBrokerIMock.AbandonedRequestsOnLedger invocations
func (mmAbandonedRequestsOnLedger *ExecutionBrokerIMock) AbandonedRequestsOnLedgerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAbandonedRequestsOnLedger.afterAbandonedRequestsOnLedgerCounter)
}

// AbandonedRequestsOnLedgerBeforeCounter returns a count of ExecutionBrokerIMock.AbandonedRequestsOnLedger invocations
func (mmAbandonedRequestsOnLedger *ExecutionBrokerIMock) AbandonedRequestsOnLedgerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAbandonedRequestsOnLedger.beforeAbandonedRequestsOnLedgerCounter)
}

// Calls returns a list of arguments used in each call to ExecutionBrokerIMock.AbandonedRequestsOnLedger.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAbandonedRequestsOnLedger *mExecutionBrokerIMockAbandonedRequestsOnLedger) Calls() []*ExecutionBrokerIMockAbandonedRequestsOnLedgerParams {
	mmAbandonedRequestsOnLedger.mutex.RLock()

	argCopy := make([]*ExecutionBrokerIMockAbandonedRequestsOnLedgerParams, len(mmAbandonedRequestsOnLedger.callArgs))
	copy(argCopy, mmAbandonedRequestsOnLedger.callArgs)

	mmAbandonedRequestsOnLedger.mutex.RUnlock()

	return argCopy
}

// MinimockAbandonedRequestsOnLedgerDone returns true if the count of the AbandonedRequestsOnLedger invocations corresponds
// the number of defined expectations
func (m *ExecutionBrokerIMock) MinimockAbandonedRequestsOnLedgerDone() bool {
	for _, e := range m.AbandonedRequestsOnLedgerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AbandonedRequestsOnLedgerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAbandonedRequestsOnLedgerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAbandonedRequestsOnLedger != nil && mm_atomic.LoadUint64(&m.afterAbandonedRequestsOnLedgerCounter) < 1 {
		return false
	}
	return true
}

// MinimockAbandonedRequestsOnLedgerInspect logs each unmet expectation
func (m *ExecutionBrokerIMock) MinimockAbandonedRequestsOnLedgerInspect() {
	for _, e := range m.AbandonedRequestsOnLedgerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.AbandonedRequestsOnLedger with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AbandonedRequestsOnLedgerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAbandonedRequestsOnLedgerCounter) < 1 {
		if m.AbandonedRequestsOnLedgerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionBrokerIMock.AbandonedRequestsOnLedger")
		} else {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.AbandonedRequestsOnLedger with params: %#v", *m.AbandonedRequestsOnLedgerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAbandonedRequestsOnLedger != nil && mm_atomic.LoadUint64(&m.afterAbandonedRequestsOnLedgerCounter) < 1 {
		m.t.Error("Expected call to ExecutionBrokerIMock.AbandonedRequestsOnLedger")
	}
}

type mExecutionBrokerIMockAddAdditionalRequestFromPrevExecutor struct {
	mock               *ExecutionBrokerIMock
	defaultExpectation *ExecutionBrokerIMockAddAdditionalRequestFromPrevExecutorExpectation
	expectations       []*ExecutionBrokerIMockAddAdditionalRequestFromPrevExecutorExpectation

	callArgs []*ExecutionBrokerIMockAddAdditionalRequestFromPrevExecutorParams
	mutex    sync.RWMutex
}

// ExecutionBrokerIMockAddAdditionalRequestFromPrevExecutorExpectation specifies expectation struct of the ExecutionBrokerI.AddAdditionalRequestFromPrevExecutor
type ExecutionBrokerIMockAddAdditionalRequestFromPrevExecutorExpectation struct {
	mock   *ExecutionBrokerIMock
	params *ExecutionBrokerIMockAddAdditionalRequestFromPrevExecutorParams

	Counter uint64
}

// ExecutionBrokerIMockAddAdditionalRequestFromPrevExecutorParams contains parameters of the ExecutionBrokerI.AddAdditionalRequestFromPrevExecutor
type ExecutionBrokerIMockAddAdditionalRequestFromPrevExecutorParams struct {
	ctx        context.Context
	transcript *common.Transcript
}

// Expect sets up expected params for ExecutionBrokerI.AddAdditionalRequestFromPrevExecutor
func (mmAddAdditionalRequestFromPrevExecutor *mExecutionBrokerIMockAddAdditionalRequestFromPrevExecutor) Expect(ctx context.Context, transcript *common.Transcript) *mExecutionBrokerIMockAddAdditionalRequestFromPrevExecutor {
	if mmAddAdditionalRequestFromPrevExecutor.mock.funcAddAdditionalRequestFromPrevExecutor != nil {
		mmAddAdditionalRequestFromPrevExecutor.mock.t.Fatalf("ExecutionBrokerIMock.AddAdditionalRequestFromPrevExecutor mock is already set by Set")
	}

	if mmAddAdditionalRequestFromPrevExecutor.defaultExpectation == nil {
		mmAddAdditionalRequestFromPrevExecutor.defaultExpectation = &ExecutionBrokerIMockAddAdditionalRequestFromPrevExecutorExpectation{}
	}

	mmAddAdditionalRequestFromPrevExecutor.defaultExpectation.params = &ExecutionBrokerIMockAddAdditionalRequestFromPrevExecutorParams{ctx, transcript}
	for _, e := range mmAddAdditionalRequestFromPrevExecutor.expectations {
		if minimock.Equal(e.params, mmAddAdditionalRequestFromPrevExecutor.defaultExpectation.params) {
			mmAddAdditionalRequestFromPrevExecutor.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddAdditionalRequestFromPrevExecutor.defaultExpectation.params)
		}
	}

	return mmAddAdditionalRequestFromPrevExecutor
}

// Inspect accepts an inspector function that has same arguments as the ExecutionBrokerI.AddAdditionalRequestFromPrevExecutor
func (mmAddAdditionalRequestFromPrevExecutor *mExecutionBrokerIMockAddAdditionalRequestFromPrevExecutor) Inspect(f func(ctx context.Context, transcript *common.Transcript)) *mExecutionBrokerIMockAddAdditionalRequestFromPrevExecutor {
	if mmAddAdditionalRequestFromPrevExecutor.mock.inspectFuncAddAdditionalRequestFromPrevExecutor != nil {
		mmAddAdditionalRequestFromPrevExecutor.mock.t.Fatalf("Inspect function is already set for ExecutionBrokerIMock.AddAdditionalRequestFromPrevExecutor")
	}

	mmAddAdditionalRequestFromPrevExecutor.mock.inspectFuncAddAdditionalRequestFromPrevExecutor = f

	return mmAddAdditionalRequestFromPrevExecutor
}

// Return sets up results that will be returned by ExecutionBrokerI.AddAdditionalRequestFromPrevExecutor
func (mmAddAdditionalRequestFromPrevExecutor *mExecutionBrokerIMockAddAdditionalRequestFromPrevExecutor) Return() *ExecutionBrokerIMock {
	if mmAddAdditionalRequestFromPrevExecutor.mock.funcAddAdditionalRequestFromPrevExecutor != nil {
		mmAddAdditionalRequestFromPrevExecutor.mock.t.Fatalf("ExecutionBrokerIMock.AddAdditionalRequestFromPrevExecutor mock is already set by Set")
	}

	if mmAddAdditionalRequestFromPrevExecutor.defaultExpectation == nil {
		mmAddAdditionalRequestFromPrevExecutor.defaultExpectation = &ExecutionBrokerIMockAddAdditionalRequestFromPrevExecutorExpectation{mock: mmAddAdditionalRequestFromPrevExecutor.mock}
	}

	return mmAddAdditionalRequestFromPrevExecutor.mock
}

//Set uses given function f to mock the ExecutionBrokerI.AddAdditionalRequestFromPrevExecutor method
func (mmAddAdditionalRequestFromPrevExecutor *mExecutionBrokerIMockAddAdditionalRequestFromPrevExecutor) Set(f func(ctx context.Context, transcript *common.Transcript)) *ExecutionBrokerIMock {
	if mmAddAdditionalRequestFromPrevExecutor.defaultExpectation != nil {
		mmAddAdditionalRequestFromPrevExecutor.mock.t.Fatalf("Default expectation is already set for the ExecutionBrokerI.AddAdditionalRequestFromPrevExecutor method")
	}

	if len(mmAddAdditionalRequestFromPrevExecutor.expectations) > 0 {
		mmAddAdditionalRequestFromPrevExecutor.mock.t.Fatalf("Some expectations are already set for the ExecutionBrokerI.AddAdditionalRequestFromPrevExecutor method")
	}

	mmAddAdditionalRequestFromPrevExecutor.mock.funcAddAdditionalRequestFromPrevExecutor = f
	return mmAddAdditionalRequestFromPrevExecutor.mock
}

// AddAdditionalRequestFromPrevExecutor implements ExecutionBrokerI
func (mmAddAdditionalRequestFromPrevExecutor *ExecutionBrokerIMock) AddAdditionalRequestFromPrevExecutor(ctx context.Context, transcript *common.Transcript) {
	mm_atomic.AddUint64(&mmAddAdditionalRequestFromPrevExecutor.beforeAddAdditionalRequestFromPrevExecutorCounter, 1)
	defer mm_atomic.AddUint64(&mmAddAdditionalRequestFromPrevExecutor.afterAddAdditionalRequestFromPrevExecutorCounter, 1)

	if mmAddAdditionalRequestFromPrevExecutor.inspectFuncAddAdditionalRequestFromPrevExecutor != nil {
		mmAddAdditionalRequestFromPrevExecutor.inspectFuncAddAdditionalRequestFromPrevExecutor(ctx, transcript)
	}

	params := &ExecutionBrokerIMockAddAdditionalRequestFromPrevExecutorParams{ctx, transcript}

	// Record call args
	mmAddAdditionalRequestFromPrevExecutor.AddAdditionalRequestFromPrevExecutorMock.mutex.Lock()
	mmAddAdditionalRequestFromPrevExecutor.AddAdditionalRequestFromPrevExecutorMock.callArgs = append(mmAddAdditionalRequestFromPrevExecutor.AddAdditionalRequestFromPrevExecutorMock.callArgs, params)
	mmAddAdditionalRequestFromPrevExecutor.AddAdditionalRequestFromPrevExecutorMock.mutex.Unlock()

	for _, e := range mmAddAdditionalRequestFromPrevExecutor.AddAdditionalRequestFromPrevExecutorMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddAdditionalRequestFromPrevExecutor.AddAdditionalRequestFromPrevExecutorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddAdditionalRequestFromPrevExecutor.AddAdditionalRequestFromPrevExecutorMock.defaultExpectation.Counter, 1)
		want := mmAddAdditionalRequestFromPrevExecutor.AddAdditionalRequestFromPrevExecutorMock.defaultExpectation.params
		got := ExecutionBrokerIMockAddAdditionalRequestFromPrevExecutorParams{ctx, transcript}
		if want != nil && !minimock.Equal(*want, got) {
			mmAddAdditionalRequestFromPrevExecutor.t.Errorf("ExecutionBrokerIMock.AddAdditionalRequestFromPrevExecutor got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmAddAdditionalRequestFromPrevExecutor.funcAddAdditionalRequestFromPrevExecutor != nil {
		mmAddAdditionalRequestFromPrevExecutor.funcAddAdditionalRequestFromPrevExecutor(ctx, transcript)
		return
	}
	mmAddAdditionalRequestFromPrevExecutor.t.Fatalf("Unexpected call to ExecutionBrokerIMock.AddAdditionalRequestFromPrevExecutor. %v %v", ctx, transcript)

}

// AddAdditionalRequestFromPrevExecutorAfterCounter returns a count of finished ExecutionBrokerIMock.AddAdditionalRequestFromPrevExecutor invocations
func (mmAddAdditionalRequestFromPrevExecutor *ExecutionBrokerIMock) AddAdditionalRequestFromPrevExecutorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddAdditionalRequestFromPrevExecutor.afterAddAdditionalRequestFromPrevExecutorCounter)
}

// AddAdditionalRequestFromPrevExecutorBeforeCounter returns a count of ExecutionBrokerIMock.AddAdditionalRequestFromPrevExecutor invocations
func (mmAddAdditionalRequestFromPrevExecutor *ExecutionBrokerIMock) AddAdditionalRequestFromPrevExecutorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddAdditionalRequestFromPrevExecutor.beforeAddAdditionalRequestFromPrevExecutorCounter)
}

// Calls returns a list of arguments used in each call to ExecutionBrokerIMock.AddAdditionalRequestFromPrevExecutor.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddAdditionalRequestFromPrevExecutor *mExecutionBrokerIMockAddAdditionalRequestFromPrevExecutor) Calls() []*ExecutionBrokerIMockAddAdditionalRequestFromPrevExecutorParams {
	mmAddAdditionalRequestFromPrevExecutor.mutex.RLock()

	argCopy := make([]*ExecutionBrokerIMockAddAdditionalRequestFromPrevExecutorParams, len(mmAddAdditionalRequestFromPrevExecutor.callArgs))
	copy(argCopy, mmAddAdditionalRequestFromPrevExecutor.callArgs)

	mmAddAdditionalRequestFromPrevExecutor.mutex.RUnlock()

	return argCopy
}

// MinimockAddAdditionalRequestFromPrevExecutorDone returns true if the count of the AddAdditionalRequestFromPrevExecutor invocations corresponds
// the number of defined expectations
func (m *ExecutionBrokerIMock) MinimockAddAdditionalRequestFromPrevExecutorDone() bool {
	for _, e := range m.AddAdditionalRequestFromPrevExecutorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddAdditionalRequestFromPrevExecutorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddAdditionalRequestFromPrevExecutorCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddAdditionalRequestFromPrevExecutor != nil && mm_atomic.LoadUint64(&m.afterAddAdditionalRequestFromPrevExecutorCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddAdditionalRequestFromPrevExecutorInspect logs each unmet expectation
func (m *ExecutionBrokerIMock) MinimockAddAdditionalRequestFromPrevExecutorInspect() {
	for _, e := range m.AddAdditionalRequestFromPrevExecutorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.AddAdditionalRequestFromPrevExecutor with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddAdditionalRequestFromPrevExecutorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddAdditionalRequestFromPrevExecutorCounter) < 1 {
		if m.AddAdditionalRequestFromPrevExecutorMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionBrokerIMock.AddAdditionalRequestFromPrevExecutor")
		} else {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.AddAdditionalRequestFromPrevExecutor with params: %#v", *m.AddAdditionalRequestFromPrevExecutorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddAdditionalRequestFromPrevExecutor != nil && mm_atomic.LoadUint64(&m.afterAddAdditionalRequestFromPrevExecutorCounter) < 1 {
		m.t.Error("Expected call to ExecutionBrokerIMock.AddAdditionalRequestFromPrevExecutor")
	}
}

type mExecutionBrokerIMockAddFreshRequest struct {
	mock               *ExecutionBrokerIMock
	defaultExpectation *ExecutionBrokerIMockAddFreshRequestExpectation
	expectations       []*ExecutionBrokerIMockAddFreshRequestExpectation

	callArgs []*ExecutionBrokerIMockAddFreshRequestParams
	mutex    sync.RWMutex
}

// ExecutionBrokerIMockAddFreshRequestExpectation specifies expectation struct of the ExecutionBrokerI.AddFreshRequest
type ExecutionBrokerIMockAddFreshRequestExpectation struct {
	mock   *ExecutionBrokerIMock
	params *ExecutionBrokerIMockAddFreshRequestParams

	Counter uint64
}

// ExecutionBrokerIMockAddFreshRequestParams contains parameters of the ExecutionBrokerI.AddFreshRequest
type ExecutionBrokerIMockAddFreshRequestParams struct {
	ctx        context.Context
	transcript *common.Transcript
}

// Expect sets up expected params for ExecutionBrokerI.AddFreshRequest
func (mmAddFreshRequest *mExecutionBrokerIMockAddFreshRequest) Expect(ctx context.Context, transcript *common.Transcript) *mExecutionBrokerIMockAddFreshRequest {
	if mmAddFreshRequest.mock.funcAddFreshRequest != nil {
		mmAddFreshRequest.mock.t.Fatalf("ExecutionBrokerIMock.AddFreshRequest mock is already set by Set")
	}

	if mmAddFreshRequest.defaultExpectation == nil {
		mmAddFreshRequest.defaultExpectation = &ExecutionBrokerIMockAddFreshRequestExpectation{}
	}

	mmAddFreshRequest.defaultExpectation.params = &ExecutionBrokerIMockAddFreshRequestParams{ctx, transcript}
	for _, e := range mmAddFreshRequest.expectations {
		if minimock.Equal(e.params, mmAddFreshRequest.defaultExpectation.params) {
			mmAddFreshRequest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddFreshRequest.defaultExpectation.params)
		}
	}

	return mmAddFreshRequest
}

// Inspect accepts an inspector function that has same arguments as the ExecutionBrokerI.AddFreshRequest
func (mmAddFreshRequest *mExecutionBrokerIMockAddFreshRequest) Inspect(f func(ctx context.Context, transcript *common.Transcript)) *mExecutionBrokerIMockAddFreshRequest {
	if mmAddFreshRequest.mock.inspectFuncAddFreshRequest != nil {
		mmAddFreshRequest.mock.t.Fatalf("Inspect function is already set for ExecutionBrokerIMock.AddFreshRequest")
	}

	mmAddFreshRequest.mock.inspectFuncAddFreshRequest = f

	return mmAddFreshRequest
}

// Return sets up results that will be returned by ExecutionBrokerI.AddFreshRequest
func (mmAddFreshRequest *mExecutionBrokerIMockAddFreshRequest) Return() *ExecutionBrokerIMock {
	if mmAddFreshRequest.mock.funcAddFreshRequest != nil {
		mmAddFreshRequest.mock.t.Fatalf("ExecutionBrokerIMock.AddFreshRequest mock is already set by Set")
	}

	if mmAddFreshRequest.defaultExpectation == nil {
		mmAddFreshRequest.defaultExpectation = &ExecutionBrokerIMockAddFreshRequestExpectation{mock: mmAddFreshRequest.mock}
	}

	return mmAddFreshRequest.mock
}

//Set uses given function f to mock the ExecutionBrokerI.AddFreshRequest method
func (mmAddFreshRequest *mExecutionBrokerIMockAddFreshRequest) Set(f func(ctx context.Context, transcript *common.Transcript)) *ExecutionBrokerIMock {
	if mmAddFreshRequest.defaultExpectation != nil {
		mmAddFreshRequest.mock.t.Fatalf("Default expectation is already set for the ExecutionBrokerI.AddFreshRequest method")
	}

	if len(mmAddFreshRequest.expectations) > 0 {
		mmAddFreshRequest.mock.t.Fatalf("Some expectations are already set for the ExecutionBrokerI.AddFreshRequest method")
	}

	mmAddFreshRequest.mock.funcAddFreshRequest = f
	return mmAddFreshRequest.mock
}

// AddFreshRequest implements ExecutionBrokerI
func (mmAddFreshRequest *ExecutionBrokerIMock) AddFreshRequest(ctx context.Context, transcript *common.Transcript) {
	mm_atomic.AddUint64(&mmAddFreshRequest.beforeAddFreshRequestCounter, 1)
	defer mm_atomic.AddUint64(&mmAddFreshRequest.afterAddFreshRequestCounter, 1)

	if mmAddFreshRequest.inspectFuncAddFreshRequest != nil {
		mmAddFreshRequest.inspectFuncAddFreshRequest(ctx, transcript)
	}

	params := &ExecutionBrokerIMockAddFreshRequestParams{ctx, transcript}

	// Record call args
	mmAddFreshRequest.AddFreshRequestMock.mutex.Lock()
	mmAddFreshRequest.AddFreshRequestMock.callArgs = append(mmAddFreshRequest.AddFreshRequestMock.callArgs, params)
	mmAddFreshRequest.AddFreshRequestMock.mutex.Unlock()

	for _, e := range mmAddFreshRequest.AddFreshRequestMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddFreshRequest.AddFreshRequestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddFreshRequest.AddFreshRequestMock.defaultExpectation.Counter, 1)
		want := mmAddFreshRequest.AddFreshRequestMock.defaultExpectation.params
		got := ExecutionBrokerIMockAddFreshRequestParams{ctx, transcript}
		if want != nil && !minimock.Equal(*want, got) {
			mmAddFreshRequest.t.Errorf("ExecutionBrokerIMock.AddFreshRequest got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmAddFreshRequest.funcAddFreshRequest != nil {
		mmAddFreshRequest.funcAddFreshRequest(ctx, transcript)
		return
	}
	mmAddFreshRequest.t.Fatalf("Unexpected call to ExecutionBrokerIMock.AddFreshRequest. %v %v", ctx, transcript)

}

// AddFreshRequestAfterCounter returns a count of finished ExecutionBrokerIMock.AddFreshRequest invocations
func (mmAddFreshRequest *ExecutionBrokerIMock) AddFreshRequestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddFreshRequest.afterAddFreshRequestCounter)
}

// AddFreshRequestBeforeCounter returns a count of ExecutionBrokerIMock.AddFreshRequest invocations
func (mmAddFreshRequest *ExecutionBrokerIMock) AddFreshRequestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddFreshRequest.beforeAddFreshRequestCounter)
}

// Calls returns a list of arguments used in each call to ExecutionBrokerIMock.AddFreshRequest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddFreshRequest *mExecutionBrokerIMockAddFreshRequest) Calls() []*ExecutionBrokerIMockAddFreshRequestParams {
	mmAddFreshRequest.mutex.RLock()

	argCopy := make([]*ExecutionBrokerIMockAddFreshRequestParams, len(mmAddFreshRequest.callArgs))
	copy(argCopy, mmAddFreshRequest.callArgs)

	mmAddFreshRequest.mutex.RUnlock()

	return argCopy
}

// MinimockAddFreshRequestDone returns true if the count of the AddFreshRequest invocations corresponds
// the number of defined expectations
func (m *ExecutionBrokerIMock) MinimockAddFreshRequestDone() bool {
	for _, e := range m.AddFreshRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddFreshRequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddFreshRequestCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddFreshRequest != nil && mm_atomic.LoadUint64(&m.afterAddFreshRequestCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddFreshRequestInspect logs each unmet expectation
func (m *ExecutionBrokerIMock) MinimockAddFreshRequestInspect() {
	for _, e := range m.AddFreshRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.AddFreshRequest with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddFreshRequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddFreshRequestCounter) < 1 {
		if m.AddFreshRequestMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionBrokerIMock.AddFreshRequest")
		} else {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.AddFreshRequest with params: %#v", *m.AddFreshRequestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddFreshRequest != nil && mm_atomic.LoadUint64(&m.afterAddFreshRequestCounter) < 1 {
		m.t.Error("Expected call to ExecutionBrokerIMock.AddFreshRequest")
	}
}

type mExecutionBrokerIMockAddRequestsFromLedger struct {
	mock               *ExecutionBrokerIMock
	defaultExpectation *ExecutionBrokerIMockAddRequestsFromLedgerExpectation
	expectations       []*ExecutionBrokerIMockAddRequestsFromLedgerExpectation

	callArgs []*ExecutionBrokerIMockAddRequestsFromLedgerParams
	mutex    sync.RWMutex
}

// ExecutionBrokerIMockAddRequestsFromLedgerExpectation specifies expectation struct of the ExecutionBrokerI.AddRequestsFromLedger
type ExecutionBrokerIMockAddRequestsFromLedgerExpectation struct {
	mock   *ExecutionBrokerIMock
	params *ExecutionBrokerIMockAddRequestsFromLedgerParams

	Counter uint64
}

// ExecutionBrokerIMockAddRequestsFromLedgerParams contains parameters of the ExecutionBrokerI.AddRequestsFromLedger
type ExecutionBrokerIMockAddRequestsFromLedgerParams struct {
	ctx         context.Context
	transcripts []*common.Transcript
}

// Expect sets up expected params for ExecutionBrokerI.AddRequestsFromLedger
func (mmAddRequestsFromLedger *mExecutionBrokerIMockAddRequestsFromLedger) Expect(ctx context.Context, transcripts ...*common.Transcript) *mExecutionBrokerIMockAddRequestsFromLedger {
	if mmAddRequestsFromLedger.mock.funcAddRequestsFromLedger != nil {
		mmAddRequestsFromLedger.mock.t.Fatalf("ExecutionBrokerIMock.AddRequestsFromLedger mock is already set by Set")
	}

	if mmAddRequestsFromLedger.defaultExpectation == nil {
		mmAddRequestsFromLedger.defaultExpectation = &ExecutionBrokerIMockAddRequestsFromLedgerExpectation{}
	}

	mmAddRequestsFromLedger.defaultExpectation.params = &ExecutionBrokerIMockAddRequestsFromLedgerParams{ctx, transcripts}
	for _, e := range mmAddRequestsFromLedger.expectations {
		if minimock.Equal(e.params, mmAddRequestsFromLedger.defaultExpectation.params) {
			mmAddRequestsFromLedger.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddRequestsFromLedger.defaultExpectation.params)
		}
	}

	return mmAddRequestsFromLedger
}

// Inspect accepts an inspector function that has same arguments as the ExecutionBrokerI.AddRequestsFromLedger
func (mmAddRequestsFromLedger *mExecutionBrokerIMockAddRequestsFromLedger) Inspect(f func(ctx context.Context, transcripts ...*common.Transcript)) *mExecutionBrokerIMockAddRequestsFromLedger {
	if mmAddRequestsFromLedger.mock.inspectFuncAddRequestsFromLedger != nil {
		mmAddRequestsFromLedger.mock.t.Fatalf("Inspect function is already set for ExecutionBrokerIMock.AddRequestsFromLedger")
	}

	mmAddRequestsFromLedger.mock.inspectFuncAddRequestsFromLedger = f

	return mmAddRequestsFromLedger
}

// Return sets up results that will be returned by ExecutionBrokerI.AddRequestsFromLedger
func (mmAddRequestsFromLedger *mExecutionBrokerIMockAddRequestsFromLedger) Return() *ExecutionBrokerIMock {
	if mmAddRequestsFromLedger.mock.funcAddRequestsFromLedger != nil {
		mmAddRequestsFromLedger.mock.t.Fatalf("ExecutionBrokerIMock.AddRequestsFromLedger mock is already set by Set")
	}

	if mmAddRequestsFromLedger.defaultExpectation == nil {
		mmAddRequestsFromLedger.defaultExpectation = &ExecutionBrokerIMockAddRequestsFromLedgerExpectation{mock: mmAddRequestsFromLedger.mock}
	}

	return mmAddRequestsFromLedger.mock
}

//Set uses given function f to mock the ExecutionBrokerI.AddRequestsFromLedger method
func (mmAddRequestsFromLedger *mExecutionBrokerIMockAddRequestsFromLedger) Set(f func(ctx context.Context, transcripts ...*common.Transcript)) *ExecutionBrokerIMock {
	if mmAddRequestsFromLedger.defaultExpectation != nil {
		mmAddRequestsFromLedger.mock.t.Fatalf("Default expectation is already set for the ExecutionBrokerI.AddRequestsFromLedger method")
	}

	if len(mmAddRequestsFromLedger.expectations) > 0 {
		mmAddRequestsFromLedger.mock.t.Fatalf("Some expectations are already set for the ExecutionBrokerI.AddRequestsFromLedger method")
	}

	mmAddRequestsFromLedger.mock.funcAddRequestsFromLedger = f
	return mmAddRequestsFromLedger.mock
}

// AddRequestsFromLedger implements ExecutionBrokerI
func (mmAddRequestsFromLedger *ExecutionBrokerIMock) AddRequestsFromLedger(ctx context.Context, transcripts ...*common.Transcript) {
	mm_atomic.AddUint64(&mmAddRequestsFromLedger.beforeAddRequestsFromLedgerCounter, 1)
	defer mm_atomic.AddUint64(&mmAddRequestsFromLedger.afterAddRequestsFromLedgerCounter, 1)

	if mmAddRequestsFromLedger.inspectFuncAddRequestsFromLedger != nil {
		mmAddRequestsFromLedger.inspectFuncAddRequestsFromLedger(ctx, transcripts...)
	}

	params := &ExecutionBrokerIMockAddRequestsFromLedgerParams{ctx, transcripts}

	// Record call args
	mmAddRequestsFromLedger.AddRequestsFromLedgerMock.mutex.Lock()
	mmAddRequestsFromLedger.AddRequestsFromLedgerMock.callArgs = append(mmAddRequestsFromLedger.AddRequestsFromLedgerMock.callArgs, params)
	mmAddRequestsFromLedger.AddRequestsFromLedgerMock.mutex.Unlock()

	for _, e := range mmAddRequestsFromLedger.AddRequestsFromLedgerMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddRequestsFromLedger.AddRequestsFromLedgerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddRequestsFromLedger.AddRequestsFromLedgerMock.defaultExpectation.Counter, 1)
		want := mmAddRequestsFromLedger.AddRequestsFromLedgerMock.defaultExpectation.params
		got := ExecutionBrokerIMockAddRequestsFromLedgerParams{ctx, transcripts}
		if want != nil && !minimock.Equal(*want, got) {
			mmAddRequestsFromLedger.t.Errorf("ExecutionBrokerIMock.AddRequestsFromLedger got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmAddRequestsFromLedger.funcAddRequestsFromLedger != nil {
		mmAddRequestsFromLedger.funcAddRequestsFromLedger(ctx, transcripts...)
		return
	}
	mmAddRequestsFromLedger.t.Fatalf("Unexpected call to ExecutionBrokerIMock.AddRequestsFromLedger. %v %v", ctx, transcripts)

}

// AddRequestsFromLedgerAfterCounter returns a count of finished ExecutionBrokerIMock.AddRequestsFromLedger invocations
func (mmAddRequestsFromLedger *ExecutionBrokerIMock) AddRequestsFromLedgerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddRequestsFromLedger.afterAddRequestsFromLedgerCounter)
}

// AddRequestsFromLedgerBeforeCounter returns a count of ExecutionBrokerIMock.AddRequestsFromLedger invocations
func (mmAddRequestsFromLedger *ExecutionBrokerIMock) AddRequestsFromLedgerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddRequestsFromLedger.beforeAddRequestsFromLedgerCounter)
}

// Calls returns a list of arguments used in each call to ExecutionBrokerIMock.AddRequestsFromLedger.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddRequestsFromLedger *mExecutionBrokerIMockAddRequestsFromLedger) Calls() []*ExecutionBrokerIMockAddRequestsFromLedgerParams {
	mmAddRequestsFromLedger.mutex.RLock()

	argCopy := make([]*ExecutionBrokerIMockAddRequestsFromLedgerParams, len(mmAddRequestsFromLedger.callArgs))
	copy(argCopy, mmAddRequestsFromLedger.callArgs)

	mmAddRequestsFromLedger.mutex.RUnlock()

	return argCopy
}

// MinimockAddRequestsFromLedgerDone returns true if the count of the AddRequestsFromLedger invocations corresponds
// the number of defined expectations
func (m *ExecutionBrokerIMock) MinimockAddRequestsFromLedgerDone() bool {
	for _, e := range m.AddRequestsFromLedgerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddRequestsFromLedgerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddRequestsFromLedgerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddRequestsFromLedger != nil && mm_atomic.LoadUint64(&m.afterAddRequestsFromLedgerCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddRequestsFromLedgerInspect logs each unmet expectation
func (m *ExecutionBrokerIMock) MinimockAddRequestsFromLedgerInspect() {
	for _, e := range m.AddRequestsFromLedgerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.AddRequestsFromLedger with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddRequestsFromLedgerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddRequestsFromLedgerCounter) < 1 {
		if m.AddRequestsFromLedgerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionBrokerIMock.AddRequestsFromLedger")
		} else {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.AddRequestsFromLedger with params: %#v", *m.AddRequestsFromLedgerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddRequestsFromLedger != nil && mm_atomic.LoadUint64(&m.afterAddRequestsFromLedgerCounter) < 1 {
		m.t.Error("Expected call to ExecutionBrokerIMock.AddRequestsFromLedger")
	}
}

type mExecutionBrokerIMockAddRequestsFromPrevExecutor struct {
	mock               *ExecutionBrokerIMock
	defaultExpectation *ExecutionBrokerIMockAddRequestsFromPrevExecutorExpectation
	expectations       []*ExecutionBrokerIMockAddRequestsFromPrevExecutorExpectation

	callArgs []*ExecutionBrokerIMockAddRequestsFromPrevExecutorParams
	mutex    sync.RWMutex
}

// ExecutionBrokerIMockAddRequestsFromPrevExecutorExpectation specifies expectation struct of the ExecutionBrokerI.AddRequestsFromPrevExecutor
type ExecutionBrokerIMockAddRequestsFromPrevExecutorExpectation struct {
	mock   *ExecutionBrokerIMock
	params *ExecutionBrokerIMockAddRequestsFromPrevExecutorParams

	Counter uint64
}

// ExecutionBrokerIMockAddRequestsFromPrevExecutorParams contains parameters of the ExecutionBrokerI.AddRequestsFromPrevExecutor
type ExecutionBrokerIMockAddRequestsFromPrevExecutorParams struct {
	ctx         context.Context
	transcripts []*common.Transcript
}

// Expect sets up expected params for ExecutionBrokerI.AddRequestsFromPrevExecutor
func (mmAddRequestsFromPrevExecutor *mExecutionBrokerIMockAddRequestsFromPrevExecutor) Expect(ctx context.Context, transcripts ...*common.Transcript) *mExecutionBrokerIMockAddRequestsFromPrevExecutor {
	if mmAddRequestsFromPrevExecutor.mock.funcAddRequestsFromPrevExecutor != nil {
		mmAddRequestsFromPrevExecutor.mock.t.Fatalf("ExecutionBrokerIMock.AddRequestsFromPrevExecutor mock is already set by Set")
	}

	if mmAddRequestsFromPrevExecutor.defaultExpectation == nil {
		mmAddRequestsFromPrevExecutor.defaultExpectation = &ExecutionBrokerIMockAddRequestsFromPrevExecutorExpectation{}
	}

	mmAddRequestsFromPrevExecutor.defaultExpectation.params = &ExecutionBrokerIMockAddRequestsFromPrevExecutorParams{ctx, transcripts}
	for _, e := range mmAddRequestsFromPrevExecutor.expectations {
		if minimock.Equal(e.params, mmAddRequestsFromPrevExecutor.defaultExpectation.params) {
			mmAddRequestsFromPrevExecutor.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddRequestsFromPrevExecutor.defaultExpectation.params)
		}
	}

	return mmAddRequestsFromPrevExecutor
}

// Inspect accepts an inspector function that has same arguments as the ExecutionBrokerI.AddRequestsFromPrevExecutor
func (mmAddRequestsFromPrevExecutor *mExecutionBrokerIMockAddRequestsFromPrevExecutor) Inspect(f func(ctx context.Context, transcripts ...*common.Transcript)) *mExecutionBrokerIMockAddRequestsFromPrevExecutor {
	if mmAddRequestsFromPrevExecutor.mock.inspectFuncAddRequestsFromPrevExecutor != nil {
		mmAddRequestsFromPrevExecutor.mock.t.Fatalf("Inspect function is already set for ExecutionBrokerIMock.AddRequestsFromPrevExecutor")
	}

	mmAddRequestsFromPrevExecutor.mock.inspectFuncAddRequestsFromPrevExecutor = f

	return mmAddRequestsFromPrevExecutor
}

// Return sets up results that will be returned by ExecutionBrokerI.AddRequestsFromPrevExecutor
func (mmAddRequestsFromPrevExecutor *mExecutionBrokerIMockAddRequestsFromPrevExecutor) Return() *ExecutionBrokerIMock {
	if mmAddRequestsFromPrevExecutor.mock.funcAddRequestsFromPrevExecutor != nil {
		mmAddRequestsFromPrevExecutor.mock.t.Fatalf("ExecutionBrokerIMock.AddRequestsFromPrevExecutor mock is already set by Set")
	}

	if mmAddRequestsFromPrevExecutor.defaultExpectation == nil {
		mmAddRequestsFromPrevExecutor.defaultExpectation = &ExecutionBrokerIMockAddRequestsFromPrevExecutorExpectation{mock: mmAddRequestsFromPrevExecutor.mock}
	}

	return mmAddRequestsFromPrevExecutor.mock
}

//Set uses given function f to mock the ExecutionBrokerI.AddRequestsFromPrevExecutor method
func (mmAddRequestsFromPrevExecutor *mExecutionBrokerIMockAddRequestsFromPrevExecutor) Set(f func(ctx context.Context, transcripts ...*common.Transcript)) *ExecutionBrokerIMock {
	if mmAddRequestsFromPrevExecutor.defaultExpectation != nil {
		mmAddRequestsFromPrevExecutor.mock.t.Fatalf("Default expectation is already set for the ExecutionBrokerI.AddRequestsFromPrevExecutor method")
	}

	if len(mmAddRequestsFromPrevExecutor.expectations) > 0 {
		mmAddRequestsFromPrevExecutor.mock.t.Fatalf("Some expectations are already set for the ExecutionBrokerI.AddRequestsFromPrevExecutor method")
	}

	mmAddRequestsFromPrevExecutor.mock.funcAddRequestsFromPrevExecutor = f
	return mmAddRequestsFromPrevExecutor.mock
}

// AddRequestsFromPrevExecutor implements ExecutionBrokerI
func (mmAddRequestsFromPrevExecutor *ExecutionBrokerIMock) AddRequestsFromPrevExecutor(ctx context.Context, transcripts ...*common.Transcript) {
	mm_atomic.AddUint64(&mmAddRequestsFromPrevExecutor.beforeAddRequestsFromPrevExecutorCounter, 1)
	defer mm_atomic.AddUint64(&mmAddRequestsFromPrevExecutor.afterAddRequestsFromPrevExecutorCounter, 1)

	if mmAddRequestsFromPrevExecutor.inspectFuncAddRequestsFromPrevExecutor != nil {
		mmAddRequestsFromPrevExecutor.inspectFuncAddRequestsFromPrevExecutor(ctx, transcripts...)
	}

	params := &ExecutionBrokerIMockAddRequestsFromPrevExecutorParams{ctx, transcripts}

	// Record call args
	mmAddRequestsFromPrevExecutor.AddRequestsFromPrevExecutorMock.mutex.Lock()
	mmAddRequestsFromPrevExecutor.AddRequestsFromPrevExecutorMock.callArgs = append(mmAddRequestsFromPrevExecutor.AddRequestsFromPrevExecutorMock.callArgs, params)
	mmAddRequestsFromPrevExecutor.AddRequestsFromPrevExecutorMock.mutex.Unlock()

	for _, e := range mmAddRequestsFromPrevExecutor.AddRequestsFromPrevExecutorMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddRequestsFromPrevExecutor.AddRequestsFromPrevExecutorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddRequestsFromPrevExecutor.AddRequestsFromPrevExecutorMock.defaultExpectation.Counter, 1)
		want := mmAddRequestsFromPrevExecutor.AddRequestsFromPrevExecutorMock.defaultExpectation.params
		got := ExecutionBrokerIMockAddRequestsFromPrevExecutorParams{ctx, transcripts}
		if want != nil && !minimock.Equal(*want, got) {
			mmAddRequestsFromPrevExecutor.t.Errorf("ExecutionBrokerIMock.AddRequestsFromPrevExecutor got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmAddRequestsFromPrevExecutor.funcAddRequestsFromPrevExecutor != nil {
		mmAddRequestsFromPrevExecutor.funcAddRequestsFromPrevExecutor(ctx, transcripts...)
		return
	}
	mmAddRequestsFromPrevExecutor.t.Fatalf("Unexpected call to ExecutionBrokerIMock.AddRequestsFromPrevExecutor. %v %v", ctx, transcripts)

}

// AddRequestsFromPrevExecutorAfterCounter returns a count of finished ExecutionBrokerIMock.AddRequestsFromPrevExecutor invocations
func (mmAddRequestsFromPrevExecutor *ExecutionBrokerIMock) AddRequestsFromPrevExecutorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddRequestsFromPrevExecutor.afterAddRequestsFromPrevExecutorCounter)
}

// AddRequestsFromPrevExecutorBeforeCounter returns a count of ExecutionBrokerIMock.AddRequestsFromPrevExecutor invocations
func (mmAddRequestsFromPrevExecutor *ExecutionBrokerIMock) AddRequestsFromPrevExecutorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddRequestsFromPrevExecutor.beforeAddRequestsFromPrevExecutorCounter)
}

// Calls returns a list of arguments used in each call to ExecutionBrokerIMock.AddRequestsFromPrevExecutor.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddRequestsFromPrevExecutor *mExecutionBrokerIMockAddRequestsFromPrevExecutor) Calls() []*ExecutionBrokerIMockAddRequestsFromPrevExecutorParams {
	mmAddRequestsFromPrevExecutor.mutex.RLock()

	argCopy := make([]*ExecutionBrokerIMockAddRequestsFromPrevExecutorParams, len(mmAddRequestsFromPrevExecutor.callArgs))
	copy(argCopy, mmAddRequestsFromPrevExecutor.callArgs)

	mmAddRequestsFromPrevExecutor.mutex.RUnlock()

	return argCopy
}

// MinimockAddRequestsFromPrevExecutorDone returns true if the count of the AddRequestsFromPrevExecutor invocations corresponds
// the number of defined expectations
func (m *ExecutionBrokerIMock) MinimockAddRequestsFromPrevExecutorDone() bool {
	for _, e := range m.AddRequestsFromPrevExecutorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddRequestsFromPrevExecutorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddRequestsFromPrevExecutorCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddRequestsFromPrevExecutor != nil && mm_atomic.LoadUint64(&m.afterAddRequestsFromPrevExecutorCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddRequestsFromPrevExecutorInspect logs each unmet expectation
func (m *ExecutionBrokerIMock) MinimockAddRequestsFromPrevExecutorInspect() {
	for _, e := range m.AddRequestsFromPrevExecutorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.AddRequestsFromPrevExecutor with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddRequestsFromPrevExecutorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddRequestsFromPrevExecutorCounter) < 1 {
		if m.AddRequestsFromPrevExecutorMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionBrokerIMock.AddRequestsFromPrevExecutor")
		} else {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.AddRequestsFromPrevExecutor with params: %#v", *m.AddRequestsFromPrevExecutorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddRequestsFromPrevExecutor != nil && mm_atomic.LoadUint64(&m.afterAddRequestsFromPrevExecutorCounter) < 1 {
		m.t.Error("Expected call to ExecutionBrokerIMock.AddRequestsFromPrevExecutor")
	}
}

type mExecutionBrokerIMockIsKnownRequest struct {
	mock               *ExecutionBrokerIMock
	defaultExpectation *ExecutionBrokerIMockIsKnownRequestExpectation
	expectations       []*ExecutionBrokerIMockIsKnownRequestExpectation

	callArgs []*ExecutionBrokerIMockIsKnownRequestParams
	mutex    sync.RWMutex
}

// ExecutionBrokerIMockIsKnownRequestExpectation specifies expectation struct of the ExecutionBrokerI.IsKnownRequest
type ExecutionBrokerIMockIsKnownRequestExpectation struct {
	mock    *ExecutionBrokerIMock
	params  *ExecutionBrokerIMockIsKnownRequestParams
	results *ExecutionBrokerIMockIsKnownRequestResults
	Counter uint64
}

// ExecutionBrokerIMockIsKnownRequestParams contains parameters of the ExecutionBrokerI.IsKnownRequest
type ExecutionBrokerIMockIsKnownRequestParams struct {
	ctx context.Context
	req insolar.Reference
}

// ExecutionBrokerIMockIsKnownRequestResults contains results of the ExecutionBrokerI.IsKnownRequest
type ExecutionBrokerIMockIsKnownRequestResults struct {
	b1 bool
}

// Expect sets up expected params for ExecutionBrokerI.IsKnownRequest
func (mmIsKnownRequest *mExecutionBrokerIMockIsKnownRequest) Expect(ctx context.Context, req insolar.Reference) *mExecutionBrokerIMockIsKnownRequest {
	if mmIsKnownRequest.mock.funcIsKnownRequest != nil {
		mmIsKnownRequest.mock.t.Fatalf("ExecutionBrokerIMock.IsKnownRequest mock is already set by Set")
	}

	if mmIsKnownRequest.defaultExpectation == nil {
		mmIsKnownRequest.defaultExpectation = &ExecutionBrokerIMockIsKnownRequestExpectation{}
	}

	mmIsKnownRequest.defaultExpectation.params = &ExecutionBrokerIMockIsKnownRequestParams{ctx, req}
	for _, e := range mmIsKnownRequest.expectations {
		if minimock.Equal(e.params, mmIsKnownRequest.defaultExpectation.params) {
			mmIsKnownRequest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsKnownRequest.defaultExpectation.params)
		}
	}

	return mmIsKnownRequest
}

// Inspect accepts an inspector function that has same arguments as the ExecutionBrokerI.IsKnownRequest
func (mmIsKnownRequest *mExecutionBrokerIMockIsKnownRequest) Inspect(f func(ctx context.Context, req insolar.Reference)) *mExecutionBrokerIMockIsKnownRequest {
	if mmIsKnownRequest.mock.inspectFuncIsKnownRequest != nil {
		mmIsKnownRequest.mock.t.Fatalf("Inspect function is already set for ExecutionBrokerIMock.IsKnownRequest")
	}

	mmIsKnownRequest.mock.inspectFuncIsKnownRequest = f

	return mmIsKnownRequest
}

// Return sets up results that will be returned by ExecutionBrokerI.IsKnownRequest
func (mmIsKnownRequest *mExecutionBrokerIMockIsKnownRequest) Return(b1 bool) *ExecutionBrokerIMock {
	if mmIsKnownRequest.mock.funcIsKnownRequest != nil {
		mmIsKnownRequest.mock.t.Fatalf("ExecutionBrokerIMock.IsKnownRequest mock is already set by Set")
	}

	if mmIsKnownRequest.defaultExpectation == nil {
		mmIsKnownRequest.defaultExpectation = &ExecutionBrokerIMockIsKnownRequestExpectation{mock: mmIsKnownRequest.mock}
	}
	mmIsKnownRequest.defaultExpectation.results = &ExecutionBrokerIMockIsKnownRequestResults{b1}
	return mmIsKnownRequest.mock
}

//Set uses given function f to mock the ExecutionBrokerI.IsKnownRequest method
func (mmIsKnownRequest *mExecutionBrokerIMockIsKnownRequest) Set(f func(ctx context.Context, req insolar.Reference) (b1 bool)) *ExecutionBrokerIMock {
	if mmIsKnownRequest.defaultExpectation != nil {
		mmIsKnownRequest.mock.t.Fatalf("Default expectation is already set for the ExecutionBrokerI.IsKnownRequest method")
	}

	if len(mmIsKnownRequest.expectations) > 0 {
		mmIsKnownRequest.mock.t.Fatalf("Some expectations are already set for the ExecutionBrokerI.IsKnownRequest method")
	}

	mmIsKnownRequest.mock.funcIsKnownRequest = f
	return mmIsKnownRequest.mock
}

// When sets expectation for the ExecutionBrokerI.IsKnownRequest which will trigger the result defined by the following
// Then helper
func (mmIsKnownRequest *mExecutionBrokerIMockIsKnownRequest) When(ctx context.Context, req insolar.Reference) *ExecutionBrokerIMockIsKnownRequestExpectation {
	if mmIsKnownRequest.mock.funcIsKnownRequest != nil {
		mmIsKnownRequest.mock.t.Fatalf("ExecutionBrokerIMock.IsKnownRequest mock is already set by Set")
	}

	expectation := &ExecutionBrokerIMockIsKnownRequestExpectation{
		mock:   mmIsKnownRequest.mock,
		params: &ExecutionBrokerIMockIsKnownRequestParams{ctx, req},
	}
	mmIsKnownRequest.expectations = append(mmIsKnownRequest.expectations, expectation)
	return expectation
}

// Then sets up ExecutionBrokerI.IsKnownRequest return parameters for the expectation previously defined by the When method
func (e *ExecutionBrokerIMockIsKnownRequestExpectation) Then(b1 bool) *ExecutionBrokerIMock {
	e.results = &ExecutionBrokerIMockIsKnownRequestResults{b1}
	return e.mock
}

// IsKnownRequest implements ExecutionBrokerI
func (mmIsKnownRequest *ExecutionBrokerIMock) IsKnownRequest(ctx context.Context, req insolar.Reference) (b1 bool) {
	mm_atomic.AddUint64(&mmIsKnownRequest.beforeIsKnownRequestCounter, 1)
	defer mm_atomic.AddUint64(&mmIsKnownRequest.afterIsKnownRequestCounter, 1)

	if mmIsKnownRequest.inspectFuncIsKnownRequest != nil {
		mmIsKnownRequest.inspectFuncIsKnownRequest(ctx, req)
	}

	params := &ExecutionBrokerIMockIsKnownRequestParams{ctx, req}

	// Record call args
	mmIsKnownRequest.IsKnownRequestMock.mutex.Lock()
	mmIsKnownRequest.IsKnownRequestMock.callArgs = append(mmIsKnownRequest.IsKnownRequestMock.callArgs, params)
	mmIsKnownRequest.IsKnownRequestMock.mutex.Unlock()

	for _, e := range mmIsKnownRequest.IsKnownRequestMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmIsKnownRequest.IsKnownRequestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsKnownRequest.IsKnownRequestMock.defaultExpectation.Counter, 1)
		want := mmIsKnownRequest.IsKnownRequestMock.defaultExpectation.params
		got := ExecutionBrokerIMockIsKnownRequestParams{ctx, req}
		if want != nil && !minimock.Equal(*want, got) {
			mmIsKnownRequest.t.Errorf("ExecutionBrokerIMock.IsKnownRequest got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmIsKnownRequest.IsKnownRequestMock.defaultExpectation.results
		if results == nil {
			mmIsKnownRequest.t.Fatal("No results are set for the ExecutionBrokerIMock.IsKnownRequest")
		}
		return (*results).b1
	}
	if mmIsKnownRequest.funcIsKnownRequest != nil {
		return mmIsKnownRequest.funcIsKnownRequest(ctx, req)
	}
	mmIsKnownRequest.t.Fatalf("Unexpected call to ExecutionBrokerIMock.IsKnownRequest. %v %v", ctx, req)
	return
}

// IsKnownRequestAfterCounter returns a count of finished ExecutionBrokerIMock.IsKnownRequest invocations
func (mmIsKnownRequest *ExecutionBrokerIMock) IsKnownRequestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsKnownRequest.afterIsKnownRequestCounter)
}

// IsKnownRequestBeforeCounter returns a count of ExecutionBrokerIMock.IsKnownRequest invocations
func (mmIsKnownRequest *ExecutionBrokerIMock) IsKnownRequestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsKnownRequest.beforeIsKnownRequestCounter)
}

// Calls returns a list of arguments used in each call to ExecutionBrokerIMock.IsKnownRequest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsKnownRequest *mExecutionBrokerIMockIsKnownRequest) Calls() []*ExecutionBrokerIMockIsKnownRequestParams {
	mmIsKnownRequest.mutex.RLock()

	argCopy := make([]*ExecutionBrokerIMockIsKnownRequestParams, len(mmIsKnownRequest.callArgs))
	copy(argCopy, mmIsKnownRequest.callArgs)

	mmIsKnownRequest.mutex.RUnlock()

	return argCopy
}

// MinimockIsKnownRequestDone returns true if the count of the IsKnownRequest invocations corresponds
// the number of defined expectations
func (m *ExecutionBrokerIMock) MinimockIsKnownRequestDone() bool {
	for _, e := range m.IsKnownRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsKnownRequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsKnownRequestCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsKnownRequest != nil && mm_atomic.LoadUint64(&m.afterIsKnownRequestCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsKnownRequestInspect logs each unmet expectation
func (m *ExecutionBrokerIMock) MinimockIsKnownRequestInspect() {
	for _, e := range m.IsKnownRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.IsKnownRequest with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsKnownRequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsKnownRequestCounter) < 1 {
		if m.IsKnownRequestMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionBrokerIMock.IsKnownRequest")
		} else {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.IsKnownRequest with params: %#v", *m.IsKnownRequestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsKnownRequest != nil && mm_atomic.LoadUint64(&m.afterIsKnownRequestCounter) < 1 {
		m.t.Error("Expected call to ExecutionBrokerIMock.IsKnownRequest")
	}
}

type mExecutionBrokerIMockMoreRequestsOnLedger struct {
	mock               *ExecutionBrokerIMock
	defaultExpectation *ExecutionBrokerIMockMoreRequestsOnLedgerExpectation
	expectations       []*ExecutionBrokerIMockMoreRequestsOnLedgerExpectation

	callArgs []*ExecutionBrokerIMockMoreRequestsOnLedgerParams
	mutex    sync.RWMutex
}

// ExecutionBrokerIMockMoreRequestsOnLedgerExpectation specifies expectation struct of the ExecutionBrokerI.MoreRequestsOnLedger
type ExecutionBrokerIMockMoreRequestsOnLedgerExpectation struct {
	mock   *ExecutionBrokerIMock
	params *ExecutionBrokerIMockMoreRequestsOnLedgerParams

	Counter uint64
}

// ExecutionBrokerIMockMoreRequestsOnLedgerParams contains parameters of the ExecutionBrokerI.MoreRequestsOnLedger
type ExecutionBrokerIMockMoreRequestsOnLedgerParams struct {
	ctx context.Context
}

// Expect sets up expected params for ExecutionBrokerI.MoreRequestsOnLedger
func (mmMoreRequestsOnLedger *mExecutionBrokerIMockMoreRequestsOnLedger) Expect(ctx context.Context) *mExecutionBrokerIMockMoreRequestsOnLedger {
	if mmMoreRequestsOnLedger.mock.funcMoreRequestsOnLedger != nil {
		mmMoreRequestsOnLedger.mock.t.Fatalf("ExecutionBrokerIMock.MoreRequestsOnLedger mock is already set by Set")
	}

	if mmMoreRequestsOnLedger.defaultExpectation == nil {
		mmMoreRequestsOnLedger.defaultExpectation = &ExecutionBrokerIMockMoreRequestsOnLedgerExpectation{}
	}

	mmMoreRequestsOnLedger.defaultExpectation.params = &ExecutionBrokerIMockMoreRequestsOnLedgerParams{ctx}
	for _, e := range mmMoreRequestsOnLedger.expectations {
		if minimock.Equal(e.params, mmMoreRequestsOnLedger.defaultExpectation.params) {
			mmMoreRequestsOnLedger.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMoreRequestsOnLedger.defaultExpectation.params)
		}
	}

	return mmMoreRequestsOnLedger
}

// Inspect accepts an inspector function that has same arguments as the ExecutionBrokerI.MoreRequestsOnLedger
func (mmMoreRequestsOnLedger *mExecutionBrokerIMockMoreRequestsOnLedger) Inspect(f func(ctx context.Context)) *mExecutionBrokerIMockMoreRequestsOnLedger {
	if mmMoreRequestsOnLedger.mock.inspectFuncMoreRequestsOnLedger != nil {
		mmMoreRequestsOnLedger.mock.t.Fatalf("Inspect function is already set for ExecutionBrokerIMock.MoreRequestsOnLedger")
	}

	mmMoreRequestsOnLedger.mock.inspectFuncMoreRequestsOnLedger = f

	return mmMoreRequestsOnLedger
}

// Return sets up results that will be returned by ExecutionBrokerI.MoreRequestsOnLedger
func (mmMoreRequestsOnLedger *mExecutionBrokerIMockMoreRequestsOnLedger) Return() *ExecutionBrokerIMock {
	if mmMoreRequestsOnLedger.mock.funcMoreRequestsOnLedger != nil {
		mmMoreRequestsOnLedger.mock.t.Fatalf("ExecutionBrokerIMock.MoreRequestsOnLedger mock is already set by Set")
	}

	if mmMoreRequestsOnLedger.defaultExpectation == nil {
		mmMoreRequestsOnLedger.defaultExpectation = &ExecutionBrokerIMockMoreRequestsOnLedgerExpectation{mock: mmMoreRequestsOnLedger.mock}
	}

	return mmMoreRequestsOnLedger.mock
}

//Set uses given function f to mock the ExecutionBrokerI.MoreRequestsOnLedger method
func (mmMoreRequestsOnLedger *mExecutionBrokerIMockMoreRequestsOnLedger) Set(f func(ctx context.Context)) *ExecutionBrokerIMock {
	if mmMoreRequestsOnLedger.defaultExpectation != nil {
		mmMoreRequestsOnLedger.mock.t.Fatalf("Default expectation is already set for the ExecutionBrokerI.MoreRequestsOnLedger method")
	}

	if len(mmMoreRequestsOnLedger.expectations) > 0 {
		mmMoreRequestsOnLedger.mock.t.Fatalf("Some expectations are already set for the ExecutionBrokerI.MoreRequestsOnLedger method")
	}

	mmMoreRequestsOnLedger.mock.funcMoreRequestsOnLedger = f
	return mmMoreRequestsOnLedger.mock
}

// MoreRequestsOnLedger implements ExecutionBrokerI
func (mmMoreRequestsOnLedger *ExecutionBrokerIMock) MoreRequestsOnLedger(ctx context.Context) {
	mm_atomic.AddUint64(&mmMoreRequestsOnLedger.beforeMoreRequestsOnLedgerCounter, 1)
	defer mm_atomic.AddUint64(&mmMoreRequestsOnLedger.afterMoreRequestsOnLedgerCounter, 1)

	if mmMoreRequestsOnLedger.inspectFuncMoreRequestsOnLedger != nil {
		mmMoreRequestsOnLedger.inspectFuncMoreRequestsOnLedger(ctx)
	}

	params := &ExecutionBrokerIMockMoreRequestsOnLedgerParams{ctx}

	// Record call args
	mmMoreRequestsOnLedger.MoreRequestsOnLedgerMock.mutex.Lock()
	mmMoreRequestsOnLedger.MoreRequestsOnLedgerMock.callArgs = append(mmMoreRequestsOnLedger.MoreRequestsOnLedgerMock.callArgs, params)
	mmMoreRequestsOnLedger.MoreRequestsOnLedgerMock.mutex.Unlock()

	for _, e := range mmMoreRequestsOnLedger.MoreRequestsOnLedgerMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmMoreRequestsOnLedger.MoreRequestsOnLedgerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMoreRequestsOnLedger.MoreRequestsOnLedgerMock.defaultExpectation.Counter, 1)
		want := mmMoreRequestsOnLedger.MoreRequestsOnLedgerMock.defaultExpectation.params
		got := ExecutionBrokerIMockMoreRequestsOnLedgerParams{ctx}
		if want != nil && !minimock.Equal(*want, got) {
			mmMoreRequestsOnLedger.t.Errorf("ExecutionBrokerIMock.MoreRequestsOnLedger got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmMoreRequestsOnLedger.funcMoreRequestsOnLedger != nil {
		mmMoreRequestsOnLedger.funcMoreRequestsOnLedger(ctx)
		return
	}
	mmMoreRequestsOnLedger.t.Fatalf("Unexpected call to ExecutionBrokerIMock.MoreRequestsOnLedger. %v", ctx)

}

// MoreRequestsOnLedgerAfterCounter returns a count of finished ExecutionBrokerIMock.MoreRequestsOnLedger invocations
func (mmMoreRequestsOnLedger *ExecutionBrokerIMock) MoreRequestsOnLedgerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMoreRequestsOnLedger.afterMoreRequestsOnLedgerCounter)
}

// MoreRequestsOnLedgerBeforeCounter returns a count of ExecutionBrokerIMock.MoreRequestsOnLedger invocations
func (mmMoreRequestsOnLedger *ExecutionBrokerIMock) MoreRequestsOnLedgerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMoreRequestsOnLedger.beforeMoreRequestsOnLedgerCounter)
}

// Calls returns a list of arguments used in each call to ExecutionBrokerIMock.MoreRequestsOnLedger.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMoreRequestsOnLedger *mExecutionBrokerIMockMoreRequestsOnLedger) Calls() []*ExecutionBrokerIMockMoreRequestsOnLedgerParams {
	mmMoreRequestsOnLedger.mutex.RLock()

	argCopy := make([]*ExecutionBrokerIMockMoreRequestsOnLedgerParams, len(mmMoreRequestsOnLedger.callArgs))
	copy(argCopy, mmMoreRequestsOnLedger.callArgs)

	mmMoreRequestsOnLedger.mutex.RUnlock()

	return argCopy
}

// MinimockMoreRequestsOnLedgerDone returns true if the count of the MoreRequestsOnLedger invocations corresponds
// the number of defined expectations
func (m *ExecutionBrokerIMock) MinimockMoreRequestsOnLedgerDone() bool {
	for _, e := range m.MoreRequestsOnLedgerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MoreRequestsOnLedgerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMoreRequestsOnLedgerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMoreRequestsOnLedger != nil && mm_atomic.LoadUint64(&m.afterMoreRequestsOnLedgerCounter) < 1 {
		return false
	}
	return true
}

// MinimockMoreRequestsOnLedgerInspect logs each unmet expectation
func (m *ExecutionBrokerIMock) MinimockMoreRequestsOnLedgerInspect() {
	for _, e := range m.MoreRequestsOnLedgerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.MoreRequestsOnLedger with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MoreRequestsOnLedgerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMoreRequestsOnLedgerCounter) < 1 {
		if m.MoreRequestsOnLedgerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionBrokerIMock.MoreRequestsOnLedger")
		} else {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.MoreRequestsOnLedger with params: %#v", *m.MoreRequestsOnLedgerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMoreRequestsOnLedger != nil && mm_atomic.LoadUint64(&m.afterMoreRequestsOnLedgerCounter) < 1 {
		m.t.Error("Expected call to ExecutionBrokerIMock.MoreRequestsOnLedger")
	}
}

type mExecutionBrokerIMockNoMoreRequestsOnLedger struct {
	mock               *ExecutionBrokerIMock
	defaultExpectation *ExecutionBrokerIMockNoMoreRequestsOnLedgerExpectation
	expectations       []*ExecutionBrokerIMockNoMoreRequestsOnLedgerExpectation

	callArgs []*ExecutionBrokerIMockNoMoreRequestsOnLedgerParams
	mutex    sync.RWMutex
}

// ExecutionBrokerIMockNoMoreRequestsOnLedgerExpectation specifies expectation struct of the ExecutionBrokerI.NoMoreRequestsOnLedger
type ExecutionBrokerIMockNoMoreRequestsOnLedgerExpectation struct {
	mock   *ExecutionBrokerIMock
	params *ExecutionBrokerIMockNoMoreRequestsOnLedgerParams

	Counter uint64
}

// ExecutionBrokerIMockNoMoreRequestsOnLedgerParams contains parameters of the ExecutionBrokerI.NoMoreRequestsOnLedger
type ExecutionBrokerIMockNoMoreRequestsOnLedgerParams struct {
	ctx context.Context
}

// Expect sets up expected params for ExecutionBrokerI.NoMoreRequestsOnLedger
func (mmNoMoreRequestsOnLedger *mExecutionBrokerIMockNoMoreRequestsOnLedger) Expect(ctx context.Context) *mExecutionBrokerIMockNoMoreRequestsOnLedger {
	if mmNoMoreRequestsOnLedger.mock.funcNoMoreRequestsOnLedger != nil {
		mmNoMoreRequestsOnLedger.mock.t.Fatalf("ExecutionBrokerIMock.NoMoreRequestsOnLedger mock is already set by Set")
	}

	if mmNoMoreRequestsOnLedger.defaultExpectation == nil {
		mmNoMoreRequestsOnLedger.defaultExpectation = &ExecutionBrokerIMockNoMoreRequestsOnLedgerExpectation{}
	}

	mmNoMoreRequestsOnLedger.defaultExpectation.params = &ExecutionBrokerIMockNoMoreRequestsOnLedgerParams{ctx}
	for _, e := range mmNoMoreRequestsOnLedger.expectations {
		if minimock.Equal(e.params, mmNoMoreRequestsOnLedger.defaultExpectation.params) {
			mmNoMoreRequestsOnLedger.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmNoMoreRequestsOnLedger.defaultExpectation.params)
		}
	}

	return mmNoMoreRequestsOnLedger
}

// Inspect accepts an inspector function that has same arguments as the ExecutionBrokerI.NoMoreRequestsOnLedger
func (mmNoMoreRequestsOnLedger *mExecutionBrokerIMockNoMoreRequestsOnLedger) Inspect(f func(ctx context.Context)) *mExecutionBrokerIMockNoMoreRequestsOnLedger {
	if mmNoMoreRequestsOnLedger.mock.inspectFuncNoMoreRequestsOnLedger != nil {
		mmNoMoreRequestsOnLedger.mock.t.Fatalf("Inspect function is already set for ExecutionBrokerIMock.NoMoreRequestsOnLedger")
	}

	mmNoMoreRequestsOnLedger.mock.inspectFuncNoMoreRequestsOnLedger = f

	return mmNoMoreRequestsOnLedger
}

// Return sets up results that will be returned by ExecutionBrokerI.NoMoreRequestsOnLedger
func (mmNoMoreRequestsOnLedger *mExecutionBrokerIMockNoMoreRequestsOnLedger) Return() *ExecutionBrokerIMock {
	if mmNoMoreRequestsOnLedger.mock.funcNoMoreRequestsOnLedger != nil {
		mmNoMoreRequestsOnLedger.mock.t.Fatalf("ExecutionBrokerIMock.NoMoreRequestsOnLedger mock is already set by Set")
	}

	if mmNoMoreRequestsOnLedger.defaultExpectation == nil {
		mmNoMoreRequestsOnLedger.defaultExpectation = &ExecutionBrokerIMockNoMoreRequestsOnLedgerExpectation{mock: mmNoMoreRequestsOnLedger.mock}
	}

	return mmNoMoreRequestsOnLedger.mock
}

//Set uses given function f to mock the ExecutionBrokerI.NoMoreRequestsOnLedger method
func (mmNoMoreRequestsOnLedger *mExecutionBrokerIMockNoMoreRequestsOnLedger) Set(f func(ctx context.Context)) *ExecutionBrokerIMock {
	if mmNoMoreRequestsOnLedger.defaultExpectation != nil {
		mmNoMoreRequestsOnLedger.mock.t.Fatalf("Default expectation is already set for the ExecutionBrokerI.NoMoreRequestsOnLedger method")
	}

	if len(mmNoMoreRequestsOnLedger.expectations) > 0 {
		mmNoMoreRequestsOnLedger.mock.t.Fatalf("Some expectations are already set for the ExecutionBrokerI.NoMoreRequestsOnLedger method")
	}

	mmNoMoreRequestsOnLedger.mock.funcNoMoreRequestsOnLedger = f
	return mmNoMoreRequestsOnLedger.mock
}

// NoMoreRequestsOnLedger implements ExecutionBrokerI
func (mmNoMoreRequestsOnLedger *ExecutionBrokerIMock) NoMoreRequestsOnLedger(ctx context.Context) {
	mm_atomic.AddUint64(&mmNoMoreRequestsOnLedger.beforeNoMoreRequestsOnLedgerCounter, 1)
	defer mm_atomic.AddUint64(&mmNoMoreRequestsOnLedger.afterNoMoreRequestsOnLedgerCounter, 1)

	if mmNoMoreRequestsOnLedger.inspectFuncNoMoreRequestsOnLedger != nil {
		mmNoMoreRequestsOnLedger.inspectFuncNoMoreRequestsOnLedger(ctx)
	}

	params := &ExecutionBrokerIMockNoMoreRequestsOnLedgerParams{ctx}

	// Record call args
	mmNoMoreRequestsOnLedger.NoMoreRequestsOnLedgerMock.mutex.Lock()
	mmNoMoreRequestsOnLedger.NoMoreRequestsOnLedgerMock.callArgs = append(mmNoMoreRequestsOnLedger.NoMoreRequestsOnLedgerMock.callArgs, params)
	mmNoMoreRequestsOnLedger.NoMoreRequestsOnLedgerMock.mutex.Unlock()

	for _, e := range mmNoMoreRequestsOnLedger.NoMoreRequestsOnLedgerMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmNoMoreRequestsOnLedger.NoMoreRequestsOnLedgerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNoMoreRequestsOnLedger.NoMoreRequestsOnLedgerMock.defaultExpectation.Counter, 1)
		want := mmNoMoreRequestsOnLedger.NoMoreRequestsOnLedgerMock.defaultExpectation.params
		got := ExecutionBrokerIMockNoMoreRequestsOnLedgerParams{ctx}
		if want != nil && !minimock.Equal(*want, got) {
			mmNoMoreRequestsOnLedger.t.Errorf("ExecutionBrokerIMock.NoMoreRequestsOnLedger got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmNoMoreRequestsOnLedger.funcNoMoreRequestsOnLedger != nil {
		mmNoMoreRequestsOnLedger.funcNoMoreRequestsOnLedger(ctx)
		return
	}
	mmNoMoreRequestsOnLedger.t.Fatalf("Unexpected call to ExecutionBrokerIMock.NoMoreRequestsOnLedger. %v", ctx)

}

// NoMoreRequestsOnLedgerAfterCounter returns a count of finished ExecutionBrokerIMock.NoMoreRequestsOnLedger invocations
func (mmNoMoreRequestsOnLedger *ExecutionBrokerIMock) NoMoreRequestsOnLedgerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNoMoreRequestsOnLedger.afterNoMoreRequestsOnLedgerCounter)
}

// NoMoreRequestsOnLedgerBeforeCounter returns a count of ExecutionBrokerIMock.NoMoreRequestsOnLedger invocations
func (mmNoMoreRequestsOnLedger *ExecutionBrokerIMock) NoMoreRequestsOnLedgerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNoMoreRequestsOnLedger.beforeNoMoreRequestsOnLedgerCounter)
}

// Calls returns a list of arguments used in each call to ExecutionBrokerIMock.NoMoreRequestsOnLedger.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmNoMoreRequestsOnLedger *mExecutionBrokerIMockNoMoreRequestsOnLedger) Calls() []*ExecutionBrokerIMockNoMoreRequestsOnLedgerParams {
	mmNoMoreRequestsOnLedger.mutex.RLock()

	argCopy := make([]*ExecutionBrokerIMockNoMoreRequestsOnLedgerParams, len(mmNoMoreRequestsOnLedger.callArgs))
	copy(argCopy, mmNoMoreRequestsOnLedger.callArgs)

	mmNoMoreRequestsOnLedger.mutex.RUnlock()

	return argCopy
}

// MinimockNoMoreRequestsOnLedgerDone returns true if the count of the NoMoreRequestsOnLedger invocations corresponds
// the number of defined expectations
func (m *ExecutionBrokerIMock) MinimockNoMoreRequestsOnLedgerDone() bool {
	for _, e := range m.NoMoreRequestsOnLedgerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NoMoreRequestsOnLedgerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNoMoreRequestsOnLedgerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNoMoreRequestsOnLedger != nil && mm_atomic.LoadUint64(&m.afterNoMoreRequestsOnLedgerCounter) < 1 {
		return false
	}
	return true
}

// MinimockNoMoreRequestsOnLedgerInspect logs each unmet expectation
func (m *ExecutionBrokerIMock) MinimockNoMoreRequestsOnLedgerInspect() {
	for _, e := range m.NoMoreRequestsOnLedgerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.NoMoreRequestsOnLedger with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NoMoreRequestsOnLedgerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNoMoreRequestsOnLedgerCounter) < 1 {
		if m.NoMoreRequestsOnLedgerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionBrokerIMock.NoMoreRequestsOnLedger")
		} else {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.NoMoreRequestsOnLedger with params: %#v", *m.NoMoreRequestsOnLedgerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNoMoreRequestsOnLedger != nil && mm_atomic.LoadUint64(&m.afterNoMoreRequestsOnLedgerCounter) < 1 {
		m.t.Error("Expected call to ExecutionBrokerIMock.NoMoreRequestsOnLedger")
	}
}

type mExecutionBrokerIMockOnPulse struct {
	mock               *ExecutionBrokerIMock
	defaultExpectation *ExecutionBrokerIMockOnPulseExpectation
	expectations       []*ExecutionBrokerIMockOnPulseExpectation

	callArgs []*ExecutionBrokerIMockOnPulseParams
	mutex    sync.RWMutex
}

// ExecutionBrokerIMockOnPulseExpectation specifies expectation struct of the ExecutionBrokerI.OnPulse
type ExecutionBrokerIMockOnPulseExpectation struct {
	mock    *ExecutionBrokerIMock
	params  *ExecutionBrokerIMockOnPulseParams
	results *ExecutionBrokerIMockOnPulseResults
	Counter uint64
}

// ExecutionBrokerIMockOnPulseParams contains parameters of the ExecutionBrokerI.OnPulse
type ExecutionBrokerIMockOnPulseParams struct {
	ctx context.Context
}

// ExecutionBrokerIMockOnPulseResults contains results of the ExecutionBrokerI.OnPulse
type ExecutionBrokerIMockOnPulseResults struct {
	pa1 []payload.Payload
}

// Expect sets up expected params for ExecutionBrokerI.OnPulse
func (mmOnPulse *mExecutionBrokerIMockOnPulse) Expect(ctx context.Context) *mExecutionBrokerIMockOnPulse {
	if mmOnPulse.mock.funcOnPulse != nil {
		mmOnPulse.mock.t.Fatalf("ExecutionBrokerIMock.OnPulse mock is already set by Set")
	}

	if mmOnPulse.defaultExpectation == nil {
		mmOnPulse.defaultExpectation = &ExecutionBrokerIMockOnPulseExpectation{}
	}

	mmOnPulse.defaultExpectation.params = &ExecutionBrokerIMockOnPulseParams{ctx}
	for _, e := range mmOnPulse.expectations {
		if minimock.Equal(e.params, mmOnPulse.defaultExpectation.params) {
			mmOnPulse.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOnPulse.defaultExpectation.params)
		}
	}

	return mmOnPulse
}

// Inspect accepts an inspector function that has same arguments as the ExecutionBrokerI.OnPulse
func (mmOnPulse *mExecutionBrokerIMockOnPulse) Inspect(f func(ctx context.Context)) *mExecutionBrokerIMockOnPulse {
	if mmOnPulse.mock.inspectFuncOnPulse != nil {
		mmOnPulse.mock.t.Fatalf("Inspect function is already set for ExecutionBrokerIMock.OnPulse")
	}

	mmOnPulse.mock.inspectFuncOnPulse = f

	return mmOnPulse
}

// Return sets up results that will be returned by ExecutionBrokerI.OnPulse
func (mmOnPulse *mExecutionBrokerIMockOnPulse) Return(pa1 []payload.Payload) *ExecutionBrokerIMock {
	if mmOnPulse.mock.funcOnPulse != nil {
		mmOnPulse.mock.t.Fatalf("ExecutionBrokerIMock.OnPulse mock is already set by Set")
	}

	if mmOnPulse.defaultExpectation == nil {
		mmOnPulse.defaultExpectation = &ExecutionBrokerIMockOnPulseExpectation{mock: mmOnPulse.mock}
	}
	mmOnPulse.defaultExpectation.results = &ExecutionBrokerIMockOnPulseResults{pa1}
	return mmOnPulse.mock
}

//Set uses given function f to mock the ExecutionBrokerI.OnPulse method
func (mmOnPulse *mExecutionBrokerIMockOnPulse) Set(f func(ctx context.Context) (pa1 []payload.Payload)) *ExecutionBrokerIMock {
	if mmOnPulse.defaultExpectation != nil {
		mmOnPulse.mock.t.Fatalf("Default expectation is already set for the ExecutionBrokerI.OnPulse method")
	}

	if len(mmOnPulse.expectations) > 0 {
		mmOnPulse.mock.t.Fatalf("Some expectations are already set for the ExecutionBrokerI.OnPulse method")
	}

	mmOnPulse.mock.funcOnPulse = f
	return mmOnPulse.mock
}

// When sets expectation for the ExecutionBrokerI.OnPulse which will trigger the result defined by the following
// Then helper
func (mmOnPulse *mExecutionBrokerIMockOnPulse) When(ctx context.Context) *ExecutionBrokerIMockOnPulseExpectation {
	if mmOnPulse.mock.funcOnPulse != nil {
		mmOnPulse.mock.t.Fatalf("ExecutionBrokerIMock.OnPulse mock is already set by Set")
	}

	expectation := &ExecutionBrokerIMockOnPulseExpectation{
		mock:   mmOnPulse.mock,
		params: &ExecutionBrokerIMockOnPulseParams{ctx},
	}
	mmOnPulse.expectations = append(mmOnPulse.expectations, expectation)
	return expectation
}

// Then sets up ExecutionBrokerI.OnPulse return parameters for the expectation previously defined by the When method
func (e *ExecutionBrokerIMockOnPulseExpectation) Then(pa1 []payload.Payload) *ExecutionBrokerIMock {
	e.results = &ExecutionBrokerIMockOnPulseResults{pa1}
	return e.mock
}

// OnPulse implements ExecutionBrokerI
func (mmOnPulse *ExecutionBrokerIMock) OnPulse(ctx context.Context) (pa1 []payload.Payload) {
	mm_atomic.AddUint64(&mmOnPulse.beforeOnPulseCounter, 1)
	defer mm_atomic.AddUint64(&mmOnPulse.afterOnPulseCounter, 1)

	if mmOnPulse.inspectFuncOnPulse != nil {
		mmOnPulse.inspectFuncOnPulse(ctx)
	}

	params := &ExecutionBrokerIMockOnPulseParams{ctx}

	// Record call args
	mmOnPulse.OnPulseMock.mutex.Lock()
	mmOnPulse.OnPulseMock.callArgs = append(mmOnPulse.OnPulseMock.callArgs, params)
	mmOnPulse.OnPulseMock.mutex.Unlock()

	for _, e := range mmOnPulse.OnPulseMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1
		}
	}

	if mmOnPulse.OnPulseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOnPulse.OnPulseMock.defaultExpectation.Counter, 1)
		want := mmOnPulse.OnPulseMock.defaultExpectation.params
		got := ExecutionBrokerIMockOnPulseParams{ctx}
		if want != nil && !minimock.Equal(*want, got) {
			mmOnPulse.t.Errorf("ExecutionBrokerIMock.OnPulse got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmOnPulse.OnPulseMock.defaultExpectation.results
		if results == nil {
			mmOnPulse.t.Fatal("No results are set for the ExecutionBrokerIMock.OnPulse")
		}
		return (*results).pa1
	}
	if mmOnPulse.funcOnPulse != nil {
		return mmOnPulse.funcOnPulse(ctx)
	}
	mmOnPulse.t.Fatalf("Unexpected call to ExecutionBrokerIMock.OnPulse. %v", ctx)
	return
}

// OnPulseAfterCounter returns a count of finished ExecutionBrokerIMock.OnPulse invocations
func (mmOnPulse *ExecutionBrokerIMock) OnPulseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOnPulse.afterOnPulseCounter)
}

// OnPulseBeforeCounter returns a count of ExecutionBrokerIMock.OnPulse invocations
func (mmOnPulse *ExecutionBrokerIMock) OnPulseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOnPulse.beforeOnPulseCounter)
}

// Calls returns a list of arguments used in each call to ExecutionBrokerIMock.OnPulse.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOnPulse *mExecutionBrokerIMockOnPulse) Calls() []*ExecutionBrokerIMockOnPulseParams {
	mmOnPulse.mutex.RLock()

	argCopy := make([]*ExecutionBrokerIMockOnPulseParams, len(mmOnPulse.callArgs))
	copy(argCopy, mmOnPulse.callArgs)

	mmOnPulse.mutex.RUnlock()

	return argCopy
}

// MinimockOnPulseDone returns true if the count of the OnPulse invocations corresponds
// the number of defined expectations
func (m *ExecutionBrokerIMock) MinimockOnPulseDone() bool {
	for _, e := range m.OnPulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OnPulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOnPulseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOnPulse != nil && mm_atomic.LoadUint64(&m.afterOnPulseCounter) < 1 {
		return false
	}
	return true
}

// MinimockOnPulseInspect logs each unmet expectation
func (m *ExecutionBrokerIMock) MinimockOnPulseInspect() {
	for _, e := range m.OnPulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.OnPulse with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OnPulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOnPulseCounter) < 1 {
		if m.OnPulseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionBrokerIMock.OnPulse")
		} else {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.OnPulse with params: %#v", *m.OnPulseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOnPulse != nil && mm_atomic.LoadUint64(&m.afterOnPulseCounter) < 1 {
		m.t.Error("Expected call to ExecutionBrokerIMock.OnPulse")
	}
}

type mExecutionBrokerIMockPendingState struct {
	mock               *ExecutionBrokerIMock
	defaultExpectation *ExecutionBrokerIMockPendingStateExpectation
	expectations       []*ExecutionBrokerIMockPendingStateExpectation
}

// ExecutionBrokerIMockPendingStateExpectation specifies expectation struct of the ExecutionBrokerI.PendingState
type ExecutionBrokerIMockPendingStateExpectation struct {
	mock *ExecutionBrokerIMock

	results *ExecutionBrokerIMockPendingStateResults
	Counter uint64
}

// ExecutionBrokerIMockPendingStateResults contains results of the ExecutionBrokerI.PendingState
type ExecutionBrokerIMockPendingStateResults struct {
	p1 insolar.PendingState
}

// Expect sets up expected params for ExecutionBrokerI.PendingState
func (mmPendingState *mExecutionBrokerIMockPendingState) Expect() *mExecutionBrokerIMockPendingState {
	if mmPendingState.mock.funcPendingState != nil {
		mmPendingState.mock.t.Fatalf("ExecutionBrokerIMock.PendingState mock is already set by Set")
	}

	if mmPendingState.defaultExpectation == nil {
		mmPendingState.defaultExpectation = &ExecutionBrokerIMockPendingStateExpectation{}
	}

	return mmPendingState
}

// Inspect accepts an inspector function that has same arguments as the ExecutionBrokerI.PendingState
func (mmPendingState *mExecutionBrokerIMockPendingState) Inspect(f func()) *mExecutionBrokerIMockPendingState {
	if mmPendingState.mock.inspectFuncPendingState != nil {
		mmPendingState.mock.t.Fatalf("Inspect function is already set for ExecutionBrokerIMock.PendingState")
	}

	mmPendingState.mock.inspectFuncPendingState = f

	return mmPendingState
}

// Return sets up results that will be returned by ExecutionBrokerI.PendingState
func (mmPendingState *mExecutionBrokerIMockPendingState) Return(p1 insolar.PendingState) *ExecutionBrokerIMock {
	if mmPendingState.mock.funcPendingState != nil {
		mmPendingState.mock.t.Fatalf("ExecutionBrokerIMock.PendingState mock is already set by Set")
	}

	if mmPendingState.defaultExpectation == nil {
		mmPendingState.defaultExpectation = &ExecutionBrokerIMockPendingStateExpectation{mock: mmPendingState.mock}
	}
	mmPendingState.defaultExpectation.results = &ExecutionBrokerIMockPendingStateResults{p1}
	return mmPendingState.mock
}

//Set uses given function f to mock the ExecutionBrokerI.PendingState method
func (mmPendingState *mExecutionBrokerIMockPendingState) Set(f func() (p1 insolar.PendingState)) *ExecutionBrokerIMock {
	if mmPendingState.defaultExpectation != nil {
		mmPendingState.mock.t.Fatalf("Default expectation is already set for the ExecutionBrokerI.PendingState method")
	}

	if len(mmPendingState.expectations) > 0 {
		mmPendingState.mock.t.Fatalf("Some expectations are already set for the ExecutionBrokerI.PendingState method")
	}

	mmPendingState.mock.funcPendingState = f
	return mmPendingState.mock
}

// PendingState implements ExecutionBrokerI
func (mmPendingState *ExecutionBrokerIMock) PendingState() (p1 insolar.PendingState) {
	mm_atomic.AddUint64(&mmPendingState.beforePendingStateCounter, 1)
	defer mm_atomic.AddUint64(&mmPendingState.afterPendingStateCounter, 1)

	if mmPendingState.inspectFuncPendingState != nil {
		mmPendingState.inspectFuncPendingState()
	}

	if mmPendingState.PendingStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPendingState.PendingStateMock.defaultExpectation.Counter, 1)

		results := mmPendingState.PendingStateMock.defaultExpectation.results
		if results == nil {
			mmPendingState.t.Fatal("No results are set for the ExecutionBrokerIMock.PendingState")
		}
		return (*results).p1
	}
	if mmPendingState.funcPendingState != nil {
		return mmPendingState.funcPendingState()
	}
	mmPendingState.t.Fatalf("Unexpected call to ExecutionBrokerIMock.PendingState.")
	return
}

// PendingStateAfterCounter returns a count of finished ExecutionBrokerIMock.PendingState invocations
func (mmPendingState *ExecutionBrokerIMock) PendingStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPendingState.afterPendingStateCounter)
}

// PendingStateBeforeCounter returns a count of ExecutionBrokerIMock.PendingState invocations
func (mmPendingState *ExecutionBrokerIMock) PendingStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPendingState.beforePendingStateCounter)
}

// MinimockPendingStateDone returns true if the count of the PendingState invocations corresponds
// the number of defined expectations
func (m *ExecutionBrokerIMock) MinimockPendingStateDone() bool {
	for _, e := range m.PendingStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PendingStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPendingStateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPendingState != nil && mm_atomic.LoadUint64(&m.afterPendingStateCounter) < 1 {
		return false
	}
	return true
}

// MinimockPendingStateInspect logs each unmet expectation
func (m *ExecutionBrokerIMock) MinimockPendingStateInspect() {
	for _, e := range m.PendingStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExecutionBrokerIMock.PendingState")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PendingStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPendingStateCounter) < 1 {
		m.t.Error("Expected call to ExecutionBrokerIMock.PendingState")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPendingState != nil && mm_atomic.LoadUint64(&m.afterPendingStateCounter) < 1 {
		m.t.Error("Expected call to ExecutionBrokerIMock.PendingState")
	}
}

type mExecutionBrokerIMockPrevExecutorPendingResult struct {
	mock               *ExecutionBrokerIMock
	defaultExpectation *ExecutionBrokerIMockPrevExecutorPendingResultExpectation
	expectations       []*ExecutionBrokerIMockPrevExecutorPendingResultExpectation

	callArgs []*ExecutionBrokerIMockPrevExecutorPendingResultParams
	mutex    sync.RWMutex
}

// ExecutionBrokerIMockPrevExecutorPendingResultExpectation specifies expectation struct of the ExecutionBrokerI.PrevExecutorPendingResult
type ExecutionBrokerIMockPrevExecutorPendingResultExpectation struct {
	mock   *ExecutionBrokerIMock
	params *ExecutionBrokerIMockPrevExecutorPendingResultParams

	Counter uint64
}

// ExecutionBrokerIMockPrevExecutorPendingResultParams contains parameters of the ExecutionBrokerI.PrevExecutorPendingResult
type ExecutionBrokerIMockPrevExecutorPendingResultParams struct {
	ctx           context.Context
	prevExecState insolar.PendingState
}

// Expect sets up expected params for ExecutionBrokerI.PrevExecutorPendingResult
func (mmPrevExecutorPendingResult *mExecutionBrokerIMockPrevExecutorPendingResult) Expect(ctx context.Context, prevExecState insolar.PendingState) *mExecutionBrokerIMockPrevExecutorPendingResult {
	if mmPrevExecutorPendingResult.mock.funcPrevExecutorPendingResult != nil {
		mmPrevExecutorPendingResult.mock.t.Fatalf("ExecutionBrokerIMock.PrevExecutorPendingResult mock is already set by Set")
	}

	if mmPrevExecutorPendingResult.defaultExpectation == nil {
		mmPrevExecutorPendingResult.defaultExpectation = &ExecutionBrokerIMockPrevExecutorPendingResultExpectation{}
	}

	mmPrevExecutorPendingResult.defaultExpectation.params = &ExecutionBrokerIMockPrevExecutorPendingResultParams{ctx, prevExecState}
	for _, e := range mmPrevExecutorPendingResult.expectations {
		if minimock.Equal(e.params, mmPrevExecutorPendingResult.defaultExpectation.params) {
			mmPrevExecutorPendingResult.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrevExecutorPendingResult.defaultExpectation.params)
		}
	}

	return mmPrevExecutorPendingResult
}

// Inspect accepts an inspector function that has same arguments as the ExecutionBrokerI.PrevExecutorPendingResult
func (mmPrevExecutorPendingResult *mExecutionBrokerIMockPrevExecutorPendingResult) Inspect(f func(ctx context.Context, prevExecState insolar.PendingState)) *mExecutionBrokerIMockPrevExecutorPendingResult {
	if mmPrevExecutorPendingResult.mock.inspectFuncPrevExecutorPendingResult != nil {
		mmPrevExecutorPendingResult.mock.t.Fatalf("Inspect function is already set for ExecutionBrokerIMock.PrevExecutorPendingResult")
	}

	mmPrevExecutorPendingResult.mock.inspectFuncPrevExecutorPendingResult = f

	return mmPrevExecutorPendingResult
}

// Return sets up results that will be returned by ExecutionBrokerI.PrevExecutorPendingResult
func (mmPrevExecutorPendingResult *mExecutionBrokerIMockPrevExecutorPendingResult) Return() *ExecutionBrokerIMock {
	if mmPrevExecutorPendingResult.mock.funcPrevExecutorPendingResult != nil {
		mmPrevExecutorPendingResult.mock.t.Fatalf("ExecutionBrokerIMock.PrevExecutorPendingResult mock is already set by Set")
	}

	if mmPrevExecutorPendingResult.defaultExpectation == nil {
		mmPrevExecutorPendingResult.defaultExpectation = &ExecutionBrokerIMockPrevExecutorPendingResultExpectation{mock: mmPrevExecutorPendingResult.mock}
	}

	return mmPrevExecutorPendingResult.mock
}

//Set uses given function f to mock the ExecutionBrokerI.PrevExecutorPendingResult method
func (mmPrevExecutorPendingResult *mExecutionBrokerIMockPrevExecutorPendingResult) Set(f func(ctx context.Context, prevExecState insolar.PendingState)) *ExecutionBrokerIMock {
	if mmPrevExecutorPendingResult.defaultExpectation != nil {
		mmPrevExecutorPendingResult.mock.t.Fatalf("Default expectation is already set for the ExecutionBrokerI.PrevExecutorPendingResult method")
	}

	if len(mmPrevExecutorPendingResult.expectations) > 0 {
		mmPrevExecutorPendingResult.mock.t.Fatalf("Some expectations are already set for the ExecutionBrokerI.PrevExecutorPendingResult method")
	}

	mmPrevExecutorPendingResult.mock.funcPrevExecutorPendingResult = f
	return mmPrevExecutorPendingResult.mock
}

// PrevExecutorPendingResult implements ExecutionBrokerI
func (mmPrevExecutorPendingResult *ExecutionBrokerIMock) PrevExecutorPendingResult(ctx context.Context, prevExecState insolar.PendingState) {
	mm_atomic.AddUint64(&mmPrevExecutorPendingResult.beforePrevExecutorPendingResultCounter, 1)
	defer mm_atomic.AddUint64(&mmPrevExecutorPendingResult.afterPrevExecutorPendingResultCounter, 1)

	if mmPrevExecutorPendingResult.inspectFuncPrevExecutorPendingResult != nil {
		mmPrevExecutorPendingResult.inspectFuncPrevExecutorPendingResult(ctx, prevExecState)
	}

	params := &ExecutionBrokerIMockPrevExecutorPendingResultParams{ctx, prevExecState}

	// Record call args
	mmPrevExecutorPendingResult.PrevExecutorPendingResultMock.mutex.Lock()
	mmPrevExecutorPendingResult.PrevExecutorPendingResultMock.callArgs = append(mmPrevExecutorPendingResult.PrevExecutorPendingResultMock.callArgs, params)
	mmPrevExecutorPendingResult.PrevExecutorPendingResultMock.mutex.Unlock()

	for _, e := range mmPrevExecutorPendingResult.PrevExecutorPendingResultMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmPrevExecutorPendingResult.PrevExecutorPendingResultMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrevExecutorPendingResult.PrevExecutorPendingResultMock.defaultExpectation.Counter, 1)
		want := mmPrevExecutorPendingResult.PrevExecutorPendingResultMock.defaultExpectation.params
		got := ExecutionBrokerIMockPrevExecutorPendingResultParams{ctx, prevExecState}
		if want != nil && !minimock.Equal(*want, got) {
			mmPrevExecutorPendingResult.t.Errorf("ExecutionBrokerIMock.PrevExecutorPendingResult got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmPrevExecutorPendingResult.funcPrevExecutorPendingResult != nil {
		mmPrevExecutorPendingResult.funcPrevExecutorPendingResult(ctx, prevExecState)
		return
	}
	mmPrevExecutorPendingResult.t.Fatalf("Unexpected call to ExecutionBrokerIMock.PrevExecutorPendingResult. %v %v", ctx, prevExecState)

}

// PrevExecutorPendingResultAfterCounter returns a count of finished ExecutionBrokerIMock.PrevExecutorPendingResult invocations
func (mmPrevExecutorPendingResult *ExecutionBrokerIMock) PrevExecutorPendingResultAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrevExecutorPendingResult.afterPrevExecutorPendingResultCounter)
}

// PrevExecutorPendingResultBeforeCounter returns a count of ExecutionBrokerIMock.PrevExecutorPendingResult invocations
func (mmPrevExecutorPendingResult *ExecutionBrokerIMock) PrevExecutorPendingResultBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrevExecutorPendingResult.beforePrevExecutorPendingResultCounter)
}

// Calls returns a list of arguments used in each call to ExecutionBrokerIMock.PrevExecutorPendingResult.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrevExecutorPendingResult *mExecutionBrokerIMockPrevExecutorPendingResult) Calls() []*ExecutionBrokerIMockPrevExecutorPendingResultParams {
	mmPrevExecutorPendingResult.mutex.RLock()

	argCopy := make([]*ExecutionBrokerIMockPrevExecutorPendingResultParams, len(mmPrevExecutorPendingResult.callArgs))
	copy(argCopy, mmPrevExecutorPendingResult.callArgs)

	mmPrevExecutorPendingResult.mutex.RUnlock()

	return argCopy
}

// MinimockPrevExecutorPendingResultDone returns true if the count of the PrevExecutorPendingResult invocations corresponds
// the number of defined expectations
func (m *ExecutionBrokerIMock) MinimockPrevExecutorPendingResultDone() bool {
	for _, e := range m.PrevExecutorPendingResultMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrevExecutorPendingResultMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrevExecutorPendingResultCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrevExecutorPendingResult != nil && mm_atomic.LoadUint64(&m.afterPrevExecutorPendingResultCounter) < 1 {
		return false
	}
	return true
}

// MinimockPrevExecutorPendingResultInspect logs each unmet expectation
func (m *ExecutionBrokerIMock) MinimockPrevExecutorPendingResultInspect() {
	for _, e := range m.PrevExecutorPendingResultMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.PrevExecutorPendingResult with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrevExecutorPendingResultMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrevExecutorPendingResultCounter) < 1 {
		if m.PrevExecutorPendingResultMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionBrokerIMock.PrevExecutorPendingResult")
		} else {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.PrevExecutorPendingResult with params: %#v", *m.PrevExecutorPendingResultMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrevExecutorPendingResult != nil && mm_atomic.LoadUint64(&m.afterPrevExecutorPendingResultCounter) < 1 {
		m.t.Error("Expected call to ExecutionBrokerIMock.PrevExecutorPendingResult")
	}
}

type mExecutionBrokerIMockPrevExecutorSentPendingFinished struct {
	mock               *ExecutionBrokerIMock
	defaultExpectation *ExecutionBrokerIMockPrevExecutorSentPendingFinishedExpectation
	expectations       []*ExecutionBrokerIMockPrevExecutorSentPendingFinishedExpectation

	callArgs []*ExecutionBrokerIMockPrevExecutorSentPendingFinishedParams
	mutex    sync.RWMutex
}

// ExecutionBrokerIMockPrevExecutorSentPendingFinishedExpectation specifies expectation struct of the ExecutionBrokerI.PrevExecutorSentPendingFinished
type ExecutionBrokerIMockPrevExecutorSentPendingFinishedExpectation struct {
	mock    *ExecutionBrokerIMock
	params  *ExecutionBrokerIMockPrevExecutorSentPendingFinishedParams
	results *ExecutionBrokerIMockPrevExecutorSentPendingFinishedResults
	Counter uint64
}

// ExecutionBrokerIMockPrevExecutorSentPendingFinishedParams contains parameters of the ExecutionBrokerI.PrevExecutorSentPendingFinished
type ExecutionBrokerIMockPrevExecutorSentPendingFinishedParams struct {
	ctx context.Context
}

// ExecutionBrokerIMockPrevExecutorSentPendingFinishedResults contains results of the ExecutionBrokerI.PrevExecutorSentPendingFinished
type ExecutionBrokerIMockPrevExecutorSentPendingFinishedResults struct {
	err error
}

// Expect sets up expected params for ExecutionBrokerI.PrevExecutorSentPendingFinished
func (mmPrevExecutorSentPendingFinished *mExecutionBrokerIMockPrevExecutorSentPendingFinished) Expect(ctx context.Context) *mExecutionBrokerIMockPrevExecutorSentPendingFinished {
	if mmPrevExecutorSentPendingFinished.mock.funcPrevExecutorSentPendingFinished != nil {
		mmPrevExecutorSentPendingFinished.mock.t.Fatalf("ExecutionBrokerIMock.PrevExecutorSentPendingFinished mock is already set by Set")
	}

	if mmPrevExecutorSentPendingFinished.defaultExpectation == nil {
		mmPrevExecutorSentPendingFinished.defaultExpectation = &ExecutionBrokerIMockPrevExecutorSentPendingFinishedExpectation{}
	}

	mmPrevExecutorSentPendingFinished.defaultExpectation.params = &ExecutionBrokerIMockPrevExecutorSentPendingFinishedParams{ctx}
	for _, e := range mmPrevExecutorSentPendingFinished.expectations {
		if minimock.Equal(e.params, mmPrevExecutorSentPendingFinished.defaultExpectation.params) {
			mmPrevExecutorSentPendingFinished.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrevExecutorSentPendingFinished.defaultExpectation.params)
		}
	}

	return mmPrevExecutorSentPendingFinished
}

// Inspect accepts an inspector function that has same arguments as the ExecutionBrokerI.PrevExecutorSentPendingFinished
func (mmPrevExecutorSentPendingFinished *mExecutionBrokerIMockPrevExecutorSentPendingFinished) Inspect(f func(ctx context.Context)) *mExecutionBrokerIMockPrevExecutorSentPendingFinished {
	if mmPrevExecutorSentPendingFinished.mock.inspectFuncPrevExecutorSentPendingFinished != nil {
		mmPrevExecutorSentPendingFinished.mock.t.Fatalf("Inspect function is already set for ExecutionBrokerIMock.PrevExecutorSentPendingFinished")
	}

	mmPrevExecutorSentPendingFinished.mock.inspectFuncPrevExecutorSentPendingFinished = f

	return mmPrevExecutorSentPendingFinished
}

// Return sets up results that will be returned by ExecutionBrokerI.PrevExecutorSentPendingFinished
func (mmPrevExecutorSentPendingFinished *mExecutionBrokerIMockPrevExecutorSentPendingFinished) Return(err error) *ExecutionBrokerIMock {
	if mmPrevExecutorSentPendingFinished.mock.funcPrevExecutorSentPendingFinished != nil {
		mmPrevExecutorSentPendingFinished.mock.t.Fatalf("ExecutionBrokerIMock.PrevExecutorSentPendingFinished mock is already set by Set")
	}

	if mmPrevExecutorSentPendingFinished.defaultExpectation == nil {
		mmPrevExecutorSentPendingFinished.defaultExpectation = &ExecutionBrokerIMockPrevExecutorSentPendingFinishedExpectation{mock: mmPrevExecutorSentPendingFinished.mock}
	}
	mmPrevExecutorSentPendingFinished.defaultExpectation.results = &ExecutionBrokerIMockPrevExecutorSentPendingFinishedResults{err}
	return mmPrevExecutorSentPendingFinished.mock
}

//Set uses given function f to mock the ExecutionBrokerI.PrevExecutorSentPendingFinished method
func (mmPrevExecutorSentPendingFinished *mExecutionBrokerIMockPrevExecutorSentPendingFinished) Set(f func(ctx context.Context) (err error)) *ExecutionBrokerIMock {
	if mmPrevExecutorSentPendingFinished.defaultExpectation != nil {
		mmPrevExecutorSentPendingFinished.mock.t.Fatalf("Default expectation is already set for the ExecutionBrokerI.PrevExecutorSentPendingFinished method")
	}

	if len(mmPrevExecutorSentPendingFinished.expectations) > 0 {
		mmPrevExecutorSentPendingFinished.mock.t.Fatalf("Some expectations are already set for the ExecutionBrokerI.PrevExecutorSentPendingFinished method")
	}

	mmPrevExecutorSentPendingFinished.mock.funcPrevExecutorSentPendingFinished = f
	return mmPrevExecutorSentPendingFinished.mock
}

// When sets expectation for the ExecutionBrokerI.PrevExecutorSentPendingFinished which will trigger the result defined by the following
// Then helper
func (mmPrevExecutorSentPendingFinished *mExecutionBrokerIMockPrevExecutorSentPendingFinished) When(ctx context.Context) *ExecutionBrokerIMockPrevExecutorSentPendingFinishedExpectation {
	if mmPrevExecutorSentPendingFinished.mock.funcPrevExecutorSentPendingFinished != nil {
		mmPrevExecutorSentPendingFinished.mock.t.Fatalf("ExecutionBrokerIMock.PrevExecutorSentPendingFinished mock is already set by Set")
	}

	expectation := &ExecutionBrokerIMockPrevExecutorSentPendingFinishedExpectation{
		mock:   mmPrevExecutorSentPendingFinished.mock,
		params: &ExecutionBrokerIMockPrevExecutorSentPendingFinishedParams{ctx},
	}
	mmPrevExecutorSentPendingFinished.expectations = append(mmPrevExecutorSentPendingFinished.expectations, expectation)
	return expectation
}

// Then sets up ExecutionBrokerI.PrevExecutorSentPendingFinished return parameters for the expectation previously defined by the When method
func (e *ExecutionBrokerIMockPrevExecutorSentPendingFinishedExpectation) Then(err error) *ExecutionBrokerIMock {
	e.results = &ExecutionBrokerIMockPrevExecutorSentPendingFinishedResults{err}
	return e.mock
}

// PrevExecutorSentPendingFinished implements ExecutionBrokerI
func (mmPrevExecutorSentPendingFinished *ExecutionBrokerIMock) PrevExecutorSentPendingFinished(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmPrevExecutorSentPendingFinished.beforePrevExecutorSentPendingFinishedCounter, 1)
	defer mm_atomic.AddUint64(&mmPrevExecutorSentPendingFinished.afterPrevExecutorSentPendingFinishedCounter, 1)

	if mmPrevExecutorSentPendingFinished.inspectFuncPrevExecutorSentPendingFinished != nil {
		mmPrevExecutorSentPendingFinished.inspectFuncPrevExecutorSentPendingFinished(ctx)
	}

	params := &ExecutionBrokerIMockPrevExecutorSentPendingFinishedParams{ctx}

	// Record call args
	mmPrevExecutorSentPendingFinished.PrevExecutorSentPendingFinishedMock.mutex.Lock()
	mmPrevExecutorSentPendingFinished.PrevExecutorSentPendingFinishedMock.callArgs = append(mmPrevExecutorSentPendingFinished.PrevExecutorSentPendingFinishedMock.callArgs, params)
	mmPrevExecutorSentPendingFinished.PrevExecutorSentPendingFinishedMock.mutex.Unlock()

	for _, e := range mmPrevExecutorSentPendingFinished.PrevExecutorSentPendingFinishedMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPrevExecutorSentPendingFinished.PrevExecutorSentPendingFinishedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrevExecutorSentPendingFinished.PrevExecutorSentPendingFinishedMock.defaultExpectation.Counter, 1)
		want := mmPrevExecutorSentPendingFinished.PrevExecutorSentPendingFinishedMock.defaultExpectation.params
		got := ExecutionBrokerIMockPrevExecutorSentPendingFinishedParams{ctx}
		if want != nil && !minimock.Equal(*want, got) {
			mmPrevExecutorSentPendingFinished.t.Errorf("ExecutionBrokerIMock.PrevExecutorSentPendingFinished got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmPrevExecutorSentPendingFinished.PrevExecutorSentPendingFinishedMock.defaultExpectation.results
		if results == nil {
			mmPrevExecutorSentPendingFinished.t.Fatal("No results are set for the ExecutionBrokerIMock.PrevExecutorSentPendingFinished")
		}
		return (*results).err
	}
	if mmPrevExecutorSentPendingFinished.funcPrevExecutorSentPendingFinished != nil {
		return mmPrevExecutorSentPendingFinished.funcPrevExecutorSentPendingFinished(ctx)
	}
	mmPrevExecutorSentPendingFinished.t.Fatalf("Unexpected call to ExecutionBrokerIMock.PrevExecutorSentPendingFinished. %v", ctx)
	return
}

// PrevExecutorSentPendingFinishedAfterCounter returns a count of finished ExecutionBrokerIMock.PrevExecutorSentPendingFinished invocations
func (mmPrevExecutorSentPendingFinished *ExecutionBrokerIMock) PrevExecutorSentPendingFinishedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrevExecutorSentPendingFinished.afterPrevExecutorSentPendingFinishedCounter)
}

// PrevExecutorSentPendingFinishedBeforeCounter returns a count of ExecutionBrokerIMock.PrevExecutorSentPendingFinished invocations
func (mmPrevExecutorSentPendingFinished *ExecutionBrokerIMock) PrevExecutorSentPendingFinishedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrevExecutorSentPendingFinished.beforePrevExecutorSentPendingFinishedCounter)
}

// Calls returns a list of arguments used in each call to ExecutionBrokerIMock.PrevExecutorSentPendingFinished.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrevExecutorSentPendingFinished *mExecutionBrokerIMockPrevExecutorSentPendingFinished) Calls() []*ExecutionBrokerIMockPrevExecutorSentPendingFinishedParams {
	mmPrevExecutorSentPendingFinished.mutex.RLock()

	argCopy := make([]*ExecutionBrokerIMockPrevExecutorSentPendingFinishedParams, len(mmPrevExecutorSentPendingFinished.callArgs))
	copy(argCopy, mmPrevExecutorSentPendingFinished.callArgs)

	mmPrevExecutorSentPendingFinished.mutex.RUnlock()

	return argCopy
}

// MinimockPrevExecutorSentPendingFinishedDone returns true if the count of the PrevExecutorSentPendingFinished invocations corresponds
// the number of defined expectations
func (m *ExecutionBrokerIMock) MinimockPrevExecutorSentPendingFinishedDone() bool {
	for _, e := range m.PrevExecutorSentPendingFinishedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrevExecutorSentPendingFinishedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrevExecutorSentPendingFinishedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrevExecutorSentPendingFinished != nil && mm_atomic.LoadUint64(&m.afterPrevExecutorSentPendingFinishedCounter) < 1 {
		return false
	}
	return true
}

// MinimockPrevExecutorSentPendingFinishedInspect logs each unmet expectation
func (m *ExecutionBrokerIMock) MinimockPrevExecutorSentPendingFinishedInspect() {
	for _, e := range m.PrevExecutorSentPendingFinishedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.PrevExecutorSentPendingFinished with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrevExecutorSentPendingFinishedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrevExecutorSentPendingFinishedCounter) < 1 {
		if m.PrevExecutorSentPendingFinishedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionBrokerIMock.PrevExecutorSentPendingFinished")
		} else {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.PrevExecutorSentPendingFinished with params: %#v", *m.PrevExecutorSentPendingFinishedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrevExecutorSentPendingFinished != nil && mm_atomic.LoadUint64(&m.afterPrevExecutorSentPendingFinishedCounter) < 1 {
		m.t.Error("Expected call to ExecutionBrokerIMock.PrevExecutorSentPendingFinished")
	}
}

type mExecutionBrokerIMockPrevExecutorStillExecuting struct {
	mock               *ExecutionBrokerIMock
	defaultExpectation *ExecutionBrokerIMockPrevExecutorStillExecutingExpectation
	expectations       []*ExecutionBrokerIMockPrevExecutorStillExecutingExpectation

	callArgs []*ExecutionBrokerIMockPrevExecutorStillExecutingParams
	mutex    sync.RWMutex
}

// ExecutionBrokerIMockPrevExecutorStillExecutingExpectation specifies expectation struct of the ExecutionBrokerI.PrevExecutorStillExecuting
type ExecutionBrokerIMockPrevExecutorStillExecutingExpectation struct {
	mock   *ExecutionBrokerIMock
	params *ExecutionBrokerIMockPrevExecutorStillExecutingParams

	Counter uint64
}

// ExecutionBrokerIMockPrevExecutorStillExecutingParams contains parameters of the ExecutionBrokerI.PrevExecutorStillExecuting
type ExecutionBrokerIMockPrevExecutorStillExecutingParams struct {
	ctx context.Context
}

// Expect sets up expected params for ExecutionBrokerI.PrevExecutorStillExecuting
func (mmPrevExecutorStillExecuting *mExecutionBrokerIMockPrevExecutorStillExecuting) Expect(ctx context.Context) *mExecutionBrokerIMockPrevExecutorStillExecuting {
	if mmPrevExecutorStillExecuting.mock.funcPrevExecutorStillExecuting != nil {
		mmPrevExecutorStillExecuting.mock.t.Fatalf("ExecutionBrokerIMock.PrevExecutorStillExecuting mock is already set by Set")
	}

	if mmPrevExecutorStillExecuting.defaultExpectation == nil {
		mmPrevExecutorStillExecuting.defaultExpectation = &ExecutionBrokerIMockPrevExecutorStillExecutingExpectation{}
	}

	mmPrevExecutorStillExecuting.defaultExpectation.params = &ExecutionBrokerIMockPrevExecutorStillExecutingParams{ctx}
	for _, e := range mmPrevExecutorStillExecuting.expectations {
		if minimock.Equal(e.params, mmPrevExecutorStillExecuting.defaultExpectation.params) {
			mmPrevExecutorStillExecuting.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrevExecutorStillExecuting.defaultExpectation.params)
		}
	}

	return mmPrevExecutorStillExecuting
}

// Inspect accepts an inspector function that has same arguments as the ExecutionBrokerI.PrevExecutorStillExecuting
func (mmPrevExecutorStillExecuting *mExecutionBrokerIMockPrevExecutorStillExecuting) Inspect(f func(ctx context.Context)) *mExecutionBrokerIMockPrevExecutorStillExecuting {
	if mmPrevExecutorStillExecuting.mock.inspectFuncPrevExecutorStillExecuting != nil {
		mmPrevExecutorStillExecuting.mock.t.Fatalf("Inspect function is already set for ExecutionBrokerIMock.PrevExecutorStillExecuting")
	}

	mmPrevExecutorStillExecuting.mock.inspectFuncPrevExecutorStillExecuting = f

	return mmPrevExecutorStillExecuting
}

// Return sets up results that will be returned by ExecutionBrokerI.PrevExecutorStillExecuting
func (mmPrevExecutorStillExecuting *mExecutionBrokerIMockPrevExecutorStillExecuting) Return() *ExecutionBrokerIMock {
	if mmPrevExecutorStillExecuting.mock.funcPrevExecutorStillExecuting != nil {
		mmPrevExecutorStillExecuting.mock.t.Fatalf("ExecutionBrokerIMock.PrevExecutorStillExecuting mock is already set by Set")
	}

	if mmPrevExecutorStillExecuting.defaultExpectation == nil {
		mmPrevExecutorStillExecuting.defaultExpectation = &ExecutionBrokerIMockPrevExecutorStillExecutingExpectation{mock: mmPrevExecutorStillExecuting.mock}
	}

	return mmPrevExecutorStillExecuting.mock
}

//Set uses given function f to mock the ExecutionBrokerI.PrevExecutorStillExecuting method
func (mmPrevExecutorStillExecuting *mExecutionBrokerIMockPrevExecutorStillExecuting) Set(f func(ctx context.Context)) *ExecutionBrokerIMock {
	if mmPrevExecutorStillExecuting.defaultExpectation != nil {
		mmPrevExecutorStillExecuting.mock.t.Fatalf("Default expectation is already set for the ExecutionBrokerI.PrevExecutorStillExecuting method")
	}

	if len(mmPrevExecutorStillExecuting.expectations) > 0 {
		mmPrevExecutorStillExecuting.mock.t.Fatalf("Some expectations are already set for the ExecutionBrokerI.PrevExecutorStillExecuting method")
	}

	mmPrevExecutorStillExecuting.mock.funcPrevExecutorStillExecuting = f
	return mmPrevExecutorStillExecuting.mock
}

// PrevExecutorStillExecuting implements ExecutionBrokerI
func (mmPrevExecutorStillExecuting *ExecutionBrokerIMock) PrevExecutorStillExecuting(ctx context.Context) {
	mm_atomic.AddUint64(&mmPrevExecutorStillExecuting.beforePrevExecutorStillExecutingCounter, 1)
	defer mm_atomic.AddUint64(&mmPrevExecutorStillExecuting.afterPrevExecutorStillExecutingCounter, 1)

	if mmPrevExecutorStillExecuting.inspectFuncPrevExecutorStillExecuting != nil {
		mmPrevExecutorStillExecuting.inspectFuncPrevExecutorStillExecuting(ctx)
	}

	params := &ExecutionBrokerIMockPrevExecutorStillExecutingParams{ctx}

	// Record call args
	mmPrevExecutorStillExecuting.PrevExecutorStillExecutingMock.mutex.Lock()
	mmPrevExecutorStillExecuting.PrevExecutorStillExecutingMock.callArgs = append(mmPrevExecutorStillExecuting.PrevExecutorStillExecutingMock.callArgs, params)
	mmPrevExecutorStillExecuting.PrevExecutorStillExecutingMock.mutex.Unlock()

	for _, e := range mmPrevExecutorStillExecuting.PrevExecutorStillExecutingMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmPrevExecutorStillExecuting.PrevExecutorStillExecutingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrevExecutorStillExecuting.PrevExecutorStillExecutingMock.defaultExpectation.Counter, 1)
		want := mmPrevExecutorStillExecuting.PrevExecutorStillExecutingMock.defaultExpectation.params
		got := ExecutionBrokerIMockPrevExecutorStillExecutingParams{ctx}
		if want != nil && !minimock.Equal(*want, got) {
			mmPrevExecutorStillExecuting.t.Errorf("ExecutionBrokerIMock.PrevExecutorStillExecuting got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmPrevExecutorStillExecuting.funcPrevExecutorStillExecuting != nil {
		mmPrevExecutorStillExecuting.funcPrevExecutorStillExecuting(ctx)
		return
	}
	mmPrevExecutorStillExecuting.t.Fatalf("Unexpected call to ExecutionBrokerIMock.PrevExecutorStillExecuting. %v", ctx)

}

// PrevExecutorStillExecutingAfterCounter returns a count of finished ExecutionBrokerIMock.PrevExecutorStillExecuting invocations
func (mmPrevExecutorStillExecuting *ExecutionBrokerIMock) PrevExecutorStillExecutingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrevExecutorStillExecuting.afterPrevExecutorStillExecutingCounter)
}

// PrevExecutorStillExecutingBeforeCounter returns a count of ExecutionBrokerIMock.PrevExecutorStillExecuting invocations
func (mmPrevExecutorStillExecuting *ExecutionBrokerIMock) PrevExecutorStillExecutingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrevExecutorStillExecuting.beforePrevExecutorStillExecutingCounter)
}

// Calls returns a list of arguments used in each call to ExecutionBrokerIMock.PrevExecutorStillExecuting.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrevExecutorStillExecuting *mExecutionBrokerIMockPrevExecutorStillExecuting) Calls() []*ExecutionBrokerIMockPrevExecutorStillExecutingParams {
	mmPrevExecutorStillExecuting.mutex.RLock()

	argCopy := make([]*ExecutionBrokerIMockPrevExecutorStillExecutingParams, len(mmPrevExecutorStillExecuting.callArgs))
	copy(argCopy, mmPrevExecutorStillExecuting.callArgs)

	mmPrevExecutorStillExecuting.mutex.RUnlock()

	return argCopy
}

// MinimockPrevExecutorStillExecutingDone returns true if the count of the PrevExecutorStillExecuting invocations corresponds
// the number of defined expectations
func (m *ExecutionBrokerIMock) MinimockPrevExecutorStillExecutingDone() bool {
	for _, e := range m.PrevExecutorStillExecutingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrevExecutorStillExecutingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrevExecutorStillExecutingCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrevExecutorStillExecuting != nil && mm_atomic.LoadUint64(&m.afterPrevExecutorStillExecutingCounter) < 1 {
		return false
	}
	return true
}

// MinimockPrevExecutorStillExecutingInspect logs each unmet expectation
func (m *ExecutionBrokerIMock) MinimockPrevExecutorStillExecutingInspect() {
	for _, e := range m.PrevExecutorStillExecutingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.PrevExecutorStillExecuting with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrevExecutorStillExecutingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrevExecutorStillExecutingCounter) < 1 {
		if m.PrevExecutorStillExecutingMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionBrokerIMock.PrevExecutorStillExecuting")
		} else {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.PrevExecutorStillExecuting with params: %#v", *m.PrevExecutorStillExecutingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrevExecutorStillExecuting != nil && mm_atomic.LoadUint64(&m.afterPrevExecutorStillExecutingCounter) < 1 {
		m.t.Error("Expected call to ExecutionBrokerIMock.PrevExecutorStillExecuting")
	}
}

type mExecutionBrokerIMockSetNotPending struct {
	mock               *ExecutionBrokerIMock
	defaultExpectation *ExecutionBrokerIMockSetNotPendingExpectation
	expectations       []*ExecutionBrokerIMockSetNotPendingExpectation

	callArgs []*ExecutionBrokerIMockSetNotPendingParams
	mutex    sync.RWMutex
}

// ExecutionBrokerIMockSetNotPendingExpectation specifies expectation struct of the ExecutionBrokerI.SetNotPending
type ExecutionBrokerIMockSetNotPendingExpectation struct {
	mock   *ExecutionBrokerIMock
	params *ExecutionBrokerIMockSetNotPendingParams

	Counter uint64
}

// ExecutionBrokerIMockSetNotPendingParams contains parameters of the ExecutionBrokerI.SetNotPending
type ExecutionBrokerIMockSetNotPendingParams struct {
	ctx context.Context
}

// Expect sets up expected params for ExecutionBrokerI.SetNotPending
func (mmSetNotPending *mExecutionBrokerIMockSetNotPending) Expect(ctx context.Context) *mExecutionBrokerIMockSetNotPending {
	if mmSetNotPending.mock.funcSetNotPending != nil {
		mmSetNotPending.mock.t.Fatalf("ExecutionBrokerIMock.SetNotPending mock is already set by Set")
	}

	if mmSetNotPending.defaultExpectation == nil {
		mmSetNotPending.defaultExpectation = &ExecutionBrokerIMockSetNotPendingExpectation{}
	}

	mmSetNotPending.defaultExpectation.params = &ExecutionBrokerIMockSetNotPendingParams{ctx}
	for _, e := range mmSetNotPending.expectations {
		if minimock.Equal(e.params, mmSetNotPending.defaultExpectation.params) {
			mmSetNotPending.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetNotPending.defaultExpectation.params)
		}
	}

	return mmSetNotPending
}

// Inspect accepts an inspector function that has same arguments as the ExecutionBrokerI.SetNotPending
func (mmSetNotPending *mExecutionBrokerIMockSetNotPending) Inspect(f func(ctx context.Context)) *mExecutionBrokerIMockSetNotPending {
	if mmSetNotPending.mock.inspectFuncSetNotPending != nil {
		mmSetNotPending.mock.t.Fatalf("Inspect function is already set for ExecutionBrokerIMock.SetNotPending")
	}

	mmSetNotPending.mock.inspectFuncSetNotPending = f

	return mmSetNotPending
}

// Return sets up results that will be returned by ExecutionBrokerI.SetNotPending
func (mmSetNotPending *mExecutionBrokerIMockSetNotPending) Return() *ExecutionBrokerIMock {
	if mmSetNotPending.mock.funcSetNotPending != nil {
		mmSetNotPending.mock.t.Fatalf("ExecutionBrokerIMock.SetNotPending mock is already set by Set")
	}

	if mmSetNotPending.defaultExpectation == nil {
		mmSetNotPending.defaultExpectation = &ExecutionBrokerIMockSetNotPendingExpectation{mock: mmSetNotPending.mock}
	}

	return mmSetNotPending.mock
}

//Set uses given function f to mock the ExecutionBrokerI.SetNotPending method
func (mmSetNotPending *mExecutionBrokerIMockSetNotPending) Set(f func(ctx context.Context)) *ExecutionBrokerIMock {
	if mmSetNotPending.defaultExpectation != nil {
		mmSetNotPending.mock.t.Fatalf("Default expectation is already set for the ExecutionBrokerI.SetNotPending method")
	}

	if len(mmSetNotPending.expectations) > 0 {
		mmSetNotPending.mock.t.Fatalf("Some expectations are already set for the ExecutionBrokerI.SetNotPending method")
	}

	mmSetNotPending.mock.funcSetNotPending = f
	return mmSetNotPending.mock
}

// SetNotPending implements ExecutionBrokerI
func (mmSetNotPending *ExecutionBrokerIMock) SetNotPending(ctx context.Context) {
	mm_atomic.AddUint64(&mmSetNotPending.beforeSetNotPendingCounter, 1)
	defer mm_atomic.AddUint64(&mmSetNotPending.afterSetNotPendingCounter, 1)

	if mmSetNotPending.inspectFuncSetNotPending != nil {
		mmSetNotPending.inspectFuncSetNotPending(ctx)
	}

	params := &ExecutionBrokerIMockSetNotPendingParams{ctx}

	// Record call args
	mmSetNotPending.SetNotPendingMock.mutex.Lock()
	mmSetNotPending.SetNotPendingMock.callArgs = append(mmSetNotPending.SetNotPendingMock.callArgs, params)
	mmSetNotPending.SetNotPendingMock.mutex.Unlock()

	for _, e := range mmSetNotPending.SetNotPendingMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetNotPending.SetNotPendingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetNotPending.SetNotPendingMock.defaultExpectation.Counter, 1)
		want := mmSetNotPending.SetNotPendingMock.defaultExpectation.params
		got := ExecutionBrokerIMockSetNotPendingParams{ctx}
		if want != nil && !minimock.Equal(*want, got) {
			mmSetNotPending.t.Errorf("ExecutionBrokerIMock.SetNotPending got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmSetNotPending.funcSetNotPending != nil {
		mmSetNotPending.funcSetNotPending(ctx)
		return
	}
	mmSetNotPending.t.Fatalf("Unexpected call to ExecutionBrokerIMock.SetNotPending. %v", ctx)

}

// SetNotPendingAfterCounter returns a count of finished ExecutionBrokerIMock.SetNotPending invocations
func (mmSetNotPending *ExecutionBrokerIMock) SetNotPendingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetNotPending.afterSetNotPendingCounter)
}

// SetNotPendingBeforeCounter returns a count of ExecutionBrokerIMock.SetNotPending invocations
func (mmSetNotPending *ExecutionBrokerIMock) SetNotPendingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetNotPending.beforeSetNotPendingCounter)
}

// Calls returns a list of arguments used in each call to ExecutionBrokerIMock.SetNotPending.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetNotPending *mExecutionBrokerIMockSetNotPending) Calls() []*ExecutionBrokerIMockSetNotPendingParams {
	mmSetNotPending.mutex.RLock()

	argCopy := make([]*ExecutionBrokerIMockSetNotPendingParams, len(mmSetNotPending.callArgs))
	copy(argCopy, mmSetNotPending.callArgs)

	mmSetNotPending.mutex.RUnlock()

	return argCopy
}

// MinimockSetNotPendingDone returns true if the count of the SetNotPending invocations corresponds
// the number of defined expectations
func (m *ExecutionBrokerIMock) MinimockSetNotPendingDone() bool {
	for _, e := range m.SetNotPendingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetNotPendingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetNotPendingCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetNotPending != nil && mm_atomic.LoadUint64(&m.afterSetNotPendingCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetNotPendingInspect logs each unmet expectation
func (m *ExecutionBrokerIMock) MinimockSetNotPendingInspect() {
	for _, e := range m.SetNotPendingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.SetNotPending with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetNotPendingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetNotPendingCounter) < 1 {
		if m.SetNotPendingMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionBrokerIMock.SetNotPending")
		} else {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.SetNotPending with params: %#v", *m.SetNotPendingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetNotPending != nil && mm_atomic.LoadUint64(&m.afterSetNotPendingCounter) < 1 {
		m.t.Error("Expected call to ExecutionBrokerIMock.SetNotPending")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ExecutionBrokerIMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAbandonedRequestsOnLedgerInspect()

		m.MinimockAddAdditionalRequestFromPrevExecutorInspect()

		m.MinimockAddFreshRequestInspect()

		m.MinimockAddRequestsFromLedgerInspect()

		m.MinimockAddRequestsFromPrevExecutorInspect()

		m.MinimockIsKnownRequestInspect()

		m.MinimockMoreRequestsOnLedgerInspect()

		m.MinimockNoMoreRequestsOnLedgerInspect()

		m.MinimockOnPulseInspect()

		m.MinimockPendingStateInspect()

		m.MinimockPrevExecutorPendingResultInspect()

		m.MinimockPrevExecutorSentPendingFinishedInspect()

		m.MinimockPrevExecutorStillExecutingInspect()

		m.MinimockSetNotPendingInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ExecutionBrokerIMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ExecutionBrokerIMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAbandonedRequestsOnLedgerDone() &&
		m.MinimockAddAdditionalRequestFromPrevExecutorDone() &&
		m.MinimockAddFreshRequestDone() &&
		m.MinimockAddRequestsFromLedgerDone() &&
		m.MinimockAddRequestsFromPrevExecutorDone() &&
		m.MinimockIsKnownRequestDone() &&
		m.MinimockMoreRequestsOnLedgerDone() &&
		m.MinimockNoMoreRequestsOnLedgerDone() &&
		m.MinimockOnPulseDone() &&
		m.MinimockPendingStateDone() &&
		m.MinimockPrevExecutorPendingResultDone() &&
		m.MinimockPrevExecutorSentPendingFinishedDone() &&
		m.MinimockPrevExecutorStillExecutingDone() &&
		m.MinimockSetNotPendingDone()
}
