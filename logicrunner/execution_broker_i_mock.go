package logicrunner

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/insolar/insolar"
	"github.com/insolar/insolar/insolar/payload"
)

// ExecutionBrokerIMock implements ExecutionBrokerI
type ExecutionBrokerIMock struct {
	t minimock.Tester

	funcAbandonedRequestsOnLedger          func(ctx context.Context)
	inspectFuncAbandonedRequestsOnLedger   func(ctx context.Context)
	afterAbandonedRequestsOnLedgerCounter  uint64
	beforeAbandonedRequestsOnLedgerCounter uint64
	AbandonedRequestsOnLedgerMock          mExecutionBrokerIMockAbandonedRequestsOnLedger

	funcHasMoreRequests          func(ctx context.Context)
	inspectFuncHasMoreRequests   func(ctx context.Context)
	afterHasMoreRequestsCounter  uint64
	beforeHasMoreRequestsCounter uint64
	HasMoreRequestsMock          mExecutionBrokerIMockHasMoreRequests

	funcOnPulse          func(ctx context.Context) (pa1 []payload.Payload)
	inspectFuncOnPulse   func(ctx context.Context)
	afterOnPulseCounter  uint64
	beforeOnPulseCounter uint64
	OnPulseMock          mExecutionBrokerIMockOnPulse

	funcPendingState          func() (p1 insolar.PendingState)
	inspectFuncPendingState   func()
	afterPendingStateCounter  uint64
	beforePendingStateCounter uint64
	PendingStateMock          mExecutionBrokerIMockPendingState

	funcPrevExecutorPendingResult          func(ctx context.Context, prevExecState insolar.PendingState)
	inspectFuncPrevExecutorPendingResult   func(ctx context.Context, prevExecState insolar.PendingState)
	afterPrevExecutorPendingResultCounter  uint64
	beforePrevExecutorPendingResultCounter uint64
	PrevExecutorPendingResultMock          mExecutionBrokerIMockPrevExecutorPendingResult

	funcPrevExecutorSentPendingFinished          func(ctx context.Context) (err error)
	inspectFuncPrevExecutorSentPendingFinished   func(ctx context.Context)
	afterPrevExecutorSentPendingFinishedCounter  uint64
	beforePrevExecutorSentPendingFinishedCounter uint64
	PrevExecutorSentPendingFinishedMock          mExecutionBrokerIMockPrevExecutorSentPendingFinished

	funcPrevExecutorStillExecuting          func(ctx context.Context) (err error)
	inspectFuncPrevExecutorStillExecuting   func(ctx context.Context)
	afterPrevExecutorStillExecutingCounter  uint64
	beforePrevExecutorStillExecutingCounter uint64
	PrevExecutorStillExecutingMock          mExecutionBrokerIMockPrevExecutorStillExecuting

	funcSetNotPending          func(ctx context.Context)
	inspectFuncSetNotPending   func(ctx context.Context)
	afterSetNotPendingCounter  uint64
	beforeSetNotPendingCounter uint64
	SetNotPendingMock          mExecutionBrokerIMockSetNotPending
}

// NewExecutionBrokerIMock returns a mock for ExecutionBrokerI
func NewExecutionBrokerIMock(t minimock.Tester) *ExecutionBrokerIMock {
	m := &ExecutionBrokerIMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AbandonedRequestsOnLedgerMock = mExecutionBrokerIMockAbandonedRequestsOnLedger{mock: m}
	m.AbandonedRequestsOnLedgerMock.callArgs = []*ExecutionBrokerIMockAbandonedRequestsOnLedgerParams{}

	m.HasMoreRequestsMock = mExecutionBrokerIMockHasMoreRequests{mock: m}
	m.HasMoreRequestsMock.callArgs = []*ExecutionBrokerIMockHasMoreRequestsParams{}

	m.OnPulseMock = mExecutionBrokerIMockOnPulse{mock: m}
	m.OnPulseMock.callArgs = []*ExecutionBrokerIMockOnPulseParams{}

	m.PendingStateMock = mExecutionBrokerIMockPendingState{mock: m}

	m.PrevExecutorPendingResultMock = mExecutionBrokerIMockPrevExecutorPendingResult{mock: m}
	m.PrevExecutorPendingResultMock.callArgs = []*ExecutionBrokerIMockPrevExecutorPendingResultParams{}

	m.PrevExecutorSentPendingFinishedMock = mExecutionBrokerIMockPrevExecutorSentPendingFinished{mock: m}
	m.PrevExecutorSentPendingFinishedMock.callArgs = []*ExecutionBrokerIMockPrevExecutorSentPendingFinishedParams{}

	m.PrevExecutorStillExecutingMock = mExecutionBrokerIMockPrevExecutorStillExecuting{mock: m}
	m.PrevExecutorStillExecutingMock.callArgs = []*ExecutionBrokerIMockPrevExecutorStillExecutingParams{}

	m.SetNotPendingMock = mExecutionBrokerIMockSetNotPending{mock: m}
	m.SetNotPendingMock.callArgs = []*ExecutionBrokerIMockSetNotPendingParams{}

	return m
}

type mExecutionBrokerIMockAbandonedRequestsOnLedger struct {
	mock               *ExecutionBrokerIMock
	defaultExpectation *ExecutionBrokerIMockAbandonedRequestsOnLedgerExpectation
	expectations       []*ExecutionBrokerIMockAbandonedRequestsOnLedgerExpectation

	callArgs []*ExecutionBrokerIMockAbandonedRequestsOnLedgerParams
	mutex    sync.RWMutex
}

// ExecutionBrokerIMockAbandonedRequestsOnLedgerExpectation specifies expectation struct of the ExecutionBrokerI.AbandonedRequestsOnLedger
type ExecutionBrokerIMockAbandonedRequestsOnLedgerExpectation struct {
	mock   *ExecutionBrokerIMock
	params *ExecutionBrokerIMockAbandonedRequestsOnLedgerParams

	Counter uint64
}

// ExecutionBrokerIMockAbandonedRequestsOnLedgerParams contains parameters of the ExecutionBrokerI.AbandonedRequestsOnLedger
type ExecutionBrokerIMockAbandonedRequestsOnLedgerParams struct {
	ctx context.Context
}

// Expect sets up expected params for ExecutionBrokerI.AbandonedRequestsOnLedger
func (mmAbandonedRequestsOnLedger *mExecutionBrokerIMockAbandonedRequestsOnLedger) Expect(ctx context.Context) *mExecutionBrokerIMockAbandonedRequestsOnLedger {
	if mmAbandonedRequestsOnLedger.mock.funcAbandonedRequestsOnLedger != nil {
		mmAbandonedRequestsOnLedger.mock.t.Fatalf("ExecutionBrokerIMock.AbandonedRequestsOnLedger mock is already set by Set")
	}

	if mmAbandonedRequestsOnLedger.defaultExpectation == nil {
		mmAbandonedRequestsOnLedger.defaultExpectation = &ExecutionBrokerIMockAbandonedRequestsOnLedgerExpectation{}
	}

	mmAbandonedRequestsOnLedger.defaultExpectation.params = &ExecutionBrokerIMockAbandonedRequestsOnLedgerParams{ctx}
	for _, e := range mmAbandonedRequestsOnLedger.expectations {
		if minimock.Equal(e.params, mmAbandonedRequestsOnLedger.defaultExpectation.params) {
			mmAbandonedRequestsOnLedger.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAbandonedRequestsOnLedger.defaultExpectation.params)
		}
	}

	return mmAbandonedRequestsOnLedger
}

// Inspect accepts an inspector function that has same arguments as the ExecutionBrokerI.AbandonedRequestsOnLedger
func (mmAbandonedRequestsOnLedger *mExecutionBrokerIMockAbandonedRequestsOnLedger) Inspect(f func(ctx context.Context)) *mExecutionBrokerIMockAbandonedRequestsOnLedger {
	if mmAbandonedRequestsOnLedger.mock.inspectFuncAbandonedRequestsOnLedger != nil {
		mmAbandonedRequestsOnLedger.mock.t.Fatalf("Inspect function is already set for ExecutionBrokerIMock.AbandonedRequestsOnLedger")
	}

	mmAbandonedRequestsOnLedger.mock.inspectFuncAbandonedRequestsOnLedger = f

	return mmAbandonedRequestsOnLedger
}

// Return sets up results that will be returned by ExecutionBrokerI.AbandonedRequestsOnLedger
func (mmAbandonedRequestsOnLedger *mExecutionBrokerIMockAbandonedRequestsOnLedger) Return() *ExecutionBrokerIMock {
	if mmAbandonedRequestsOnLedger.mock.funcAbandonedRequestsOnLedger != nil {
		mmAbandonedRequestsOnLedger.mock.t.Fatalf("ExecutionBrokerIMock.AbandonedRequestsOnLedger mock is already set by Set")
	}

	if mmAbandonedRequestsOnLedger.defaultExpectation == nil {
		mmAbandonedRequestsOnLedger.defaultExpectation = &ExecutionBrokerIMockAbandonedRequestsOnLedgerExpectation{mock: mmAbandonedRequestsOnLedger.mock}
	}

	return mmAbandonedRequestsOnLedger.mock
}

//Set uses given function f to mock the ExecutionBrokerI.AbandonedRequestsOnLedger method
func (mmAbandonedRequestsOnLedger *mExecutionBrokerIMockAbandonedRequestsOnLedger) Set(f func(ctx context.Context)) *ExecutionBrokerIMock {
	if mmAbandonedRequestsOnLedger.defaultExpectation != nil {
		mmAbandonedRequestsOnLedger.mock.t.Fatalf("Default expectation is already set for the ExecutionBrokerI.AbandonedRequestsOnLedger method")
	}

	if len(mmAbandonedRequestsOnLedger.expectations) > 0 {
		mmAbandonedRequestsOnLedger.mock.t.Fatalf("Some expectations are already set for the ExecutionBrokerI.AbandonedRequestsOnLedger method")
	}

	mmAbandonedRequestsOnLedger.mock.funcAbandonedRequestsOnLedger = f
	return mmAbandonedRequestsOnLedger.mock
}

// AbandonedRequestsOnLedger implements ExecutionBrokerI
func (mmAbandonedRequestsOnLedger *ExecutionBrokerIMock) AbandonedRequestsOnLedger(ctx context.Context) {
	mm_atomic.AddUint64(&mmAbandonedRequestsOnLedger.beforeAbandonedRequestsOnLedgerCounter, 1)
	defer mm_atomic.AddUint64(&mmAbandonedRequestsOnLedger.afterAbandonedRequestsOnLedgerCounter, 1)

	if mmAbandonedRequestsOnLedger.inspectFuncAbandonedRequestsOnLedger != nil {
		mmAbandonedRequestsOnLedger.inspectFuncAbandonedRequestsOnLedger(ctx)
	}

	mm_params := &ExecutionBrokerIMockAbandonedRequestsOnLedgerParams{ctx}

	// Record call args
	mmAbandonedRequestsOnLedger.AbandonedRequestsOnLedgerMock.mutex.Lock()
	mmAbandonedRequestsOnLedger.AbandonedRequestsOnLedgerMock.callArgs = append(mmAbandonedRequestsOnLedger.AbandonedRequestsOnLedgerMock.callArgs, mm_params)
	mmAbandonedRequestsOnLedger.AbandonedRequestsOnLedgerMock.mutex.Unlock()

	for _, e := range mmAbandonedRequestsOnLedger.AbandonedRequestsOnLedgerMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAbandonedRequestsOnLedger.AbandonedRequestsOnLedgerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAbandonedRequestsOnLedger.AbandonedRequestsOnLedgerMock.defaultExpectation.Counter, 1)
		mm_want := mmAbandonedRequestsOnLedger.AbandonedRequestsOnLedgerMock.defaultExpectation.params
		mm_got := ExecutionBrokerIMockAbandonedRequestsOnLedgerParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAbandonedRequestsOnLedger.t.Errorf("ExecutionBrokerIMock.AbandonedRequestsOnLedger got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAbandonedRequestsOnLedger.funcAbandonedRequestsOnLedger != nil {
		mmAbandonedRequestsOnLedger.funcAbandonedRequestsOnLedger(ctx)
		return
	}
	mmAbandonedRequestsOnLedger.t.Fatalf("Unexpected call to ExecutionBrokerIMock.AbandonedRequestsOnLedger. %v", ctx)

}

// AbandonedRequestsOnLedgerAfterCounter returns a count of finished ExecutionBrokerIMock.AbandonedRequestsOnLedger invocations
func (mmAbandonedRequestsOnLedger *ExecutionBrokerIMock) AbandonedRequestsOnLedgerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAbandonedRequestsOnLedger.afterAbandonedRequestsOnLedgerCounter)
}

// AbandonedRequestsOnLedgerBeforeCounter returns a count of ExecutionBrokerIMock.AbandonedRequestsOnLedger invocations
func (mmAbandonedRequestsOnLedger *ExecutionBrokerIMock) AbandonedRequestsOnLedgerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAbandonedRequestsOnLedger.beforeAbandonedRequestsOnLedgerCounter)
}

// Calls returns a list of arguments used in each call to ExecutionBrokerIMock.AbandonedRequestsOnLedger.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAbandonedRequestsOnLedger *mExecutionBrokerIMockAbandonedRequestsOnLedger) Calls() []*ExecutionBrokerIMockAbandonedRequestsOnLedgerParams {
	mmAbandonedRequestsOnLedger.mutex.RLock()

	argCopy := make([]*ExecutionBrokerIMockAbandonedRequestsOnLedgerParams, len(mmAbandonedRequestsOnLedger.callArgs))
	copy(argCopy, mmAbandonedRequestsOnLedger.callArgs)

	mmAbandonedRequestsOnLedger.mutex.RUnlock()

	return argCopy
}

// MinimockAbandonedRequestsOnLedgerDone returns true if the count of the AbandonedRequestsOnLedger invocations corresponds
// the number of defined expectations
func (m *ExecutionBrokerIMock) MinimockAbandonedRequestsOnLedgerDone() bool {
	for _, e := range m.AbandonedRequestsOnLedgerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AbandonedRequestsOnLedgerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAbandonedRequestsOnLedgerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAbandonedRequestsOnLedger != nil && mm_atomic.LoadUint64(&m.afterAbandonedRequestsOnLedgerCounter) < 1 {
		return false
	}
	return true
}

// MinimockAbandonedRequestsOnLedgerInspect logs each unmet expectation
func (m *ExecutionBrokerIMock) MinimockAbandonedRequestsOnLedgerInspect() {
	for _, e := range m.AbandonedRequestsOnLedgerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.AbandonedRequestsOnLedger with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AbandonedRequestsOnLedgerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAbandonedRequestsOnLedgerCounter) < 1 {
		if m.AbandonedRequestsOnLedgerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionBrokerIMock.AbandonedRequestsOnLedger")
		} else {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.AbandonedRequestsOnLedger with params: %#v", *m.AbandonedRequestsOnLedgerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAbandonedRequestsOnLedger != nil && mm_atomic.LoadUint64(&m.afterAbandonedRequestsOnLedgerCounter) < 1 {
		m.t.Error("Expected call to ExecutionBrokerIMock.AbandonedRequestsOnLedger")
	}
}

type mExecutionBrokerIMockHasMoreRequests struct {
	mock               *ExecutionBrokerIMock
	defaultExpectation *ExecutionBrokerIMockHasMoreRequestsExpectation
	expectations       []*ExecutionBrokerIMockHasMoreRequestsExpectation

	callArgs []*ExecutionBrokerIMockHasMoreRequestsParams
	mutex    sync.RWMutex
}

// ExecutionBrokerIMockHasMoreRequestsExpectation specifies expectation struct of the ExecutionBrokerI.HasMoreRequests
type ExecutionBrokerIMockHasMoreRequestsExpectation struct {
	mock   *ExecutionBrokerIMock
	params *ExecutionBrokerIMockHasMoreRequestsParams

	Counter uint64
}

// ExecutionBrokerIMockHasMoreRequestsParams contains parameters of the ExecutionBrokerI.HasMoreRequests
type ExecutionBrokerIMockHasMoreRequestsParams struct {
	ctx context.Context
}

// Expect sets up expected params for ExecutionBrokerI.HasMoreRequests
func (mmHasMoreRequests *mExecutionBrokerIMockHasMoreRequests) Expect(ctx context.Context) *mExecutionBrokerIMockHasMoreRequests {
	if mmHasMoreRequests.mock.funcHasMoreRequests != nil {
		mmHasMoreRequests.mock.t.Fatalf("ExecutionBrokerIMock.HasMoreRequests mock is already set by Set")
	}

	if mmHasMoreRequests.defaultExpectation == nil {
		mmHasMoreRequests.defaultExpectation = &ExecutionBrokerIMockHasMoreRequestsExpectation{}
	}

	mmHasMoreRequests.defaultExpectation.params = &ExecutionBrokerIMockHasMoreRequestsParams{ctx}
	for _, e := range mmHasMoreRequests.expectations {
		if minimock.Equal(e.params, mmHasMoreRequests.defaultExpectation.params) {
			mmHasMoreRequests.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHasMoreRequests.defaultExpectation.params)
		}
	}

	return mmHasMoreRequests
}

// Inspect accepts an inspector function that has same arguments as the ExecutionBrokerI.HasMoreRequests
func (mmHasMoreRequests *mExecutionBrokerIMockHasMoreRequests) Inspect(f func(ctx context.Context)) *mExecutionBrokerIMockHasMoreRequests {
	if mmHasMoreRequests.mock.inspectFuncHasMoreRequests != nil {
		mmHasMoreRequests.mock.t.Fatalf("Inspect function is already set for ExecutionBrokerIMock.HasMoreRequests")
	}

	mmHasMoreRequests.mock.inspectFuncHasMoreRequests = f

	return mmHasMoreRequests
}

// Return sets up results that will be returned by ExecutionBrokerI.HasMoreRequests
func (mmHasMoreRequests *mExecutionBrokerIMockHasMoreRequests) Return() *ExecutionBrokerIMock {
	if mmHasMoreRequests.mock.funcHasMoreRequests != nil {
		mmHasMoreRequests.mock.t.Fatalf("ExecutionBrokerIMock.HasMoreRequests mock is already set by Set")
	}

	if mmHasMoreRequests.defaultExpectation == nil {
		mmHasMoreRequests.defaultExpectation = &ExecutionBrokerIMockHasMoreRequestsExpectation{mock: mmHasMoreRequests.mock}
	}

	return mmHasMoreRequests.mock
}

//Set uses given function f to mock the ExecutionBrokerI.HasMoreRequests method
func (mmHasMoreRequests *mExecutionBrokerIMockHasMoreRequests) Set(f func(ctx context.Context)) *ExecutionBrokerIMock {
	if mmHasMoreRequests.defaultExpectation != nil {
		mmHasMoreRequests.mock.t.Fatalf("Default expectation is already set for the ExecutionBrokerI.HasMoreRequests method")
	}

	if len(mmHasMoreRequests.expectations) > 0 {
		mmHasMoreRequests.mock.t.Fatalf("Some expectations are already set for the ExecutionBrokerI.HasMoreRequests method")
	}

	mmHasMoreRequests.mock.funcHasMoreRequests = f
	return mmHasMoreRequests.mock
}

// HasMoreRequests implements ExecutionBrokerI
func (mmHasMoreRequests *ExecutionBrokerIMock) HasMoreRequests(ctx context.Context) {
	mm_atomic.AddUint64(&mmHasMoreRequests.beforeHasMoreRequestsCounter, 1)
	defer mm_atomic.AddUint64(&mmHasMoreRequests.afterHasMoreRequestsCounter, 1)

	if mmHasMoreRequests.inspectFuncHasMoreRequests != nil {
		mmHasMoreRequests.inspectFuncHasMoreRequests(ctx)
	}

	mm_params := &ExecutionBrokerIMockHasMoreRequestsParams{ctx}

	// Record call args
	mmHasMoreRequests.HasMoreRequestsMock.mutex.Lock()
	mmHasMoreRequests.HasMoreRequestsMock.callArgs = append(mmHasMoreRequests.HasMoreRequestsMock.callArgs, mm_params)
	mmHasMoreRequests.HasMoreRequestsMock.mutex.Unlock()

	for _, e := range mmHasMoreRequests.HasMoreRequestsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmHasMoreRequests.HasMoreRequestsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHasMoreRequests.HasMoreRequestsMock.defaultExpectation.Counter, 1)
		mm_want := mmHasMoreRequests.HasMoreRequestsMock.defaultExpectation.params
		mm_got := ExecutionBrokerIMockHasMoreRequestsParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHasMoreRequests.t.Errorf("ExecutionBrokerIMock.HasMoreRequests got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmHasMoreRequests.funcHasMoreRequests != nil {
		mmHasMoreRequests.funcHasMoreRequests(ctx)
		return
	}
	mmHasMoreRequests.t.Fatalf("Unexpected call to ExecutionBrokerIMock.HasMoreRequests. %v", ctx)

}

// HasMoreRequestsAfterCounter returns a count of finished ExecutionBrokerIMock.HasMoreRequests invocations
func (mmHasMoreRequests *ExecutionBrokerIMock) HasMoreRequestsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHasMoreRequests.afterHasMoreRequestsCounter)
}

// HasMoreRequestsBeforeCounter returns a count of ExecutionBrokerIMock.HasMoreRequests invocations
func (mmHasMoreRequests *ExecutionBrokerIMock) HasMoreRequestsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHasMoreRequests.beforeHasMoreRequestsCounter)
}

// Calls returns a list of arguments used in each call to ExecutionBrokerIMock.HasMoreRequests.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHasMoreRequests *mExecutionBrokerIMockHasMoreRequests) Calls() []*ExecutionBrokerIMockHasMoreRequestsParams {
	mmHasMoreRequests.mutex.RLock()

	argCopy := make([]*ExecutionBrokerIMockHasMoreRequestsParams, len(mmHasMoreRequests.callArgs))
	copy(argCopy, mmHasMoreRequests.callArgs)

	mmHasMoreRequests.mutex.RUnlock()

	return argCopy
}

// MinimockHasMoreRequestsDone returns true if the count of the HasMoreRequests invocations corresponds
// the number of defined expectations
func (m *ExecutionBrokerIMock) MinimockHasMoreRequestsDone() bool {
	for _, e := range m.HasMoreRequestsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HasMoreRequestsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHasMoreRequestsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHasMoreRequests != nil && mm_atomic.LoadUint64(&m.afterHasMoreRequestsCounter) < 1 {
		return false
	}
	return true
}

// MinimockHasMoreRequestsInspect logs each unmet expectation
func (m *ExecutionBrokerIMock) MinimockHasMoreRequestsInspect() {
	for _, e := range m.HasMoreRequestsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.HasMoreRequests with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HasMoreRequestsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHasMoreRequestsCounter) < 1 {
		if m.HasMoreRequestsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionBrokerIMock.HasMoreRequests")
		} else {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.HasMoreRequests with params: %#v", *m.HasMoreRequestsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHasMoreRequests != nil && mm_atomic.LoadUint64(&m.afterHasMoreRequestsCounter) < 1 {
		m.t.Error("Expected call to ExecutionBrokerIMock.HasMoreRequests")
	}
}

type mExecutionBrokerIMockOnPulse struct {
	mock               *ExecutionBrokerIMock
	defaultExpectation *ExecutionBrokerIMockOnPulseExpectation
	expectations       []*ExecutionBrokerIMockOnPulseExpectation

	callArgs []*ExecutionBrokerIMockOnPulseParams
	mutex    sync.RWMutex
}

// ExecutionBrokerIMockOnPulseExpectation specifies expectation struct of the ExecutionBrokerI.OnPulse
type ExecutionBrokerIMockOnPulseExpectation struct {
	mock    *ExecutionBrokerIMock
	params  *ExecutionBrokerIMockOnPulseParams
	results *ExecutionBrokerIMockOnPulseResults
	Counter uint64
}

// ExecutionBrokerIMockOnPulseParams contains parameters of the ExecutionBrokerI.OnPulse
type ExecutionBrokerIMockOnPulseParams struct {
	ctx context.Context
}

// ExecutionBrokerIMockOnPulseResults contains results of the ExecutionBrokerI.OnPulse
type ExecutionBrokerIMockOnPulseResults struct {
	pa1 []payload.Payload
}

// Expect sets up expected params for ExecutionBrokerI.OnPulse
func (mmOnPulse *mExecutionBrokerIMockOnPulse) Expect(ctx context.Context) *mExecutionBrokerIMockOnPulse {
	if mmOnPulse.mock.funcOnPulse != nil {
		mmOnPulse.mock.t.Fatalf("ExecutionBrokerIMock.OnPulse mock is already set by Set")
	}

	if mmOnPulse.defaultExpectation == nil {
		mmOnPulse.defaultExpectation = &ExecutionBrokerIMockOnPulseExpectation{}
	}

	mmOnPulse.defaultExpectation.params = &ExecutionBrokerIMockOnPulseParams{ctx}
	for _, e := range mmOnPulse.expectations {
		if minimock.Equal(e.params, mmOnPulse.defaultExpectation.params) {
			mmOnPulse.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOnPulse.defaultExpectation.params)
		}
	}

	return mmOnPulse
}

// Inspect accepts an inspector function that has same arguments as the ExecutionBrokerI.OnPulse
func (mmOnPulse *mExecutionBrokerIMockOnPulse) Inspect(f func(ctx context.Context)) *mExecutionBrokerIMockOnPulse {
	if mmOnPulse.mock.inspectFuncOnPulse != nil {
		mmOnPulse.mock.t.Fatalf("Inspect function is already set for ExecutionBrokerIMock.OnPulse")
	}

	mmOnPulse.mock.inspectFuncOnPulse = f

	return mmOnPulse
}

// Return sets up results that will be returned by ExecutionBrokerI.OnPulse
func (mmOnPulse *mExecutionBrokerIMockOnPulse) Return(pa1 []payload.Payload) *ExecutionBrokerIMock {
	if mmOnPulse.mock.funcOnPulse != nil {
		mmOnPulse.mock.t.Fatalf("ExecutionBrokerIMock.OnPulse mock is already set by Set")
	}

	if mmOnPulse.defaultExpectation == nil {
		mmOnPulse.defaultExpectation = &ExecutionBrokerIMockOnPulseExpectation{mock: mmOnPulse.mock}
	}
	mmOnPulse.defaultExpectation.results = &ExecutionBrokerIMockOnPulseResults{pa1}
	return mmOnPulse.mock
}

//Set uses given function f to mock the ExecutionBrokerI.OnPulse method
func (mmOnPulse *mExecutionBrokerIMockOnPulse) Set(f func(ctx context.Context) (pa1 []payload.Payload)) *ExecutionBrokerIMock {
	if mmOnPulse.defaultExpectation != nil {
		mmOnPulse.mock.t.Fatalf("Default expectation is already set for the ExecutionBrokerI.OnPulse method")
	}

	if len(mmOnPulse.expectations) > 0 {
		mmOnPulse.mock.t.Fatalf("Some expectations are already set for the ExecutionBrokerI.OnPulse method")
	}

	mmOnPulse.mock.funcOnPulse = f
	return mmOnPulse.mock
}

// When sets expectation for the ExecutionBrokerI.OnPulse which will trigger the result defined by the following
// Then helper
func (mmOnPulse *mExecutionBrokerIMockOnPulse) When(ctx context.Context) *ExecutionBrokerIMockOnPulseExpectation {
	if mmOnPulse.mock.funcOnPulse != nil {
		mmOnPulse.mock.t.Fatalf("ExecutionBrokerIMock.OnPulse mock is already set by Set")
	}

	expectation := &ExecutionBrokerIMockOnPulseExpectation{
		mock:   mmOnPulse.mock,
		params: &ExecutionBrokerIMockOnPulseParams{ctx},
	}
	mmOnPulse.expectations = append(mmOnPulse.expectations, expectation)
	return expectation
}

// Then sets up ExecutionBrokerI.OnPulse return parameters for the expectation previously defined by the When method
func (e *ExecutionBrokerIMockOnPulseExpectation) Then(pa1 []payload.Payload) *ExecutionBrokerIMock {
	e.results = &ExecutionBrokerIMockOnPulseResults{pa1}
	return e.mock
}

// OnPulse implements ExecutionBrokerI
func (mmOnPulse *ExecutionBrokerIMock) OnPulse(ctx context.Context) (pa1 []payload.Payload) {
	mm_atomic.AddUint64(&mmOnPulse.beforeOnPulseCounter, 1)
	defer mm_atomic.AddUint64(&mmOnPulse.afterOnPulseCounter, 1)

	if mmOnPulse.inspectFuncOnPulse != nil {
		mmOnPulse.inspectFuncOnPulse(ctx)
	}

	mm_params := &ExecutionBrokerIMockOnPulseParams{ctx}

	// Record call args
	mmOnPulse.OnPulseMock.mutex.Lock()
	mmOnPulse.OnPulseMock.callArgs = append(mmOnPulse.OnPulseMock.callArgs, mm_params)
	mmOnPulse.OnPulseMock.mutex.Unlock()

	for _, e := range mmOnPulse.OnPulseMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1
		}
	}

	if mmOnPulse.OnPulseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOnPulse.OnPulseMock.defaultExpectation.Counter, 1)
		mm_want := mmOnPulse.OnPulseMock.defaultExpectation.params
		mm_got := ExecutionBrokerIMockOnPulseParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOnPulse.t.Errorf("ExecutionBrokerIMock.OnPulse got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOnPulse.OnPulseMock.defaultExpectation.results
		if mm_results == nil {
			mmOnPulse.t.Fatal("No results are set for the ExecutionBrokerIMock.OnPulse")
		}
		return (*mm_results).pa1
	}
	if mmOnPulse.funcOnPulse != nil {
		return mmOnPulse.funcOnPulse(ctx)
	}
	mmOnPulse.t.Fatalf("Unexpected call to ExecutionBrokerIMock.OnPulse. %v", ctx)
	return
}

// OnPulseAfterCounter returns a count of finished ExecutionBrokerIMock.OnPulse invocations
func (mmOnPulse *ExecutionBrokerIMock) OnPulseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOnPulse.afterOnPulseCounter)
}

// OnPulseBeforeCounter returns a count of ExecutionBrokerIMock.OnPulse invocations
func (mmOnPulse *ExecutionBrokerIMock) OnPulseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOnPulse.beforeOnPulseCounter)
}

// Calls returns a list of arguments used in each call to ExecutionBrokerIMock.OnPulse.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOnPulse *mExecutionBrokerIMockOnPulse) Calls() []*ExecutionBrokerIMockOnPulseParams {
	mmOnPulse.mutex.RLock()

	argCopy := make([]*ExecutionBrokerIMockOnPulseParams, len(mmOnPulse.callArgs))
	copy(argCopy, mmOnPulse.callArgs)

	mmOnPulse.mutex.RUnlock()

	return argCopy
}

// MinimockOnPulseDone returns true if the count of the OnPulse invocations corresponds
// the number of defined expectations
func (m *ExecutionBrokerIMock) MinimockOnPulseDone() bool {
	for _, e := range m.OnPulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OnPulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOnPulseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOnPulse != nil && mm_atomic.LoadUint64(&m.afterOnPulseCounter) < 1 {
		return false
	}
	return true
}

// MinimockOnPulseInspect logs each unmet expectation
func (m *ExecutionBrokerIMock) MinimockOnPulseInspect() {
	for _, e := range m.OnPulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.OnPulse with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OnPulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOnPulseCounter) < 1 {
		if m.OnPulseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionBrokerIMock.OnPulse")
		} else {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.OnPulse with params: %#v", *m.OnPulseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOnPulse != nil && mm_atomic.LoadUint64(&m.afterOnPulseCounter) < 1 {
		m.t.Error("Expected call to ExecutionBrokerIMock.OnPulse")
	}
}

type mExecutionBrokerIMockPendingState struct {
	mock               *ExecutionBrokerIMock
	defaultExpectation *ExecutionBrokerIMockPendingStateExpectation
	expectations       []*ExecutionBrokerIMockPendingStateExpectation
}

// ExecutionBrokerIMockPendingStateExpectation specifies expectation struct of the ExecutionBrokerI.PendingState
type ExecutionBrokerIMockPendingStateExpectation struct {
	mock *ExecutionBrokerIMock

	results *ExecutionBrokerIMockPendingStateResults
	Counter uint64
}

// ExecutionBrokerIMockPendingStateResults contains results of the ExecutionBrokerI.PendingState
type ExecutionBrokerIMockPendingStateResults struct {
	p1 insolar.PendingState
}

// Expect sets up expected params for ExecutionBrokerI.PendingState
func (mmPendingState *mExecutionBrokerIMockPendingState) Expect() *mExecutionBrokerIMockPendingState {
	if mmPendingState.mock.funcPendingState != nil {
		mmPendingState.mock.t.Fatalf("ExecutionBrokerIMock.PendingState mock is already set by Set")
	}

	if mmPendingState.defaultExpectation == nil {
		mmPendingState.defaultExpectation = &ExecutionBrokerIMockPendingStateExpectation{}
	}

	return mmPendingState
}

// Inspect accepts an inspector function that has same arguments as the ExecutionBrokerI.PendingState
func (mmPendingState *mExecutionBrokerIMockPendingState) Inspect(f func()) *mExecutionBrokerIMockPendingState {
	if mmPendingState.mock.inspectFuncPendingState != nil {
		mmPendingState.mock.t.Fatalf("Inspect function is already set for ExecutionBrokerIMock.PendingState")
	}

	mmPendingState.mock.inspectFuncPendingState = f

	return mmPendingState
}

// Return sets up results that will be returned by ExecutionBrokerI.PendingState
func (mmPendingState *mExecutionBrokerIMockPendingState) Return(p1 insolar.PendingState) *ExecutionBrokerIMock {
	if mmPendingState.mock.funcPendingState != nil {
		mmPendingState.mock.t.Fatalf("ExecutionBrokerIMock.PendingState mock is already set by Set")
	}

	if mmPendingState.defaultExpectation == nil {
		mmPendingState.defaultExpectation = &ExecutionBrokerIMockPendingStateExpectation{mock: mmPendingState.mock}
	}
	mmPendingState.defaultExpectation.results = &ExecutionBrokerIMockPendingStateResults{p1}
	return mmPendingState.mock
}

//Set uses given function f to mock the ExecutionBrokerI.PendingState method
func (mmPendingState *mExecutionBrokerIMockPendingState) Set(f func() (p1 insolar.PendingState)) *ExecutionBrokerIMock {
	if mmPendingState.defaultExpectation != nil {
		mmPendingState.mock.t.Fatalf("Default expectation is already set for the ExecutionBrokerI.PendingState method")
	}

	if len(mmPendingState.expectations) > 0 {
		mmPendingState.mock.t.Fatalf("Some expectations are already set for the ExecutionBrokerI.PendingState method")
	}

	mmPendingState.mock.funcPendingState = f
	return mmPendingState.mock
}

// PendingState implements ExecutionBrokerI
func (mmPendingState *ExecutionBrokerIMock) PendingState() (p1 insolar.PendingState) {
	mm_atomic.AddUint64(&mmPendingState.beforePendingStateCounter, 1)
	defer mm_atomic.AddUint64(&mmPendingState.afterPendingStateCounter, 1)

	if mmPendingState.inspectFuncPendingState != nil {
		mmPendingState.inspectFuncPendingState()
	}

	if mmPendingState.PendingStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPendingState.PendingStateMock.defaultExpectation.Counter, 1)

		mm_results := mmPendingState.PendingStateMock.defaultExpectation.results
		if mm_results == nil {
			mmPendingState.t.Fatal("No results are set for the ExecutionBrokerIMock.PendingState")
		}
		return (*mm_results).p1
	}
	if mmPendingState.funcPendingState != nil {
		return mmPendingState.funcPendingState()
	}
	mmPendingState.t.Fatalf("Unexpected call to ExecutionBrokerIMock.PendingState.")
	return
}

// PendingStateAfterCounter returns a count of finished ExecutionBrokerIMock.PendingState invocations
func (mmPendingState *ExecutionBrokerIMock) PendingStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPendingState.afterPendingStateCounter)
}

// PendingStateBeforeCounter returns a count of ExecutionBrokerIMock.PendingState invocations
func (mmPendingState *ExecutionBrokerIMock) PendingStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPendingState.beforePendingStateCounter)
}

// MinimockPendingStateDone returns true if the count of the PendingState invocations corresponds
// the number of defined expectations
func (m *ExecutionBrokerIMock) MinimockPendingStateDone() bool {
	for _, e := range m.PendingStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PendingStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPendingStateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPendingState != nil && mm_atomic.LoadUint64(&m.afterPendingStateCounter) < 1 {
		return false
	}
	return true
}

// MinimockPendingStateInspect logs each unmet expectation
func (m *ExecutionBrokerIMock) MinimockPendingStateInspect() {
	for _, e := range m.PendingStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExecutionBrokerIMock.PendingState")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PendingStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPendingStateCounter) < 1 {
		m.t.Error("Expected call to ExecutionBrokerIMock.PendingState")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPendingState != nil && mm_atomic.LoadUint64(&m.afterPendingStateCounter) < 1 {
		m.t.Error("Expected call to ExecutionBrokerIMock.PendingState")
	}
}

type mExecutionBrokerIMockPrevExecutorPendingResult struct {
	mock               *ExecutionBrokerIMock
	defaultExpectation *ExecutionBrokerIMockPrevExecutorPendingResultExpectation
	expectations       []*ExecutionBrokerIMockPrevExecutorPendingResultExpectation

	callArgs []*ExecutionBrokerIMockPrevExecutorPendingResultParams
	mutex    sync.RWMutex
}

// ExecutionBrokerIMockPrevExecutorPendingResultExpectation specifies expectation struct of the ExecutionBrokerI.PrevExecutorPendingResult
type ExecutionBrokerIMockPrevExecutorPendingResultExpectation struct {
	mock   *ExecutionBrokerIMock
	params *ExecutionBrokerIMockPrevExecutorPendingResultParams

	Counter uint64
}

// ExecutionBrokerIMockPrevExecutorPendingResultParams contains parameters of the ExecutionBrokerI.PrevExecutorPendingResult
type ExecutionBrokerIMockPrevExecutorPendingResultParams struct {
	ctx           context.Context
	prevExecState insolar.PendingState
}

// Expect sets up expected params for ExecutionBrokerI.PrevExecutorPendingResult
func (mmPrevExecutorPendingResult *mExecutionBrokerIMockPrevExecutorPendingResult) Expect(ctx context.Context, prevExecState insolar.PendingState) *mExecutionBrokerIMockPrevExecutorPendingResult {
	if mmPrevExecutorPendingResult.mock.funcPrevExecutorPendingResult != nil {
		mmPrevExecutorPendingResult.mock.t.Fatalf("ExecutionBrokerIMock.PrevExecutorPendingResult mock is already set by Set")
	}

	if mmPrevExecutorPendingResult.defaultExpectation == nil {
		mmPrevExecutorPendingResult.defaultExpectation = &ExecutionBrokerIMockPrevExecutorPendingResultExpectation{}
	}

	mmPrevExecutorPendingResult.defaultExpectation.params = &ExecutionBrokerIMockPrevExecutorPendingResultParams{ctx, prevExecState}
	for _, e := range mmPrevExecutorPendingResult.expectations {
		if minimock.Equal(e.params, mmPrevExecutorPendingResult.defaultExpectation.params) {
			mmPrevExecutorPendingResult.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrevExecutorPendingResult.defaultExpectation.params)
		}
	}

	return mmPrevExecutorPendingResult
}

// Inspect accepts an inspector function that has same arguments as the ExecutionBrokerI.PrevExecutorPendingResult
func (mmPrevExecutorPendingResult *mExecutionBrokerIMockPrevExecutorPendingResult) Inspect(f func(ctx context.Context, prevExecState insolar.PendingState)) *mExecutionBrokerIMockPrevExecutorPendingResult {
	if mmPrevExecutorPendingResult.mock.inspectFuncPrevExecutorPendingResult != nil {
		mmPrevExecutorPendingResult.mock.t.Fatalf("Inspect function is already set for ExecutionBrokerIMock.PrevExecutorPendingResult")
	}

	mmPrevExecutorPendingResult.mock.inspectFuncPrevExecutorPendingResult = f

	return mmPrevExecutorPendingResult
}

// Return sets up results that will be returned by ExecutionBrokerI.PrevExecutorPendingResult
func (mmPrevExecutorPendingResult *mExecutionBrokerIMockPrevExecutorPendingResult) Return() *ExecutionBrokerIMock {
	if mmPrevExecutorPendingResult.mock.funcPrevExecutorPendingResult != nil {
		mmPrevExecutorPendingResult.mock.t.Fatalf("ExecutionBrokerIMock.PrevExecutorPendingResult mock is already set by Set")
	}

	if mmPrevExecutorPendingResult.defaultExpectation == nil {
		mmPrevExecutorPendingResult.defaultExpectation = &ExecutionBrokerIMockPrevExecutorPendingResultExpectation{mock: mmPrevExecutorPendingResult.mock}
	}

	return mmPrevExecutorPendingResult.mock
}

//Set uses given function f to mock the ExecutionBrokerI.PrevExecutorPendingResult method
func (mmPrevExecutorPendingResult *mExecutionBrokerIMockPrevExecutorPendingResult) Set(f func(ctx context.Context, prevExecState insolar.PendingState)) *ExecutionBrokerIMock {
	if mmPrevExecutorPendingResult.defaultExpectation != nil {
		mmPrevExecutorPendingResult.mock.t.Fatalf("Default expectation is already set for the ExecutionBrokerI.PrevExecutorPendingResult method")
	}

	if len(mmPrevExecutorPendingResult.expectations) > 0 {
		mmPrevExecutorPendingResult.mock.t.Fatalf("Some expectations are already set for the ExecutionBrokerI.PrevExecutorPendingResult method")
	}

	mmPrevExecutorPendingResult.mock.funcPrevExecutorPendingResult = f
	return mmPrevExecutorPendingResult.mock
}

// PrevExecutorPendingResult implements ExecutionBrokerI
func (mmPrevExecutorPendingResult *ExecutionBrokerIMock) PrevExecutorPendingResult(ctx context.Context, prevExecState insolar.PendingState) {
	mm_atomic.AddUint64(&mmPrevExecutorPendingResult.beforePrevExecutorPendingResultCounter, 1)
	defer mm_atomic.AddUint64(&mmPrevExecutorPendingResult.afterPrevExecutorPendingResultCounter, 1)

	if mmPrevExecutorPendingResult.inspectFuncPrevExecutorPendingResult != nil {
		mmPrevExecutorPendingResult.inspectFuncPrevExecutorPendingResult(ctx, prevExecState)
	}

	mm_params := &ExecutionBrokerIMockPrevExecutorPendingResultParams{ctx, prevExecState}

	// Record call args
	mmPrevExecutorPendingResult.PrevExecutorPendingResultMock.mutex.Lock()
	mmPrevExecutorPendingResult.PrevExecutorPendingResultMock.callArgs = append(mmPrevExecutorPendingResult.PrevExecutorPendingResultMock.callArgs, mm_params)
	mmPrevExecutorPendingResult.PrevExecutorPendingResultMock.mutex.Unlock()

	for _, e := range mmPrevExecutorPendingResult.PrevExecutorPendingResultMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmPrevExecutorPendingResult.PrevExecutorPendingResultMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrevExecutorPendingResult.PrevExecutorPendingResultMock.defaultExpectation.Counter, 1)
		mm_want := mmPrevExecutorPendingResult.PrevExecutorPendingResultMock.defaultExpectation.params
		mm_got := ExecutionBrokerIMockPrevExecutorPendingResultParams{ctx, prevExecState}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPrevExecutorPendingResult.t.Errorf("ExecutionBrokerIMock.PrevExecutorPendingResult got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmPrevExecutorPendingResult.funcPrevExecutorPendingResult != nil {
		mmPrevExecutorPendingResult.funcPrevExecutorPendingResult(ctx, prevExecState)
		return
	}
	mmPrevExecutorPendingResult.t.Fatalf("Unexpected call to ExecutionBrokerIMock.PrevExecutorPendingResult. %v %v", ctx, prevExecState)

}

// PrevExecutorPendingResultAfterCounter returns a count of finished ExecutionBrokerIMock.PrevExecutorPendingResult invocations
func (mmPrevExecutorPendingResult *ExecutionBrokerIMock) PrevExecutorPendingResultAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrevExecutorPendingResult.afterPrevExecutorPendingResultCounter)
}

// PrevExecutorPendingResultBeforeCounter returns a count of ExecutionBrokerIMock.PrevExecutorPendingResult invocations
func (mmPrevExecutorPendingResult *ExecutionBrokerIMock) PrevExecutorPendingResultBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrevExecutorPendingResult.beforePrevExecutorPendingResultCounter)
}

// Calls returns a list of arguments used in each call to ExecutionBrokerIMock.PrevExecutorPendingResult.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrevExecutorPendingResult *mExecutionBrokerIMockPrevExecutorPendingResult) Calls() []*ExecutionBrokerIMockPrevExecutorPendingResultParams {
	mmPrevExecutorPendingResult.mutex.RLock()

	argCopy := make([]*ExecutionBrokerIMockPrevExecutorPendingResultParams, len(mmPrevExecutorPendingResult.callArgs))
	copy(argCopy, mmPrevExecutorPendingResult.callArgs)

	mmPrevExecutorPendingResult.mutex.RUnlock()

	return argCopy
}

// MinimockPrevExecutorPendingResultDone returns true if the count of the PrevExecutorPendingResult invocations corresponds
// the number of defined expectations
func (m *ExecutionBrokerIMock) MinimockPrevExecutorPendingResultDone() bool {
	for _, e := range m.PrevExecutorPendingResultMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrevExecutorPendingResultMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrevExecutorPendingResultCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrevExecutorPendingResult != nil && mm_atomic.LoadUint64(&m.afterPrevExecutorPendingResultCounter) < 1 {
		return false
	}
	return true
}

// MinimockPrevExecutorPendingResultInspect logs each unmet expectation
func (m *ExecutionBrokerIMock) MinimockPrevExecutorPendingResultInspect() {
	for _, e := range m.PrevExecutorPendingResultMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.PrevExecutorPendingResult with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrevExecutorPendingResultMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrevExecutorPendingResultCounter) < 1 {
		if m.PrevExecutorPendingResultMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionBrokerIMock.PrevExecutorPendingResult")
		} else {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.PrevExecutorPendingResult with params: %#v", *m.PrevExecutorPendingResultMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrevExecutorPendingResult != nil && mm_atomic.LoadUint64(&m.afterPrevExecutorPendingResultCounter) < 1 {
		m.t.Error("Expected call to ExecutionBrokerIMock.PrevExecutorPendingResult")
	}
}

type mExecutionBrokerIMockPrevExecutorSentPendingFinished struct {
	mock               *ExecutionBrokerIMock
	defaultExpectation *ExecutionBrokerIMockPrevExecutorSentPendingFinishedExpectation
	expectations       []*ExecutionBrokerIMockPrevExecutorSentPendingFinishedExpectation

	callArgs []*ExecutionBrokerIMockPrevExecutorSentPendingFinishedParams
	mutex    sync.RWMutex
}

// ExecutionBrokerIMockPrevExecutorSentPendingFinishedExpectation specifies expectation struct of the ExecutionBrokerI.PrevExecutorSentPendingFinished
type ExecutionBrokerIMockPrevExecutorSentPendingFinishedExpectation struct {
	mock    *ExecutionBrokerIMock
	params  *ExecutionBrokerIMockPrevExecutorSentPendingFinishedParams
	results *ExecutionBrokerIMockPrevExecutorSentPendingFinishedResults
	Counter uint64
}

// ExecutionBrokerIMockPrevExecutorSentPendingFinishedParams contains parameters of the ExecutionBrokerI.PrevExecutorSentPendingFinished
type ExecutionBrokerIMockPrevExecutorSentPendingFinishedParams struct {
	ctx context.Context
}

// ExecutionBrokerIMockPrevExecutorSentPendingFinishedResults contains results of the ExecutionBrokerI.PrevExecutorSentPendingFinished
type ExecutionBrokerIMockPrevExecutorSentPendingFinishedResults struct {
	err error
}

// Expect sets up expected params for ExecutionBrokerI.PrevExecutorSentPendingFinished
func (mmPrevExecutorSentPendingFinished *mExecutionBrokerIMockPrevExecutorSentPendingFinished) Expect(ctx context.Context) *mExecutionBrokerIMockPrevExecutorSentPendingFinished {
	if mmPrevExecutorSentPendingFinished.mock.funcPrevExecutorSentPendingFinished != nil {
		mmPrevExecutorSentPendingFinished.mock.t.Fatalf("ExecutionBrokerIMock.PrevExecutorSentPendingFinished mock is already set by Set")
	}

	if mmPrevExecutorSentPendingFinished.defaultExpectation == nil {
		mmPrevExecutorSentPendingFinished.defaultExpectation = &ExecutionBrokerIMockPrevExecutorSentPendingFinishedExpectation{}
	}

	mmPrevExecutorSentPendingFinished.defaultExpectation.params = &ExecutionBrokerIMockPrevExecutorSentPendingFinishedParams{ctx}
	for _, e := range mmPrevExecutorSentPendingFinished.expectations {
		if minimock.Equal(e.params, mmPrevExecutorSentPendingFinished.defaultExpectation.params) {
			mmPrevExecutorSentPendingFinished.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrevExecutorSentPendingFinished.defaultExpectation.params)
		}
	}

	return mmPrevExecutorSentPendingFinished
}

// Inspect accepts an inspector function that has same arguments as the ExecutionBrokerI.PrevExecutorSentPendingFinished
func (mmPrevExecutorSentPendingFinished *mExecutionBrokerIMockPrevExecutorSentPendingFinished) Inspect(f func(ctx context.Context)) *mExecutionBrokerIMockPrevExecutorSentPendingFinished {
	if mmPrevExecutorSentPendingFinished.mock.inspectFuncPrevExecutorSentPendingFinished != nil {
		mmPrevExecutorSentPendingFinished.mock.t.Fatalf("Inspect function is already set for ExecutionBrokerIMock.PrevExecutorSentPendingFinished")
	}

	mmPrevExecutorSentPendingFinished.mock.inspectFuncPrevExecutorSentPendingFinished = f

	return mmPrevExecutorSentPendingFinished
}

// Return sets up results that will be returned by ExecutionBrokerI.PrevExecutorSentPendingFinished
func (mmPrevExecutorSentPendingFinished *mExecutionBrokerIMockPrevExecutorSentPendingFinished) Return(err error) *ExecutionBrokerIMock {
	if mmPrevExecutorSentPendingFinished.mock.funcPrevExecutorSentPendingFinished != nil {
		mmPrevExecutorSentPendingFinished.mock.t.Fatalf("ExecutionBrokerIMock.PrevExecutorSentPendingFinished mock is already set by Set")
	}

	if mmPrevExecutorSentPendingFinished.defaultExpectation == nil {
		mmPrevExecutorSentPendingFinished.defaultExpectation = &ExecutionBrokerIMockPrevExecutorSentPendingFinishedExpectation{mock: mmPrevExecutorSentPendingFinished.mock}
	}
	mmPrevExecutorSentPendingFinished.defaultExpectation.results = &ExecutionBrokerIMockPrevExecutorSentPendingFinishedResults{err}
	return mmPrevExecutorSentPendingFinished.mock
}

//Set uses given function f to mock the ExecutionBrokerI.PrevExecutorSentPendingFinished method
func (mmPrevExecutorSentPendingFinished *mExecutionBrokerIMockPrevExecutorSentPendingFinished) Set(f func(ctx context.Context) (err error)) *ExecutionBrokerIMock {
	if mmPrevExecutorSentPendingFinished.defaultExpectation != nil {
		mmPrevExecutorSentPendingFinished.mock.t.Fatalf("Default expectation is already set for the ExecutionBrokerI.PrevExecutorSentPendingFinished method")
	}

	if len(mmPrevExecutorSentPendingFinished.expectations) > 0 {
		mmPrevExecutorSentPendingFinished.mock.t.Fatalf("Some expectations are already set for the ExecutionBrokerI.PrevExecutorSentPendingFinished method")
	}

	mmPrevExecutorSentPendingFinished.mock.funcPrevExecutorSentPendingFinished = f
	return mmPrevExecutorSentPendingFinished.mock
}

// When sets expectation for the ExecutionBrokerI.PrevExecutorSentPendingFinished which will trigger the result defined by the following
// Then helper
func (mmPrevExecutorSentPendingFinished *mExecutionBrokerIMockPrevExecutorSentPendingFinished) When(ctx context.Context) *ExecutionBrokerIMockPrevExecutorSentPendingFinishedExpectation {
	if mmPrevExecutorSentPendingFinished.mock.funcPrevExecutorSentPendingFinished != nil {
		mmPrevExecutorSentPendingFinished.mock.t.Fatalf("ExecutionBrokerIMock.PrevExecutorSentPendingFinished mock is already set by Set")
	}

	expectation := &ExecutionBrokerIMockPrevExecutorSentPendingFinishedExpectation{
		mock:   mmPrevExecutorSentPendingFinished.mock,
		params: &ExecutionBrokerIMockPrevExecutorSentPendingFinishedParams{ctx},
	}
	mmPrevExecutorSentPendingFinished.expectations = append(mmPrevExecutorSentPendingFinished.expectations, expectation)
	return expectation
}

// Then sets up ExecutionBrokerI.PrevExecutorSentPendingFinished return parameters for the expectation previously defined by the When method
func (e *ExecutionBrokerIMockPrevExecutorSentPendingFinishedExpectation) Then(err error) *ExecutionBrokerIMock {
	e.results = &ExecutionBrokerIMockPrevExecutorSentPendingFinishedResults{err}
	return e.mock
}

// PrevExecutorSentPendingFinished implements ExecutionBrokerI
func (mmPrevExecutorSentPendingFinished *ExecutionBrokerIMock) PrevExecutorSentPendingFinished(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmPrevExecutorSentPendingFinished.beforePrevExecutorSentPendingFinishedCounter, 1)
	defer mm_atomic.AddUint64(&mmPrevExecutorSentPendingFinished.afterPrevExecutorSentPendingFinishedCounter, 1)

	if mmPrevExecutorSentPendingFinished.inspectFuncPrevExecutorSentPendingFinished != nil {
		mmPrevExecutorSentPendingFinished.inspectFuncPrevExecutorSentPendingFinished(ctx)
	}

	mm_params := &ExecutionBrokerIMockPrevExecutorSentPendingFinishedParams{ctx}

	// Record call args
	mmPrevExecutorSentPendingFinished.PrevExecutorSentPendingFinishedMock.mutex.Lock()
	mmPrevExecutorSentPendingFinished.PrevExecutorSentPendingFinishedMock.callArgs = append(mmPrevExecutorSentPendingFinished.PrevExecutorSentPendingFinishedMock.callArgs, mm_params)
	mmPrevExecutorSentPendingFinished.PrevExecutorSentPendingFinishedMock.mutex.Unlock()

	for _, e := range mmPrevExecutorSentPendingFinished.PrevExecutorSentPendingFinishedMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPrevExecutorSentPendingFinished.PrevExecutorSentPendingFinishedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrevExecutorSentPendingFinished.PrevExecutorSentPendingFinishedMock.defaultExpectation.Counter, 1)
		mm_want := mmPrevExecutorSentPendingFinished.PrevExecutorSentPendingFinishedMock.defaultExpectation.params
		mm_got := ExecutionBrokerIMockPrevExecutorSentPendingFinishedParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPrevExecutorSentPendingFinished.t.Errorf("ExecutionBrokerIMock.PrevExecutorSentPendingFinished got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPrevExecutorSentPendingFinished.PrevExecutorSentPendingFinishedMock.defaultExpectation.results
		if mm_results == nil {
			mmPrevExecutorSentPendingFinished.t.Fatal("No results are set for the ExecutionBrokerIMock.PrevExecutorSentPendingFinished")
		}
		return (*mm_results).err
	}
	if mmPrevExecutorSentPendingFinished.funcPrevExecutorSentPendingFinished != nil {
		return mmPrevExecutorSentPendingFinished.funcPrevExecutorSentPendingFinished(ctx)
	}
	mmPrevExecutorSentPendingFinished.t.Fatalf("Unexpected call to ExecutionBrokerIMock.PrevExecutorSentPendingFinished. %v", ctx)
	return
}

// PrevExecutorSentPendingFinishedAfterCounter returns a count of finished ExecutionBrokerIMock.PrevExecutorSentPendingFinished invocations
func (mmPrevExecutorSentPendingFinished *ExecutionBrokerIMock) PrevExecutorSentPendingFinishedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrevExecutorSentPendingFinished.afterPrevExecutorSentPendingFinishedCounter)
}

// PrevExecutorSentPendingFinishedBeforeCounter returns a count of ExecutionBrokerIMock.PrevExecutorSentPendingFinished invocations
func (mmPrevExecutorSentPendingFinished *ExecutionBrokerIMock) PrevExecutorSentPendingFinishedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrevExecutorSentPendingFinished.beforePrevExecutorSentPendingFinishedCounter)
}

// Calls returns a list of arguments used in each call to ExecutionBrokerIMock.PrevExecutorSentPendingFinished.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrevExecutorSentPendingFinished *mExecutionBrokerIMockPrevExecutorSentPendingFinished) Calls() []*ExecutionBrokerIMockPrevExecutorSentPendingFinishedParams {
	mmPrevExecutorSentPendingFinished.mutex.RLock()

	argCopy := make([]*ExecutionBrokerIMockPrevExecutorSentPendingFinishedParams, len(mmPrevExecutorSentPendingFinished.callArgs))
	copy(argCopy, mmPrevExecutorSentPendingFinished.callArgs)

	mmPrevExecutorSentPendingFinished.mutex.RUnlock()

	return argCopy
}

// MinimockPrevExecutorSentPendingFinishedDone returns true if the count of the PrevExecutorSentPendingFinished invocations corresponds
// the number of defined expectations
func (m *ExecutionBrokerIMock) MinimockPrevExecutorSentPendingFinishedDone() bool {
	for _, e := range m.PrevExecutorSentPendingFinishedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrevExecutorSentPendingFinishedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrevExecutorSentPendingFinishedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrevExecutorSentPendingFinished != nil && mm_atomic.LoadUint64(&m.afterPrevExecutorSentPendingFinishedCounter) < 1 {
		return false
	}
	return true
}

// MinimockPrevExecutorSentPendingFinishedInspect logs each unmet expectation
func (m *ExecutionBrokerIMock) MinimockPrevExecutorSentPendingFinishedInspect() {
	for _, e := range m.PrevExecutorSentPendingFinishedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.PrevExecutorSentPendingFinished with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrevExecutorSentPendingFinishedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrevExecutorSentPendingFinishedCounter) < 1 {
		if m.PrevExecutorSentPendingFinishedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionBrokerIMock.PrevExecutorSentPendingFinished")
		} else {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.PrevExecutorSentPendingFinished with params: %#v", *m.PrevExecutorSentPendingFinishedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrevExecutorSentPendingFinished != nil && mm_atomic.LoadUint64(&m.afterPrevExecutorSentPendingFinishedCounter) < 1 {
		m.t.Error("Expected call to ExecutionBrokerIMock.PrevExecutorSentPendingFinished")
	}
}

type mExecutionBrokerIMockPrevExecutorStillExecuting struct {
	mock               *ExecutionBrokerIMock
	defaultExpectation *ExecutionBrokerIMockPrevExecutorStillExecutingExpectation
	expectations       []*ExecutionBrokerIMockPrevExecutorStillExecutingExpectation

	callArgs []*ExecutionBrokerIMockPrevExecutorStillExecutingParams
	mutex    sync.RWMutex
}

// ExecutionBrokerIMockPrevExecutorStillExecutingExpectation specifies expectation struct of the ExecutionBrokerI.PrevExecutorStillExecuting
type ExecutionBrokerIMockPrevExecutorStillExecutingExpectation struct {
	mock    *ExecutionBrokerIMock
	params  *ExecutionBrokerIMockPrevExecutorStillExecutingParams
	results *ExecutionBrokerIMockPrevExecutorStillExecutingResults
	Counter uint64
}

// ExecutionBrokerIMockPrevExecutorStillExecutingParams contains parameters of the ExecutionBrokerI.PrevExecutorStillExecuting
type ExecutionBrokerIMockPrevExecutorStillExecutingParams struct {
	ctx context.Context
}

// ExecutionBrokerIMockPrevExecutorStillExecutingResults contains results of the ExecutionBrokerI.PrevExecutorStillExecuting
type ExecutionBrokerIMockPrevExecutorStillExecutingResults struct {
	err error
}

// Expect sets up expected params for ExecutionBrokerI.PrevExecutorStillExecuting
func (mmPrevExecutorStillExecuting *mExecutionBrokerIMockPrevExecutorStillExecuting) Expect(ctx context.Context) *mExecutionBrokerIMockPrevExecutorStillExecuting {
	if mmPrevExecutorStillExecuting.mock.funcPrevExecutorStillExecuting != nil {
		mmPrevExecutorStillExecuting.mock.t.Fatalf("ExecutionBrokerIMock.PrevExecutorStillExecuting mock is already set by Set")
	}

	if mmPrevExecutorStillExecuting.defaultExpectation == nil {
		mmPrevExecutorStillExecuting.defaultExpectation = &ExecutionBrokerIMockPrevExecutorStillExecutingExpectation{}
	}

	mmPrevExecutorStillExecuting.defaultExpectation.params = &ExecutionBrokerIMockPrevExecutorStillExecutingParams{ctx}
	for _, e := range mmPrevExecutorStillExecuting.expectations {
		if minimock.Equal(e.params, mmPrevExecutorStillExecuting.defaultExpectation.params) {
			mmPrevExecutorStillExecuting.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrevExecutorStillExecuting.defaultExpectation.params)
		}
	}

	return mmPrevExecutorStillExecuting
}

// Inspect accepts an inspector function that has same arguments as the ExecutionBrokerI.PrevExecutorStillExecuting
func (mmPrevExecutorStillExecuting *mExecutionBrokerIMockPrevExecutorStillExecuting) Inspect(f func(ctx context.Context)) *mExecutionBrokerIMockPrevExecutorStillExecuting {
	if mmPrevExecutorStillExecuting.mock.inspectFuncPrevExecutorStillExecuting != nil {
		mmPrevExecutorStillExecuting.mock.t.Fatalf("Inspect function is already set for ExecutionBrokerIMock.PrevExecutorStillExecuting")
	}

	mmPrevExecutorStillExecuting.mock.inspectFuncPrevExecutorStillExecuting = f

	return mmPrevExecutorStillExecuting
}

// Return sets up results that will be returned by ExecutionBrokerI.PrevExecutorStillExecuting
func (mmPrevExecutorStillExecuting *mExecutionBrokerIMockPrevExecutorStillExecuting) Return(err error) *ExecutionBrokerIMock {
	if mmPrevExecutorStillExecuting.mock.funcPrevExecutorStillExecuting != nil {
		mmPrevExecutorStillExecuting.mock.t.Fatalf("ExecutionBrokerIMock.PrevExecutorStillExecuting mock is already set by Set")
	}

	if mmPrevExecutorStillExecuting.defaultExpectation == nil {
		mmPrevExecutorStillExecuting.defaultExpectation = &ExecutionBrokerIMockPrevExecutorStillExecutingExpectation{mock: mmPrevExecutorStillExecuting.mock}
	}
	mmPrevExecutorStillExecuting.defaultExpectation.results = &ExecutionBrokerIMockPrevExecutorStillExecutingResults{err}
	return mmPrevExecutorStillExecuting.mock
}

//Set uses given function f to mock the ExecutionBrokerI.PrevExecutorStillExecuting method
func (mmPrevExecutorStillExecuting *mExecutionBrokerIMockPrevExecutorStillExecuting) Set(f func(ctx context.Context) (err error)) *ExecutionBrokerIMock {
	if mmPrevExecutorStillExecuting.defaultExpectation != nil {
		mmPrevExecutorStillExecuting.mock.t.Fatalf("Default expectation is already set for the ExecutionBrokerI.PrevExecutorStillExecuting method")
	}

	if len(mmPrevExecutorStillExecuting.expectations) > 0 {
		mmPrevExecutorStillExecuting.mock.t.Fatalf("Some expectations are already set for the ExecutionBrokerI.PrevExecutorStillExecuting method")
	}

	mmPrevExecutorStillExecuting.mock.funcPrevExecutorStillExecuting = f
	return mmPrevExecutorStillExecuting.mock
}

// When sets expectation for the ExecutionBrokerI.PrevExecutorStillExecuting which will trigger the result defined by the following
// Then helper
func (mmPrevExecutorStillExecuting *mExecutionBrokerIMockPrevExecutorStillExecuting) When(ctx context.Context) *ExecutionBrokerIMockPrevExecutorStillExecutingExpectation {
	if mmPrevExecutorStillExecuting.mock.funcPrevExecutorStillExecuting != nil {
		mmPrevExecutorStillExecuting.mock.t.Fatalf("ExecutionBrokerIMock.PrevExecutorStillExecuting mock is already set by Set")
	}

	expectation := &ExecutionBrokerIMockPrevExecutorStillExecutingExpectation{
		mock:   mmPrevExecutorStillExecuting.mock,
		params: &ExecutionBrokerIMockPrevExecutorStillExecutingParams{ctx},
	}
	mmPrevExecutorStillExecuting.expectations = append(mmPrevExecutorStillExecuting.expectations, expectation)
	return expectation
}

// Then sets up ExecutionBrokerI.PrevExecutorStillExecuting return parameters for the expectation previously defined by the When method
func (e *ExecutionBrokerIMockPrevExecutorStillExecutingExpectation) Then(err error) *ExecutionBrokerIMock {
	e.results = &ExecutionBrokerIMockPrevExecutorStillExecutingResults{err}
	return e.mock
}

// PrevExecutorStillExecuting implements ExecutionBrokerI
func (mmPrevExecutorStillExecuting *ExecutionBrokerIMock) PrevExecutorStillExecuting(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmPrevExecutorStillExecuting.beforePrevExecutorStillExecutingCounter, 1)
	defer mm_atomic.AddUint64(&mmPrevExecutorStillExecuting.afterPrevExecutorStillExecutingCounter, 1)

	if mmPrevExecutorStillExecuting.inspectFuncPrevExecutorStillExecuting != nil {
		mmPrevExecutorStillExecuting.inspectFuncPrevExecutorStillExecuting(ctx)
	}

	mm_params := &ExecutionBrokerIMockPrevExecutorStillExecutingParams{ctx}

	// Record call args
	mmPrevExecutorStillExecuting.PrevExecutorStillExecutingMock.mutex.Lock()
	mmPrevExecutorStillExecuting.PrevExecutorStillExecutingMock.callArgs = append(mmPrevExecutorStillExecuting.PrevExecutorStillExecutingMock.callArgs, mm_params)
	mmPrevExecutorStillExecuting.PrevExecutorStillExecutingMock.mutex.Unlock()

	for _, e := range mmPrevExecutorStillExecuting.PrevExecutorStillExecutingMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPrevExecutorStillExecuting.PrevExecutorStillExecutingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrevExecutorStillExecuting.PrevExecutorStillExecutingMock.defaultExpectation.Counter, 1)
		mm_want := mmPrevExecutorStillExecuting.PrevExecutorStillExecutingMock.defaultExpectation.params
		mm_got := ExecutionBrokerIMockPrevExecutorStillExecutingParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPrevExecutorStillExecuting.t.Errorf("ExecutionBrokerIMock.PrevExecutorStillExecuting got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPrevExecutorStillExecuting.PrevExecutorStillExecutingMock.defaultExpectation.results
		if mm_results == nil {
			mmPrevExecutorStillExecuting.t.Fatal("No results are set for the ExecutionBrokerIMock.PrevExecutorStillExecuting")
		}
		return (*mm_results).err
	}
	if mmPrevExecutorStillExecuting.funcPrevExecutorStillExecuting != nil {
		return mmPrevExecutorStillExecuting.funcPrevExecutorStillExecuting(ctx)
	}
	mmPrevExecutorStillExecuting.t.Fatalf("Unexpected call to ExecutionBrokerIMock.PrevExecutorStillExecuting. %v", ctx)
	return
}

// PrevExecutorStillExecutingAfterCounter returns a count of finished ExecutionBrokerIMock.PrevExecutorStillExecuting invocations
func (mmPrevExecutorStillExecuting *ExecutionBrokerIMock) PrevExecutorStillExecutingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrevExecutorStillExecuting.afterPrevExecutorStillExecutingCounter)
}

// PrevExecutorStillExecutingBeforeCounter returns a count of ExecutionBrokerIMock.PrevExecutorStillExecuting invocations
func (mmPrevExecutorStillExecuting *ExecutionBrokerIMock) PrevExecutorStillExecutingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrevExecutorStillExecuting.beforePrevExecutorStillExecutingCounter)
}

// Calls returns a list of arguments used in each call to ExecutionBrokerIMock.PrevExecutorStillExecuting.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrevExecutorStillExecuting *mExecutionBrokerIMockPrevExecutorStillExecuting) Calls() []*ExecutionBrokerIMockPrevExecutorStillExecutingParams {
	mmPrevExecutorStillExecuting.mutex.RLock()

	argCopy := make([]*ExecutionBrokerIMockPrevExecutorStillExecutingParams, len(mmPrevExecutorStillExecuting.callArgs))
	copy(argCopy, mmPrevExecutorStillExecuting.callArgs)

	mmPrevExecutorStillExecuting.mutex.RUnlock()

	return argCopy
}

// MinimockPrevExecutorStillExecutingDone returns true if the count of the PrevExecutorStillExecuting invocations corresponds
// the number of defined expectations
func (m *ExecutionBrokerIMock) MinimockPrevExecutorStillExecutingDone() bool {
	for _, e := range m.PrevExecutorStillExecutingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrevExecutorStillExecutingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrevExecutorStillExecutingCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrevExecutorStillExecuting != nil && mm_atomic.LoadUint64(&m.afterPrevExecutorStillExecutingCounter) < 1 {
		return false
	}
	return true
}

// MinimockPrevExecutorStillExecutingInspect logs each unmet expectation
func (m *ExecutionBrokerIMock) MinimockPrevExecutorStillExecutingInspect() {
	for _, e := range m.PrevExecutorStillExecutingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.PrevExecutorStillExecuting with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrevExecutorStillExecutingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrevExecutorStillExecutingCounter) < 1 {
		if m.PrevExecutorStillExecutingMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionBrokerIMock.PrevExecutorStillExecuting")
		} else {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.PrevExecutorStillExecuting with params: %#v", *m.PrevExecutorStillExecutingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrevExecutorStillExecuting != nil && mm_atomic.LoadUint64(&m.afterPrevExecutorStillExecutingCounter) < 1 {
		m.t.Error("Expected call to ExecutionBrokerIMock.PrevExecutorStillExecuting")
	}
}

type mExecutionBrokerIMockSetNotPending struct {
	mock               *ExecutionBrokerIMock
	defaultExpectation *ExecutionBrokerIMockSetNotPendingExpectation
	expectations       []*ExecutionBrokerIMockSetNotPendingExpectation

	callArgs []*ExecutionBrokerIMockSetNotPendingParams
	mutex    sync.RWMutex
}

// ExecutionBrokerIMockSetNotPendingExpectation specifies expectation struct of the ExecutionBrokerI.SetNotPending
type ExecutionBrokerIMockSetNotPendingExpectation struct {
	mock   *ExecutionBrokerIMock
	params *ExecutionBrokerIMockSetNotPendingParams

	Counter uint64
}

// ExecutionBrokerIMockSetNotPendingParams contains parameters of the ExecutionBrokerI.SetNotPending
type ExecutionBrokerIMockSetNotPendingParams struct {
	ctx context.Context
}

// Expect sets up expected params for ExecutionBrokerI.SetNotPending
func (mmSetNotPending *mExecutionBrokerIMockSetNotPending) Expect(ctx context.Context) *mExecutionBrokerIMockSetNotPending {
	if mmSetNotPending.mock.funcSetNotPending != nil {
		mmSetNotPending.mock.t.Fatalf("ExecutionBrokerIMock.SetNotPending mock is already set by Set")
	}

	if mmSetNotPending.defaultExpectation == nil {
		mmSetNotPending.defaultExpectation = &ExecutionBrokerIMockSetNotPendingExpectation{}
	}

	mmSetNotPending.defaultExpectation.params = &ExecutionBrokerIMockSetNotPendingParams{ctx}
	for _, e := range mmSetNotPending.expectations {
		if minimock.Equal(e.params, mmSetNotPending.defaultExpectation.params) {
			mmSetNotPending.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetNotPending.defaultExpectation.params)
		}
	}

	return mmSetNotPending
}

// Inspect accepts an inspector function that has same arguments as the ExecutionBrokerI.SetNotPending
func (mmSetNotPending *mExecutionBrokerIMockSetNotPending) Inspect(f func(ctx context.Context)) *mExecutionBrokerIMockSetNotPending {
	if mmSetNotPending.mock.inspectFuncSetNotPending != nil {
		mmSetNotPending.mock.t.Fatalf("Inspect function is already set for ExecutionBrokerIMock.SetNotPending")
	}

	mmSetNotPending.mock.inspectFuncSetNotPending = f

	return mmSetNotPending
}

// Return sets up results that will be returned by ExecutionBrokerI.SetNotPending
func (mmSetNotPending *mExecutionBrokerIMockSetNotPending) Return() *ExecutionBrokerIMock {
	if mmSetNotPending.mock.funcSetNotPending != nil {
		mmSetNotPending.mock.t.Fatalf("ExecutionBrokerIMock.SetNotPending mock is already set by Set")
	}

	if mmSetNotPending.defaultExpectation == nil {
		mmSetNotPending.defaultExpectation = &ExecutionBrokerIMockSetNotPendingExpectation{mock: mmSetNotPending.mock}
	}

	return mmSetNotPending.mock
}

//Set uses given function f to mock the ExecutionBrokerI.SetNotPending method
func (mmSetNotPending *mExecutionBrokerIMockSetNotPending) Set(f func(ctx context.Context)) *ExecutionBrokerIMock {
	if mmSetNotPending.defaultExpectation != nil {
		mmSetNotPending.mock.t.Fatalf("Default expectation is already set for the ExecutionBrokerI.SetNotPending method")
	}

	if len(mmSetNotPending.expectations) > 0 {
		mmSetNotPending.mock.t.Fatalf("Some expectations are already set for the ExecutionBrokerI.SetNotPending method")
	}

	mmSetNotPending.mock.funcSetNotPending = f
	return mmSetNotPending.mock
}

// SetNotPending implements ExecutionBrokerI
func (mmSetNotPending *ExecutionBrokerIMock) SetNotPending(ctx context.Context) {
	mm_atomic.AddUint64(&mmSetNotPending.beforeSetNotPendingCounter, 1)
	defer mm_atomic.AddUint64(&mmSetNotPending.afterSetNotPendingCounter, 1)

	if mmSetNotPending.inspectFuncSetNotPending != nil {
		mmSetNotPending.inspectFuncSetNotPending(ctx)
	}

	mm_params := &ExecutionBrokerIMockSetNotPendingParams{ctx}

	// Record call args
	mmSetNotPending.SetNotPendingMock.mutex.Lock()
	mmSetNotPending.SetNotPendingMock.callArgs = append(mmSetNotPending.SetNotPendingMock.callArgs, mm_params)
	mmSetNotPending.SetNotPendingMock.mutex.Unlock()

	for _, e := range mmSetNotPending.SetNotPendingMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetNotPending.SetNotPendingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetNotPending.SetNotPendingMock.defaultExpectation.Counter, 1)
		mm_want := mmSetNotPending.SetNotPendingMock.defaultExpectation.params
		mm_got := ExecutionBrokerIMockSetNotPendingParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetNotPending.t.Errorf("ExecutionBrokerIMock.SetNotPending got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetNotPending.funcSetNotPending != nil {
		mmSetNotPending.funcSetNotPending(ctx)
		return
	}
	mmSetNotPending.t.Fatalf("Unexpected call to ExecutionBrokerIMock.SetNotPending. %v", ctx)

}

// SetNotPendingAfterCounter returns a count of finished ExecutionBrokerIMock.SetNotPending invocations
func (mmSetNotPending *ExecutionBrokerIMock) SetNotPendingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetNotPending.afterSetNotPendingCounter)
}

// SetNotPendingBeforeCounter returns a count of ExecutionBrokerIMock.SetNotPending invocations
func (mmSetNotPending *ExecutionBrokerIMock) SetNotPendingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetNotPending.beforeSetNotPendingCounter)
}

// Calls returns a list of arguments used in each call to ExecutionBrokerIMock.SetNotPending.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetNotPending *mExecutionBrokerIMockSetNotPending) Calls() []*ExecutionBrokerIMockSetNotPendingParams {
	mmSetNotPending.mutex.RLock()

	argCopy := make([]*ExecutionBrokerIMockSetNotPendingParams, len(mmSetNotPending.callArgs))
	copy(argCopy, mmSetNotPending.callArgs)

	mmSetNotPending.mutex.RUnlock()

	return argCopy
}

// MinimockSetNotPendingDone returns true if the count of the SetNotPending invocations corresponds
// the number of defined expectations
func (m *ExecutionBrokerIMock) MinimockSetNotPendingDone() bool {
	for _, e := range m.SetNotPendingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetNotPendingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetNotPendingCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetNotPending != nil && mm_atomic.LoadUint64(&m.afterSetNotPendingCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetNotPendingInspect logs each unmet expectation
func (m *ExecutionBrokerIMock) MinimockSetNotPendingInspect() {
	for _, e := range m.SetNotPendingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.SetNotPending with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetNotPendingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetNotPendingCounter) < 1 {
		if m.SetNotPendingMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionBrokerIMock.SetNotPending")
		} else {
			m.t.Errorf("Expected call to ExecutionBrokerIMock.SetNotPending with params: %#v", *m.SetNotPendingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetNotPending != nil && mm_atomic.LoadUint64(&m.afterSetNotPendingCounter) < 1 {
		m.t.Error("Expected call to ExecutionBrokerIMock.SetNotPending")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ExecutionBrokerIMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAbandonedRequestsOnLedgerInspect()

		m.MinimockHasMoreRequestsInspect()

		m.MinimockOnPulseInspect()

		m.MinimockPendingStateInspect()

		m.MinimockPrevExecutorPendingResultInspect()

		m.MinimockPrevExecutorSentPendingFinishedInspect()

		m.MinimockPrevExecutorStillExecutingInspect()

		m.MinimockSetNotPendingInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ExecutionBrokerIMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ExecutionBrokerIMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAbandonedRequestsOnLedgerDone() &&
		m.MinimockHasMoreRequestsDone() &&
		m.MinimockOnPulseDone() &&
		m.MinimockPendingStateDone() &&
		m.MinimockPrevExecutorPendingResultDone() &&
		m.MinimockPrevExecutorSentPendingFinishedDone() &&
		m.MinimockPrevExecutorStillExecutingDone() &&
		m.MinimockSetNotPendingDone()
}
