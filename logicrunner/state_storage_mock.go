package logicrunner

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/insolar/insolar"
	"github.com/insolar/insolar/insolar/payload"
	"github.com/insolar/insolar/logicrunner/executionregistry"
)

// StateStorageMock implements StateStorage
type StateStorageMock struct {
	t minimock.Tester

	funcGetExecutionRegistry          func(ref insolar.Reference) (e1 executionregistry.ExecutionRegistry)
	inspectFuncGetExecutionRegistry   func(ref insolar.Reference)
	afterGetExecutionRegistryCounter  uint64
	beforeGetExecutionRegistryCounter uint64
	GetExecutionRegistryMock          mStateStorageMockGetExecutionRegistry

	funcGetExecutionState          func(ref insolar.Reference) (e1 ExecutionBrokerI)
	inspectFuncGetExecutionState   func(ref insolar.Reference)
	afterGetExecutionStateCounter  uint64
	beforeGetExecutionStateCounter uint64
	GetExecutionStateMock          mStateStorageMockGetExecutionState

	funcIsEmpty          func() (b1 bool)
	inspectFuncIsEmpty   func()
	afterIsEmptyCounter  uint64
	beforeIsEmptyCounter uint64
	IsEmptyMock          mStateStorageMockIsEmpty

	funcOnPulse          func(ctx context.Context, pulse insolar.Pulse) (m1 map[insolar.Reference][]payload.Payload)
	inspectFuncOnPulse   func(ctx context.Context, pulse insolar.Pulse)
	afterOnPulseCounter  uint64
	beforeOnPulseCounter uint64
	OnPulseMock          mStateStorageMockOnPulse

	funcUpsertExecutionState          func(ref insolar.Reference) (e1 ExecutionBrokerI)
	inspectFuncUpsertExecutionState   func(ref insolar.Reference)
	afterUpsertExecutionStateCounter  uint64
	beforeUpsertExecutionStateCounter uint64
	UpsertExecutionStateMock          mStateStorageMockUpsertExecutionState
}

// NewStateStorageMock returns a mock for StateStorage
func NewStateStorageMock(t minimock.Tester) *StateStorageMock {
	m := &StateStorageMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetExecutionRegistryMock = mStateStorageMockGetExecutionRegistry{mock: m}
	m.GetExecutionRegistryMock.callArgs = []*StateStorageMockGetExecutionRegistryParams{}

	m.GetExecutionStateMock = mStateStorageMockGetExecutionState{mock: m}
	m.GetExecutionStateMock.callArgs = []*StateStorageMockGetExecutionStateParams{}

	m.IsEmptyMock = mStateStorageMockIsEmpty{mock: m}

	m.OnPulseMock = mStateStorageMockOnPulse{mock: m}
	m.OnPulseMock.callArgs = []*StateStorageMockOnPulseParams{}

	m.UpsertExecutionStateMock = mStateStorageMockUpsertExecutionState{mock: m}
	m.UpsertExecutionStateMock.callArgs = []*StateStorageMockUpsertExecutionStateParams{}

	return m
}

type mStateStorageMockGetExecutionRegistry struct {
	mock               *StateStorageMock
	defaultExpectation *StateStorageMockGetExecutionRegistryExpectation
	expectations       []*StateStorageMockGetExecutionRegistryExpectation

	callArgs []*StateStorageMockGetExecutionRegistryParams
	mutex    sync.RWMutex
}

// StateStorageMockGetExecutionRegistryExpectation specifies expectation struct of the StateStorage.GetExecutionRegistry
type StateStorageMockGetExecutionRegistryExpectation struct {
	mock    *StateStorageMock
	params  *StateStorageMockGetExecutionRegistryParams
	results *StateStorageMockGetExecutionRegistryResults
	Counter uint64
}

// StateStorageMockGetExecutionRegistryParams contains parameters of the StateStorage.GetExecutionRegistry
type StateStorageMockGetExecutionRegistryParams struct {
	ref insolar.Reference
}

// StateStorageMockGetExecutionRegistryResults contains results of the StateStorage.GetExecutionRegistry
type StateStorageMockGetExecutionRegistryResults struct {
	e1 executionregistry.ExecutionRegistry
}

// Expect sets up expected params for StateStorage.GetExecutionRegistry
func (mmGetExecutionRegistry *mStateStorageMockGetExecutionRegistry) Expect(ref insolar.Reference) *mStateStorageMockGetExecutionRegistry {
	if mmGetExecutionRegistry.mock.funcGetExecutionRegistry != nil {
		mmGetExecutionRegistry.mock.t.Fatalf("StateStorageMock.GetExecutionRegistry mock is already set by Set")
	}

	if mmGetExecutionRegistry.defaultExpectation == nil {
		mmGetExecutionRegistry.defaultExpectation = &StateStorageMockGetExecutionRegistryExpectation{}
	}

	mmGetExecutionRegistry.defaultExpectation.params = &StateStorageMockGetExecutionRegistryParams{ref}
	for _, e := range mmGetExecutionRegistry.expectations {
		if minimock.Equal(e.params, mmGetExecutionRegistry.defaultExpectation.params) {
			mmGetExecutionRegistry.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetExecutionRegistry.defaultExpectation.params)
		}
	}

	return mmGetExecutionRegistry
}

// Inspect accepts an inspector function that has same arguments as the StateStorage.GetExecutionRegistry
func (mmGetExecutionRegistry *mStateStorageMockGetExecutionRegistry) Inspect(f func(ref insolar.Reference)) *mStateStorageMockGetExecutionRegistry {
	if mmGetExecutionRegistry.mock.inspectFuncGetExecutionRegistry != nil {
		mmGetExecutionRegistry.mock.t.Fatalf("Inspect function is already set for StateStorageMock.GetExecutionRegistry")
	}

	mmGetExecutionRegistry.mock.inspectFuncGetExecutionRegistry = f

	return mmGetExecutionRegistry
}

// Return sets up results that will be returned by StateStorage.GetExecutionRegistry
func (mmGetExecutionRegistry *mStateStorageMockGetExecutionRegistry) Return(e1 executionregistry.ExecutionRegistry) *StateStorageMock {
	if mmGetExecutionRegistry.mock.funcGetExecutionRegistry != nil {
		mmGetExecutionRegistry.mock.t.Fatalf("StateStorageMock.GetExecutionRegistry mock is already set by Set")
	}

	if mmGetExecutionRegistry.defaultExpectation == nil {
		mmGetExecutionRegistry.defaultExpectation = &StateStorageMockGetExecutionRegistryExpectation{mock: mmGetExecutionRegistry.mock}
	}
	mmGetExecutionRegistry.defaultExpectation.results = &StateStorageMockGetExecutionRegistryResults{e1}
	return mmGetExecutionRegistry.mock
}

//Set uses given function f to mock the StateStorage.GetExecutionRegistry method
func (mmGetExecutionRegistry *mStateStorageMockGetExecutionRegistry) Set(f func(ref insolar.Reference) (e1 executionregistry.ExecutionRegistry)) *StateStorageMock {
	if mmGetExecutionRegistry.defaultExpectation != nil {
		mmGetExecutionRegistry.mock.t.Fatalf("Default expectation is already set for the StateStorage.GetExecutionRegistry method")
	}

	if len(mmGetExecutionRegistry.expectations) > 0 {
		mmGetExecutionRegistry.mock.t.Fatalf("Some expectations are already set for the StateStorage.GetExecutionRegistry method")
	}

	mmGetExecutionRegistry.mock.funcGetExecutionRegistry = f
	return mmGetExecutionRegistry.mock
}

// When sets expectation for the StateStorage.GetExecutionRegistry which will trigger the result defined by the following
// Then helper
func (mmGetExecutionRegistry *mStateStorageMockGetExecutionRegistry) When(ref insolar.Reference) *StateStorageMockGetExecutionRegistryExpectation {
	if mmGetExecutionRegistry.mock.funcGetExecutionRegistry != nil {
		mmGetExecutionRegistry.mock.t.Fatalf("StateStorageMock.GetExecutionRegistry mock is already set by Set")
	}

	expectation := &StateStorageMockGetExecutionRegistryExpectation{
		mock:   mmGetExecutionRegistry.mock,
		params: &StateStorageMockGetExecutionRegistryParams{ref},
	}
	mmGetExecutionRegistry.expectations = append(mmGetExecutionRegistry.expectations, expectation)
	return expectation
}

// Then sets up StateStorage.GetExecutionRegistry return parameters for the expectation previously defined by the When method
func (e *StateStorageMockGetExecutionRegistryExpectation) Then(e1 executionregistry.ExecutionRegistry) *StateStorageMock {
	e.results = &StateStorageMockGetExecutionRegistryResults{e1}
	return e.mock
}

// GetExecutionRegistry implements StateStorage
func (mmGetExecutionRegistry *StateStorageMock) GetExecutionRegistry(ref insolar.Reference) (e1 executionregistry.ExecutionRegistry) {
	mm_atomic.AddUint64(&mmGetExecutionRegistry.beforeGetExecutionRegistryCounter, 1)
	defer mm_atomic.AddUint64(&mmGetExecutionRegistry.afterGetExecutionRegistryCounter, 1)

	if mmGetExecutionRegistry.inspectFuncGetExecutionRegistry != nil {
		mmGetExecutionRegistry.inspectFuncGetExecutionRegistry(ref)
	}

	mm_params := &StateStorageMockGetExecutionRegistryParams{ref}

	// Record call args
	mmGetExecutionRegistry.GetExecutionRegistryMock.mutex.Lock()
	mmGetExecutionRegistry.GetExecutionRegistryMock.callArgs = append(mmGetExecutionRegistry.GetExecutionRegistryMock.callArgs, mm_params)
	mmGetExecutionRegistry.GetExecutionRegistryMock.mutex.Unlock()

	for _, e := range mmGetExecutionRegistry.GetExecutionRegistryMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.e1
		}
	}

	if mmGetExecutionRegistry.GetExecutionRegistryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetExecutionRegistry.GetExecutionRegistryMock.defaultExpectation.Counter, 1)
		mm_want := mmGetExecutionRegistry.GetExecutionRegistryMock.defaultExpectation.params
		mm_got := StateStorageMockGetExecutionRegistryParams{ref}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetExecutionRegistry.t.Errorf("StateStorageMock.GetExecutionRegistry got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetExecutionRegistry.GetExecutionRegistryMock.defaultExpectation.results
		if mm_results == nil {
			mmGetExecutionRegistry.t.Fatal("No results are set for the StateStorageMock.GetExecutionRegistry")
		}
		return (*mm_results).e1
	}
	if mmGetExecutionRegistry.funcGetExecutionRegistry != nil {
		return mmGetExecutionRegistry.funcGetExecutionRegistry(ref)
	}
	mmGetExecutionRegistry.t.Fatalf("Unexpected call to StateStorageMock.GetExecutionRegistry. %v", ref)
	return
}

// GetExecutionRegistryAfterCounter returns a count of finished StateStorageMock.GetExecutionRegistry invocations
func (mmGetExecutionRegistry *StateStorageMock) GetExecutionRegistryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetExecutionRegistry.afterGetExecutionRegistryCounter)
}

// GetExecutionRegistryBeforeCounter returns a count of StateStorageMock.GetExecutionRegistry invocations
func (mmGetExecutionRegistry *StateStorageMock) GetExecutionRegistryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetExecutionRegistry.beforeGetExecutionRegistryCounter)
}

// Calls returns a list of arguments used in each call to StateStorageMock.GetExecutionRegistry.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetExecutionRegistry *mStateStorageMockGetExecutionRegistry) Calls() []*StateStorageMockGetExecutionRegistryParams {
	mmGetExecutionRegistry.mutex.RLock()

	argCopy := make([]*StateStorageMockGetExecutionRegistryParams, len(mmGetExecutionRegistry.callArgs))
	copy(argCopy, mmGetExecutionRegistry.callArgs)

	mmGetExecutionRegistry.mutex.RUnlock()

	return argCopy
}

// MinimockGetExecutionRegistryDone returns true if the count of the GetExecutionRegistry invocations corresponds
// the number of defined expectations
func (m *StateStorageMock) MinimockGetExecutionRegistryDone() bool {
	for _, e := range m.GetExecutionRegistryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetExecutionRegistryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetExecutionRegistryCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetExecutionRegistry != nil && mm_atomic.LoadUint64(&m.afterGetExecutionRegistryCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetExecutionRegistryInspect logs each unmet expectation
func (m *StateStorageMock) MinimockGetExecutionRegistryInspect() {
	for _, e := range m.GetExecutionRegistryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StateStorageMock.GetExecutionRegistry with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetExecutionRegistryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetExecutionRegistryCounter) < 1 {
		if m.GetExecutionRegistryMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StateStorageMock.GetExecutionRegistry")
		} else {
			m.t.Errorf("Expected call to StateStorageMock.GetExecutionRegistry with params: %#v", *m.GetExecutionRegistryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetExecutionRegistry != nil && mm_atomic.LoadUint64(&m.afterGetExecutionRegistryCounter) < 1 {
		m.t.Error("Expected call to StateStorageMock.GetExecutionRegistry")
	}
}

type mStateStorageMockGetExecutionState struct {
	mock               *StateStorageMock
	defaultExpectation *StateStorageMockGetExecutionStateExpectation
	expectations       []*StateStorageMockGetExecutionStateExpectation

	callArgs []*StateStorageMockGetExecutionStateParams
	mutex    sync.RWMutex
}

// StateStorageMockGetExecutionStateExpectation specifies expectation struct of the StateStorage.GetExecutionState
type StateStorageMockGetExecutionStateExpectation struct {
	mock    *StateStorageMock
	params  *StateStorageMockGetExecutionStateParams
	results *StateStorageMockGetExecutionStateResults
	Counter uint64
}

// StateStorageMockGetExecutionStateParams contains parameters of the StateStorage.GetExecutionState
type StateStorageMockGetExecutionStateParams struct {
	ref insolar.Reference
}

// StateStorageMockGetExecutionStateResults contains results of the StateStorage.GetExecutionState
type StateStorageMockGetExecutionStateResults struct {
	e1 ExecutionBrokerI
}

// Expect sets up expected params for StateStorage.GetExecutionState
func (mmGetExecutionState *mStateStorageMockGetExecutionState) Expect(ref insolar.Reference) *mStateStorageMockGetExecutionState {
	if mmGetExecutionState.mock.funcGetExecutionState != nil {
		mmGetExecutionState.mock.t.Fatalf("StateStorageMock.GetExecutionState mock is already set by Set")
	}

	if mmGetExecutionState.defaultExpectation == nil {
		mmGetExecutionState.defaultExpectation = &StateStorageMockGetExecutionStateExpectation{}
	}

	mmGetExecutionState.defaultExpectation.params = &StateStorageMockGetExecutionStateParams{ref}
	for _, e := range mmGetExecutionState.expectations {
		if minimock.Equal(e.params, mmGetExecutionState.defaultExpectation.params) {
			mmGetExecutionState.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetExecutionState.defaultExpectation.params)
		}
	}

	return mmGetExecutionState
}

// Inspect accepts an inspector function that has same arguments as the StateStorage.GetExecutionState
func (mmGetExecutionState *mStateStorageMockGetExecutionState) Inspect(f func(ref insolar.Reference)) *mStateStorageMockGetExecutionState {
	if mmGetExecutionState.mock.inspectFuncGetExecutionState != nil {
		mmGetExecutionState.mock.t.Fatalf("Inspect function is already set for StateStorageMock.GetExecutionState")
	}

	mmGetExecutionState.mock.inspectFuncGetExecutionState = f

	return mmGetExecutionState
}

// Return sets up results that will be returned by StateStorage.GetExecutionState
func (mmGetExecutionState *mStateStorageMockGetExecutionState) Return(e1 ExecutionBrokerI) *StateStorageMock {
	if mmGetExecutionState.mock.funcGetExecutionState != nil {
		mmGetExecutionState.mock.t.Fatalf("StateStorageMock.GetExecutionState mock is already set by Set")
	}

	if mmGetExecutionState.defaultExpectation == nil {
		mmGetExecutionState.defaultExpectation = &StateStorageMockGetExecutionStateExpectation{mock: mmGetExecutionState.mock}
	}
	mmGetExecutionState.defaultExpectation.results = &StateStorageMockGetExecutionStateResults{e1}
	return mmGetExecutionState.mock
}

//Set uses given function f to mock the StateStorage.GetExecutionState method
func (mmGetExecutionState *mStateStorageMockGetExecutionState) Set(f func(ref insolar.Reference) (e1 ExecutionBrokerI)) *StateStorageMock {
	if mmGetExecutionState.defaultExpectation != nil {
		mmGetExecutionState.mock.t.Fatalf("Default expectation is already set for the StateStorage.GetExecutionState method")
	}

	if len(mmGetExecutionState.expectations) > 0 {
		mmGetExecutionState.mock.t.Fatalf("Some expectations are already set for the StateStorage.GetExecutionState method")
	}

	mmGetExecutionState.mock.funcGetExecutionState = f
	return mmGetExecutionState.mock
}

// When sets expectation for the StateStorage.GetExecutionState which will trigger the result defined by the following
// Then helper
func (mmGetExecutionState *mStateStorageMockGetExecutionState) When(ref insolar.Reference) *StateStorageMockGetExecutionStateExpectation {
	if mmGetExecutionState.mock.funcGetExecutionState != nil {
		mmGetExecutionState.mock.t.Fatalf("StateStorageMock.GetExecutionState mock is already set by Set")
	}

	expectation := &StateStorageMockGetExecutionStateExpectation{
		mock:   mmGetExecutionState.mock,
		params: &StateStorageMockGetExecutionStateParams{ref},
	}
	mmGetExecutionState.expectations = append(mmGetExecutionState.expectations, expectation)
	return expectation
}

// Then sets up StateStorage.GetExecutionState return parameters for the expectation previously defined by the When method
func (e *StateStorageMockGetExecutionStateExpectation) Then(e1 ExecutionBrokerI) *StateStorageMock {
	e.results = &StateStorageMockGetExecutionStateResults{e1}
	return e.mock
}

// GetExecutionState implements StateStorage
func (mmGetExecutionState *StateStorageMock) GetExecutionState(ref insolar.Reference) (e1 ExecutionBrokerI) {
	mm_atomic.AddUint64(&mmGetExecutionState.beforeGetExecutionStateCounter, 1)
	defer mm_atomic.AddUint64(&mmGetExecutionState.afterGetExecutionStateCounter, 1)

	if mmGetExecutionState.inspectFuncGetExecutionState != nil {
		mmGetExecutionState.inspectFuncGetExecutionState(ref)
	}

	mm_params := &StateStorageMockGetExecutionStateParams{ref}

	// Record call args
	mmGetExecutionState.GetExecutionStateMock.mutex.Lock()
	mmGetExecutionState.GetExecutionStateMock.callArgs = append(mmGetExecutionState.GetExecutionStateMock.callArgs, mm_params)
	mmGetExecutionState.GetExecutionStateMock.mutex.Unlock()

	for _, e := range mmGetExecutionState.GetExecutionStateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.e1
		}
	}

	if mmGetExecutionState.GetExecutionStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetExecutionState.GetExecutionStateMock.defaultExpectation.Counter, 1)
		mm_want := mmGetExecutionState.GetExecutionStateMock.defaultExpectation.params
		mm_got := StateStorageMockGetExecutionStateParams{ref}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetExecutionState.t.Errorf("StateStorageMock.GetExecutionState got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetExecutionState.GetExecutionStateMock.defaultExpectation.results
		if mm_results == nil {
			mmGetExecutionState.t.Fatal("No results are set for the StateStorageMock.GetExecutionState")
		}
		return (*mm_results).e1
	}
	if mmGetExecutionState.funcGetExecutionState != nil {
		return mmGetExecutionState.funcGetExecutionState(ref)
	}
	mmGetExecutionState.t.Fatalf("Unexpected call to StateStorageMock.GetExecutionState. %v", ref)
	return
}

// GetExecutionStateAfterCounter returns a count of finished StateStorageMock.GetExecutionState invocations
func (mmGetExecutionState *StateStorageMock) GetExecutionStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetExecutionState.afterGetExecutionStateCounter)
}

// GetExecutionStateBeforeCounter returns a count of StateStorageMock.GetExecutionState invocations
func (mmGetExecutionState *StateStorageMock) GetExecutionStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetExecutionState.beforeGetExecutionStateCounter)
}

// Calls returns a list of arguments used in each call to StateStorageMock.GetExecutionState.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetExecutionState *mStateStorageMockGetExecutionState) Calls() []*StateStorageMockGetExecutionStateParams {
	mmGetExecutionState.mutex.RLock()

	argCopy := make([]*StateStorageMockGetExecutionStateParams, len(mmGetExecutionState.callArgs))
	copy(argCopy, mmGetExecutionState.callArgs)

	mmGetExecutionState.mutex.RUnlock()

	return argCopy
}

// MinimockGetExecutionStateDone returns true if the count of the GetExecutionState invocations corresponds
// the number of defined expectations
func (m *StateStorageMock) MinimockGetExecutionStateDone() bool {
	for _, e := range m.GetExecutionStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetExecutionStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetExecutionStateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetExecutionState != nil && mm_atomic.LoadUint64(&m.afterGetExecutionStateCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetExecutionStateInspect logs each unmet expectation
func (m *StateStorageMock) MinimockGetExecutionStateInspect() {
	for _, e := range m.GetExecutionStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StateStorageMock.GetExecutionState with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetExecutionStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetExecutionStateCounter) < 1 {
		if m.GetExecutionStateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StateStorageMock.GetExecutionState")
		} else {
			m.t.Errorf("Expected call to StateStorageMock.GetExecutionState with params: %#v", *m.GetExecutionStateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetExecutionState != nil && mm_atomic.LoadUint64(&m.afterGetExecutionStateCounter) < 1 {
		m.t.Error("Expected call to StateStorageMock.GetExecutionState")
	}
}

type mStateStorageMockIsEmpty struct {
	mock               *StateStorageMock
	defaultExpectation *StateStorageMockIsEmptyExpectation
	expectations       []*StateStorageMockIsEmptyExpectation
}

// StateStorageMockIsEmptyExpectation specifies expectation struct of the StateStorage.IsEmpty
type StateStorageMockIsEmptyExpectation struct {
	mock *StateStorageMock

	results *StateStorageMockIsEmptyResults
	Counter uint64
}

// StateStorageMockIsEmptyResults contains results of the StateStorage.IsEmpty
type StateStorageMockIsEmptyResults struct {
	b1 bool
}

// Expect sets up expected params for StateStorage.IsEmpty
func (mmIsEmpty *mStateStorageMockIsEmpty) Expect() *mStateStorageMockIsEmpty {
	if mmIsEmpty.mock.funcIsEmpty != nil {
		mmIsEmpty.mock.t.Fatalf("StateStorageMock.IsEmpty mock is already set by Set")
	}

	if mmIsEmpty.defaultExpectation == nil {
		mmIsEmpty.defaultExpectation = &StateStorageMockIsEmptyExpectation{}
	}

	return mmIsEmpty
}

// Inspect accepts an inspector function that has same arguments as the StateStorage.IsEmpty
func (mmIsEmpty *mStateStorageMockIsEmpty) Inspect(f func()) *mStateStorageMockIsEmpty {
	if mmIsEmpty.mock.inspectFuncIsEmpty != nil {
		mmIsEmpty.mock.t.Fatalf("Inspect function is already set for StateStorageMock.IsEmpty")
	}

	mmIsEmpty.mock.inspectFuncIsEmpty = f

	return mmIsEmpty
}

// Return sets up results that will be returned by StateStorage.IsEmpty
func (mmIsEmpty *mStateStorageMockIsEmpty) Return(b1 bool) *StateStorageMock {
	if mmIsEmpty.mock.funcIsEmpty != nil {
		mmIsEmpty.mock.t.Fatalf("StateStorageMock.IsEmpty mock is already set by Set")
	}

	if mmIsEmpty.defaultExpectation == nil {
		mmIsEmpty.defaultExpectation = &StateStorageMockIsEmptyExpectation{mock: mmIsEmpty.mock}
	}
	mmIsEmpty.defaultExpectation.results = &StateStorageMockIsEmptyResults{b1}
	return mmIsEmpty.mock
}

//Set uses given function f to mock the StateStorage.IsEmpty method
func (mmIsEmpty *mStateStorageMockIsEmpty) Set(f func() (b1 bool)) *StateStorageMock {
	if mmIsEmpty.defaultExpectation != nil {
		mmIsEmpty.mock.t.Fatalf("Default expectation is already set for the StateStorage.IsEmpty method")
	}

	if len(mmIsEmpty.expectations) > 0 {
		mmIsEmpty.mock.t.Fatalf("Some expectations are already set for the StateStorage.IsEmpty method")
	}

	mmIsEmpty.mock.funcIsEmpty = f
	return mmIsEmpty.mock
}

// IsEmpty implements StateStorage
func (mmIsEmpty *StateStorageMock) IsEmpty() (b1 bool) {
	mm_atomic.AddUint64(&mmIsEmpty.beforeIsEmptyCounter, 1)
	defer mm_atomic.AddUint64(&mmIsEmpty.afterIsEmptyCounter, 1)

	if mmIsEmpty.inspectFuncIsEmpty != nil {
		mmIsEmpty.inspectFuncIsEmpty()
	}

	if mmIsEmpty.IsEmptyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsEmpty.IsEmptyMock.defaultExpectation.Counter, 1)

		mm_results := mmIsEmpty.IsEmptyMock.defaultExpectation.results
		if mm_results == nil {
			mmIsEmpty.t.Fatal("No results are set for the StateStorageMock.IsEmpty")
		}
		return (*mm_results).b1
	}
	if mmIsEmpty.funcIsEmpty != nil {
		return mmIsEmpty.funcIsEmpty()
	}
	mmIsEmpty.t.Fatalf("Unexpected call to StateStorageMock.IsEmpty.")
	return
}

// IsEmptyAfterCounter returns a count of finished StateStorageMock.IsEmpty invocations
func (mmIsEmpty *StateStorageMock) IsEmptyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsEmpty.afterIsEmptyCounter)
}

// IsEmptyBeforeCounter returns a count of StateStorageMock.IsEmpty invocations
func (mmIsEmpty *StateStorageMock) IsEmptyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsEmpty.beforeIsEmptyCounter)
}

// MinimockIsEmptyDone returns true if the count of the IsEmpty invocations corresponds
// the number of defined expectations
func (m *StateStorageMock) MinimockIsEmptyDone() bool {
	for _, e := range m.IsEmptyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsEmptyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsEmptyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsEmpty != nil && mm_atomic.LoadUint64(&m.afterIsEmptyCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsEmptyInspect logs each unmet expectation
func (m *StateStorageMock) MinimockIsEmptyInspect() {
	for _, e := range m.IsEmptyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StateStorageMock.IsEmpty")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsEmptyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsEmptyCounter) < 1 {
		m.t.Error("Expected call to StateStorageMock.IsEmpty")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsEmpty != nil && mm_atomic.LoadUint64(&m.afterIsEmptyCounter) < 1 {
		m.t.Error("Expected call to StateStorageMock.IsEmpty")
	}
}

type mStateStorageMockOnPulse struct {
	mock               *StateStorageMock
	defaultExpectation *StateStorageMockOnPulseExpectation
	expectations       []*StateStorageMockOnPulseExpectation

	callArgs []*StateStorageMockOnPulseParams
	mutex    sync.RWMutex
}

// StateStorageMockOnPulseExpectation specifies expectation struct of the StateStorage.OnPulse
type StateStorageMockOnPulseExpectation struct {
	mock    *StateStorageMock
	params  *StateStorageMockOnPulseParams
	results *StateStorageMockOnPulseResults
	Counter uint64
}

// StateStorageMockOnPulseParams contains parameters of the StateStorage.OnPulse
type StateStorageMockOnPulseParams struct {
	ctx   context.Context
	pulse insolar.Pulse
}

// StateStorageMockOnPulseResults contains results of the StateStorage.OnPulse
type StateStorageMockOnPulseResults struct {
	m1 map[insolar.Reference][]payload.Payload
}

// Expect sets up expected params for StateStorage.OnPulse
func (mmOnPulse *mStateStorageMockOnPulse) Expect(ctx context.Context, pulse insolar.Pulse) *mStateStorageMockOnPulse {
	if mmOnPulse.mock.funcOnPulse != nil {
		mmOnPulse.mock.t.Fatalf("StateStorageMock.OnPulse mock is already set by Set")
	}

	if mmOnPulse.defaultExpectation == nil {
		mmOnPulse.defaultExpectation = &StateStorageMockOnPulseExpectation{}
	}

	mmOnPulse.defaultExpectation.params = &StateStorageMockOnPulseParams{ctx, pulse}
	for _, e := range mmOnPulse.expectations {
		if minimock.Equal(e.params, mmOnPulse.defaultExpectation.params) {
			mmOnPulse.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOnPulse.defaultExpectation.params)
		}
	}

	return mmOnPulse
}

// Inspect accepts an inspector function that has same arguments as the StateStorage.OnPulse
func (mmOnPulse *mStateStorageMockOnPulse) Inspect(f func(ctx context.Context, pulse insolar.Pulse)) *mStateStorageMockOnPulse {
	if mmOnPulse.mock.inspectFuncOnPulse != nil {
		mmOnPulse.mock.t.Fatalf("Inspect function is already set for StateStorageMock.OnPulse")
	}

	mmOnPulse.mock.inspectFuncOnPulse = f

	return mmOnPulse
}

// Return sets up results that will be returned by StateStorage.OnPulse
func (mmOnPulse *mStateStorageMockOnPulse) Return(m1 map[insolar.Reference][]payload.Payload) *StateStorageMock {
	if mmOnPulse.mock.funcOnPulse != nil {
		mmOnPulse.mock.t.Fatalf("StateStorageMock.OnPulse mock is already set by Set")
	}

	if mmOnPulse.defaultExpectation == nil {
		mmOnPulse.defaultExpectation = &StateStorageMockOnPulseExpectation{mock: mmOnPulse.mock}
	}
	mmOnPulse.defaultExpectation.results = &StateStorageMockOnPulseResults{m1}
	return mmOnPulse.mock
}

//Set uses given function f to mock the StateStorage.OnPulse method
func (mmOnPulse *mStateStorageMockOnPulse) Set(f func(ctx context.Context, pulse insolar.Pulse) (m1 map[insolar.Reference][]payload.Payload)) *StateStorageMock {
	if mmOnPulse.defaultExpectation != nil {
		mmOnPulse.mock.t.Fatalf("Default expectation is already set for the StateStorage.OnPulse method")
	}

	if len(mmOnPulse.expectations) > 0 {
		mmOnPulse.mock.t.Fatalf("Some expectations are already set for the StateStorage.OnPulse method")
	}

	mmOnPulse.mock.funcOnPulse = f
	return mmOnPulse.mock
}

// When sets expectation for the StateStorage.OnPulse which will trigger the result defined by the following
// Then helper
func (mmOnPulse *mStateStorageMockOnPulse) When(ctx context.Context, pulse insolar.Pulse) *StateStorageMockOnPulseExpectation {
	if mmOnPulse.mock.funcOnPulse != nil {
		mmOnPulse.mock.t.Fatalf("StateStorageMock.OnPulse mock is already set by Set")
	}

	expectation := &StateStorageMockOnPulseExpectation{
		mock:   mmOnPulse.mock,
		params: &StateStorageMockOnPulseParams{ctx, pulse},
	}
	mmOnPulse.expectations = append(mmOnPulse.expectations, expectation)
	return expectation
}

// Then sets up StateStorage.OnPulse return parameters for the expectation previously defined by the When method
func (e *StateStorageMockOnPulseExpectation) Then(m1 map[insolar.Reference][]payload.Payload) *StateStorageMock {
	e.results = &StateStorageMockOnPulseResults{m1}
	return e.mock
}

// OnPulse implements StateStorage
func (mmOnPulse *StateStorageMock) OnPulse(ctx context.Context, pulse insolar.Pulse) (m1 map[insolar.Reference][]payload.Payload) {
	mm_atomic.AddUint64(&mmOnPulse.beforeOnPulseCounter, 1)
	defer mm_atomic.AddUint64(&mmOnPulse.afterOnPulseCounter, 1)

	if mmOnPulse.inspectFuncOnPulse != nil {
		mmOnPulse.inspectFuncOnPulse(ctx, pulse)
	}

	mm_params := &StateStorageMockOnPulseParams{ctx, pulse}

	// Record call args
	mmOnPulse.OnPulseMock.mutex.Lock()
	mmOnPulse.OnPulseMock.callArgs = append(mmOnPulse.OnPulseMock.callArgs, mm_params)
	mmOnPulse.OnPulseMock.mutex.Unlock()

	for _, e := range mmOnPulse.OnPulseMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1
		}
	}

	if mmOnPulse.OnPulseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOnPulse.OnPulseMock.defaultExpectation.Counter, 1)
		mm_want := mmOnPulse.OnPulseMock.defaultExpectation.params
		mm_got := StateStorageMockOnPulseParams{ctx, pulse}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOnPulse.t.Errorf("StateStorageMock.OnPulse got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOnPulse.OnPulseMock.defaultExpectation.results
		if mm_results == nil {
			mmOnPulse.t.Fatal("No results are set for the StateStorageMock.OnPulse")
		}
		return (*mm_results).m1
	}
	if mmOnPulse.funcOnPulse != nil {
		return mmOnPulse.funcOnPulse(ctx, pulse)
	}
	mmOnPulse.t.Fatalf("Unexpected call to StateStorageMock.OnPulse. %v %v", ctx, pulse)
	return
}

// OnPulseAfterCounter returns a count of finished StateStorageMock.OnPulse invocations
func (mmOnPulse *StateStorageMock) OnPulseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOnPulse.afterOnPulseCounter)
}

// OnPulseBeforeCounter returns a count of StateStorageMock.OnPulse invocations
func (mmOnPulse *StateStorageMock) OnPulseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOnPulse.beforeOnPulseCounter)
}

// Calls returns a list of arguments used in each call to StateStorageMock.OnPulse.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOnPulse *mStateStorageMockOnPulse) Calls() []*StateStorageMockOnPulseParams {
	mmOnPulse.mutex.RLock()

	argCopy := make([]*StateStorageMockOnPulseParams, len(mmOnPulse.callArgs))
	copy(argCopy, mmOnPulse.callArgs)

	mmOnPulse.mutex.RUnlock()

	return argCopy
}

// MinimockOnPulseDone returns true if the count of the OnPulse invocations corresponds
// the number of defined expectations
func (m *StateStorageMock) MinimockOnPulseDone() bool {
	for _, e := range m.OnPulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OnPulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOnPulseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOnPulse != nil && mm_atomic.LoadUint64(&m.afterOnPulseCounter) < 1 {
		return false
	}
	return true
}

// MinimockOnPulseInspect logs each unmet expectation
func (m *StateStorageMock) MinimockOnPulseInspect() {
	for _, e := range m.OnPulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StateStorageMock.OnPulse with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OnPulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOnPulseCounter) < 1 {
		if m.OnPulseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StateStorageMock.OnPulse")
		} else {
			m.t.Errorf("Expected call to StateStorageMock.OnPulse with params: %#v", *m.OnPulseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOnPulse != nil && mm_atomic.LoadUint64(&m.afterOnPulseCounter) < 1 {
		m.t.Error("Expected call to StateStorageMock.OnPulse")
	}
}

type mStateStorageMockUpsertExecutionState struct {
	mock               *StateStorageMock
	defaultExpectation *StateStorageMockUpsertExecutionStateExpectation
	expectations       []*StateStorageMockUpsertExecutionStateExpectation

	callArgs []*StateStorageMockUpsertExecutionStateParams
	mutex    sync.RWMutex
}

// StateStorageMockUpsertExecutionStateExpectation specifies expectation struct of the StateStorage.UpsertExecutionState
type StateStorageMockUpsertExecutionStateExpectation struct {
	mock    *StateStorageMock
	params  *StateStorageMockUpsertExecutionStateParams
	results *StateStorageMockUpsertExecutionStateResults
	Counter uint64
}

// StateStorageMockUpsertExecutionStateParams contains parameters of the StateStorage.UpsertExecutionState
type StateStorageMockUpsertExecutionStateParams struct {
	ref insolar.Reference
}

// StateStorageMockUpsertExecutionStateResults contains results of the StateStorage.UpsertExecutionState
type StateStorageMockUpsertExecutionStateResults struct {
	e1 ExecutionBrokerI
}

// Expect sets up expected params for StateStorage.UpsertExecutionState
func (mmUpsertExecutionState *mStateStorageMockUpsertExecutionState) Expect(ref insolar.Reference) *mStateStorageMockUpsertExecutionState {
	if mmUpsertExecutionState.mock.funcUpsertExecutionState != nil {
		mmUpsertExecutionState.mock.t.Fatalf("StateStorageMock.UpsertExecutionState mock is already set by Set")
	}

	if mmUpsertExecutionState.defaultExpectation == nil {
		mmUpsertExecutionState.defaultExpectation = &StateStorageMockUpsertExecutionStateExpectation{}
	}

	mmUpsertExecutionState.defaultExpectation.params = &StateStorageMockUpsertExecutionStateParams{ref}
	for _, e := range mmUpsertExecutionState.expectations {
		if minimock.Equal(e.params, mmUpsertExecutionState.defaultExpectation.params) {
			mmUpsertExecutionState.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpsertExecutionState.defaultExpectation.params)
		}
	}

	return mmUpsertExecutionState
}

// Inspect accepts an inspector function that has same arguments as the StateStorage.UpsertExecutionState
func (mmUpsertExecutionState *mStateStorageMockUpsertExecutionState) Inspect(f func(ref insolar.Reference)) *mStateStorageMockUpsertExecutionState {
	if mmUpsertExecutionState.mock.inspectFuncUpsertExecutionState != nil {
		mmUpsertExecutionState.mock.t.Fatalf("Inspect function is already set for StateStorageMock.UpsertExecutionState")
	}

	mmUpsertExecutionState.mock.inspectFuncUpsertExecutionState = f

	return mmUpsertExecutionState
}

// Return sets up results that will be returned by StateStorage.UpsertExecutionState
func (mmUpsertExecutionState *mStateStorageMockUpsertExecutionState) Return(e1 ExecutionBrokerI) *StateStorageMock {
	if mmUpsertExecutionState.mock.funcUpsertExecutionState != nil {
		mmUpsertExecutionState.mock.t.Fatalf("StateStorageMock.UpsertExecutionState mock is already set by Set")
	}

	if mmUpsertExecutionState.defaultExpectation == nil {
		mmUpsertExecutionState.defaultExpectation = &StateStorageMockUpsertExecutionStateExpectation{mock: mmUpsertExecutionState.mock}
	}
	mmUpsertExecutionState.defaultExpectation.results = &StateStorageMockUpsertExecutionStateResults{e1}
	return mmUpsertExecutionState.mock
}

//Set uses given function f to mock the StateStorage.UpsertExecutionState method
func (mmUpsertExecutionState *mStateStorageMockUpsertExecutionState) Set(f func(ref insolar.Reference) (e1 ExecutionBrokerI)) *StateStorageMock {
	if mmUpsertExecutionState.defaultExpectation != nil {
		mmUpsertExecutionState.mock.t.Fatalf("Default expectation is already set for the StateStorage.UpsertExecutionState method")
	}

	if len(mmUpsertExecutionState.expectations) > 0 {
		mmUpsertExecutionState.mock.t.Fatalf("Some expectations are already set for the StateStorage.UpsertExecutionState method")
	}

	mmUpsertExecutionState.mock.funcUpsertExecutionState = f
	return mmUpsertExecutionState.mock
}

// When sets expectation for the StateStorage.UpsertExecutionState which will trigger the result defined by the following
// Then helper
func (mmUpsertExecutionState *mStateStorageMockUpsertExecutionState) When(ref insolar.Reference) *StateStorageMockUpsertExecutionStateExpectation {
	if mmUpsertExecutionState.mock.funcUpsertExecutionState != nil {
		mmUpsertExecutionState.mock.t.Fatalf("StateStorageMock.UpsertExecutionState mock is already set by Set")
	}

	expectation := &StateStorageMockUpsertExecutionStateExpectation{
		mock:   mmUpsertExecutionState.mock,
		params: &StateStorageMockUpsertExecutionStateParams{ref},
	}
	mmUpsertExecutionState.expectations = append(mmUpsertExecutionState.expectations, expectation)
	return expectation
}

// Then sets up StateStorage.UpsertExecutionState return parameters for the expectation previously defined by the When method
func (e *StateStorageMockUpsertExecutionStateExpectation) Then(e1 ExecutionBrokerI) *StateStorageMock {
	e.results = &StateStorageMockUpsertExecutionStateResults{e1}
	return e.mock
}

// UpsertExecutionState implements StateStorage
func (mmUpsertExecutionState *StateStorageMock) UpsertExecutionState(ref insolar.Reference) (e1 ExecutionBrokerI) {
	mm_atomic.AddUint64(&mmUpsertExecutionState.beforeUpsertExecutionStateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpsertExecutionState.afterUpsertExecutionStateCounter, 1)

	if mmUpsertExecutionState.inspectFuncUpsertExecutionState != nil {
		mmUpsertExecutionState.inspectFuncUpsertExecutionState(ref)
	}

	mm_params := &StateStorageMockUpsertExecutionStateParams{ref}

	// Record call args
	mmUpsertExecutionState.UpsertExecutionStateMock.mutex.Lock()
	mmUpsertExecutionState.UpsertExecutionStateMock.callArgs = append(mmUpsertExecutionState.UpsertExecutionStateMock.callArgs, mm_params)
	mmUpsertExecutionState.UpsertExecutionStateMock.mutex.Unlock()

	for _, e := range mmUpsertExecutionState.UpsertExecutionStateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.e1
		}
	}

	if mmUpsertExecutionState.UpsertExecutionStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpsertExecutionState.UpsertExecutionStateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpsertExecutionState.UpsertExecutionStateMock.defaultExpectation.params
		mm_got := StateStorageMockUpsertExecutionStateParams{ref}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpsertExecutionState.t.Errorf("StateStorageMock.UpsertExecutionState got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpsertExecutionState.UpsertExecutionStateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpsertExecutionState.t.Fatal("No results are set for the StateStorageMock.UpsertExecutionState")
		}
		return (*mm_results).e1
	}
	if mmUpsertExecutionState.funcUpsertExecutionState != nil {
		return mmUpsertExecutionState.funcUpsertExecutionState(ref)
	}
	mmUpsertExecutionState.t.Fatalf("Unexpected call to StateStorageMock.UpsertExecutionState. %v", ref)
	return
}

// UpsertExecutionStateAfterCounter returns a count of finished StateStorageMock.UpsertExecutionState invocations
func (mmUpsertExecutionState *StateStorageMock) UpsertExecutionStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertExecutionState.afterUpsertExecutionStateCounter)
}

// UpsertExecutionStateBeforeCounter returns a count of StateStorageMock.UpsertExecutionState invocations
func (mmUpsertExecutionState *StateStorageMock) UpsertExecutionStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertExecutionState.beforeUpsertExecutionStateCounter)
}

// Calls returns a list of arguments used in each call to StateStorageMock.UpsertExecutionState.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpsertExecutionState *mStateStorageMockUpsertExecutionState) Calls() []*StateStorageMockUpsertExecutionStateParams {
	mmUpsertExecutionState.mutex.RLock()

	argCopy := make([]*StateStorageMockUpsertExecutionStateParams, len(mmUpsertExecutionState.callArgs))
	copy(argCopy, mmUpsertExecutionState.callArgs)

	mmUpsertExecutionState.mutex.RUnlock()

	return argCopy
}

// MinimockUpsertExecutionStateDone returns true if the count of the UpsertExecutionState invocations corresponds
// the number of defined expectations
func (m *StateStorageMock) MinimockUpsertExecutionStateDone() bool {
	for _, e := range m.UpsertExecutionStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertExecutionStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpsertExecutionStateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertExecutionState != nil && mm_atomic.LoadUint64(&m.afterUpsertExecutionStateCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpsertExecutionStateInspect logs each unmet expectation
func (m *StateStorageMock) MinimockUpsertExecutionStateInspect() {
	for _, e := range m.UpsertExecutionStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StateStorageMock.UpsertExecutionState with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertExecutionStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpsertExecutionStateCounter) < 1 {
		if m.UpsertExecutionStateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StateStorageMock.UpsertExecutionState")
		} else {
			m.t.Errorf("Expected call to StateStorageMock.UpsertExecutionState with params: %#v", *m.UpsertExecutionStateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertExecutionState != nil && mm_atomic.LoadUint64(&m.afterUpsertExecutionStateCounter) < 1 {
		m.t.Error("Expected call to StateStorageMock.UpsertExecutionState")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StateStorageMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetExecutionRegistryInspect()

		m.MinimockGetExecutionStateInspect()

		m.MinimockIsEmptyInspect()

		m.MinimockOnPulseInspect()

		m.MinimockUpsertExecutionStateInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StateStorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StateStorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetExecutionRegistryDone() &&
		m.MinimockGetExecutionStateDone() &&
		m.MinimockIsEmptyDone() &&
		m.MinimockOnPulseDone() &&
		m.MinimockUpsertExecutionStateDone()
}
