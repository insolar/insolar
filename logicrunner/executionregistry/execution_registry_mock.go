package executionregistry

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/insolar"
	"github.com/insolar/insolar/insolar/payload"
	"github.com/insolar/insolar/logicrunner/common"
)

// ExecutionRegistryMock implements ExecutionRegistry
type ExecutionRegistryMock struct {
	t minimock.Tester

	funcDone          func(transcript *common.Transcript) (b1 bool)
	inspectFuncDone   func(transcript *common.Transcript)
	afterDoneCounter  uint64
	beforeDoneCounter uint64
	DoneMock          mExecutionRegistryMockDone

	funcFindRequestLoop          func(ctx context.Context, reqRef insolar.Reference, apiRequestID string) (b1 bool)
	inspectFuncFindRequestLoop   func(ctx context.Context, reqRef insolar.Reference, apiRequestID string)
	afterFindRequestLoopCounter  uint64
	beforeFindRequestLoopCounter uint64
	FindRequestLoopMock          mExecutionRegistryMockFindRequestLoop

	funcGetActiveTranscript          func(req insolar.Reference) (tp1 *common.Transcript)
	inspectFuncGetActiveTranscript   func(req insolar.Reference)
	afterGetActiveTranscriptCounter  uint64
	beforeGetActiveTranscriptCounter uint64
	GetActiveTranscriptMock          mExecutionRegistryMockGetActiveTranscript

	funcIsEmpty          func() (b1 bool)
	inspectFuncIsEmpty   func()
	afterIsEmptyCounter  uint64
	beforeIsEmptyCounter uint64
	IsEmptyMock          mExecutionRegistryMockIsEmpty

	funcLength          func() (i1 int)
	inspectFuncLength   func()
	afterLengthCounter  uint64
	beforeLengthCounter uint64
	LengthMock          mExecutionRegistryMockLength

	funcOnPulse          func(ctx context.Context) (pa1 []payload.Payload)
	inspectFuncOnPulse   func(ctx context.Context)
	afterOnPulseCounter  uint64
	beforeOnPulseCounter uint64
	OnPulseMock          mExecutionRegistryMockOnPulse

	funcRegister          func(ctx context.Context, transcript *common.Transcript) (err error)
	inspectFuncRegister   func(ctx context.Context, transcript *common.Transcript)
	afterRegisterCounter  uint64
	beforeRegisterCounter uint64
	RegisterMock          mExecutionRegistryMockRegister
}

// NewExecutionRegistryMock returns a mock for ExecutionRegistry
func NewExecutionRegistryMock(t minimock.Tester) *ExecutionRegistryMock {
	m := &ExecutionRegistryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DoneMock = mExecutionRegistryMockDone{mock: m}
	m.DoneMock.callArgs = []*ExecutionRegistryMockDoneParams{}

	m.FindRequestLoopMock = mExecutionRegistryMockFindRequestLoop{mock: m}
	m.FindRequestLoopMock.callArgs = []*ExecutionRegistryMockFindRequestLoopParams{}

	m.GetActiveTranscriptMock = mExecutionRegistryMockGetActiveTranscript{mock: m}
	m.GetActiveTranscriptMock.callArgs = []*ExecutionRegistryMockGetActiveTranscriptParams{}

	m.IsEmptyMock = mExecutionRegistryMockIsEmpty{mock: m}

	m.LengthMock = mExecutionRegistryMockLength{mock: m}

	m.OnPulseMock = mExecutionRegistryMockOnPulse{mock: m}
	m.OnPulseMock.callArgs = []*ExecutionRegistryMockOnPulseParams{}

	m.RegisterMock = mExecutionRegistryMockRegister{mock: m}
	m.RegisterMock.callArgs = []*ExecutionRegistryMockRegisterParams{}

	return m
}

type mExecutionRegistryMockDone struct {
	mock               *ExecutionRegistryMock
	defaultExpectation *ExecutionRegistryMockDoneExpectation
	expectations       []*ExecutionRegistryMockDoneExpectation

	callArgs []*ExecutionRegistryMockDoneParams
	mutex    sync.RWMutex
}

// ExecutionRegistryMockDoneExpectation specifies expectation struct of the ExecutionRegistry.Done
type ExecutionRegistryMockDoneExpectation struct {
	mock    *ExecutionRegistryMock
	params  *ExecutionRegistryMockDoneParams
	results *ExecutionRegistryMockDoneResults
	Counter uint64
}

// ExecutionRegistryMockDoneParams contains parameters of the ExecutionRegistry.Done
type ExecutionRegistryMockDoneParams struct {
	transcript *common.Transcript
}

// ExecutionRegistryMockDoneResults contains results of the ExecutionRegistry.Done
type ExecutionRegistryMockDoneResults struct {
	b1 bool
}

// Expect sets up expected params for ExecutionRegistry.Done
func (mmDone *mExecutionRegistryMockDone) Expect(transcript *common.Transcript) *mExecutionRegistryMockDone {
	if mmDone.mock.funcDone != nil {
		mmDone.mock.t.Fatalf("ExecutionRegistryMock.Done mock is already set by Set")
	}

	if mmDone.defaultExpectation == nil {
		mmDone.defaultExpectation = &ExecutionRegistryMockDoneExpectation{}
	}

	mmDone.defaultExpectation.params = &ExecutionRegistryMockDoneParams{transcript}
	for _, e := range mmDone.expectations {
		if minimock.Equal(e.params, mmDone.defaultExpectation.params) {
			mmDone.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDone.defaultExpectation.params)
		}
	}

	return mmDone
}

// Inspect accepts an inspector function that has same arguments as the ExecutionRegistry.Done
func (mmDone *mExecutionRegistryMockDone) Inspect(f func(transcript *common.Transcript)) *mExecutionRegistryMockDone {
	if mmDone.mock.inspectFuncDone != nil {
		mmDone.mock.t.Fatalf("Inspect function is already set for ExecutionRegistryMock.Done")
	}

	mmDone.mock.inspectFuncDone = f

	return mmDone
}

// Return sets up results that will be returned by ExecutionRegistry.Done
func (mmDone *mExecutionRegistryMockDone) Return(b1 bool) *ExecutionRegistryMock {
	if mmDone.mock.funcDone != nil {
		mmDone.mock.t.Fatalf("ExecutionRegistryMock.Done mock is already set by Set")
	}

	if mmDone.defaultExpectation == nil {
		mmDone.defaultExpectation = &ExecutionRegistryMockDoneExpectation{mock: mmDone.mock}
	}
	mmDone.defaultExpectation.results = &ExecutionRegistryMockDoneResults{b1}
	return mmDone.mock
}

//Set uses given function f to mock the ExecutionRegistry.Done method
func (mmDone *mExecutionRegistryMockDone) Set(f func(transcript *common.Transcript) (b1 bool)) *ExecutionRegistryMock {
	if mmDone.defaultExpectation != nil {
		mmDone.mock.t.Fatalf("Default expectation is already set for the ExecutionRegistry.Done method")
	}

	if len(mmDone.expectations) > 0 {
		mmDone.mock.t.Fatalf("Some expectations are already set for the ExecutionRegistry.Done method")
	}

	mmDone.mock.funcDone = f
	return mmDone.mock
}

// When sets expectation for the ExecutionRegistry.Done which will trigger the result defined by the following
// Then helper
func (mmDone *mExecutionRegistryMockDone) When(transcript *common.Transcript) *ExecutionRegistryMockDoneExpectation {
	if mmDone.mock.funcDone != nil {
		mmDone.mock.t.Fatalf("ExecutionRegistryMock.Done mock is already set by Set")
	}

	expectation := &ExecutionRegistryMockDoneExpectation{
		mock:   mmDone.mock,
		params: &ExecutionRegistryMockDoneParams{transcript},
	}
	mmDone.expectations = append(mmDone.expectations, expectation)
	return expectation
}

// Then sets up ExecutionRegistry.Done return parameters for the expectation previously defined by the When method
func (e *ExecutionRegistryMockDoneExpectation) Then(b1 bool) *ExecutionRegistryMock {
	e.results = &ExecutionRegistryMockDoneResults{b1}
	return e.mock
}

// Done implements ExecutionRegistry
func (mmDone *ExecutionRegistryMock) Done(transcript *common.Transcript) (b1 bool) {
	mm_atomic.AddUint64(&mmDone.beforeDoneCounter, 1)
	defer mm_atomic.AddUint64(&mmDone.afterDoneCounter, 1)

	if mmDone.inspectFuncDone != nil {
		mmDone.inspectFuncDone(transcript)
	}

	params := &ExecutionRegistryMockDoneParams{transcript}

	// Record call args
	mmDone.DoneMock.mutex.Lock()
	mmDone.DoneMock.callArgs = append(mmDone.DoneMock.callArgs, params)
	mmDone.DoneMock.mutex.Unlock()

	for _, e := range mmDone.DoneMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmDone.DoneMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDone.DoneMock.defaultExpectation.Counter, 1)
		want := mmDone.DoneMock.defaultExpectation.params
		got := ExecutionRegistryMockDoneParams{transcript}
		if want != nil && !minimock.Equal(*want, got) {
			mmDone.t.Errorf("ExecutionRegistryMock.Done got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmDone.DoneMock.defaultExpectation.results
		if results == nil {
			mmDone.t.Fatal("No results are set for the ExecutionRegistryMock.Done")
		}
		return (*results).b1
	}
	if mmDone.funcDone != nil {
		return mmDone.funcDone(transcript)
	}
	mmDone.t.Fatalf("Unexpected call to ExecutionRegistryMock.Done. %v", transcript)
	return
}

// DoneAfterCounter returns a count of finished ExecutionRegistryMock.Done invocations
func (mmDone *ExecutionRegistryMock) DoneAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDone.afterDoneCounter)
}

// DoneBeforeCounter returns a count of ExecutionRegistryMock.Done invocations
func (mmDone *ExecutionRegistryMock) DoneBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDone.beforeDoneCounter)
}

// Calls returns a list of arguments used in each call to ExecutionRegistryMock.Done.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDone *mExecutionRegistryMockDone) Calls() []*ExecutionRegistryMockDoneParams {
	mmDone.mutex.RLock()

	argCopy := make([]*ExecutionRegistryMockDoneParams, len(mmDone.callArgs))
	copy(argCopy, mmDone.callArgs)

	mmDone.mutex.RUnlock()

	return argCopy
}

// MinimockDoneDone returns true if the count of the Done invocations corresponds
// the number of defined expectations
func (m *ExecutionRegistryMock) MinimockDoneDone() bool {
	for _, e := range m.DoneMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DoneMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDoneCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDone != nil && mm_atomic.LoadUint64(&m.afterDoneCounter) < 1 {
		return false
	}
	return true
}

// MinimockDoneInspect logs each unmet expectation
func (m *ExecutionRegistryMock) MinimockDoneInspect() {
	for _, e := range m.DoneMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionRegistryMock.Done with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DoneMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDoneCounter) < 1 {
		if m.DoneMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionRegistryMock.Done")
		} else {
			m.t.Errorf("Expected call to ExecutionRegistryMock.Done with params: %#v", *m.DoneMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDone != nil && mm_atomic.LoadUint64(&m.afterDoneCounter) < 1 {
		m.t.Error("Expected call to ExecutionRegistryMock.Done")
	}
}

type mExecutionRegistryMockFindRequestLoop struct {
	mock               *ExecutionRegistryMock
	defaultExpectation *ExecutionRegistryMockFindRequestLoopExpectation
	expectations       []*ExecutionRegistryMockFindRequestLoopExpectation

	callArgs []*ExecutionRegistryMockFindRequestLoopParams
	mutex    sync.RWMutex
}

// ExecutionRegistryMockFindRequestLoopExpectation specifies expectation struct of the ExecutionRegistry.FindRequestLoop
type ExecutionRegistryMockFindRequestLoopExpectation struct {
	mock    *ExecutionRegistryMock
	params  *ExecutionRegistryMockFindRequestLoopParams
	results *ExecutionRegistryMockFindRequestLoopResults
	Counter uint64
}

// ExecutionRegistryMockFindRequestLoopParams contains parameters of the ExecutionRegistry.FindRequestLoop
type ExecutionRegistryMockFindRequestLoopParams struct {
	ctx          context.Context
	reqRef       insolar.Reference
	apiRequestID string
}

// ExecutionRegistryMockFindRequestLoopResults contains results of the ExecutionRegistry.FindRequestLoop
type ExecutionRegistryMockFindRequestLoopResults struct {
	b1 bool
}

// Expect sets up expected params for ExecutionRegistry.FindRequestLoop
func (mmFindRequestLoop *mExecutionRegistryMockFindRequestLoop) Expect(ctx context.Context, reqRef insolar.Reference, apiRequestID string) *mExecutionRegistryMockFindRequestLoop {
	if mmFindRequestLoop.mock.funcFindRequestLoop != nil {
		mmFindRequestLoop.mock.t.Fatalf("ExecutionRegistryMock.FindRequestLoop mock is already set by Set")
	}

	if mmFindRequestLoop.defaultExpectation == nil {
		mmFindRequestLoop.defaultExpectation = &ExecutionRegistryMockFindRequestLoopExpectation{}
	}

	mmFindRequestLoop.defaultExpectation.params = &ExecutionRegistryMockFindRequestLoopParams{ctx, reqRef, apiRequestID}
	for _, e := range mmFindRequestLoop.expectations {
		if minimock.Equal(e.params, mmFindRequestLoop.defaultExpectation.params) {
			mmFindRequestLoop.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindRequestLoop.defaultExpectation.params)
		}
	}

	return mmFindRequestLoop
}

// Inspect accepts an inspector function that has same arguments as the ExecutionRegistry.FindRequestLoop
func (mmFindRequestLoop *mExecutionRegistryMockFindRequestLoop) Inspect(f func(ctx context.Context, reqRef insolar.Reference, apiRequestID string)) *mExecutionRegistryMockFindRequestLoop {
	if mmFindRequestLoop.mock.inspectFuncFindRequestLoop != nil {
		mmFindRequestLoop.mock.t.Fatalf("Inspect function is already set for ExecutionRegistryMock.FindRequestLoop")
	}

	mmFindRequestLoop.mock.inspectFuncFindRequestLoop = f

	return mmFindRequestLoop
}

// Return sets up results that will be returned by ExecutionRegistry.FindRequestLoop
func (mmFindRequestLoop *mExecutionRegistryMockFindRequestLoop) Return(b1 bool) *ExecutionRegistryMock {
	if mmFindRequestLoop.mock.funcFindRequestLoop != nil {
		mmFindRequestLoop.mock.t.Fatalf("ExecutionRegistryMock.FindRequestLoop mock is already set by Set")
	}

	if mmFindRequestLoop.defaultExpectation == nil {
		mmFindRequestLoop.defaultExpectation = &ExecutionRegistryMockFindRequestLoopExpectation{mock: mmFindRequestLoop.mock}
	}
	mmFindRequestLoop.defaultExpectation.results = &ExecutionRegistryMockFindRequestLoopResults{b1}
	return mmFindRequestLoop.mock
}

//Set uses given function f to mock the ExecutionRegistry.FindRequestLoop method
func (mmFindRequestLoop *mExecutionRegistryMockFindRequestLoop) Set(f func(ctx context.Context, reqRef insolar.Reference, apiRequestID string) (b1 bool)) *ExecutionRegistryMock {
	if mmFindRequestLoop.defaultExpectation != nil {
		mmFindRequestLoop.mock.t.Fatalf("Default expectation is already set for the ExecutionRegistry.FindRequestLoop method")
	}

	if len(mmFindRequestLoop.expectations) > 0 {
		mmFindRequestLoop.mock.t.Fatalf("Some expectations are already set for the ExecutionRegistry.FindRequestLoop method")
	}

	mmFindRequestLoop.mock.funcFindRequestLoop = f
	return mmFindRequestLoop.mock
}

// When sets expectation for the ExecutionRegistry.FindRequestLoop which will trigger the result defined by the following
// Then helper
func (mmFindRequestLoop *mExecutionRegistryMockFindRequestLoop) When(ctx context.Context, reqRef insolar.Reference, apiRequestID string) *ExecutionRegistryMockFindRequestLoopExpectation {
	if mmFindRequestLoop.mock.funcFindRequestLoop != nil {
		mmFindRequestLoop.mock.t.Fatalf("ExecutionRegistryMock.FindRequestLoop mock is already set by Set")
	}

	expectation := &ExecutionRegistryMockFindRequestLoopExpectation{
		mock:   mmFindRequestLoop.mock,
		params: &ExecutionRegistryMockFindRequestLoopParams{ctx, reqRef, apiRequestID},
	}
	mmFindRequestLoop.expectations = append(mmFindRequestLoop.expectations, expectation)
	return expectation
}

// Then sets up ExecutionRegistry.FindRequestLoop return parameters for the expectation previously defined by the When method
func (e *ExecutionRegistryMockFindRequestLoopExpectation) Then(b1 bool) *ExecutionRegistryMock {
	e.results = &ExecutionRegistryMockFindRequestLoopResults{b1}
	return e.mock
}

// FindRequestLoop implements ExecutionRegistry
func (mmFindRequestLoop *ExecutionRegistryMock) FindRequestLoop(ctx context.Context, reqRef insolar.Reference, apiRequestID string) (b1 bool) {
	mm_atomic.AddUint64(&mmFindRequestLoop.beforeFindRequestLoopCounter, 1)
	defer mm_atomic.AddUint64(&mmFindRequestLoop.afterFindRequestLoopCounter, 1)

	if mmFindRequestLoop.inspectFuncFindRequestLoop != nil {
		mmFindRequestLoop.inspectFuncFindRequestLoop(ctx, reqRef, apiRequestID)
	}

	params := &ExecutionRegistryMockFindRequestLoopParams{ctx, reqRef, apiRequestID}

	// Record call args
	mmFindRequestLoop.FindRequestLoopMock.mutex.Lock()
	mmFindRequestLoop.FindRequestLoopMock.callArgs = append(mmFindRequestLoop.FindRequestLoopMock.callArgs, params)
	mmFindRequestLoop.FindRequestLoopMock.mutex.Unlock()

	for _, e := range mmFindRequestLoop.FindRequestLoopMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmFindRequestLoop.FindRequestLoopMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFindRequestLoop.FindRequestLoopMock.defaultExpectation.Counter, 1)
		want := mmFindRequestLoop.FindRequestLoopMock.defaultExpectation.params
		got := ExecutionRegistryMockFindRequestLoopParams{ctx, reqRef, apiRequestID}
		if want != nil && !minimock.Equal(*want, got) {
			mmFindRequestLoop.t.Errorf("ExecutionRegistryMock.FindRequestLoop got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmFindRequestLoop.FindRequestLoopMock.defaultExpectation.results
		if results == nil {
			mmFindRequestLoop.t.Fatal("No results are set for the ExecutionRegistryMock.FindRequestLoop")
		}
		return (*results).b1
	}
	if mmFindRequestLoop.funcFindRequestLoop != nil {
		return mmFindRequestLoop.funcFindRequestLoop(ctx, reqRef, apiRequestID)
	}
	mmFindRequestLoop.t.Fatalf("Unexpected call to ExecutionRegistryMock.FindRequestLoop. %v %v %v", ctx, reqRef, apiRequestID)
	return
}

// FindRequestLoopAfterCounter returns a count of finished ExecutionRegistryMock.FindRequestLoop invocations
func (mmFindRequestLoop *ExecutionRegistryMock) FindRequestLoopAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindRequestLoop.afterFindRequestLoopCounter)
}

// FindRequestLoopBeforeCounter returns a count of ExecutionRegistryMock.FindRequestLoop invocations
func (mmFindRequestLoop *ExecutionRegistryMock) FindRequestLoopBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindRequestLoop.beforeFindRequestLoopCounter)
}

// Calls returns a list of arguments used in each call to ExecutionRegistryMock.FindRequestLoop.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindRequestLoop *mExecutionRegistryMockFindRequestLoop) Calls() []*ExecutionRegistryMockFindRequestLoopParams {
	mmFindRequestLoop.mutex.RLock()

	argCopy := make([]*ExecutionRegistryMockFindRequestLoopParams, len(mmFindRequestLoop.callArgs))
	copy(argCopy, mmFindRequestLoop.callArgs)

	mmFindRequestLoop.mutex.RUnlock()

	return argCopy
}

// MinimockFindRequestLoopDone returns true if the count of the FindRequestLoop invocations corresponds
// the number of defined expectations
func (m *ExecutionRegistryMock) MinimockFindRequestLoopDone() bool {
	for _, e := range m.FindRequestLoopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FindRequestLoopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFindRequestLoopCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindRequestLoop != nil && mm_atomic.LoadUint64(&m.afterFindRequestLoopCounter) < 1 {
		return false
	}
	return true
}

// MinimockFindRequestLoopInspect logs each unmet expectation
func (m *ExecutionRegistryMock) MinimockFindRequestLoopInspect() {
	for _, e := range m.FindRequestLoopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionRegistryMock.FindRequestLoop with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FindRequestLoopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFindRequestLoopCounter) < 1 {
		if m.FindRequestLoopMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionRegistryMock.FindRequestLoop")
		} else {
			m.t.Errorf("Expected call to ExecutionRegistryMock.FindRequestLoop with params: %#v", *m.FindRequestLoopMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindRequestLoop != nil && mm_atomic.LoadUint64(&m.afterFindRequestLoopCounter) < 1 {
		m.t.Error("Expected call to ExecutionRegistryMock.FindRequestLoop")
	}
}

type mExecutionRegistryMockGetActiveTranscript struct {
	mock               *ExecutionRegistryMock
	defaultExpectation *ExecutionRegistryMockGetActiveTranscriptExpectation
	expectations       []*ExecutionRegistryMockGetActiveTranscriptExpectation

	callArgs []*ExecutionRegistryMockGetActiveTranscriptParams
	mutex    sync.RWMutex
}

// ExecutionRegistryMockGetActiveTranscriptExpectation specifies expectation struct of the ExecutionRegistry.GetActiveTranscript
type ExecutionRegistryMockGetActiveTranscriptExpectation struct {
	mock    *ExecutionRegistryMock
	params  *ExecutionRegistryMockGetActiveTranscriptParams
	results *ExecutionRegistryMockGetActiveTranscriptResults
	Counter uint64
}

// ExecutionRegistryMockGetActiveTranscriptParams contains parameters of the ExecutionRegistry.GetActiveTranscript
type ExecutionRegistryMockGetActiveTranscriptParams struct {
	req insolar.Reference
}

// ExecutionRegistryMockGetActiveTranscriptResults contains results of the ExecutionRegistry.GetActiveTranscript
type ExecutionRegistryMockGetActiveTranscriptResults struct {
	tp1 *common.Transcript
}

// Expect sets up expected params for ExecutionRegistry.GetActiveTranscript
func (mmGetActiveTranscript *mExecutionRegistryMockGetActiveTranscript) Expect(req insolar.Reference) *mExecutionRegistryMockGetActiveTranscript {
	if mmGetActiveTranscript.mock.funcGetActiveTranscript != nil {
		mmGetActiveTranscript.mock.t.Fatalf("ExecutionRegistryMock.GetActiveTranscript mock is already set by Set")
	}

	if mmGetActiveTranscript.defaultExpectation == nil {
		mmGetActiveTranscript.defaultExpectation = &ExecutionRegistryMockGetActiveTranscriptExpectation{}
	}

	mmGetActiveTranscript.defaultExpectation.params = &ExecutionRegistryMockGetActiveTranscriptParams{req}
	for _, e := range mmGetActiveTranscript.expectations {
		if minimock.Equal(e.params, mmGetActiveTranscript.defaultExpectation.params) {
			mmGetActiveTranscript.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetActiveTranscript.defaultExpectation.params)
		}
	}

	return mmGetActiveTranscript
}

// Inspect accepts an inspector function that has same arguments as the ExecutionRegistry.GetActiveTranscript
func (mmGetActiveTranscript *mExecutionRegistryMockGetActiveTranscript) Inspect(f func(req insolar.Reference)) *mExecutionRegistryMockGetActiveTranscript {
	if mmGetActiveTranscript.mock.inspectFuncGetActiveTranscript != nil {
		mmGetActiveTranscript.mock.t.Fatalf("Inspect function is already set for ExecutionRegistryMock.GetActiveTranscript")
	}

	mmGetActiveTranscript.mock.inspectFuncGetActiveTranscript = f

	return mmGetActiveTranscript
}

// Return sets up results that will be returned by ExecutionRegistry.GetActiveTranscript
func (mmGetActiveTranscript *mExecutionRegistryMockGetActiveTranscript) Return(tp1 *common.Transcript) *ExecutionRegistryMock {
	if mmGetActiveTranscript.mock.funcGetActiveTranscript != nil {
		mmGetActiveTranscript.mock.t.Fatalf("ExecutionRegistryMock.GetActiveTranscript mock is already set by Set")
	}

	if mmGetActiveTranscript.defaultExpectation == nil {
		mmGetActiveTranscript.defaultExpectation = &ExecutionRegistryMockGetActiveTranscriptExpectation{mock: mmGetActiveTranscript.mock}
	}
	mmGetActiveTranscript.defaultExpectation.results = &ExecutionRegistryMockGetActiveTranscriptResults{tp1}
	return mmGetActiveTranscript.mock
}

//Set uses given function f to mock the ExecutionRegistry.GetActiveTranscript method
func (mmGetActiveTranscript *mExecutionRegistryMockGetActiveTranscript) Set(f func(req insolar.Reference) (tp1 *common.Transcript)) *ExecutionRegistryMock {
	if mmGetActiveTranscript.defaultExpectation != nil {
		mmGetActiveTranscript.mock.t.Fatalf("Default expectation is already set for the ExecutionRegistry.GetActiveTranscript method")
	}

	if len(mmGetActiveTranscript.expectations) > 0 {
		mmGetActiveTranscript.mock.t.Fatalf("Some expectations are already set for the ExecutionRegistry.GetActiveTranscript method")
	}

	mmGetActiveTranscript.mock.funcGetActiveTranscript = f
	return mmGetActiveTranscript.mock
}

// When sets expectation for the ExecutionRegistry.GetActiveTranscript which will trigger the result defined by the following
// Then helper
func (mmGetActiveTranscript *mExecutionRegistryMockGetActiveTranscript) When(req insolar.Reference) *ExecutionRegistryMockGetActiveTranscriptExpectation {
	if mmGetActiveTranscript.mock.funcGetActiveTranscript != nil {
		mmGetActiveTranscript.mock.t.Fatalf("ExecutionRegistryMock.GetActiveTranscript mock is already set by Set")
	}

	expectation := &ExecutionRegistryMockGetActiveTranscriptExpectation{
		mock:   mmGetActiveTranscript.mock,
		params: &ExecutionRegistryMockGetActiveTranscriptParams{req},
	}
	mmGetActiveTranscript.expectations = append(mmGetActiveTranscript.expectations, expectation)
	return expectation
}

// Then sets up ExecutionRegistry.GetActiveTranscript return parameters for the expectation previously defined by the When method
func (e *ExecutionRegistryMockGetActiveTranscriptExpectation) Then(tp1 *common.Transcript) *ExecutionRegistryMock {
	e.results = &ExecutionRegistryMockGetActiveTranscriptResults{tp1}
	return e.mock
}

// GetActiveTranscript implements ExecutionRegistry
func (mmGetActiveTranscript *ExecutionRegistryMock) GetActiveTranscript(req insolar.Reference) (tp1 *common.Transcript) {
	mm_atomic.AddUint64(&mmGetActiveTranscript.beforeGetActiveTranscriptCounter, 1)
	defer mm_atomic.AddUint64(&mmGetActiveTranscript.afterGetActiveTranscriptCounter, 1)

	if mmGetActiveTranscript.inspectFuncGetActiveTranscript != nil {
		mmGetActiveTranscript.inspectFuncGetActiveTranscript(req)
	}

	params := &ExecutionRegistryMockGetActiveTranscriptParams{req}

	// Record call args
	mmGetActiveTranscript.GetActiveTranscriptMock.mutex.Lock()
	mmGetActiveTranscript.GetActiveTranscriptMock.callArgs = append(mmGetActiveTranscript.GetActiveTranscriptMock.callArgs, params)
	mmGetActiveTranscript.GetActiveTranscriptMock.mutex.Unlock()

	for _, e := range mmGetActiveTranscript.GetActiveTranscriptMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp1
		}
	}

	if mmGetActiveTranscript.GetActiveTranscriptMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetActiveTranscript.GetActiveTranscriptMock.defaultExpectation.Counter, 1)
		want := mmGetActiveTranscript.GetActiveTranscriptMock.defaultExpectation.params
		got := ExecutionRegistryMockGetActiveTranscriptParams{req}
		if want != nil && !minimock.Equal(*want, got) {
			mmGetActiveTranscript.t.Errorf("ExecutionRegistryMock.GetActiveTranscript got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmGetActiveTranscript.GetActiveTranscriptMock.defaultExpectation.results
		if results == nil {
			mmGetActiveTranscript.t.Fatal("No results are set for the ExecutionRegistryMock.GetActiveTranscript")
		}
		return (*results).tp1
	}
	if mmGetActiveTranscript.funcGetActiveTranscript != nil {
		return mmGetActiveTranscript.funcGetActiveTranscript(req)
	}
	mmGetActiveTranscript.t.Fatalf("Unexpected call to ExecutionRegistryMock.GetActiveTranscript. %v", req)
	return
}

// GetActiveTranscriptAfterCounter returns a count of finished ExecutionRegistryMock.GetActiveTranscript invocations
func (mmGetActiveTranscript *ExecutionRegistryMock) GetActiveTranscriptAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetActiveTranscript.afterGetActiveTranscriptCounter)
}

// GetActiveTranscriptBeforeCounter returns a count of ExecutionRegistryMock.GetActiveTranscript invocations
func (mmGetActiveTranscript *ExecutionRegistryMock) GetActiveTranscriptBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetActiveTranscript.beforeGetActiveTranscriptCounter)
}

// Calls returns a list of arguments used in each call to ExecutionRegistryMock.GetActiveTranscript.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetActiveTranscript *mExecutionRegistryMockGetActiveTranscript) Calls() []*ExecutionRegistryMockGetActiveTranscriptParams {
	mmGetActiveTranscript.mutex.RLock()

	argCopy := make([]*ExecutionRegistryMockGetActiveTranscriptParams, len(mmGetActiveTranscript.callArgs))
	copy(argCopy, mmGetActiveTranscript.callArgs)

	mmGetActiveTranscript.mutex.RUnlock()

	return argCopy
}

// MinimockGetActiveTranscriptDone returns true if the count of the GetActiveTranscript invocations corresponds
// the number of defined expectations
func (m *ExecutionRegistryMock) MinimockGetActiveTranscriptDone() bool {
	for _, e := range m.GetActiveTranscriptMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetActiveTranscriptMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetActiveTranscriptCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetActiveTranscript != nil && mm_atomic.LoadUint64(&m.afterGetActiveTranscriptCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetActiveTranscriptInspect logs each unmet expectation
func (m *ExecutionRegistryMock) MinimockGetActiveTranscriptInspect() {
	for _, e := range m.GetActiveTranscriptMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionRegistryMock.GetActiveTranscript with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetActiveTranscriptMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetActiveTranscriptCounter) < 1 {
		if m.GetActiveTranscriptMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionRegistryMock.GetActiveTranscript")
		} else {
			m.t.Errorf("Expected call to ExecutionRegistryMock.GetActiveTranscript with params: %#v", *m.GetActiveTranscriptMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetActiveTranscript != nil && mm_atomic.LoadUint64(&m.afterGetActiveTranscriptCounter) < 1 {
		m.t.Error("Expected call to ExecutionRegistryMock.GetActiveTranscript")
	}
}

type mExecutionRegistryMockIsEmpty struct {
	mock               *ExecutionRegistryMock
	defaultExpectation *ExecutionRegistryMockIsEmptyExpectation
	expectations       []*ExecutionRegistryMockIsEmptyExpectation
}

// ExecutionRegistryMockIsEmptyExpectation specifies expectation struct of the ExecutionRegistry.IsEmpty
type ExecutionRegistryMockIsEmptyExpectation struct {
	mock *ExecutionRegistryMock

	results *ExecutionRegistryMockIsEmptyResults
	Counter uint64
}

// ExecutionRegistryMockIsEmptyResults contains results of the ExecutionRegistry.IsEmpty
type ExecutionRegistryMockIsEmptyResults struct {
	b1 bool
}

// Expect sets up expected params for ExecutionRegistry.IsEmpty
func (mmIsEmpty *mExecutionRegistryMockIsEmpty) Expect() *mExecutionRegistryMockIsEmpty {
	if mmIsEmpty.mock.funcIsEmpty != nil {
		mmIsEmpty.mock.t.Fatalf("ExecutionRegistryMock.IsEmpty mock is already set by Set")
	}

	if mmIsEmpty.defaultExpectation == nil {
		mmIsEmpty.defaultExpectation = &ExecutionRegistryMockIsEmptyExpectation{}
	}

	return mmIsEmpty
}

// Inspect accepts an inspector function that has same arguments as the ExecutionRegistry.IsEmpty
func (mmIsEmpty *mExecutionRegistryMockIsEmpty) Inspect(f func()) *mExecutionRegistryMockIsEmpty {
	if mmIsEmpty.mock.inspectFuncIsEmpty != nil {
		mmIsEmpty.mock.t.Fatalf("Inspect function is already set for ExecutionRegistryMock.IsEmpty")
	}

	mmIsEmpty.mock.inspectFuncIsEmpty = f

	return mmIsEmpty
}

// Return sets up results that will be returned by ExecutionRegistry.IsEmpty
func (mmIsEmpty *mExecutionRegistryMockIsEmpty) Return(b1 bool) *ExecutionRegistryMock {
	if mmIsEmpty.mock.funcIsEmpty != nil {
		mmIsEmpty.mock.t.Fatalf("ExecutionRegistryMock.IsEmpty mock is already set by Set")
	}

	if mmIsEmpty.defaultExpectation == nil {
		mmIsEmpty.defaultExpectation = &ExecutionRegistryMockIsEmptyExpectation{mock: mmIsEmpty.mock}
	}
	mmIsEmpty.defaultExpectation.results = &ExecutionRegistryMockIsEmptyResults{b1}
	return mmIsEmpty.mock
}

//Set uses given function f to mock the ExecutionRegistry.IsEmpty method
func (mmIsEmpty *mExecutionRegistryMockIsEmpty) Set(f func() (b1 bool)) *ExecutionRegistryMock {
	if mmIsEmpty.defaultExpectation != nil {
		mmIsEmpty.mock.t.Fatalf("Default expectation is already set for the ExecutionRegistry.IsEmpty method")
	}

	if len(mmIsEmpty.expectations) > 0 {
		mmIsEmpty.mock.t.Fatalf("Some expectations are already set for the ExecutionRegistry.IsEmpty method")
	}

	mmIsEmpty.mock.funcIsEmpty = f
	return mmIsEmpty.mock
}

// IsEmpty implements ExecutionRegistry
func (mmIsEmpty *ExecutionRegistryMock) IsEmpty() (b1 bool) {
	mm_atomic.AddUint64(&mmIsEmpty.beforeIsEmptyCounter, 1)
	defer mm_atomic.AddUint64(&mmIsEmpty.afterIsEmptyCounter, 1)

	if mmIsEmpty.inspectFuncIsEmpty != nil {
		mmIsEmpty.inspectFuncIsEmpty()
	}

	if mmIsEmpty.IsEmptyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsEmpty.IsEmptyMock.defaultExpectation.Counter, 1)

		results := mmIsEmpty.IsEmptyMock.defaultExpectation.results
		if results == nil {
			mmIsEmpty.t.Fatal("No results are set for the ExecutionRegistryMock.IsEmpty")
		}
		return (*results).b1
	}
	if mmIsEmpty.funcIsEmpty != nil {
		return mmIsEmpty.funcIsEmpty()
	}
	mmIsEmpty.t.Fatalf("Unexpected call to ExecutionRegistryMock.IsEmpty.")
	return
}

// IsEmptyAfterCounter returns a count of finished ExecutionRegistryMock.IsEmpty invocations
func (mmIsEmpty *ExecutionRegistryMock) IsEmptyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsEmpty.afterIsEmptyCounter)
}

// IsEmptyBeforeCounter returns a count of ExecutionRegistryMock.IsEmpty invocations
func (mmIsEmpty *ExecutionRegistryMock) IsEmptyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsEmpty.beforeIsEmptyCounter)
}

// MinimockIsEmptyDone returns true if the count of the IsEmpty invocations corresponds
// the number of defined expectations
func (m *ExecutionRegistryMock) MinimockIsEmptyDone() bool {
	for _, e := range m.IsEmptyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsEmptyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsEmptyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsEmpty != nil && mm_atomic.LoadUint64(&m.afterIsEmptyCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsEmptyInspect logs each unmet expectation
func (m *ExecutionRegistryMock) MinimockIsEmptyInspect() {
	for _, e := range m.IsEmptyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExecutionRegistryMock.IsEmpty")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsEmptyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsEmptyCounter) < 1 {
		m.t.Error("Expected call to ExecutionRegistryMock.IsEmpty")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsEmpty != nil && mm_atomic.LoadUint64(&m.afterIsEmptyCounter) < 1 {
		m.t.Error("Expected call to ExecutionRegistryMock.IsEmpty")
	}
}

type mExecutionRegistryMockLength struct {
	mock               *ExecutionRegistryMock
	defaultExpectation *ExecutionRegistryMockLengthExpectation
	expectations       []*ExecutionRegistryMockLengthExpectation
}

// ExecutionRegistryMockLengthExpectation specifies expectation struct of the ExecutionRegistry.Length
type ExecutionRegistryMockLengthExpectation struct {
	mock *ExecutionRegistryMock

	results *ExecutionRegistryMockLengthResults
	Counter uint64
}

// ExecutionRegistryMockLengthResults contains results of the ExecutionRegistry.Length
type ExecutionRegistryMockLengthResults struct {
	i1 int
}

// Expect sets up expected params for ExecutionRegistry.Length
func (mmLength *mExecutionRegistryMockLength) Expect() *mExecutionRegistryMockLength {
	if mmLength.mock.funcLength != nil {
		mmLength.mock.t.Fatalf("ExecutionRegistryMock.Length mock is already set by Set")
	}

	if mmLength.defaultExpectation == nil {
		mmLength.defaultExpectation = &ExecutionRegistryMockLengthExpectation{}
	}

	return mmLength
}

// Inspect accepts an inspector function that has same arguments as the ExecutionRegistry.Length
func (mmLength *mExecutionRegistryMockLength) Inspect(f func()) *mExecutionRegistryMockLength {
	if mmLength.mock.inspectFuncLength != nil {
		mmLength.mock.t.Fatalf("Inspect function is already set for ExecutionRegistryMock.Length")
	}

	mmLength.mock.inspectFuncLength = f

	return mmLength
}

// Return sets up results that will be returned by ExecutionRegistry.Length
func (mmLength *mExecutionRegistryMockLength) Return(i1 int) *ExecutionRegistryMock {
	if mmLength.mock.funcLength != nil {
		mmLength.mock.t.Fatalf("ExecutionRegistryMock.Length mock is already set by Set")
	}

	if mmLength.defaultExpectation == nil {
		mmLength.defaultExpectation = &ExecutionRegistryMockLengthExpectation{mock: mmLength.mock}
	}
	mmLength.defaultExpectation.results = &ExecutionRegistryMockLengthResults{i1}
	return mmLength.mock
}

//Set uses given function f to mock the ExecutionRegistry.Length method
func (mmLength *mExecutionRegistryMockLength) Set(f func() (i1 int)) *ExecutionRegistryMock {
	if mmLength.defaultExpectation != nil {
		mmLength.mock.t.Fatalf("Default expectation is already set for the ExecutionRegistry.Length method")
	}

	if len(mmLength.expectations) > 0 {
		mmLength.mock.t.Fatalf("Some expectations are already set for the ExecutionRegistry.Length method")
	}

	mmLength.mock.funcLength = f
	return mmLength.mock
}

// Length implements ExecutionRegistry
func (mmLength *ExecutionRegistryMock) Length() (i1 int) {
	mm_atomic.AddUint64(&mmLength.beforeLengthCounter, 1)
	defer mm_atomic.AddUint64(&mmLength.afterLengthCounter, 1)

	if mmLength.inspectFuncLength != nil {
		mmLength.inspectFuncLength()
	}

	if mmLength.LengthMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLength.LengthMock.defaultExpectation.Counter, 1)

		results := mmLength.LengthMock.defaultExpectation.results
		if results == nil {
			mmLength.t.Fatal("No results are set for the ExecutionRegistryMock.Length")
		}
		return (*results).i1
	}
	if mmLength.funcLength != nil {
		return mmLength.funcLength()
	}
	mmLength.t.Fatalf("Unexpected call to ExecutionRegistryMock.Length.")
	return
}

// LengthAfterCounter returns a count of finished ExecutionRegistryMock.Length invocations
func (mmLength *ExecutionRegistryMock) LengthAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLength.afterLengthCounter)
}

// LengthBeforeCounter returns a count of ExecutionRegistryMock.Length invocations
func (mmLength *ExecutionRegistryMock) LengthBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLength.beforeLengthCounter)
}

// MinimockLengthDone returns true if the count of the Length invocations corresponds
// the number of defined expectations
func (m *ExecutionRegistryMock) MinimockLengthDone() bool {
	for _, e := range m.LengthMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LengthMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLengthCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLength != nil && mm_atomic.LoadUint64(&m.afterLengthCounter) < 1 {
		return false
	}
	return true
}

// MinimockLengthInspect logs each unmet expectation
func (m *ExecutionRegistryMock) MinimockLengthInspect() {
	for _, e := range m.LengthMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExecutionRegistryMock.Length")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LengthMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLengthCounter) < 1 {
		m.t.Error("Expected call to ExecutionRegistryMock.Length")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLength != nil && mm_atomic.LoadUint64(&m.afterLengthCounter) < 1 {
		m.t.Error("Expected call to ExecutionRegistryMock.Length")
	}
}

type mExecutionRegistryMockOnPulse struct {
	mock               *ExecutionRegistryMock
	defaultExpectation *ExecutionRegistryMockOnPulseExpectation
	expectations       []*ExecutionRegistryMockOnPulseExpectation

	callArgs []*ExecutionRegistryMockOnPulseParams
	mutex    sync.RWMutex
}

// ExecutionRegistryMockOnPulseExpectation specifies expectation struct of the ExecutionRegistry.OnPulse
type ExecutionRegistryMockOnPulseExpectation struct {
	mock    *ExecutionRegistryMock
	params  *ExecutionRegistryMockOnPulseParams
	results *ExecutionRegistryMockOnPulseResults
	Counter uint64
}

// ExecutionRegistryMockOnPulseParams contains parameters of the ExecutionRegistry.OnPulse
type ExecutionRegistryMockOnPulseParams struct {
	ctx context.Context
}

// ExecutionRegistryMockOnPulseResults contains results of the ExecutionRegistry.OnPulse
type ExecutionRegistryMockOnPulseResults struct {
	pa1 []payload.Payload
}

// Expect sets up expected params for ExecutionRegistry.OnPulse
func (mmOnPulse *mExecutionRegistryMockOnPulse) Expect(ctx context.Context) *mExecutionRegistryMockOnPulse {
	if mmOnPulse.mock.funcOnPulse != nil {
		mmOnPulse.mock.t.Fatalf("ExecutionRegistryMock.OnPulse mock is already set by Set")
	}

	if mmOnPulse.defaultExpectation == nil {
		mmOnPulse.defaultExpectation = &ExecutionRegistryMockOnPulseExpectation{}
	}

	mmOnPulse.defaultExpectation.params = &ExecutionRegistryMockOnPulseParams{ctx}
	for _, e := range mmOnPulse.expectations {
		if minimock.Equal(e.params, mmOnPulse.defaultExpectation.params) {
			mmOnPulse.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOnPulse.defaultExpectation.params)
		}
	}

	return mmOnPulse
}

// Inspect accepts an inspector function that has same arguments as the ExecutionRegistry.OnPulse
func (mmOnPulse *mExecutionRegistryMockOnPulse) Inspect(f func(ctx context.Context)) *mExecutionRegistryMockOnPulse {
	if mmOnPulse.mock.inspectFuncOnPulse != nil {
		mmOnPulse.mock.t.Fatalf("Inspect function is already set for ExecutionRegistryMock.OnPulse")
	}

	mmOnPulse.mock.inspectFuncOnPulse = f

	return mmOnPulse
}

// Return sets up results that will be returned by ExecutionRegistry.OnPulse
func (mmOnPulse *mExecutionRegistryMockOnPulse) Return(pa1 []payload.Payload) *ExecutionRegistryMock {
	if mmOnPulse.mock.funcOnPulse != nil {
		mmOnPulse.mock.t.Fatalf("ExecutionRegistryMock.OnPulse mock is already set by Set")
	}

	if mmOnPulse.defaultExpectation == nil {
		mmOnPulse.defaultExpectation = &ExecutionRegistryMockOnPulseExpectation{mock: mmOnPulse.mock}
	}
	mmOnPulse.defaultExpectation.results = &ExecutionRegistryMockOnPulseResults{pa1}
	return mmOnPulse.mock
}

//Set uses given function f to mock the ExecutionRegistry.OnPulse method
func (mmOnPulse *mExecutionRegistryMockOnPulse) Set(f func(ctx context.Context) (pa1 []payload.Payload)) *ExecutionRegistryMock {
	if mmOnPulse.defaultExpectation != nil {
		mmOnPulse.mock.t.Fatalf("Default expectation is already set for the ExecutionRegistry.OnPulse method")
	}

	if len(mmOnPulse.expectations) > 0 {
		mmOnPulse.mock.t.Fatalf("Some expectations are already set for the ExecutionRegistry.OnPulse method")
	}

	mmOnPulse.mock.funcOnPulse = f
	return mmOnPulse.mock
}

// When sets expectation for the ExecutionRegistry.OnPulse which will trigger the result defined by the following
// Then helper
func (mmOnPulse *mExecutionRegistryMockOnPulse) When(ctx context.Context) *ExecutionRegistryMockOnPulseExpectation {
	if mmOnPulse.mock.funcOnPulse != nil {
		mmOnPulse.mock.t.Fatalf("ExecutionRegistryMock.OnPulse mock is already set by Set")
	}

	expectation := &ExecutionRegistryMockOnPulseExpectation{
		mock:   mmOnPulse.mock,
		params: &ExecutionRegistryMockOnPulseParams{ctx},
	}
	mmOnPulse.expectations = append(mmOnPulse.expectations, expectation)
	return expectation
}

// Then sets up ExecutionRegistry.OnPulse return parameters for the expectation previously defined by the When method
func (e *ExecutionRegistryMockOnPulseExpectation) Then(pa1 []payload.Payload) *ExecutionRegistryMock {
	e.results = &ExecutionRegistryMockOnPulseResults{pa1}
	return e.mock
}

// OnPulse implements ExecutionRegistry
func (mmOnPulse *ExecutionRegistryMock) OnPulse(ctx context.Context) (pa1 []payload.Payload) {
	mm_atomic.AddUint64(&mmOnPulse.beforeOnPulseCounter, 1)
	defer mm_atomic.AddUint64(&mmOnPulse.afterOnPulseCounter, 1)

	if mmOnPulse.inspectFuncOnPulse != nil {
		mmOnPulse.inspectFuncOnPulse(ctx)
	}

	params := &ExecutionRegistryMockOnPulseParams{ctx}

	// Record call args
	mmOnPulse.OnPulseMock.mutex.Lock()
	mmOnPulse.OnPulseMock.callArgs = append(mmOnPulse.OnPulseMock.callArgs, params)
	mmOnPulse.OnPulseMock.mutex.Unlock()

	for _, e := range mmOnPulse.OnPulseMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1
		}
	}

	if mmOnPulse.OnPulseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOnPulse.OnPulseMock.defaultExpectation.Counter, 1)
		want := mmOnPulse.OnPulseMock.defaultExpectation.params
		got := ExecutionRegistryMockOnPulseParams{ctx}
		if want != nil && !minimock.Equal(*want, got) {
			mmOnPulse.t.Errorf("ExecutionRegistryMock.OnPulse got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmOnPulse.OnPulseMock.defaultExpectation.results
		if results == nil {
			mmOnPulse.t.Fatal("No results are set for the ExecutionRegistryMock.OnPulse")
		}
		return (*results).pa1
	}
	if mmOnPulse.funcOnPulse != nil {
		return mmOnPulse.funcOnPulse(ctx)
	}
	mmOnPulse.t.Fatalf("Unexpected call to ExecutionRegistryMock.OnPulse. %v", ctx)
	return
}

// OnPulseAfterCounter returns a count of finished ExecutionRegistryMock.OnPulse invocations
func (mmOnPulse *ExecutionRegistryMock) OnPulseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOnPulse.afterOnPulseCounter)
}

// OnPulseBeforeCounter returns a count of ExecutionRegistryMock.OnPulse invocations
func (mmOnPulse *ExecutionRegistryMock) OnPulseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOnPulse.beforeOnPulseCounter)
}

// Calls returns a list of arguments used in each call to ExecutionRegistryMock.OnPulse.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOnPulse *mExecutionRegistryMockOnPulse) Calls() []*ExecutionRegistryMockOnPulseParams {
	mmOnPulse.mutex.RLock()

	argCopy := make([]*ExecutionRegistryMockOnPulseParams, len(mmOnPulse.callArgs))
	copy(argCopy, mmOnPulse.callArgs)

	mmOnPulse.mutex.RUnlock()

	return argCopy
}

// MinimockOnPulseDone returns true if the count of the OnPulse invocations corresponds
// the number of defined expectations
func (m *ExecutionRegistryMock) MinimockOnPulseDone() bool {
	for _, e := range m.OnPulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OnPulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOnPulseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOnPulse != nil && mm_atomic.LoadUint64(&m.afterOnPulseCounter) < 1 {
		return false
	}
	return true
}

// MinimockOnPulseInspect logs each unmet expectation
func (m *ExecutionRegistryMock) MinimockOnPulseInspect() {
	for _, e := range m.OnPulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionRegistryMock.OnPulse with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OnPulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOnPulseCounter) < 1 {
		if m.OnPulseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionRegistryMock.OnPulse")
		} else {
			m.t.Errorf("Expected call to ExecutionRegistryMock.OnPulse with params: %#v", *m.OnPulseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOnPulse != nil && mm_atomic.LoadUint64(&m.afterOnPulseCounter) < 1 {
		m.t.Error("Expected call to ExecutionRegistryMock.OnPulse")
	}
}

type mExecutionRegistryMockRegister struct {
	mock               *ExecutionRegistryMock
	defaultExpectation *ExecutionRegistryMockRegisterExpectation
	expectations       []*ExecutionRegistryMockRegisterExpectation

	callArgs []*ExecutionRegistryMockRegisterParams
	mutex    sync.RWMutex
}

// ExecutionRegistryMockRegisterExpectation specifies expectation struct of the ExecutionRegistry.Register
type ExecutionRegistryMockRegisterExpectation struct {
	mock    *ExecutionRegistryMock
	params  *ExecutionRegistryMockRegisterParams
	results *ExecutionRegistryMockRegisterResults
	Counter uint64
}

// ExecutionRegistryMockRegisterParams contains parameters of the ExecutionRegistry.Register
type ExecutionRegistryMockRegisterParams struct {
	ctx        context.Context
	transcript *common.Transcript
}

// ExecutionRegistryMockRegisterResults contains results of the ExecutionRegistry.Register
type ExecutionRegistryMockRegisterResults struct {
	err error
}

// Expect sets up expected params for ExecutionRegistry.Register
func (mmRegister *mExecutionRegistryMockRegister) Expect(ctx context.Context, transcript *common.Transcript) *mExecutionRegistryMockRegister {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("ExecutionRegistryMock.Register mock is already set by Set")
	}

	if mmRegister.defaultExpectation == nil {
		mmRegister.defaultExpectation = &ExecutionRegistryMockRegisterExpectation{}
	}

	mmRegister.defaultExpectation.params = &ExecutionRegistryMockRegisterParams{ctx, transcript}
	for _, e := range mmRegister.expectations {
		if minimock.Equal(e.params, mmRegister.defaultExpectation.params) {
			mmRegister.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegister.defaultExpectation.params)
		}
	}

	return mmRegister
}

// Inspect accepts an inspector function that has same arguments as the ExecutionRegistry.Register
func (mmRegister *mExecutionRegistryMockRegister) Inspect(f func(ctx context.Context, transcript *common.Transcript)) *mExecutionRegistryMockRegister {
	if mmRegister.mock.inspectFuncRegister != nil {
		mmRegister.mock.t.Fatalf("Inspect function is already set for ExecutionRegistryMock.Register")
	}

	mmRegister.mock.inspectFuncRegister = f

	return mmRegister
}

// Return sets up results that will be returned by ExecutionRegistry.Register
func (mmRegister *mExecutionRegistryMockRegister) Return(err error) *ExecutionRegistryMock {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("ExecutionRegistryMock.Register mock is already set by Set")
	}

	if mmRegister.defaultExpectation == nil {
		mmRegister.defaultExpectation = &ExecutionRegistryMockRegisterExpectation{mock: mmRegister.mock}
	}
	mmRegister.defaultExpectation.results = &ExecutionRegistryMockRegisterResults{err}
	return mmRegister.mock
}

//Set uses given function f to mock the ExecutionRegistry.Register method
func (mmRegister *mExecutionRegistryMockRegister) Set(f func(ctx context.Context, transcript *common.Transcript) (err error)) *ExecutionRegistryMock {
	if mmRegister.defaultExpectation != nil {
		mmRegister.mock.t.Fatalf("Default expectation is already set for the ExecutionRegistry.Register method")
	}

	if len(mmRegister.expectations) > 0 {
		mmRegister.mock.t.Fatalf("Some expectations are already set for the ExecutionRegistry.Register method")
	}

	mmRegister.mock.funcRegister = f
	return mmRegister.mock
}

// When sets expectation for the ExecutionRegistry.Register which will trigger the result defined by the following
// Then helper
func (mmRegister *mExecutionRegistryMockRegister) When(ctx context.Context, transcript *common.Transcript) *ExecutionRegistryMockRegisterExpectation {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("ExecutionRegistryMock.Register mock is already set by Set")
	}

	expectation := &ExecutionRegistryMockRegisterExpectation{
		mock:   mmRegister.mock,
		params: &ExecutionRegistryMockRegisterParams{ctx, transcript},
	}
	mmRegister.expectations = append(mmRegister.expectations, expectation)
	return expectation
}

// Then sets up ExecutionRegistry.Register return parameters for the expectation previously defined by the When method
func (e *ExecutionRegistryMockRegisterExpectation) Then(err error) *ExecutionRegistryMock {
	e.results = &ExecutionRegistryMockRegisterResults{err}
	return e.mock
}

// Register implements ExecutionRegistry
func (mmRegister *ExecutionRegistryMock) Register(ctx context.Context, transcript *common.Transcript) (err error) {
	mm_atomic.AddUint64(&mmRegister.beforeRegisterCounter, 1)
	defer mm_atomic.AddUint64(&mmRegister.afterRegisterCounter, 1)

	if mmRegister.inspectFuncRegister != nil {
		mmRegister.inspectFuncRegister(ctx, transcript)
	}

	params := &ExecutionRegistryMockRegisterParams{ctx, transcript}

	// Record call args
	mmRegister.RegisterMock.mutex.Lock()
	mmRegister.RegisterMock.callArgs = append(mmRegister.RegisterMock.callArgs, params)
	mmRegister.RegisterMock.mutex.Unlock()

	for _, e := range mmRegister.RegisterMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRegister.RegisterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegister.RegisterMock.defaultExpectation.Counter, 1)
		want := mmRegister.RegisterMock.defaultExpectation.params
		got := ExecutionRegistryMockRegisterParams{ctx, transcript}
		if want != nil && !minimock.Equal(*want, got) {
			mmRegister.t.Errorf("ExecutionRegistryMock.Register got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmRegister.RegisterMock.defaultExpectation.results
		if results == nil {
			mmRegister.t.Fatal("No results are set for the ExecutionRegistryMock.Register")
		}
		return (*results).err
	}
	if mmRegister.funcRegister != nil {
		return mmRegister.funcRegister(ctx, transcript)
	}
	mmRegister.t.Fatalf("Unexpected call to ExecutionRegistryMock.Register. %v %v", ctx, transcript)
	return
}

// RegisterAfterCounter returns a count of finished ExecutionRegistryMock.Register invocations
func (mmRegister *ExecutionRegistryMock) RegisterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegister.afterRegisterCounter)
}

// RegisterBeforeCounter returns a count of ExecutionRegistryMock.Register invocations
func (mmRegister *ExecutionRegistryMock) RegisterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegister.beforeRegisterCounter)
}

// Calls returns a list of arguments used in each call to ExecutionRegistryMock.Register.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegister *mExecutionRegistryMockRegister) Calls() []*ExecutionRegistryMockRegisterParams {
	mmRegister.mutex.RLock()

	argCopy := make([]*ExecutionRegistryMockRegisterParams, len(mmRegister.callArgs))
	copy(argCopy, mmRegister.callArgs)

	mmRegister.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterDone returns true if the count of the Register invocations corresponds
// the number of defined expectations
func (m *ExecutionRegistryMock) MinimockRegisterDone() bool {
	for _, e := range m.RegisterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegister != nil && mm_atomic.LoadUint64(&m.afterRegisterCounter) < 1 {
		return false
	}
	return true
}

// MinimockRegisterInspect logs each unmet expectation
func (m *ExecutionRegistryMock) MinimockRegisterInspect() {
	for _, e := range m.RegisterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionRegistryMock.Register with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterCounter) < 1 {
		if m.RegisterMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionRegistryMock.Register")
		} else {
			m.t.Errorf("Expected call to ExecutionRegistryMock.Register with params: %#v", *m.RegisterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegister != nil && mm_atomic.LoadUint64(&m.afterRegisterCounter) < 1 {
		m.t.Error("Expected call to ExecutionRegistryMock.Register")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ExecutionRegistryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockDoneInspect()

		m.MinimockFindRequestLoopInspect()

		m.MinimockGetActiveTranscriptInspect()

		m.MinimockIsEmptyInspect()

		m.MinimockLengthInspect()

		m.MinimockOnPulseInspect()

		m.MinimockRegisterInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ExecutionRegistryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ExecutionRegistryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDoneDone() &&
		m.MinimockFindRequestLoopDone() &&
		m.MinimockGetActiveTranscriptDone() &&
		m.MinimockIsEmptyDone() &&
		m.MinimockLengthDone() &&
		m.MinimockOnPulseDone() &&
		m.MinimockRegisterDone()
}
