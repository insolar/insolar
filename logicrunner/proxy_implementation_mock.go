package logicrunner

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/logicrunner/goplugin/rpctypes"
)

// ProxyImplementationMock implements ProxyImplementation
type ProxyImplementationMock struct {
	t minimock.Tester

	funcDeactivateObject          func(ctx context.Context, tp1 *Transcript, u1 rpctypes.UpDeactivateObjectReq, up1 *rpctypes.UpDeactivateObjectResp) (err error)
	inspectFuncDeactivateObject   func(ctx context.Context, tp1 *Transcript, u1 rpctypes.UpDeactivateObjectReq, up1 *rpctypes.UpDeactivateObjectResp)
	afterDeactivateObjectCounter  uint64
	beforeDeactivateObjectCounter uint64
	DeactivateObjectMock          mProxyImplementationMockDeactivateObject

	funcGetCode          func(ctx context.Context, tp1 *Transcript, u1 rpctypes.UpGetCodeReq, up1 *rpctypes.UpGetCodeResp) (err error)
	inspectFuncGetCode   func(ctx context.Context, tp1 *Transcript, u1 rpctypes.UpGetCodeReq, up1 *rpctypes.UpGetCodeResp)
	afterGetCodeCounter  uint64
	beforeGetCodeCounter uint64
	GetCodeMock          mProxyImplementationMockGetCode

	funcRouteCall          func(ctx context.Context, tp1 *Transcript, u1 rpctypes.UpRouteReq, up1 *rpctypes.UpRouteResp) (err error)
	inspectFuncRouteCall   func(ctx context.Context, tp1 *Transcript, u1 rpctypes.UpRouteReq, up1 *rpctypes.UpRouteResp)
	afterRouteCallCounter  uint64
	beforeRouteCallCounter uint64
	RouteCallMock          mProxyImplementationMockRouteCall

	funcSaveAsChild          func(ctx context.Context, tp1 *Transcript, u1 rpctypes.UpSaveAsChildReq, up1 *rpctypes.UpSaveAsChildResp) (err error)
	inspectFuncSaveAsChild   func(ctx context.Context, tp1 *Transcript, u1 rpctypes.UpSaveAsChildReq, up1 *rpctypes.UpSaveAsChildResp)
	afterSaveAsChildCounter  uint64
	beforeSaveAsChildCounter uint64
	SaveAsChildMock          mProxyImplementationMockSaveAsChild
}

// NewProxyImplementationMock returns a mock for ProxyImplementation
func NewProxyImplementationMock(t minimock.Tester) *ProxyImplementationMock {
	m := &ProxyImplementationMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DeactivateObjectMock = mProxyImplementationMockDeactivateObject{mock: m}
	m.DeactivateObjectMock.callArgs = []*ProxyImplementationMockDeactivateObjectParams{}

	m.GetCodeMock = mProxyImplementationMockGetCode{mock: m}
	m.GetCodeMock.callArgs = []*ProxyImplementationMockGetCodeParams{}

	m.RouteCallMock = mProxyImplementationMockRouteCall{mock: m}
	m.RouteCallMock.callArgs = []*ProxyImplementationMockRouteCallParams{}

	m.SaveAsChildMock = mProxyImplementationMockSaveAsChild{mock: m}
	m.SaveAsChildMock.callArgs = []*ProxyImplementationMockSaveAsChildParams{}

	return m
}

type mProxyImplementationMockDeactivateObject struct {
	mock               *ProxyImplementationMock
	defaultExpectation *ProxyImplementationMockDeactivateObjectExpectation
	expectations       []*ProxyImplementationMockDeactivateObjectExpectation

	callArgs []*ProxyImplementationMockDeactivateObjectParams
	mutex    sync.RWMutex
}

// ProxyImplementationMockDeactivateObjectExpectation specifies expectation struct of the ProxyImplementation.DeactivateObject
type ProxyImplementationMockDeactivateObjectExpectation struct {
	mock    *ProxyImplementationMock
	params  *ProxyImplementationMockDeactivateObjectParams
	results *ProxyImplementationMockDeactivateObjectResults
	Counter uint64
}

// ProxyImplementationMockDeactivateObjectParams contains parameters of the ProxyImplementation.DeactivateObject
type ProxyImplementationMockDeactivateObjectParams struct {
	ctx context.Context
	tp1 *Transcript
	u1  rpctypes.UpDeactivateObjectReq
	up1 *rpctypes.UpDeactivateObjectResp
}

// ProxyImplementationMockDeactivateObjectResults contains results of the ProxyImplementation.DeactivateObject
type ProxyImplementationMockDeactivateObjectResults struct {
	err error
}

// Expect sets up expected params for ProxyImplementation.DeactivateObject
func (mmDeactivateObject *mProxyImplementationMockDeactivateObject) Expect(ctx context.Context, tp1 *Transcript, u1 rpctypes.UpDeactivateObjectReq, up1 *rpctypes.UpDeactivateObjectResp) *mProxyImplementationMockDeactivateObject {
	if mmDeactivateObject.mock.funcDeactivateObject != nil {
		mmDeactivateObject.mock.t.Fatalf("ProxyImplementationMock.DeactivateObject mock is already set by Set")
	}

	if mmDeactivateObject.defaultExpectation == nil {
		mmDeactivateObject.defaultExpectation = &ProxyImplementationMockDeactivateObjectExpectation{}
	}

	mmDeactivateObject.defaultExpectation.params = &ProxyImplementationMockDeactivateObjectParams{ctx, tp1, u1, up1}
	for _, e := range mmDeactivateObject.expectations {
		if minimock.Equal(e.params, mmDeactivateObject.defaultExpectation.params) {
			mmDeactivateObject.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeactivateObject.defaultExpectation.params)
		}
	}

	return mmDeactivateObject
}

// Inspect accepts an inspector function that has same arguments as the ProxyImplementation.DeactivateObject
func (mmDeactivateObject *mProxyImplementationMockDeactivateObject) Inspect(f func(ctx context.Context, tp1 *Transcript, u1 rpctypes.UpDeactivateObjectReq, up1 *rpctypes.UpDeactivateObjectResp)) *mProxyImplementationMockDeactivateObject {
	if mmDeactivateObject.mock.inspectFuncDeactivateObject != nil {
		mmDeactivateObject.mock.t.Fatalf("Inspect function is already set for ProxyImplementationMock.DeactivateObject")
	}

	mmDeactivateObject.mock.inspectFuncDeactivateObject = f

	return mmDeactivateObject
}

// Return sets up results that will be returned by ProxyImplementation.DeactivateObject
func (mmDeactivateObject *mProxyImplementationMockDeactivateObject) Return(err error) *ProxyImplementationMock {
	if mmDeactivateObject.mock.funcDeactivateObject != nil {
		mmDeactivateObject.mock.t.Fatalf("ProxyImplementationMock.DeactivateObject mock is already set by Set")
	}

	if mmDeactivateObject.defaultExpectation == nil {
		mmDeactivateObject.defaultExpectation = &ProxyImplementationMockDeactivateObjectExpectation{mock: mmDeactivateObject.mock}
	}
	mmDeactivateObject.defaultExpectation.results = &ProxyImplementationMockDeactivateObjectResults{err}
	return mmDeactivateObject.mock
}

//Set uses given function f to mock the ProxyImplementation.DeactivateObject method
func (mmDeactivateObject *mProxyImplementationMockDeactivateObject) Set(f func(ctx context.Context, tp1 *Transcript, u1 rpctypes.UpDeactivateObjectReq, up1 *rpctypes.UpDeactivateObjectResp) (err error)) *ProxyImplementationMock {
	if mmDeactivateObject.defaultExpectation != nil {
		mmDeactivateObject.mock.t.Fatalf("Default expectation is already set for the ProxyImplementation.DeactivateObject method")
	}

	if len(mmDeactivateObject.expectations) > 0 {
		mmDeactivateObject.mock.t.Fatalf("Some expectations are already set for the ProxyImplementation.DeactivateObject method")
	}

	mmDeactivateObject.mock.funcDeactivateObject = f
	return mmDeactivateObject.mock
}

// When sets expectation for the ProxyImplementation.DeactivateObject which will trigger the result defined by the following
// Then helper
func (mmDeactivateObject *mProxyImplementationMockDeactivateObject) When(ctx context.Context, tp1 *Transcript, u1 rpctypes.UpDeactivateObjectReq, up1 *rpctypes.UpDeactivateObjectResp) *ProxyImplementationMockDeactivateObjectExpectation {
	if mmDeactivateObject.mock.funcDeactivateObject != nil {
		mmDeactivateObject.mock.t.Fatalf("ProxyImplementationMock.DeactivateObject mock is already set by Set")
	}

	expectation := &ProxyImplementationMockDeactivateObjectExpectation{
		mock:   mmDeactivateObject.mock,
		params: &ProxyImplementationMockDeactivateObjectParams{ctx, tp1, u1, up1},
	}
	mmDeactivateObject.expectations = append(mmDeactivateObject.expectations, expectation)
	return expectation
}

// Then sets up ProxyImplementation.DeactivateObject return parameters for the expectation previously defined by the When method
func (e *ProxyImplementationMockDeactivateObjectExpectation) Then(err error) *ProxyImplementationMock {
	e.results = &ProxyImplementationMockDeactivateObjectResults{err}
	return e.mock
}

// DeactivateObject implements ProxyImplementation
func (mmDeactivateObject *ProxyImplementationMock) DeactivateObject(ctx context.Context, tp1 *Transcript, u1 rpctypes.UpDeactivateObjectReq, up1 *rpctypes.UpDeactivateObjectResp) (err error) {
	mm_atomic.AddUint64(&mmDeactivateObject.beforeDeactivateObjectCounter, 1)
	defer mm_atomic.AddUint64(&mmDeactivateObject.afterDeactivateObjectCounter, 1)

	if mmDeactivateObject.inspectFuncDeactivateObject != nil {
		mmDeactivateObject.inspectFuncDeactivateObject(ctx, tp1, u1, up1)
	}

	params := &ProxyImplementationMockDeactivateObjectParams{ctx, tp1, u1, up1}

	// Record call args
	mmDeactivateObject.DeactivateObjectMock.mutex.Lock()
	mmDeactivateObject.DeactivateObjectMock.callArgs = append(mmDeactivateObject.DeactivateObjectMock.callArgs, params)
	mmDeactivateObject.DeactivateObjectMock.mutex.Unlock()

	for _, e := range mmDeactivateObject.DeactivateObjectMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeactivateObject.DeactivateObjectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeactivateObject.DeactivateObjectMock.defaultExpectation.Counter, 1)
		want := mmDeactivateObject.DeactivateObjectMock.defaultExpectation.params
		got := ProxyImplementationMockDeactivateObjectParams{ctx, tp1, u1, up1}
		if want != nil && !minimock.Equal(*want, got) {
			mmDeactivateObject.t.Errorf("ProxyImplementationMock.DeactivateObject got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmDeactivateObject.DeactivateObjectMock.defaultExpectation.results
		if results == nil {
			mmDeactivateObject.t.Fatal("No results are set for the ProxyImplementationMock.DeactivateObject")
		}
		return (*results).err
	}
	if mmDeactivateObject.funcDeactivateObject != nil {
		return mmDeactivateObject.funcDeactivateObject(ctx, tp1, u1, up1)
	}
	mmDeactivateObject.t.Fatalf("Unexpected call to ProxyImplementationMock.DeactivateObject. %v %v %v %v", ctx, tp1, u1, up1)
	return
}

// DeactivateObjectAfterCounter returns a count of finished ProxyImplementationMock.DeactivateObject invocations
func (mmDeactivateObject *ProxyImplementationMock) DeactivateObjectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeactivateObject.afterDeactivateObjectCounter)
}

// DeactivateObjectBeforeCounter returns a count of ProxyImplementationMock.DeactivateObject invocations
func (mmDeactivateObject *ProxyImplementationMock) DeactivateObjectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeactivateObject.beforeDeactivateObjectCounter)
}

// Calls returns a list of arguments used in each call to ProxyImplementationMock.DeactivateObject.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeactivateObject *mProxyImplementationMockDeactivateObject) Calls() []*ProxyImplementationMockDeactivateObjectParams {
	mmDeactivateObject.mutex.RLock()

	argCopy := make([]*ProxyImplementationMockDeactivateObjectParams, len(mmDeactivateObject.callArgs))
	copy(argCopy, mmDeactivateObject.callArgs)

	mmDeactivateObject.mutex.RUnlock()

	return argCopy
}

// MinimockDeactivateObjectDone returns true if the count of the DeactivateObject invocations corresponds
// the number of defined expectations
func (m *ProxyImplementationMock) MinimockDeactivateObjectDone() bool {
	for _, e := range m.DeactivateObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeactivateObjectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeactivateObjectCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeactivateObject != nil && mm_atomic.LoadUint64(&m.afterDeactivateObjectCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeactivateObjectInspect logs each unmet expectation
func (m *ProxyImplementationMock) MinimockDeactivateObjectInspect() {
	for _, e := range m.DeactivateObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProxyImplementationMock.DeactivateObject with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeactivateObjectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeactivateObjectCounter) < 1 {
		if m.DeactivateObjectMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ProxyImplementationMock.DeactivateObject")
		} else {
			m.t.Errorf("Expected call to ProxyImplementationMock.DeactivateObject with params: %#v", *m.DeactivateObjectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeactivateObject != nil && mm_atomic.LoadUint64(&m.afterDeactivateObjectCounter) < 1 {
		m.t.Error("Expected call to ProxyImplementationMock.DeactivateObject")
	}
}

type mProxyImplementationMockGetCode struct {
	mock               *ProxyImplementationMock
	defaultExpectation *ProxyImplementationMockGetCodeExpectation
	expectations       []*ProxyImplementationMockGetCodeExpectation

	callArgs []*ProxyImplementationMockGetCodeParams
	mutex    sync.RWMutex
}

// ProxyImplementationMockGetCodeExpectation specifies expectation struct of the ProxyImplementation.GetCode
type ProxyImplementationMockGetCodeExpectation struct {
	mock    *ProxyImplementationMock
	params  *ProxyImplementationMockGetCodeParams
	results *ProxyImplementationMockGetCodeResults
	Counter uint64
}

// ProxyImplementationMockGetCodeParams contains parameters of the ProxyImplementation.GetCode
type ProxyImplementationMockGetCodeParams struct {
	ctx context.Context
	tp1 *Transcript
	u1  rpctypes.UpGetCodeReq
	up1 *rpctypes.UpGetCodeResp
}

// ProxyImplementationMockGetCodeResults contains results of the ProxyImplementation.GetCode
type ProxyImplementationMockGetCodeResults struct {
	err error
}

// Expect sets up expected params for ProxyImplementation.GetCode
func (mmGetCode *mProxyImplementationMockGetCode) Expect(ctx context.Context, tp1 *Transcript, u1 rpctypes.UpGetCodeReq, up1 *rpctypes.UpGetCodeResp) *mProxyImplementationMockGetCode {
	if mmGetCode.mock.funcGetCode != nil {
		mmGetCode.mock.t.Fatalf("ProxyImplementationMock.GetCode mock is already set by Set")
	}

	if mmGetCode.defaultExpectation == nil {
		mmGetCode.defaultExpectation = &ProxyImplementationMockGetCodeExpectation{}
	}

	mmGetCode.defaultExpectation.params = &ProxyImplementationMockGetCodeParams{ctx, tp1, u1, up1}
	for _, e := range mmGetCode.expectations {
		if minimock.Equal(e.params, mmGetCode.defaultExpectation.params) {
			mmGetCode.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCode.defaultExpectation.params)
		}
	}

	return mmGetCode
}

// Inspect accepts an inspector function that has same arguments as the ProxyImplementation.GetCode
func (mmGetCode *mProxyImplementationMockGetCode) Inspect(f func(ctx context.Context, tp1 *Transcript, u1 rpctypes.UpGetCodeReq, up1 *rpctypes.UpGetCodeResp)) *mProxyImplementationMockGetCode {
	if mmGetCode.mock.inspectFuncGetCode != nil {
		mmGetCode.mock.t.Fatalf("Inspect function is already set for ProxyImplementationMock.GetCode")
	}

	mmGetCode.mock.inspectFuncGetCode = f

	return mmGetCode
}

// Return sets up results that will be returned by ProxyImplementation.GetCode
func (mmGetCode *mProxyImplementationMockGetCode) Return(err error) *ProxyImplementationMock {
	if mmGetCode.mock.funcGetCode != nil {
		mmGetCode.mock.t.Fatalf("ProxyImplementationMock.GetCode mock is already set by Set")
	}

	if mmGetCode.defaultExpectation == nil {
		mmGetCode.defaultExpectation = &ProxyImplementationMockGetCodeExpectation{mock: mmGetCode.mock}
	}
	mmGetCode.defaultExpectation.results = &ProxyImplementationMockGetCodeResults{err}
	return mmGetCode.mock
}

//Set uses given function f to mock the ProxyImplementation.GetCode method
func (mmGetCode *mProxyImplementationMockGetCode) Set(f func(ctx context.Context, tp1 *Transcript, u1 rpctypes.UpGetCodeReq, up1 *rpctypes.UpGetCodeResp) (err error)) *ProxyImplementationMock {
	if mmGetCode.defaultExpectation != nil {
		mmGetCode.mock.t.Fatalf("Default expectation is already set for the ProxyImplementation.GetCode method")
	}

	if len(mmGetCode.expectations) > 0 {
		mmGetCode.mock.t.Fatalf("Some expectations are already set for the ProxyImplementation.GetCode method")
	}

	mmGetCode.mock.funcGetCode = f
	return mmGetCode.mock
}

// When sets expectation for the ProxyImplementation.GetCode which will trigger the result defined by the following
// Then helper
func (mmGetCode *mProxyImplementationMockGetCode) When(ctx context.Context, tp1 *Transcript, u1 rpctypes.UpGetCodeReq, up1 *rpctypes.UpGetCodeResp) *ProxyImplementationMockGetCodeExpectation {
	if mmGetCode.mock.funcGetCode != nil {
		mmGetCode.mock.t.Fatalf("ProxyImplementationMock.GetCode mock is already set by Set")
	}

	expectation := &ProxyImplementationMockGetCodeExpectation{
		mock:   mmGetCode.mock,
		params: &ProxyImplementationMockGetCodeParams{ctx, tp1, u1, up1},
	}
	mmGetCode.expectations = append(mmGetCode.expectations, expectation)
	return expectation
}

// Then sets up ProxyImplementation.GetCode return parameters for the expectation previously defined by the When method
func (e *ProxyImplementationMockGetCodeExpectation) Then(err error) *ProxyImplementationMock {
	e.results = &ProxyImplementationMockGetCodeResults{err}
	return e.mock
}

// GetCode implements ProxyImplementation
func (mmGetCode *ProxyImplementationMock) GetCode(ctx context.Context, tp1 *Transcript, u1 rpctypes.UpGetCodeReq, up1 *rpctypes.UpGetCodeResp) (err error) {
	mm_atomic.AddUint64(&mmGetCode.beforeGetCodeCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCode.afterGetCodeCounter, 1)

	if mmGetCode.inspectFuncGetCode != nil {
		mmGetCode.inspectFuncGetCode(ctx, tp1, u1, up1)
	}

	params := &ProxyImplementationMockGetCodeParams{ctx, tp1, u1, up1}

	// Record call args
	mmGetCode.GetCodeMock.mutex.Lock()
	mmGetCode.GetCodeMock.callArgs = append(mmGetCode.GetCodeMock.callArgs, params)
	mmGetCode.GetCodeMock.mutex.Unlock()

	for _, e := range mmGetCode.GetCodeMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmGetCode.GetCodeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCode.GetCodeMock.defaultExpectation.Counter, 1)
		want := mmGetCode.GetCodeMock.defaultExpectation.params
		got := ProxyImplementationMockGetCodeParams{ctx, tp1, u1, up1}
		if want != nil && !minimock.Equal(*want, got) {
			mmGetCode.t.Errorf("ProxyImplementationMock.GetCode got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmGetCode.GetCodeMock.defaultExpectation.results
		if results == nil {
			mmGetCode.t.Fatal("No results are set for the ProxyImplementationMock.GetCode")
		}
		return (*results).err
	}
	if mmGetCode.funcGetCode != nil {
		return mmGetCode.funcGetCode(ctx, tp1, u1, up1)
	}
	mmGetCode.t.Fatalf("Unexpected call to ProxyImplementationMock.GetCode. %v %v %v %v", ctx, tp1, u1, up1)
	return
}

// GetCodeAfterCounter returns a count of finished ProxyImplementationMock.GetCode invocations
func (mmGetCode *ProxyImplementationMock) GetCodeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCode.afterGetCodeCounter)
}

// GetCodeBeforeCounter returns a count of ProxyImplementationMock.GetCode invocations
func (mmGetCode *ProxyImplementationMock) GetCodeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCode.beforeGetCodeCounter)
}

// Calls returns a list of arguments used in each call to ProxyImplementationMock.GetCode.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCode *mProxyImplementationMockGetCode) Calls() []*ProxyImplementationMockGetCodeParams {
	mmGetCode.mutex.RLock()

	argCopy := make([]*ProxyImplementationMockGetCodeParams, len(mmGetCode.callArgs))
	copy(argCopy, mmGetCode.callArgs)

	mmGetCode.mutex.RUnlock()

	return argCopy
}

// MinimockGetCodeDone returns true if the count of the GetCode invocations corresponds
// the number of defined expectations
func (m *ProxyImplementationMock) MinimockGetCodeDone() bool {
	for _, e := range m.GetCodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCodeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCode != nil && mm_atomic.LoadUint64(&m.afterGetCodeCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCodeInspect logs each unmet expectation
func (m *ProxyImplementationMock) MinimockGetCodeInspect() {
	for _, e := range m.GetCodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProxyImplementationMock.GetCode with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCodeCounter) < 1 {
		if m.GetCodeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ProxyImplementationMock.GetCode")
		} else {
			m.t.Errorf("Expected call to ProxyImplementationMock.GetCode with params: %#v", *m.GetCodeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCode != nil && mm_atomic.LoadUint64(&m.afterGetCodeCounter) < 1 {
		m.t.Error("Expected call to ProxyImplementationMock.GetCode")
	}
}

type mProxyImplementationMockRouteCall struct {
	mock               *ProxyImplementationMock
	defaultExpectation *ProxyImplementationMockRouteCallExpectation
	expectations       []*ProxyImplementationMockRouteCallExpectation

	callArgs []*ProxyImplementationMockRouteCallParams
	mutex    sync.RWMutex
}

// ProxyImplementationMockRouteCallExpectation specifies expectation struct of the ProxyImplementation.RouteCall
type ProxyImplementationMockRouteCallExpectation struct {
	mock    *ProxyImplementationMock
	params  *ProxyImplementationMockRouteCallParams
	results *ProxyImplementationMockRouteCallResults
	Counter uint64
}

// ProxyImplementationMockRouteCallParams contains parameters of the ProxyImplementation.RouteCall
type ProxyImplementationMockRouteCallParams struct {
	ctx context.Context
	tp1 *Transcript
	u1  rpctypes.UpRouteReq
	up1 *rpctypes.UpRouteResp
}

// ProxyImplementationMockRouteCallResults contains results of the ProxyImplementation.RouteCall
type ProxyImplementationMockRouteCallResults struct {
	err error
}

// Expect sets up expected params for ProxyImplementation.RouteCall
func (mmRouteCall *mProxyImplementationMockRouteCall) Expect(ctx context.Context, tp1 *Transcript, u1 rpctypes.UpRouteReq, up1 *rpctypes.UpRouteResp) *mProxyImplementationMockRouteCall {
	if mmRouteCall.mock.funcRouteCall != nil {
		mmRouteCall.mock.t.Fatalf("ProxyImplementationMock.RouteCall mock is already set by Set")
	}

	if mmRouteCall.defaultExpectation == nil {
		mmRouteCall.defaultExpectation = &ProxyImplementationMockRouteCallExpectation{}
	}

	mmRouteCall.defaultExpectation.params = &ProxyImplementationMockRouteCallParams{ctx, tp1, u1, up1}
	for _, e := range mmRouteCall.expectations {
		if minimock.Equal(e.params, mmRouteCall.defaultExpectation.params) {
			mmRouteCall.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRouteCall.defaultExpectation.params)
		}
	}

	return mmRouteCall
}

// Inspect accepts an inspector function that has same arguments as the ProxyImplementation.RouteCall
func (mmRouteCall *mProxyImplementationMockRouteCall) Inspect(f func(ctx context.Context, tp1 *Transcript, u1 rpctypes.UpRouteReq, up1 *rpctypes.UpRouteResp)) *mProxyImplementationMockRouteCall {
	if mmRouteCall.mock.inspectFuncRouteCall != nil {
		mmRouteCall.mock.t.Fatalf("Inspect function is already set for ProxyImplementationMock.RouteCall")
	}

	mmRouteCall.mock.inspectFuncRouteCall = f

	return mmRouteCall
}

// Return sets up results that will be returned by ProxyImplementation.RouteCall
func (mmRouteCall *mProxyImplementationMockRouteCall) Return(err error) *ProxyImplementationMock {
	if mmRouteCall.mock.funcRouteCall != nil {
		mmRouteCall.mock.t.Fatalf("ProxyImplementationMock.RouteCall mock is already set by Set")
	}

	if mmRouteCall.defaultExpectation == nil {
		mmRouteCall.defaultExpectation = &ProxyImplementationMockRouteCallExpectation{mock: mmRouteCall.mock}
	}
	mmRouteCall.defaultExpectation.results = &ProxyImplementationMockRouteCallResults{err}
	return mmRouteCall.mock
}

//Set uses given function f to mock the ProxyImplementation.RouteCall method
func (mmRouteCall *mProxyImplementationMockRouteCall) Set(f func(ctx context.Context, tp1 *Transcript, u1 rpctypes.UpRouteReq, up1 *rpctypes.UpRouteResp) (err error)) *ProxyImplementationMock {
	if mmRouteCall.defaultExpectation != nil {
		mmRouteCall.mock.t.Fatalf("Default expectation is already set for the ProxyImplementation.RouteCall method")
	}

	if len(mmRouteCall.expectations) > 0 {
		mmRouteCall.mock.t.Fatalf("Some expectations are already set for the ProxyImplementation.RouteCall method")
	}

	mmRouteCall.mock.funcRouteCall = f
	return mmRouteCall.mock
}

// When sets expectation for the ProxyImplementation.RouteCall which will trigger the result defined by the following
// Then helper
func (mmRouteCall *mProxyImplementationMockRouteCall) When(ctx context.Context, tp1 *Transcript, u1 rpctypes.UpRouteReq, up1 *rpctypes.UpRouteResp) *ProxyImplementationMockRouteCallExpectation {
	if mmRouteCall.mock.funcRouteCall != nil {
		mmRouteCall.mock.t.Fatalf("ProxyImplementationMock.RouteCall mock is already set by Set")
	}

	expectation := &ProxyImplementationMockRouteCallExpectation{
		mock:   mmRouteCall.mock,
		params: &ProxyImplementationMockRouteCallParams{ctx, tp1, u1, up1},
	}
	mmRouteCall.expectations = append(mmRouteCall.expectations, expectation)
	return expectation
}

// Then sets up ProxyImplementation.RouteCall return parameters for the expectation previously defined by the When method
func (e *ProxyImplementationMockRouteCallExpectation) Then(err error) *ProxyImplementationMock {
	e.results = &ProxyImplementationMockRouteCallResults{err}
	return e.mock
}

// RouteCall implements ProxyImplementation
func (mmRouteCall *ProxyImplementationMock) RouteCall(ctx context.Context, tp1 *Transcript, u1 rpctypes.UpRouteReq, up1 *rpctypes.UpRouteResp) (err error) {
	mm_atomic.AddUint64(&mmRouteCall.beforeRouteCallCounter, 1)
	defer mm_atomic.AddUint64(&mmRouteCall.afterRouteCallCounter, 1)

	if mmRouteCall.inspectFuncRouteCall != nil {
		mmRouteCall.inspectFuncRouteCall(ctx, tp1, u1, up1)
	}

	params := &ProxyImplementationMockRouteCallParams{ctx, tp1, u1, up1}

	// Record call args
	mmRouteCall.RouteCallMock.mutex.Lock()
	mmRouteCall.RouteCallMock.callArgs = append(mmRouteCall.RouteCallMock.callArgs, params)
	mmRouteCall.RouteCallMock.mutex.Unlock()

	for _, e := range mmRouteCall.RouteCallMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRouteCall.RouteCallMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRouteCall.RouteCallMock.defaultExpectation.Counter, 1)
		want := mmRouteCall.RouteCallMock.defaultExpectation.params
		got := ProxyImplementationMockRouteCallParams{ctx, tp1, u1, up1}
		if want != nil && !minimock.Equal(*want, got) {
			mmRouteCall.t.Errorf("ProxyImplementationMock.RouteCall got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmRouteCall.RouteCallMock.defaultExpectation.results
		if results == nil {
			mmRouteCall.t.Fatal("No results are set for the ProxyImplementationMock.RouteCall")
		}
		return (*results).err
	}
	if mmRouteCall.funcRouteCall != nil {
		return mmRouteCall.funcRouteCall(ctx, tp1, u1, up1)
	}
	mmRouteCall.t.Fatalf("Unexpected call to ProxyImplementationMock.RouteCall. %v %v %v %v", ctx, tp1, u1, up1)
	return
}

// RouteCallAfterCounter returns a count of finished ProxyImplementationMock.RouteCall invocations
func (mmRouteCall *ProxyImplementationMock) RouteCallAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRouteCall.afterRouteCallCounter)
}

// RouteCallBeforeCounter returns a count of ProxyImplementationMock.RouteCall invocations
func (mmRouteCall *ProxyImplementationMock) RouteCallBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRouteCall.beforeRouteCallCounter)
}

// Calls returns a list of arguments used in each call to ProxyImplementationMock.RouteCall.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRouteCall *mProxyImplementationMockRouteCall) Calls() []*ProxyImplementationMockRouteCallParams {
	mmRouteCall.mutex.RLock()

	argCopy := make([]*ProxyImplementationMockRouteCallParams, len(mmRouteCall.callArgs))
	copy(argCopy, mmRouteCall.callArgs)

	mmRouteCall.mutex.RUnlock()

	return argCopy
}

// MinimockRouteCallDone returns true if the count of the RouteCall invocations corresponds
// the number of defined expectations
func (m *ProxyImplementationMock) MinimockRouteCallDone() bool {
	for _, e := range m.RouteCallMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RouteCallMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRouteCallCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRouteCall != nil && mm_atomic.LoadUint64(&m.afterRouteCallCounter) < 1 {
		return false
	}
	return true
}

// MinimockRouteCallInspect logs each unmet expectation
func (m *ProxyImplementationMock) MinimockRouteCallInspect() {
	for _, e := range m.RouteCallMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProxyImplementationMock.RouteCall with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RouteCallMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRouteCallCounter) < 1 {
		if m.RouteCallMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ProxyImplementationMock.RouteCall")
		} else {
			m.t.Errorf("Expected call to ProxyImplementationMock.RouteCall with params: %#v", *m.RouteCallMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRouteCall != nil && mm_atomic.LoadUint64(&m.afterRouteCallCounter) < 1 {
		m.t.Error("Expected call to ProxyImplementationMock.RouteCall")
	}
}

type mProxyImplementationMockSaveAsChild struct {
	mock               *ProxyImplementationMock
	defaultExpectation *ProxyImplementationMockSaveAsChildExpectation
	expectations       []*ProxyImplementationMockSaveAsChildExpectation

	callArgs []*ProxyImplementationMockSaveAsChildParams
	mutex    sync.RWMutex
}

// ProxyImplementationMockSaveAsChildExpectation specifies expectation struct of the ProxyImplementation.SaveAsChild
type ProxyImplementationMockSaveAsChildExpectation struct {
	mock    *ProxyImplementationMock
	params  *ProxyImplementationMockSaveAsChildParams
	results *ProxyImplementationMockSaveAsChildResults
	Counter uint64
}

// ProxyImplementationMockSaveAsChildParams contains parameters of the ProxyImplementation.SaveAsChild
type ProxyImplementationMockSaveAsChildParams struct {
	ctx context.Context
	tp1 *Transcript
	u1  rpctypes.UpSaveAsChildReq
	up1 *rpctypes.UpSaveAsChildResp
}

// ProxyImplementationMockSaveAsChildResults contains results of the ProxyImplementation.SaveAsChild
type ProxyImplementationMockSaveAsChildResults struct {
	err error
}

// Expect sets up expected params for ProxyImplementation.SaveAsChild
func (mmSaveAsChild *mProxyImplementationMockSaveAsChild) Expect(ctx context.Context, tp1 *Transcript, u1 rpctypes.UpSaveAsChildReq, up1 *rpctypes.UpSaveAsChildResp) *mProxyImplementationMockSaveAsChild {
	if mmSaveAsChild.mock.funcSaveAsChild != nil {
		mmSaveAsChild.mock.t.Fatalf("ProxyImplementationMock.SaveAsChild mock is already set by Set")
	}

	if mmSaveAsChild.defaultExpectation == nil {
		mmSaveAsChild.defaultExpectation = &ProxyImplementationMockSaveAsChildExpectation{}
	}

	mmSaveAsChild.defaultExpectation.params = &ProxyImplementationMockSaveAsChildParams{ctx, tp1, u1, up1}
	for _, e := range mmSaveAsChild.expectations {
		if minimock.Equal(e.params, mmSaveAsChild.defaultExpectation.params) {
			mmSaveAsChild.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveAsChild.defaultExpectation.params)
		}
	}

	return mmSaveAsChild
}

// Inspect accepts an inspector function that has same arguments as the ProxyImplementation.SaveAsChild
func (mmSaveAsChild *mProxyImplementationMockSaveAsChild) Inspect(f func(ctx context.Context, tp1 *Transcript, u1 rpctypes.UpSaveAsChildReq, up1 *rpctypes.UpSaveAsChildResp)) *mProxyImplementationMockSaveAsChild {
	if mmSaveAsChild.mock.inspectFuncSaveAsChild != nil {
		mmSaveAsChild.mock.t.Fatalf("Inspect function is already set for ProxyImplementationMock.SaveAsChild")
	}

	mmSaveAsChild.mock.inspectFuncSaveAsChild = f

	return mmSaveAsChild
}

// Return sets up results that will be returned by ProxyImplementation.SaveAsChild
func (mmSaveAsChild *mProxyImplementationMockSaveAsChild) Return(err error) *ProxyImplementationMock {
	if mmSaveAsChild.mock.funcSaveAsChild != nil {
		mmSaveAsChild.mock.t.Fatalf("ProxyImplementationMock.SaveAsChild mock is already set by Set")
	}

	if mmSaveAsChild.defaultExpectation == nil {
		mmSaveAsChild.defaultExpectation = &ProxyImplementationMockSaveAsChildExpectation{mock: mmSaveAsChild.mock}
	}
	mmSaveAsChild.defaultExpectation.results = &ProxyImplementationMockSaveAsChildResults{err}
	return mmSaveAsChild.mock
}

//Set uses given function f to mock the ProxyImplementation.SaveAsChild method
func (mmSaveAsChild *mProxyImplementationMockSaveAsChild) Set(f func(ctx context.Context, tp1 *Transcript, u1 rpctypes.UpSaveAsChildReq, up1 *rpctypes.UpSaveAsChildResp) (err error)) *ProxyImplementationMock {
	if mmSaveAsChild.defaultExpectation != nil {
		mmSaveAsChild.mock.t.Fatalf("Default expectation is already set for the ProxyImplementation.SaveAsChild method")
	}

	if len(mmSaveAsChild.expectations) > 0 {
		mmSaveAsChild.mock.t.Fatalf("Some expectations are already set for the ProxyImplementation.SaveAsChild method")
	}

	mmSaveAsChild.mock.funcSaveAsChild = f
	return mmSaveAsChild.mock
}

// When sets expectation for the ProxyImplementation.SaveAsChild which will trigger the result defined by the following
// Then helper
func (mmSaveAsChild *mProxyImplementationMockSaveAsChild) When(ctx context.Context, tp1 *Transcript, u1 rpctypes.UpSaveAsChildReq, up1 *rpctypes.UpSaveAsChildResp) *ProxyImplementationMockSaveAsChildExpectation {
	if mmSaveAsChild.mock.funcSaveAsChild != nil {
		mmSaveAsChild.mock.t.Fatalf("ProxyImplementationMock.SaveAsChild mock is already set by Set")
	}

	expectation := &ProxyImplementationMockSaveAsChildExpectation{
		mock:   mmSaveAsChild.mock,
		params: &ProxyImplementationMockSaveAsChildParams{ctx, tp1, u1, up1},
	}
	mmSaveAsChild.expectations = append(mmSaveAsChild.expectations, expectation)
	return expectation
}

// Then sets up ProxyImplementation.SaveAsChild return parameters for the expectation previously defined by the When method
func (e *ProxyImplementationMockSaveAsChildExpectation) Then(err error) *ProxyImplementationMock {
	e.results = &ProxyImplementationMockSaveAsChildResults{err}
	return e.mock
}

// SaveAsChild implements ProxyImplementation
func (mmSaveAsChild *ProxyImplementationMock) SaveAsChild(ctx context.Context, tp1 *Transcript, u1 rpctypes.UpSaveAsChildReq, up1 *rpctypes.UpSaveAsChildResp) (err error) {
	mm_atomic.AddUint64(&mmSaveAsChild.beforeSaveAsChildCounter, 1)
	defer mm_atomic.AddUint64(&mmSaveAsChild.afterSaveAsChildCounter, 1)

	if mmSaveAsChild.inspectFuncSaveAsChild != nil {
		mmSaveAsChild.inspectFuncSaveAsChild(ctx, tp1, u1, up1)
	}

	params := &ProxyImplementationMockSaveAsChildParams{ctx, tp1, u1, up1}

	// Record call args
	mmSaveAsChild.SaveAsChildMock.mutex.Lock()
	mmSaveAsChild.SaveAsChildMock.callArgs = append(mmSaveAsChild.SaveAsChildMock.callArgs, params)
	mmSaveAsChild.SaveAsChildMock.mutex.Unlock()

	for _, e := range mmSaveAsChild.SaveAsChildMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSaveAsChild.SaveAsChildMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSaveAsChild.SaveAsChildMock.defaultExpectation.Counter, 1)
		want := mmSaveAsChild.SaveAsChildMock.defaultExpectation.params
		got := ProxyImplementationMockSaveAsChildParams{ctx, tp1, u1, up1}
		if want != nil && !minimock.Equal(*want, got) {
			mmSaveAsChild.t.Errorf("ProxyImplementationMock.SaveAsChild got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmSaveAsChild.SaveAsChildMock.defaultExpectation.results
		if results == nil {
			mmSaveAsChild.t.Fatal("No results are set for the ProxyImplementationMock.SaveAsChild")
		}
		return (*results).err
	}
	if mmSaveAsChild.funcSaveAsChild != nil {
		return mmSaveAsChild.funcSaveAsChild(ctx, tp1, u1, up1)
	}
	mmSaveAsChild.t.Fatalf("Unexpected call to ProxyImplementationMock.SaveAsChild. %v %v %v %v", ctx, tp1, u1, up1)
	return
}

// SaveAsChildAfterCounter returns a count of finished ProxyImplementationMock.SaveAsChild invocations
func (mmSaveAsChild *ProxyImplementationMock) SaveAsChildAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveAsChild.afterSaveAsChildCounter)
}

// SaveAsChildBeforeCounter returns a count of ProxyImplementationMock.SaveAsChild invocations
func (mmSaveAsChild *ProxyImplementationMock) SaveAsChildBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveAsChild.beforeSaveAsChildCounter)
}

// Calls returns a list of arguments used in each call to ProxyImplementationMock.SaveAsChild.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveAsChild *mProxyImplementationMockSaveAsChild) Calls() []*ProxyImplementationMockSaveAsChildParams {
	mmSaveAsChild.mutex.RLock()

	argCopy := make([]*ProxyImplementationMockSaveAsChildParams, len(mmSaveAsChild.callArgs))
	copy(argCopy, mmSaveAsChild.callArgs)

	mmSaveAsChild.mutex.RUnlock()

	return argCopy
}

// MinimockSaveAsChildDone returns true if the count of the SaveAsChild invocations corresponds
// the number of defined expectations
func (m *ProxyImplementationMock) MinimockSaveAsChildDone() bool {
	for _, e := range m.SaveAsChildMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveAsChildMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveAsChildCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveAsChild != nil && mm_atomic.LoadUint64(&m.afterSaveAsChildCounter) < 1 {
		return false
	}
	return true
}

// MinimockSaveAsChildInspect logs each unmet expectation
func (m *ProxyImplementationMock) MinimockSaveAsChildInspect() {
	for _, e := range m.SaveAsChildMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProxyImplementationMock.SaveAsChild with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveAsChildMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveAsChildCounter) < 1 {
		if m.SaveAsChildMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ProxyImplementationMock.SaveAsChild")
		} else {
			m.t.Errorf("Expected call to ProxyImplementationMock.SaveAsChild with params: %#v", *m.SaveAsChildMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveAsChild != nil && mm_atomic.LoadUint64(&m.afterSaveAsChildCounter) < 1 {
		m.t.Error("Expected call to ProxyImplementationMock.SaveAsChild")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ProxyImplementationMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockDeactivateObjectInspect()

		m.MinimockGetCodeInspect()

		m.MinimockRouteCallInspect()

		m.MinimockSaveAsChildInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ProxyImplementationMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ProxyImplementationMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDeactivateObjectDone() &&
		m.MinimockGetCodeDone() &&
		m.MinimockRouteCallDone() &&
		m.MinimockSaveAsChildDone()
}
