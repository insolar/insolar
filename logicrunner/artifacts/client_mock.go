package artifacts

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/insolar"
	"github.com/insolar/insolar/insolar/payload"
	"github.com/insolar/insolar/insolar/record"
)

// ClientMock implements Client
type ClientMock struct {
	t minimock.Tester

	funcActivatePrototype          func(ctx context.Context, request insolar.Reference, parent insolar.Reference, code insolar.Reference, memory []byte) (err error)
	inspectFuncActivatePrototype   func(ctx context.Context, request insolar.Reference, parent insolar.Reference, code insolar.Reference, memory []byte)
	afterActivatePrototypeCounter  uint64
	beforeActivatePrototypeCounter uint64
	ActivatePrototypeMock          mClientMockActivatePrototype

	funcDeployCode          func(ctx context.Context, domain insolar.Reference, request insolar.Reference, code []byte, machineType insolar.MachineType) (ip1 *insolar.ID, err error)
	inspectFuncDeployCode   func(ctx context.Context, domain insolar.Reference, request insolar.Reference, code []byte, machineType insolar.MachineType)
	afterDeployCodeCounter  uint64
	beforeDeployCodeCounter uint64
	DeployCodeMock          mClientMockDeployCode

	funcGetAbandonedRequest          func(ctx context.Context, objectRef insolar.Reference, reqRef insolar.Reference) (r1 record.Request, err error)
	inspectFuncGetAbandonedRequest   func(ctx context.Context, objectRef insolar.Reference, reqRef insolar.Reference)
	afterGetAbandonedRequestCounter  uint64
	beforeGetAbandonedRequestCounter uint64
	GetAbandonedRequestMock          mClientMockGetAbandonedRequest

	funcGetCode          func(ctx context.Context, ref insolar.Reference) (c2 CodeDescriptor, err error)
	inspectFuncGetCode   func(ctx context.Context, ref insolar.Reference)
	afterGetCodeCounter  uint64
	beforeGetCodeCounter uint64
	GetCodeMock          mClientMockGetCode

	funcGetObject          func(ctx context.Context, head insolar.Reference) (o1 ObjectDescriptor, err error)
	inspectFuncGetObject   func(ctx context.Context, head insolar.Reference)
	afterGetObjectCounter  uint64
	beforeGetObjectCounter uint64
	GetObjectMock          mClientMockGetObject

	funcGetPendings          func(ctx context.Context, objectRef insolar.Reference) (ra1 []insolar.Reference, err error)
	inspectFuncGetPendings   func(ctx context.Context, objectRef insolar.Reference)
	afterGetPendingsCounter  uint64
	beforeGetPendingsCounter uint64
	GetPendingsMock          mClientMockGetPendings

	funcHasPendings          func(ctx context.Context, object insolar.Reference) (b1 bool, err error)
	inspectFuncHasPendings   func(ctx context.Context, object insolar.Reference)
	afterHasPendingsCounter  uint64
	beforeHasPendingsCounter uint64
	HasPendingsMock          mClientMockHasPendings

	funcInjectCodeDescriptor          func(r1 insolar.Reference, c1 CodeDescriptor)
	inspectFuncInjectCodeDescriptor   func(r1 insolar.Reference, c1 CodeDescriptor)
	afterInjectCodeDescriptorCounter  uint64
	beforeInjectCodeDescriptorCounter uint64
	InjectCodeDescriptorMock          mClientMockInjectCodeDescriptor

	funcInjectFinish          func()
	inspectFuncInjectFinish   func()
	afterInjectFinishCounter  uint64
	beforeInjectFinishCounter uint64
	InjectFinishMock          mClientMockInjectFinish

	funcInjectObjectDescriptor          func(r1 insolar.Reference, o1 ObjectDescriptor)
	inspectFuncInjectObjectDescriptor   func(r1 insolar.Reference, o1 ObjectDescriptor)
	afterInjectObjectDescriptorCounter  uint64
	beforeInjectObjectDescriptorCounter uint64
	InjectObjectDescriptorMock          mClientMockInjectObjectDescriptor

	funcRegisterIncomingRequest          func(ctx context.Context, request *record.IncomingRequest) (rp1 *payload.RequestInfo, err error)
	inspectFuncRegisterIncomingRequest   func(ctx context.Context, request *record.IncomingRequest)
	afterRegisterIncomingRequestCounter  uint64
	beforeRegisterIncomingRequestCounter uint64
	RegisterIncomingRequestMock          mClientMockRegisterIncomingRequest

	funcRegisterOutgoingRequest          func(ctx context.Context, request *record.OutgoingRequest) (rp1 *payload.RequestInfo, err error)
	inspectFuncRegisterOutgoingRequest   func(ctx context.Context, request *record.OutgoingRequest)
	afterRegisterOutgoingRequestCounter  uint64
	beforeRegisterOutgoingRequestCounter uint64
	RegisterOutgoingRequestMock          mClientMockRegisterOutgoingRequest

	funcRegisterResult          func(ctx context.Context, request insolar.Reference, result RequestResult) (err error)
	inspectFuncRegisterResult   func(ctx context.Context, request insolar.Reference, result RequestResult)
	afterRegisterResultCounter  uint64
	beforeRegisterResultCounter uint64
	RegisterResultMock          mClientMockRegisterResult

	funcState          func() (ba1 []byte)
	inspectFuncState   func()
	afterStateCounter  uint64
	beforeStateCounter uint64
	StateMock          mClientMockState
}

// NewClientMock returns a mock for Client
func NewClientMock(t minimock.Tester) *ClientMock {
	m := &ClientMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ActivatePrototypeMock = mClientMockActivatePrototype{mock: m}
	m.ActivatePrototypeMock.callArgs = []*ClientMockActivatePrototypeParams{}

	m.DeployCodeMock = mClientMockDeployCode{mock: m}
	m.DeployCodeMock.callArgs = []*ClientMockDeployCodeParams{}

	m.GetAbandonedRequestMock = mClientMockGetAbandonedRequest{mock: m}
	m.GetAbandonedRequestMock.callArgs = []*ClientMockGetAbandonedRequestParams{}

	m.GetCodeMock = mClientMockGetCode{mock: m}
	m.GetCodeMock.callArgs = []*ClientMockGetCodeParams{}

	m.GetObjectMock = mClientMockGetObject{mock: m}
	m.GetObjectMock.callArgs = []*ClientMockGetObjectParams{}

	m.GetPendingsMock = mClientMockGetPendings{mock: m}
	m.GetPendingsMock.callArgs = []*ClientMockGetPendingsParams{}

	m.HasPendingsMock = mClientMockHasPendings{mock: m}
	m.HasPendingsMock.callArgs = []*ClientMockHasPendingsParams{}

	m.InjectCodeDescriptorMock = mClientMockInjectCodeDescriptor{mock: m}
	m.InjectCodeDescriptorMock.callArgs = []*ClientMockInjectCodeDescriptorParams{}

	m.InjectFinishMock = mClientMockInjectFinish{mock: m}

	m.InjectObjectDescriptorMock = mClientMockInjectObjectDescriptor{mock: m}
	m.InjectObjectDescriptorMock.callArgs = []*ClientMockInjectObjectDescriptorParams{}

	m.RegisterIncomingRequestMock = mClientMockRegisterIncomingRequest{mock: m}
	m.RegisterIncomingRequestMock.callArgs = []*ClientMockRegisterIncomingRequestParams{}

	m.RegisterOutgoingRequestMock = mClientMockRegisterOutgoingRequest{mock: m}
	m.RegisterOutgoingRequestMock.callArgs = []*ClientMockRegisterOutgoingRequestParams{}

	m.RegisterResultMock = mClientMockRegisterResult{mock: m}
	m.RegisterResultMock.callArgs = []*ClientMockRegisterResultParams{}

	m.StateMock = mClientMockState{mock: m}

	return m
}

type mClientMockActivatePrototype struct {
	mock               *ClientMock
	defaultExpectation *ClientMockActivatePrototypeExpectation
	expectations       []*ClientMockActivatePrototypeExpectation

	callArgs []*ClientMockActivatePrototypeParams
	mutex    sync.RWMutex
}

// ClientMockActivatePrototypeExpectation specifies expectation struct of the Client.ActivatePrototype
type ClientMockActivatePrototypeExpectation struct {
	mock    *ClientMock
	params  *ClientMockActivatePrototypeParams
	results *ClientMockActivatePrototypeResults
	Counter uint64
}

// ClientMockActivatePrototypeParams contains parameters of the Client.ActivatePrototype
type ClientMockActivatePrototypeParams struct {
	ctx     context.Context
	request insolar.Reference
	parent  insolar.Reference
	code    insolar.Reference
	memory  []byte
}

// ClientMockActivatePrototypeResults contains results of the Client.ActivatePrototype
type ClientMockActivatePrototypeResults struct {
	err error
}

// Expect sets up expected params for Client.ActivatePrototype
func (mmActivatePrototype *mClientMockActivatePrototype) Expect(ctx context.Context, request insolar.Reference, parent insolar.Reference, code insolar.Reference, memory []byte) *mClientMockActivatePrototype {
	if mmActivatePrototype.mock.funcActivatePrototype != nil {
		mmActivatePrototype.mock.t.Fatalf("ClientMock.ActivatePrototype mock is already set by Set")
	}

	if mmActivatePrototype.defaultExpectation == nil {
		mmActivatePrototype.defaultExpectation = &ClientMockActivatePrototypeExpectation{}
	}

	mmActivatePrototype.defaultExpectation.params = &ClientMockActivatePrototypeParams{ctx, request, parent, code, memory}
	for _, e := range mmActivatePrototype.expectations {
		if minimock.Equal(e.params, mmActivatePrototype.defaultExpectation.params) {
			mmActivatePrototype.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmActivatePrototype.defaultExpectation.params)
		}
	}

	return mmActivatePrototype
}

// Inspect accepts an inspector function that has same arguments as the Client.ActivatePrototype
func (mmActivatePrototype *mClientMockActivatePrototype) Inspect(f func(ctx context.Context, request insolar.Reference, parent insolar.Reference, code insolar.Reference, memory []byte)) *mClientMockActivatePrototype {
	if mmActivatePrototype.mock.inspectFuncActivatePrototype != nil {
		mmActivatePrototype.mock.t.Fatalf("Inspect function is already set for ClientMock.ActivatePrototype")
	}

	mmActivatePrototype.mock.inspectFuncActivatePrototype = f

	return mmActivatePrototype
}

// Return sets up results that will be returned by Client.ActivatePrototype
func (mmActivatePrototype *mClientMockActivatePrototype) Return(err error) *ClientMock {
	if mmActivatePrototype.mock.funcActivatePrototype != nil {
		mmActivatePrototype.mock.t.Fatalf("ClientMock.ActivatePrototype mock is already set by Set")
	}

	if mmActivatePrototype.defaultExpectation == nil {
		mmActivatePrototype.defaultExpectation = &ClientMockActivatePrototypeExpectation{mock: mmActivatePrototype.mock}
	}
	mmActivatePrototype.defaultExpectation.results = &ClientMockActivatePrototypeResults{err}
	return mmActivatePrototype.mock
}

//Set uses given function f to mock the Client.ActivatePrototype method
func (mmActivatePrototype *mClientMockActivatePrototype) Set(f func(ctx context.Context, request insolar.Reference, parent insolar.Reference, code insolar.Reference, memory []byte) (err error)) *ClientMock {
	if mmActivatePrototype.defaultExpectation != nil {
		mmActivatePrototype.mock.t.Fatalf("Default expectation is already set for the Client.ActivatePrototype method")
	}

	if len(mmActivatePrototype.expectations) > 0 {
		mmActivatePrototype.mock.t.Fatalf("Some expectations are already set for the Client.ActivatePrototype method")
	}

	mmActivatePrototype.mock.funcActivatePrototype = f
	return mmActivatePrototype.mock
}

// When sets expectation for the Client.ActivatePrototype which will trigger the result defined by the following
// Then helper
func (mmActivatePrototype *mClientMockActivatePrototype) When(ctx context.Context, request insolar.Reference, parent insolar.Reference, code insolar.Reference, memory []byte) *ClientMockActivatePrototypeExpectation {
	if mmActivatePrototype.mock.funcActivatePrototype != nil {
		mmActivatePrototype.mock.t.Fatalf("ClientMock.ActivatePrototype mock is already set by Set")
	}

	expectation := &ClientMockActivatePrototypeExpectation{
		mock:   mmActivatePrototype.mock,
		params: &ClientMockActivatePrototypeParams{ctx, request, parent, code, memory},
	}
	mmActivatePrototype.expectations = append(mmActivatePrototype.expectations, expectation)
	return expectation
}

// Then sets up Client.ActivatePrototype return parameters for the expectation previously defined by the When method
func (e *ClientMockActivatePrototypeExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockActivatePrototypeResults{err}
	return e.mock
}

// ActivatePrototype implements Client
func (mmActivatePrototype *ClientMock) ActivatePrototype(ctx context.Context, request insolar.Reference, parent insolar.Reference, code insolar.Reference, memory []byte) (err error) {
	mm_atomic.AddUint64(&mmActivatePrototype.beforeActivatePrototypeCounter, 1)
	defer mm_atomic.AddUint64(&mmActivatePrototype.afterActivatePrototypeCounter, 1)

	if mmActivatePrototype.inspectFuncActivatePrototype != nil {
		mmActivatePrototype.inspectFuncActivatePrototype(ctx, request, parent, code, memory)
	}

	params := &ClientMockActivatePrototypeParams{ctx, request, parent, code, memory}

	// Record call args
	mmActivatePrototype.ActivatePrototypeMock.mutex.Lock()
	mmActivatePrototype.ActivatePrototypeMock.callArgs = append(mmActivatePrototype.ActivatePrototypeMock.callArgs, params)
	mmActivatePrototype.ActivatePrototypeMock.mutex.Unlock()

	for _, e := range mmActivatePrototype.ActivatePrototypeMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmActivatePrototype.ActivatePrototypeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmActivatePrototype.ActivatePrototypeMock.defaultExpectation.Counter, 1)
		want := mmActivatePrototype.ActivatePrototypeMock.defaultExpectation.params
		got := ClientMockActivatePrototypeParams{ctx, request, parent, code, memory}
		if want != nil && !minimock.Equal(*want, got) {
			mmActivatePrototype.t.Errorf("ClientMock.ActivatePrototype got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmActivatePrototype.ActivatePrototypeMock.defaultExpectation.results
		if results == nil {
			mmActivatePrototype.t.Fatal("No results are set for the ClientMock.ActivatePrototype")
		}
		return (*results).err
	}
	if mmActivatePrototype.funcActivatePrototype != nil {
		return mmActivatePrototype.funcActivatePrototype(ctx, request, parent, code, memory)
	}
	mmActivatePrototype.t.Fatalf("Unexpected call to ClientMock.ActivatePrototype. %v %v %v %v %v", ctx, request, parent, code, memory)
	return
}

// ActivatePrototypeAfterCounter returns a count of finished ClientMock.ActivatePrototype invocations
func (mmActivatePrototype *ClientMock) ActivatePrototypeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmActivatePrototype.afterActivatePrototypeCounter)
}

// ActivatePrototypeBeforeCounter returns a count of ClientMock.ActivatePrototype invocations
func (mmActivatePrototype *ClientMock) ActivatePrototypeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmActivatePrototype.beforeActivatePrototypeCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.ActivatePrototype.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmActivatePrototype *mClientMockActivatePrototype) Calls() []*ClientMockActivatePrototypeParams {
	mmActivatePrototype.mutex.RLock()

	argCopy := make([]*ClientMockActivatePrototypeParams, len(mmActivatePrototype.callArgs))
	copy(argCopy, mmActivatePrototype.callArgs)

	mmActivatePrototype.mutex.RUnlock()

	return argCopy
}

// MinimockActivatePrototypeDone returns true if the count of the ActivatePrototype invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockActivatePrototypeDone() bool {
	for _, e := range m.ActivatePrototypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ActivatePrototypeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterActivatePrototypeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcActivatePrototype != nil && mm_atomic.LoadUint64(&m.afterActivatePrototypeCounter) < 1 {
		return false
	}
	return true
}

// MinimockActivatePrototypeInspect logs each unmet expectation
func (m *ClientMock) MinimockActivatePrototypeInspect() {
	for _, e := range m.ActivatePrototypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.ActivatePrototype with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ActivatePrototypeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterActivatePrototypeCounter) < 1 {
		if m.ActivatePrototypeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.ActivatePrototype")
		} else {
			m.t.Errorf("Expected call to ClientMock.ActivatePrototype with params: %#v", *m.ActivatePrototypeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcActivatePrototype != nil && mm_atomic.LoadUint64(&m.afterActivatePrototypeCounter) < 1 {
		m.t.Error("Expected call to ClientMock.ActivatePrototype")
	}
}

type mClientMockDeployCode struct {
	mock               *ClientMock
	defaultExpectation *ClientMockDeployCodeExpectation
	expectations       []*ClientMockDeployCodeExpectation

	callArgs []*ClientMockDeployCodeParams
	mutex    sync.RWMutex
}

// ClientMockDeployCodeExpectation specifies expectation struct of the Client.DeployCode
type ClientMockDeployCodeExpectation struct {
	mock    *ClientMock
	params  *ClientMockDeployCodeParams
	results *ClientMockDeployCodeResults
	Counter uint64
}

// ClientMockDeployCodeParams contains parameters of the Client.DeployCode
type ClientMockDeployCodeParams struct {
	ctx         context.Context
	domain      insolar.Reference
	request     insolar.Reference
	code        []byte
	machineType insolar.MachineType
}

// ClientMockDeployCodeResults contains results of the Client.DeployCode
type ClientMockDeployCodeResults struct {
	ip1 *insolar.ID
	err error
}

// Expect sets up expected params for Client.DeployCode
func (mmDeployCode *mClientMockDeployCode) Expect(ctx context.Context, domain insolar.Reference, request insolar.Reference, code []byte, machineType insolar.MachineType) *mClientMockDeployCode {
	if mmDeployCode.mock.funcDeployCode != nil {
		mmDeployCode.mock.t.Fatalf("ClientMock.DeployCode mock is already set by Set")
	}

	if mmDeployCode.defaultExpectation == nil {
		mmDeployCode.defaultExpectation = &ClientMockDeployCodeExpectation{}
	}

	mmDeployCode.defaultExpectation.params = &ClientMockDeployCodeParams{ctx, domain, request, code, machineType}
	for _, e := range mmDeployCode.expectations {
		if minimock.Equal(e.params, mmDeployCode.defaultExpectation.params) {
			mmDeployCode.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeployCode.defaultExpectation.params)
		}
	}

	return mmDeployCode
}

// Inspect accepts an inspector function that has same arguments as the Client.DeployCode
func (mmDeployCode *mClientMockDeployCode) Inspect(f func(ctx context.Context, domain insolar.Reference, request insolar.Reference, code []byte, machineType insolar.MachineType)) *mClientMockDeployCode {
	if mmDeployCode.mock.inspectFuncDeployCode != nil {
		mmDeployCode.mock.t.Fatalf("Inspect function is already set for ClientMock.DeployCode")
	}

	mmDeployCode.mock.inspectFuncDeployCode = f

	return mmDeployCode
}

// Return sets up results that will be returned by Client.DeployCode
func (mmDeployCode *mClientMockDeployCode) Return(ip1 *insolar.ID, err error) *ClientMock {
	if mmDeployCode.mock.funcDeployCode != nil {
		mmDeployCode.mock.t.Fatalf("ClientMock.DeployCode mock is already set by Set")
	}

	if mmDeployCode.defaultExpectation == nil {
		mmDeployCode.defaultExpectation = &ClientMockDeployCodeExpectation{mock: mmDeployCode.mock}
	}
	mmDeployCode.defaultExpectation.results = &ClientMockDeployCodeResults{ip1, err}
	return mmDeployCode.mock
}

//Set uses given function f to mock the Client.DeployCode method
func (mmDeployCode *mClientMockDeployCode) Set(f func(ctx context.Context, domain insolar.Reference, request insolar.Reference, code []byte, machineType insolar.MachineType) (ip1 *insolar.ID, err error)) *ClientMock {
	if mmDeployCode.defaultExpectation != nil {
		mmDeployCode.mock.t.Fatalf("Default expectation is already set for the Client.DeployCode method")
	}

	if len(mmDeployCode.expectations) > 0 {
		mmDeployCode.mock.t.Fatalf("Some expectations are already set for the Client.DeployCode method")
	}

	mmDeployCode.mock.funcDeployCode = f
	return mmDeployCode.mock
}

// When sets expectation for the Client.DeployCode which will trigger the result defined by the following
// Then helper
func (mmDeployCode *mClientMockDeployCode) When(ctx context.Context, domain insolar.Reference, request insolar.Reference, code []byte, machineType insolar.MachineType) *ClientMockDeployCodeExpectation {
	if mmDeployCode.mock.funcDeployCode != nil {
		mmDeployCode.mock.t.Fatalf("ClientMock.DeployCode mock is already set by Set")
	}

	expectation := &ClientMockDeployCodeExpectation{
		mock:   mmDeployCode.mock,
		params: &ClientMockDeployCodeParams{ctx, domain, request, code, machineType},
	}
	mmDeployCode.expectations = append(mmDeployCode.expectations, expectation)
	return expectation
}

// Then sets up Client.DeployCode return parameters for the expectation previously defined by the When method
func (e *ClientMockDeployCodeExpectation) Then(ip1 *insolar.ID, err error) *ClientMock {
	e.results = &ClientMockDeployCodeResults{ip1, err}
	return e.mock
}

// DeployCode implements Client
func (mmDeployCode *ClientMock) DeployCode(ctx context.Context, domain insolar.Reference, request insolar.Reference, code []byte, machineType insolar.MachineType) (ip1 *insolar.ID, err error) {
	mm_atomic.AddUint64(&mmDeployCode.beforeDeployCodeCounter, 1)
	defer mm_atomic.AddUint64(&mmDeployCode.afterDeployCodeCounter, 1)

	if mmDeployCode.inspectFuncDeployCode != nil {
		mmDeployCode.inspectFuncDeployCode(ctx, domain, request, code, machineType)
	}

	params := &ClientMockDeployCodeParams{ctx, domain, request, code, machineType}

	// Record call args
	mmDeployCode.DeployCodeMock.mutex.Lock()
	mmDeployCode.DeployCodeMock.callArgs = append(mmDeployCode.DeployCodeMock.callArgs, params)
	mmDeployCode.DeployCodeMock.mutex.Unlock()

	for _, e := range mmDeployCode.DeployCodeMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ip1, e.results.err
		}
	}

	if mmDeployCode.DeployCodeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeployCode.DeployCodeMock.defaultExpectation.Counter, 1)
		want := mmDeployCode.DeployCodeMock.defaultExpectation.params
		got := ClientMockDeployCodeParams{ctx, domain, request, code, machineType}
		if want != nil && !minimock.Equal(*want, got) {
			mmDeployCode.t.Errorf("ClientMock.DeployCode got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmDeployCode.DeployCodeMock.defaultExpectation.results
		if results == nil {
			mmDeployCode.t.Fatal("No results are set for the ClientMock.DeployCode")
		}
		return (*results).ip1, (*results).err
	}
	if mmDeployCode.funcDeployCode != nil {
		return mmDeployCode.funcDeployCode(ctx, domain, request, code, machineType)
	}
	mmDeployCode.t.Fatalf("Unexpected call to ClientMock.DeployCode. %v %v %v %v %v", ctx, domain, request, code, machineType)
	return
}

// DeployCodeAfterCounter returns a count of finished ClientMock.DeployCode invocations
func (mmDeployCode *ClientMock) DeployCodeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeployCode.afterDeployCodeCounter)
}

// DeployCodeBeforeCounter returns a count of ClientMock.DeployCode invocations
func (mmDeployCode *ClientMock) DeployCodeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeployCode.beforeDeployCodeCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.DeployCode.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeployCode *mClientMockDeployCode) Calls() []*ClientMockDeployCodeParams {
	mmDeployCode.mutex.RLock()

	argCopy := make([]*ClientMockDeployCodeParams, len(mmDeployCode.callArgs))
	copy(argCopy, mmDeployCode.callArgs)

	mmDeployCode.mutex.RUnlock()

	return argCopy
}

// MinimockDeployCodeDone returns true if the count of the DeployCode invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockDeployCodeDone() bool {
	for _, e := range m.DeployCodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeployCodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeployCodeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeployCode != nil && mm_atomic.LoadUint64(&m.afterDeployCodeCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeployCodeInspect logs each unmet expectation
func (m *ClientMock) MinimockDeployCodeInspect() {
	for _, e := range m.DeployCodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.DeployCode with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeployCodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeployCodeCounter) < 1 {
		if m.DeployCodeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.DeployCode")
		} else {
			m.t.Errorf("Expected call to ClientMock.DeployCode with params: %#v", *m.DeployCodeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeployCode != nil && mm_atomic.LoadUint64(&m.afterDeployCodeCounter) < 1 {
		m.t.Error("Expected call to ClientMock.DeployCode")
	}
}

type mClientMockGetAbandonedRequest struct {
	mock               *ClientMock
	defaultExpectation *ClientMockGetAbandonedRequestExpectation
	expectations       []*ClientMockGetAbandonedRequestExpectation

	callArgs []*ClientMockGetAbandonedRequestParams
	mutex    sync.RWMutex
}

// ClientMockGetAbandonedRequestExpectation specifies expectation struct of the Client.GetAbandonedRequest
type ClientMockGetAbandonedRequestExpectation struct {
	mock    *ClientMock
	params  *ClientMockGetAbandonedRequestParams
	results *ClientMockGetAbandonedRequestResults
	Counter uint64
}

// ClientMockGetAbandonedRequestParams contains parameters of the Client.GetAbandonedRequest
type ClientMockGetAbandonedRequestParams struct {
	ctx       context.Context
	objectRef insolar.Reference
	reqRef    insolar.Reference
}

// ClientMockGetAbandonedRequestResults contains results of the Client.GetAbandonedRequest
type ClientMockGetAbandonedRequestResults struct {
	r1  record.Request
	err error
}

// Expect sets up expected params for Client.GetAbandonedRequest
func (mmGetAbandonedRequest *mClientMockGetAbandonedRequest) Expect(ctx context.Context, objectRef insolar.Reference, reqRef insolar.Reference) *mClientMockGetAbandonedRequest {
	if mmGetAbandonedRequest.mock.funcGetAbandonedRequest != nil {
		mmGetAbandonedRequest.mock.t.Fatalf("ClientMock.GetAbandonedRequest mock is already set by Set")
	}

	if mmGetAbandonedRequest.defaultExpectation == nil {
		mmGetAbandonedRequest.defaultExpectation = &ClientMockGetAbandonedRequestExpectation{}
	}

	mmGetAbandonedRequest.defaultExpectation.params = &ClientMockGetAbandonedRequestParams{ctx, objectRef, reqRef}
	for _, e := range mmGetAbandonedRequest.expectations {
		if minimock.Equal(e.params, mmGetAbandonedRequest.defaultExpectation.params) {
			mmGetAbandonedRequest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAbandonedRequest.defaultExpectation.params)
		}
	}

	return mmGetAbandonedRequest
}

// Inspect accepts an inspector function that has same arguments as the Client.GetAbandonedRequest
func (mmGetAbandonedRequest *mClientMockGetAbandonedRequest) Inspect(f func(ctx context.Context, objectRef insolar.Reference, reqRef insolar.Reference)) *mClientMockGetAbandonedRequest {
	if mmGetAbandonedRequest.mock.inspectFuncGetAbandonedRequest != nil {
		mmGetAbandonedRequest.mock.t.Fatalf("Inspect function is already set for ClientMock.GetAbandonedRequest")
	}

	mmGetAbandonedRequest.mock.inspectFuncGetAbandonedRequest = f

	return mmGetAbandonedRequest
}

// Return sets up results that will be returned by Client.GetAbandonedRequest
func (mmGetAbandonedRequest *mClientMockGetAbandonedRequest) Return(r1 record.Request, err error) *ClientMock {
	if mmGetAbandonedRequest.mock.funcGetAbandonedRequest != nil {
		mmGetAbandonedRequest.mock.t.Fatalf("ClientMock.GetAbandonedRequest mock is already set by Set")
	}

	if mmGetAbandonedRequest.defaultExpectation == nil {
		mmGetAbandonedRequest.defaultExpectation = &ClientMockGetAbandonedRequestExpectation{mock: mmGetAbandonedRequest.mock}
	}
	mmGetAbandonedRequest.defaultExpectation.results = &ClientMockGetAbandonedRequestResults{r1, err}
	return mmGetAbandonedRequest.mock
}

//Set uses given function f to mock the Client.GetAbandonedRequest method
func (mmGetAbandonedRequest *mClientMockGetAbandonedRequest) Set(f func(ctx context.Context, objectRef insolar.Reference, reqRef insolar.Reference) (r1 record.Request, err error)) *ClientMock {
	if mmGetAbandonedRequest.defaultExpectation != nil {
		mmGetAbandonedRequest.mock.t.Fatalf("Default expectation is already set for the Client.GetAbandonedRequest method")
	}

	if len(mmGetAbandonedRequest.expectations) > 0 {
		mmGetAbandonedRequest.mock.t.Fatalf("Some expectations are already set for the Client.GetAbandonedRequest method")
	}

	mmGetAbandonedRequest.mock.funcGetAbandonedRequest = f
	return mmGetAbandonedRequest.mock
}

// When sets expectation for the Client.GetAbandonedRequest which will trigger the result defined by the following
// Then helper
func (mmGetAbandonedRequest *mClientMockGetAbandonedRequest) When(ctx context.Context, objectRef insolar.Reference, reqRef insolar.Reference) *ClientMockGetAbandonedRequestExpectation {
	if mmGetAbandonedRequest.mock.funcGetAbandonedRequest != nil {
		mmGetAbandonedRequest.mock.t.Fatalf("ClientMock.GetAbandonedRequest mock is already set by Set")
	}

	expectation := &ClientMockGetAbandonedRequestExpectation{
		mock:   mmGetAbandonedRequest.mock,
		params: &ClientMockGetAbandonedRequestParams{ctx, objectRef, reqRef},
	}
	mmGetAbandonedRequest.expectations = append(mmGetAbandonedRequest.expectations, expectation)
	return expectation
}

// Then sets up Client.GetAbandonedRequest return parameters for the expectation previously defined by the When method
func (e *ClientMockGetAbandonedRequestExpectation) Then(r1 record.Request, err error) *ClientMock {
	e.results = &ClientMockGetAbandonedRequestResults{r1, err}
	return e.mock
}

// GetAbandonedRequest implements Client
func (mmGetAbandonedRequest *ClientMock) GetAbandonedRequest(ctx context.Context, objectRef insolar.Reference, reqRef insolar.Reference) (r1 record.Request, err error) {
	mm_atomic.AddUint64(&mmGetAbandonedRequest.beforeGetAbandonedRequestCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAbandonedRequest.afterGetAbandonedRequestCounter, 1)

	if mmGetAbandonedRequest.inspectFuncGetAbandonedRequest != nil {
		mmGetAbandonedRequest.inspectFuncGetAbandonedRequest(ctx, objectRef, reqRef)
	}

	params := &ClientMockGetAbandonedRequestParams{ctx, objectRef, reqRef}

	// Record call args
	mmGetAbandonedRequest.GetAbandonedRequestMock.mutex.Lock()
	mmGetAbandonedRequest.GetAbandonedRequestMock.callArgs = append(mmGetAbandonedRequest.GetAbandonedRequestMock.callArgs, params)
	mmGetAbandonedRequest.GetAbandonedRequestMock.mutex.Unlock()

	for _, e := range mmGetAbandonedRequest.GetAbandonedRequestMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmGetAbandonedRequest.GetAbandonedRequestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAbandonedRequest.GetAbandonedRequestMock.defaultExpectation.Counter, 1)
		want := mmGetAbandonedRequest.GetAbandonedRequestMock.defaultExpectation.params
		got := ClientMockGetAbandonedRequestParams{ctx, objectRef, reqRef}
		if want != nil && !minimock.Equal(*want, got) {
			mmGetAbandonedRequest.t.Errorf("ClientMock.GetAbandonedRequest got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmGetAbandonedRequest.GetAbandonedRequestMock.defaultExpectation.results
		if results == nil {
			mmGetAbandonedRequest.t.Fatal("No results are set for the ClientMock.GetAbandonedRequest")
		}
		return (*results).r1, (*results).err
	}
	if mmGetAbandonedRequest.funcGetAbandonedRequest != nil {
		return mmGetAbandonedRequest.funcGetAbandonedRequest(ctx, objectRef, reqRef)
	}
	mmGetAbandonedRequest.t.Fatalf("Unexpected call to ClientMock.GetAbandonedRequest. %v %v %v", ctx, objectRef, reqRef)
	return
}

// GetAbandonedRequestAfterCounter returns a count of finished ClientMock.GetAbandonedRequest invocations
func (mmGetAbandonedRequest *ClientMock) GetAbandonedRequestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAbandonedRequest.afterGetAbandonedRequestCounter)
}

// GetAbandonedRequestBeforeCounter returns a count of ClientMock.GetAbandonedRequest invocations
func (mmGetAbandonedRequest *ClientMock) GetAbandonedRequestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAbandonedRequest.beforeGetAbandonedRequestCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetAbandonedRequest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAbandonedRequest *mClientMockGetAbandonedRequest) Calls() []*ClientMockGetAbandonedRequestParams {
	mmGetAbandonedRequest.mutex.RLock()

	argCopy := make([]*ClientMockGetAbandonedRequestParams, len(mmGetAbandonedRequest.callArgs))
	copy(argCopy, mmGetAbandonedRequest.callArgs)

	mmGetAbandonedRequest.mutex.RUnlock()

	return argCopy
}

// MinimockGetAbandonedRequestDone returns true if the count of the GetAbandonedRequest invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetAbandonedRequestDone() bool {
	for _, e := range m.GetAbandonedRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAbandonedRequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAbandonedRequestCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAbandonedRequest != nil && mm_atomic.LoadUint64(&m.afterGetAbandonedRequestCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetAbandonedRequestInspect logs each unmet expectation
func (m *ClientMock) MinimockGetAbandonedRequestInspect() {
	for _, e := range m.GetAbandonedRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetAbandonedRequest with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAbandonedRequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAbandonedRequestCounter) < 1 {
		if m.GetAbandonedRequestMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetAbandonedRequest")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetAbandonedRequest with params: %#v", *m.GetAbandonedRequestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAbandonedRequest != nil && mm_atomic.LoadUint64(&m.afterGetAbandonedRequestCounter) < 1 {
		m.t.Error("Expected call to ClientMock.GetAbandonedRequest")
	}
}

type mClientMockGetCode struct {
	mock               *ClientMock
	defaultExpectation *ClientMockGetCodeExpectation
	expectations       []*ClientMockGetCodeExpectation

	callArgs []*ClientMockGetCodeParams
	mutex    sync.RWMutex
}

// ClientMockGetCodeExpectation specifies expectation struct of the Client.GetCode
type ClientMockGetCodeExpectation struct {
	mock    *ClientMock
	params  *ClientMockGetCodeParams
	results *ClientMockGetCodeResults
	Counter uint64
}

// ClientMockGetCodeParams contains parameters of the Client.GetCode
type ClientMockGetCodeParams struct {
	ctx context.Context
	ref insolar.Reference
}

// ClientMockGetCodeResults contains results of the Client.GetCode
type ClientMockGetCodeResults struct {
	c2  CodeDescriptor
	err error
}

// Expect sets up expected params for Client.GetCode
func (mmGetCode *mClientMockGetCode) Expect(ctx context.Context, ref insolar.Reference) *mClientMockGetCode {
	if mmGetCode.mock.funcGetCode != nil {
		mmGetCode.mock.t.Fatalf("ClientMock.GetCode mock is already set by Set")
	}

	if mmGetCode.defaultExpectation == nil {
		mmGetCode.defaultExpectation = &ClientMockGetCodeExpectation{}
	}

	mmGetCode.defaultExpectation.params = &ClientMockGetCodeParams{ctx, ref}
	for _, e := range mmGetCode.expectations {
		if minimock.Equal(e.params, mmGetCode.defaultExpectation.params) {
			mmGetCode.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCode.defaultExpectation.params)
		}
	}

	return mmGetCode
}

// Inspect accepts an inspector function that has same arguments as the Client.GetCode
func (mmGetCode *mClientMockGetCode) Inspect(f func(ctx context.Context, ref insolar.Reference)) *mClientMockGetCode {
	if mmGetCode.mock.inspectFuncGetCode != nil {
		mmGetCode.mock.t.Fatalf("Inspect function is already set for ClientMock.GetCode")
	}

	mmGetCode.mock.inspectFuncGetCode = f

	return mmGetCode
}

// Return sets up results that will be returned by Client.GetCode
func (mmGetCode *mClientMockGetCode) Return(c2 CodeDescriptor, err error) *ClientMock {
	if mmGetCode.mock.funcGetCode != nil {
		mmGetCode.mock.t.Fatalf("ClientMock.GetCode mock is already set by Set")
	}

	if mmGetCode.defaultExpectation == nil {
		mmGetCode.defaultExpectation = &ClientMockGetCodeExpectation{mock: mmGetCode.mock}
	}
	mmGetCode.defaultExpectation.results = &ClientMockGetCodeResults{c2, err}
	return mmGetCode.mock
}

//Set uses given function f to mock the Client.GetCode method
func (mmGetCode *mClientMockGetCode) Set(f func(ctx context.Context, ref insolar.Reference) (c2 CodeDescriptor, err error)) *ClientMock {
	if mmGetCode.defaultExpectation != nil {
		mmGetCode.mock.t.Fatalf("Default expectation is already set for the Client.GetCode method")
	}

	if len(mmGetCode.expectations) > 0 {
		mmGetCode.mock.t.Fatalf("Some expectations are already set for the Client.GetCode method")
	}

	mmGetCode.mock.funcGetCode = f
	return mmGetCode.mock
}

// When sets expectation for the Client.GetCode which will trigger the result defined by the following
// Then helper
func (mmGetCode *mClientMockGetCode) When(ctx context.Context, ref insolar.Reference) *ClientMockGetCodeExpectation {
	if mmGetCode.mock.funcGetCode != nil {
		mmGetCode.mock.t.Fatalf("ClientMock.GetCode mock is already set by Set")
	}

	expectation := &ClientMockGetCodeExpectation{
		mock:   mmGetCode.mock,
		params: &ClientMockGetCodeParams{ctx, ref},
	}
	mmGetCode.expectations = append(mmGetCode.expectations, expectation)
	return expectation
}

// Then sets up Client.GetCode return parameters for the expectation previously defined by the When method
func (e *ClientMockGetCodeExpectation) Then(c2 CodeDescriptor, err error) *ClientMock {
	e.results = &ClientMockGetCodeResults{c2, err}
	return e.mock
}

// GetCode implements Client
func (mmGetCode *ClientMock) GetCode(ctx context.Context, ref insolar.Reference) (c2 CodeDescriptor, err error) {
	mm_atomic.AddUint64(&mmGetCode.beforeGetCodeCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCode.afterGetCodeCounter, 1)

	if mmGetCode.inspectFuncGetCode != nil {
		mmGetCode.inspectFuncGetCode(ctx, ref)
	}

	params := &ClientMockGetCodeParams{ctx, ref}

	// Record call args
	mmGetCode.GetCodeMock.mutex.Lock()
	mmGetCode.GetCodeMock.callArgs = append(mmGetCode.GetCodeMock.callArgs, params)
	mmGetCode.GetCodeMock.mutex.Unlock()

	for _, e := range mmGetCode.GetCodeMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.err
		}
	}

	if mmGetCode.GetCodeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCode.GetCodeMock.defaultExpectation.Counter, 1)
		want := mmGetCode.GetCodeMock.defaultExpectation.params
		got := ClientMockGetCodeParams{ctx, ref}
		if want != nil && !minimock.Equal(*want, got) {
			mmGetCode.t.Errorf("ClientMock.GetCode got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmGetCode.GetCodeMock.defaultExpectation.results
		if results == nil {
			mmGetCode.t.Fatal("No results are set for the ClientMock.GetCode")
		}
		return (*results).c2, (*results).err
	}
	if mmGetCode.funcGetCode != nil {
		return mmGetCode.funcGetCode(ctx, ref)
	}
	mmGetCode.t.Fatalf("Unexpected call to ClientMock.GetCode. %v %v", ctx, ref)
	return
}

// GetCodeAfterCounter returns a count of finished ClientMock.GetCode invocations
func (mmGetCode *ClientMock) GetCodeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCode.afterGetCodeCounter)
}

// GetCodeBeforeCounter returns a count of ClientMock.GetCode invocations
func (mmGetCode *ClientMock) GetCodeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCode.beforeGetCodeCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetCode.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCode *mClientMockGetCode) Calls() []*ClientMockGetCodeParams {
	mmGetCode.mutex.RLock()

	argCopy := make([]*ClientMockGetCodeParams, len(mmGetCode.callArgs))
	copy(argCopy, mmGetCode.callArgs)

	mmGetCode.mutex.RUnlock()

	return argCopy
}

// MinimockGetCodeDone returns true if the count of the GetCode invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetCodeDone() bool {
	for _, e := range m.GetCodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCodeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCode != nil && mm_atomic.LoadUint64(&m.afterGetCodeCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCodeInspect logs each unmet expectation
func (m *ClientMock) MinimockGetCodeInspect() {
	for _, e := range m.GetCodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetCode with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCodeCounter) < 1 {
		if m.GetCodeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetCode")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetCode with params: %#v", *m.GetCodeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCode != nil && mm_atomic.LoadUint64(&m.afterGetCodeCounter) < 1 {
		m.t.Error("Expected call to ClientMock.GetCode")
	}
}

type mClientMockGetObject struct {
	mock               *ClientMock
	defaultExpectation *ClientMockGetObjectExpectation
	expectations       []*ClientMockGetObjectExpectation

	callArgs []*ClientMockGetObjectParams
	mutex    sync.RWMutex
}

// ClientMockGetObjectExpectation specifies expectation struct of the Client.GetObject
type ClientMockGetObjectExpectation struct {
	mock    *ClientMock
	params  *ClientMockGetObjectParams
	results *ClientMockGetObjectResults
	Counter uint64
}

// ClientMockGetObjectParams contains parameters of the Client.GetObject
type ClientMockGetObjectParams struct {
	ctx  context.Context
	head insolar.Reference
}

// ClientMockGetObjectResults contains results of the Client.GetObject
type ClientMockGetObjectResults struct {
	o1  ObjectDescriptor
	err error
}

// Expect sets up expected params for Client.GetObject
func (mmGetObject *mClientMockGetObject) Expect(ctx context.Context, head insolar.Reference) *mClientMockGetObject {
	if mmGetObject.mock.funcGetObject != nil {
		mmGetObject.mock.t.Fatalf("ClientMock.GetObject mock is already set by Set")
	}

	if mmGetObject.defaultExpectation == nil {
		mmGetObject.defaultExpectation = &ClientMockGetObjectExpectation{}
	}

	mmGetObject.defaultExpectation.params = &ClientMockGetObjectParams{ctx, head}
	for _, e := range mmGetObject.expectations {
		if minimock.Equal(e.params, mmGetObject.defaultExpectation.params) {
			mmGetObject.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetObject.defaultExpectation.params)
		}
	}

	return mmGetObject
}

// Inspect accepts an inspector function that has same arguments as the Client.GetObject
func (mmGetObject *mClientMockGetObject) Inspect(f func(ctx context.Context, head insolar.Reference)) *mClientMockGetObject {
	if mmGetObject.mock.inspectFuncGetObject != nil {
		mmGetObject.mock.t.Fatalf("Inspect function is already set for ClientMock.GetObject")
	}

	mmGetObject.mock.inspectFuncGetObject = f

	return mmGetObject
}

// Return sets up results that will be returned by Client.GetObject
func (mmGetObject *mClientMockGetObject) Return(o1 ObjectDescriptor, err error) *ClientMock {
	if mmGetObject.mock.funcGetObject != nil {
		mmGetObject.mock.t.Fatalf("ClientMock.GetObject mock is already set by Set")
	}

	if mmGetObject.defaultExpectation == nil {
		mmGetObject.defaultExpectation = &ClientMockGetObjectExpectation{mock: mmGetObject.mock}
	}
	mmGetObject.defaultExpectation.results = &ClientMockGetObjectResults{o1, err}
	return mmGetObject.mock
}

//Set uses given function f to mock the Client.GetObject method
func (mmGetObject *mClientMockGetObject) Set(f func(ctx context.Context, head insolar.Reference) (o1 ObjectDescriptor, err error)) *ClientMock {
	if mmGetObject.defaultExpectation != nil {
		mmGetObject.mock.t.Fatalf("Default expectation is already set for the Client.GetObject method")
	}

	if len(mmGetObject.expectations) > 0 {
		mmGetObject.mock.t.Fatalf("Some expectations are already set for the Client.GetObject method")
	}

	mmGetObject.mock.funcGetObject = f
	return mmGetObject.mock
}

// When sets expectation for the Client.GetObject which will trigger the result defined by the following
// Then helper
func (mmGetObject *mClientMockGetObject) When(ctx context.Context, head insolar.Reference) *ClientMockGetObjectExpectation {
	if mmGetObject.mock.funcGetObject != nil {
		mmGetObject.mock.t.Fatalf("ClientMock.GetObject mock is already set by Set")
	}

	expectation := &ClientMockGetObjectExpectation{
		mock:   mmGetObject.mock,
		params: &ClientMockGetObjectParams{ctx, head},
	}
	mmGetObject.expectations = append(mmGetObject.expectations, expectation)
	return expectation
}

// Then sets up Client.GetObject return parameters for the expectation previously defined by the When method
func (e *ClientMockGetObjectExpectation) Then(o1 ObjectDescriptor, err error) *ClientMock {
	e.results = &ClientMockGetObjectResults{o1, err}
	return e.mock
}

// GetObject implements Client
func (mmGetObject *ClientMock) GetObject(ctx context.Context, head insolar.Reference) (o1 ObjectDescriptor, err error) {
	mm_atomic.AddUint64(&mmGetObject.beforeGetObjectCounter, 1)
	defer mm_atomic.AddUint64(&mmGetObject.afterGetObjectCounter, 1)

	if mmGetObject.inspectFuncGetObject != nil {
		mmGetObject.inspectFuncGetObject(ctx, head)
	}

	params := &ClientMockGetObjectParams{ctx, head}

	// Record call args
	mmGetObject.GetObjectMock.mutex.Lock()
	mmGetObject.GetObjectMock.callArgs = append(mmGetObject.GetObjectMock.callArgs, params)
	mmGetObject.GetObjectMock.mutex.Unlock()

	for _, e := range mmGetObject.GetObjectMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o1, e.results.err
		}
	}

	if mmGetObject.GetObjectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetObject.GetObjectMock.defaultExpectation.Counter, 1)
		want := mmGetObject.GetObjectMock.defaultExpectation.params
		got := ClientMockGetObjectParams{ctx, head}
		if want != nil && !minimock.Equal(*want, got) {
			mmGetObject.t.Errorf("ClientMock.GetObject got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmGetObject.GetObjectMock.defaultExpectation.results
		if results == nil {
			mmGetObject.t.Fatal("No results are set for the ClientMock.GetObject")
		}
		return (*results).o1, (*results).err
	}
	if mmGetObject.funcGetObject != nil {
		return mmGetObject.funcGetObject(ctx, head)
	}
	mmGetObject.t.Fatalf("Unexpected call to ClientMock.GetObject. %v %v", ctx, head)
	return
}

// GetObjectAfterCounter returns a count of finished ClientMock.GetObject invocations
func (mmGetObject *ClientMock) GetObjectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObject.afterGetObjectCounter)
}

// GetObjectBeforeCounter returns a count of ClientMock.GetObject invocations
func (mmGetObject *ClientMock) GetObjectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObject.beforeGetObjectCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetObject.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetObject *mClientMockGetObject) Calls() []*ClientMockGetObjectParams {
	mmGetObject.mutex.RLock()

	argCopy := make([]*ClientMockGetObjectParams, len(mmGetObject.callArgs))
	copy(argCopy, mmGetObject.callArgs)

	mmGetObject.mutex.RUnlock()

	return argCopy
}

// MinimockGetObjectDone returns true if the count of the GetObject invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetObjectDone() bool {
	for _, e := range m.GetObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetObjectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetObjectCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetObject != nil && mm_atomic.LoadUint64(&m.afterGetObjectCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetObjectInspect logs each unmet expectation
func (m *ClientMock) MinimockGetObjectInspect() {
	for _, e := range m.GetObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetObject with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetObjectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetObjectCounter) < 1 {
		if m.GetObjectMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetObject")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetObject with params: %#v", *m.GetObjectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetObject != nil && mm_atomic.LoadUint64(&m.afterGetObjectCounter) < 1 {
		m.t.Error("Expected call to ClientMock.GetObject")
	}
}

type mClientMockGetPendings struct {
	mock               *ClientMock
	defaultExpectation *ClientMockGetPendingsExpectation
	expectations       []*ClientMockGetPendingsExpectation

	callArgs []*ClientMockGetPendingsParams
	mutex    sync.RWMutex
}

// ClientMockGetPendingsExpectation specifies expectation struct of the Client.GetPendings
type ClientMockGetPendingsExpectation struct {
	mock    *ClientMock
	params  *ClientMockGetPendingsParams
	results *ClientMockGetPendingsResults
	Counter uint64
}

// ClientMockGetPendingsParams contains parameters of the Client.GetPendings
type ClientMockGetPendingsParams struct {
	ctx       context.Context
	objectRef insolar.Reference
}

// ClientMockGetPendingsResults contains results of the Client.GetPendings
type ClientMockGetPendingsResults struct {
	ra1 []insolar.Reference
	err error
}

// Expect sets up expected params for Client.GetPendings
func (mmGetPendings *mClientMockGetPendings) Expect(ctx context.Context, objectRef insolar.Reference) *mClientMockGetPendings {
	if mmGetPendings.mock.funcGetPendings != nil {
		mmGetPendings.mock.t.Fatalf("ClientMock.GetPendings mock is already set by Set")
	}

	if mmGetPendings.defaultExpectation == nil {
		mmGetPendings.defaultExpectation = &ClientMockGetPendingsExpectation{}
	}

	mmGetPendings.defaultExpectation.params = &ClientMockGetPendingsParams{ctx, objectRef}
	for _, e := range mmGetPendings.expectations {
		if minimock.Equal(e.params, mmGetPendings.defaultExpectation.params) {
			mmGetPendings.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPendings.defaultExpectation.params)
		}
	}

	return mmGetPendings
}

// Inspect accepts an inspector function that has same arguments as the Client.GetPendings
func (mmGetPendings *mClientMockGetPendings) Inspect(f func(ctx context.Context, objectRef insolar.Reference)) *mClientMockGetPendings {
	if mmGetPendings.mock.inspectFuncGetPendings != nil {
		mmGetPendings.mock.t.Fatalf("Inspect function is already set for ClientMock.GetPendings")
	}

	mmGetPendings.mock.inspectFuncGetPendings = f

	return mmGetPendings
}

// Return sets up results that will be returned by Client.GetPendings
func (mmGetPendings *mClientMockGetPendings) Return(ra1 []insolar.Reference, err error) *ClientMock {
	if mmGetPendings.mock.funcGetPendings != nil {
		mmGetPendings.mock.t.Fatalf("ClientMock.GetPendings mock is already set by Set")
	}

	if mmGetPendings.defaultExpectation == nil {
		mmGetPendings.defaultExpectation = &ClientMockGetPendingsExpectation{mock: mmGetPendings.mock}
	}
	mmGetPendings.defaultExpectation.results = &ClientMockGetPendingsResults{ra1, err}
	return mmGetPendings.mock
}

//Set uses given function f to mock the Client.GetPendings method
func (mmGetPendings *mClientMockGetPendings) Set(f func(ctx context.Context, objectRef insolar.Reference) (ra1 []insolar.Reference, err error)) *ClientMock {
	if mmGetPendings.defaultExpectation != nil {
		mmGetPendings.mock.t.Fatalf("Default expectation is already set for the Client.GetPendings method")
	}

	if len(mmGetPendings.expectations) > 0 {
		mmGetPendings.mock.t.Fatalf("Some expectations are already set for the Client.GetPendings method")
	}

	mmGetPendings.mock.funcGetPendings = f
	return mmGetPendings.mock
}

// When sets expectation for the Client.GetPendings which will trigger the result defined by the following
// Then helper
func (mmGetPendings *mClientMockGetPendings) When(ctx context.Context, objectRef insolar.Reference) *ClientMockGetPendingsExpectation {
	if mmGetPendings.mock.funcGetPendings != nil {
		mmGetPendings.mock.t.Fatalf("ClientMock.GetPendings mock is already set by Set")
	}

	expectation := &ClientMockGetPendingsExpectation{
		mock:   mmGetPendings.mock,
		params: &ClientMockGetPendingsParams{ctx, objectRef},
	}
	mmGetPendings.expectations = append(mmGetPendings.expectations, expectation)
	return expectation
}

// Then sets up Client.GetPendings return parameters for the expectation previously defined by the When method
func (e *ClientMockGetPendingsExpectation) Then(ra1 []insolar.Reference, err error) *ClientMock {
	e.results = &ClientMockGetPendingsResults{ra1, err}
	return e.mock
}

// GetPendings implements Client
func (mmGetPendings *ClientMock) GetPendings(ctx context.Context, objectRef insolar.Reference) (ra1 []insolar.Reference, err error) {
	mm_atomic.AddUint64(&mmGetPendings.beforeGetPendingsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPendings.afterGetPendingsCounter, 1)

	if mmGetPendings.inspectFuncGetPendings != nil {
		mmGetPendings.inspectFuncGetPendings(ctx, objectRef)
	}

	params := &ClientMockGetPendingsParams{ctx, objectRef}

	// Record call args
	mmGetPendings.GetPendingsMock.mutex.Lock()
	mmGetPendings.GetPendingsMock.callArgs = append(mmGetPendings.GetPendingsMock.callArgs, params)
	mmGetPendings.GetPendingsMock.mutex.Unlock()

	for _, e := range mmGetPendings.GetPendingsMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ra1, e.results.err
		}
	}

	if mmGetPendings.GetPendingsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPendings.GetPendingsMock.defaultExpectation.Counter, 1)
		want := mmGetPendings.GetPendingsMock.defaultExpectation.params
		got := ClientMockGetPendingsParams{ctx, objectRef}
		if want != nil && !minimock.Equal(*want, got) {
			mmGetPendings.t.Errorf("ClientMock.GetPendings got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmGetPendings.GetPendingsMock.defaultExpectation.results
		if results == nil {
			mmGetPendings.t.Fatal("No results are set for the ClientMock.GetPendings")
		}
		return (*results).ra1, (*results).err
	}
	if mmGetPendings.funcGetPendings != nil {
		return mmGetPendings.funcGetPendings(ctx, objectRef)
	}
	mmGetPendings.t.Fatalf("Unexpected call to ClientMock.GetPendings. %v %v", ctx, objectRef)
	return
}

// GetPendingsAfterCounter returns a count of finished ClientMock.GetPendings invocations
func (mmGetPendings *ClientMock) GetPendingsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPendings.afterGetPendingsCounter)
}

// GetPendingsBeforeCounter returns a count of ClientMock.GetPendings invocations
func (mmGetPendings *ClientMock) GetPendingsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPendings.beforeGetPendingsCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetPendings.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPendings *mClientMockGetPendings) Calls() []*ClientMockGetPendingsParams {
	mmGetPendings.mutex.RLock()

	argCopy := make([]*ClientMockGetPendingsParams, len(mmGetPendings.callArgs))
	copy(argCopy, mmGetPendings.callArgs)

	mmGetPendings.mutex.RUnlock()

	return argCopy
}

// MinimockGetPendingsDone returns true if the count of the GetPendings invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetPendingsDone() bool {
	for _, e := range m.GetPendingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPendingsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPendingsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPendings != nil && mm_atomic.LoadUint64(&m.afterGetPendingsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPendingsInspect logs each unmet expectation
func (m *ClientMock) MinimockGetPendingsInspect() {
	for _, e := range m.GetPendingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetPendings with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPendingsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPendingsCounter) < 1 {
		if m.GetPendingsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetPendings")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetPendings with params: %#v", *m.GetPendingsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPendings != nil && mm_atomic.LoadUint64(&m.afterGetPendingsCounter) < 1 {
		m.t.Error("Expected call to ClientMock.GetPendings")
	}
}

type mClientMockHasPendings struct {
	mock               *ClientMock
	defaultExpectation *ClientMockHasPendingsExpectation
	expectations       []*ClientMockHasPendingsExpectation

	callArgs []*ClientMockHasPendingsParams
	mutex    sync.RWMutex
}

// ClientMockHasPendingsExpectation specifies expectation struct of the Client.HasPendings
type ClientMockHasPendingsExpectation struct {
	mock    *ClientMock
	params  *ClientMockHasPendingsParams
	results *ClientMockHasPendingsResults
	Counter uint64
}

// ClientMockHasPendingsParams contains parameters of the Client.HasPendings
type ClientMockHasPendingsParams struct {
	ctx    context.Context
	object insolar.Reference
}

// ClientMockHasPendingsResults contains results of the Client.HasPendings
type ClientMockHasPendingsResults struct {
	b1  bool
	err error
}

// Expect sets up expected params for Client.HasPendings
func (mmHasPendings *mClientMockHasPendings) Expect(ctx context.Context, object insolar.Reference) *mClientMockHasPendings {
	if mmHasPendings.mock.funcHasPendings != nil {
		mmHasPendings.mock.t.Fatalf("ClientMock.HasPendings mock is already set by Set")
	}

	if mmHasPendings.defaultExpectation == nil {
		mmHasPendings.defaultExpectation = &ClientMockHasPendingsExpectation{}
	}

	mmHasPendings.defaultExpectation.params = &ClientMockHasPendingsParams{ctx, object}
	for _, e := range mmHasPendings.expectations {
		if minimock.Equal(e.params, mmHasPendings.defaultExpectation.params) {
			mmHasPendings.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHasPendings.defaultExpectation.params)
		}
	}

	return mmHasPendings
}

// Inspect accepts an inspector function that has same arguments as the Client.HasPendings
func (mmHasPendings *mClientMockHasPendings) Inspect(f func(ctx context.Context, object insolar.Reference)) *mClientMockHasPendings {
	if mmHasPendings.mock.inspectFuncHasPendings != nil {
		mmHasPendings.mock.t.Fatalf("Inspect function is already set for ClientMock.HasPendings")
	}

	mmHasPendings.mock.inspectFuncHasPendings = f

	return mmHasPendings
}

// Return sets up results that will be returned by Client.HasPendings
func (mmHasPendings *mClientMockHasPendings) Return(b1 bool, err error) *ClientMock {
	if mmHasPendings.mock.funcHasPendings != nil {
		mmHasPendings.mock.t.Fatalf("ClientMock.HasPendings mock is already set by Set")
	}

	if mmHasPendings.defaultExpectation == nil {
		mmHasPendings.defaultExpectation = &ClientMockHasPendingsExpectation{mock: mmHasPendings.mock}
	}
	mmHasPendings.defaultExpectation.results = &ClientMockHasPendingsResults{b1, err}
	return mmHasPendings.mock
}

//Set uses given function f to mock the Client.HasPendings method
func (mmHasPendings *mClientMockHasPendings) Set(f func(ctx context.Context, object insolar.Reference) (b1 bool, err error)) *ClientMock {
	if mmHasPendings.defaultExpectation != nil {
		mmHasPendings.mock.t.Fatalf("Default expectation is already set for the Client.HasPendings method")
	}

	if len(mmHasPendings.expectations) > 0 {
		mmHasPendings.mock.t.Fatalf("Some expectations are already set for the Client.HasPendings method")
	}

	mmHasPendings.mock.funcHasPendings = f
	return mmHasPendings.mock
}

// When sets expectation for the Client.HasPendings which will trigger the result defined by the following
// Then helper
func (mmHasPendings *mClientMockHasPendings) When(ctx context.Context, object insolar.Reference) *ClientMockHasPendingsExpectation {
	if mmHasPendings.mock.funcHasPendings != nil {
		mmHasPendings.mock.t.Fatalf("ClientMock.HasPendings mock is already set by Set")
	}

	expectation := &ClientMockHasPendingsExpectation{
		mock:   mmHasPendings.mock,
		params: &ClientMockHasPendingsParams{ctx, object},
	}
	mmHasPendings.expectations = append(mmHasPendings.expectations, expectation)
	return expectation
}

// Then sets up Client.HasPendings return parameters for the expectation previously defined by the When method
func (e *ClientMockHasPendingsExpectation) Then(b1 bool, err error) *ClientMock {
	e.results = &ClientMockHasPendingsResults{b1, err}
	return e.mock
}

// HasPendings implements Client
func (mmHasPendings *ClientMock) HasPendings(ctx context.Context, object insolar.Reference) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmHasPendings.beforeHasPendingsCounter, 1)
	defer mm_atomic.AddUint64(&mmHasPendings.afterHasPendingsCounter, 1)

	if mmHasPendings.inspectFuncHasPendings != nil {
		mmHasPendings.inspectFuncHasPendings(ctx, object)
	}

	params := &ClientMockHasPendingsParams{ctx, object}

	// Record call args
	mmHasPendings.HasPendingsMock.mutex.Lock()
	mmHasPendings.HasPendingsMock.callArgs = append(mmHasPendings.HasPendingsMock.callArgs, params)
	mmHasPendings.HasPendingsMock.mutex.Unlock()

	for _, e := range mmHasPendings.HasPendingsMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmHasPendings.HasPendingsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHasPendings.HasPendingsMock.defaultExpectation.Counter, 1)
		want := mmHasPendings.HasPendingsMock.defaultExpectation.params
		got := ClientMockHasPendingsParams{ctx, object}
		if want != nil && !minimock.Equal(*want, got) {
			mmHasPendings.t.Errorf("ClientMock.HasPendings got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmHasPendings.HasPendingsMock.defaultExpectation.results
		if results == nil {
			mmHasPendings.t.Fatal("No results are set for the ClientMock.HasPendings")
		}
		return (*results).b1, (*results).err
	}
	if mmHasPendings.funcHasPendings != nil {
		return mmHasPendings.funcHasPendings(ctx, object)
	}
	mmHasPendings.t.Fatalf("Unexpected call to ClientMock.HasPendings. %v %v", ctx, object)
	return
}

// HasPendingsAfterCounter returns a count of finished ClientMock.HasPendings invocations
func (mmHasPendings *ClientMock) HasPendingsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHasPendings.afterHasPendingsCounter)
}

// HasPendingsBeforeCounter returns a count of ClientMock.HasPendings invocations
func (mmHasPendings *ClientMock) HasPendingsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHasPendings.beforeHasPendingsCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.HasPendings.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHasPendings *mClientMockHasPendings) Calls() []*ClientMockHasPendingsParams {
	mmHasPendings.mutex.RLock()

	argCopy := make([]*ClientMockHasPendingsParams, len(mmHasPendings.callArgs))
	copy(argCopy, mmHasPendings.callArgs)

	mmHasPendings.mutex.RUnlock()

	return argCopy
}

// MinimockHasPendingsDone returns true if the count of the HasPendings invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockHasPendingsDone() bool {
	for _, e := range m.HasPendingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HasPendingsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHasPendingsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHasPendings != nil && mm_atomic.LoadUint64(&m.afterHasPendingsCounter) < 1 {
		return false
	}
	return true
}

// MinimockHasPendingsInspect logs each unmet expectation
func (m *ClientMock) MinimockHasPendingsInspect() {
	for _, e := range m.HasPendingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.HasPendings with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HasPendingsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHasPendingsCounter) < 1 {
		if m.HasPendingsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.HasPendings")
		} else {
			m.t.Errorf("Expected call to ClientMock.HasPendings with params: %#v", *m.HasPendingsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHasPendings != nil && mm_atomic.LoadUint64(&m.afterHasPendingsCounter) < 1 {
		m.t.Error("Expected call to ClientMock.HasPendings")
	}
}

type mClientMockInjectCodeDescriptor struct {
	mock               *ClientMock
	defaultExpectation *ClientMockInjectCodeDescriptorExpectation
	expectations       []*ClientMockInjectCodeDescriptorExpectation

	callArgs []*ClientMockInjectCodeDescriptorParams
	mutex    sync.RWMutex
}

// ClientMockInjectCodeDescriptorExpectation specifies expectation struct of the Client.InjectCodeDescriptor
type ClientMockInjectCodeDescriptorExpectation struct {
	mock   *ClientMock
	params *ClientMockInjectCodeDescriptorParams

	Counter uint64
}

// ClientMockInjectCodeDescriptorParams contains parameters of the Client.InjectCodeDescriptor
type ClientMockInjectCodeDescriptorParams struct {
	r1 insolar.Reference
	c1 CodeDescriptor
}

// Expect sets up expected params for Client.InjectCodeDescriptor
func (mmInjectCodeDescriptor *mClientMockInjectCodeDescriptor) Expect(r1 insolar.Reference, c1 CodeDescriptor) *mClientMockInjectCodeDescriptor {
	if mmInjectCodeDescriptor.mock.funcInjectCodeDescriptor != nil {
		mmInjectCodeDescriptor.mock.t.Fatalf("ClientMock.InjectCodeDescriptor mock is already set by Set")
	}

	if mmInjectCodeDescriptor.defaultExpectation == nil {
		mmInjectCodeDescriptor.defaultExpectation = &ClientMockInjectCodeDescriptorExpectation{}
	}

	mmInjectCodeDescriptor.defaultExpectation.params = &ClientMockInjectCodeDescriptorParams{r1, c1}
	for _, e := range mmInjectCodeDescriptor.expectations {
		if minimock.Equal(e.params, mmInjectCodeDescriptor.defaultExpectation.params) {
			mmInjectCodeDescriptor.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInjectCodeDescriptor.defaultExpectation.params)
		}
	}

	return mmInjectCodeDescriptor
}

// Inspect accepts an inspector function that has same arguments as the Client.InjectCodeDescriptor
func (mmInjectCodeDescriptor *mClientMockInjectCodeDescriptor) Inspect(f func(r1 insolar.Reference, c1 CodeDescriptor)) *mClientMockInjectCodeDescriptor {
	if mmInjectCodeDescriptor.mock.inspectFuncInjectCodeDescriptor != nil {
		mmInjectCodeDescriptor.mock.t.Fatalf("Inspect function is already set for ClientMock.InjectCodeDescriptor")
	}

	mmInjectCodeDescriptor.mock.inspectFuncInjectCodeDescriptor = f

	return mmInjectCodeDescriptor
}

// Return sets up results that will be returned by Client.InjectCodeDescriptor
func (mmInjectCodeDescriptor *mClientMockInjectCodeDescriptor) Return() *ClientMock {
	if mmInjectCodeDescriptor.mock.funcInjectCodeDescriptor != nil {
		mmInjectCodeDescriptor.mock.t.Fatalf("ClientMock.InjectCodeDescriptor mock is already set by Set")
	}

	if mmInjectCodeDescriptor.defaultExpectation == nil {
		mmInjectCodeDescriptor.defaultExpectation = &ClientMockInjectCodeDescriptorExpectation{mock: mmInjectCodeDescriptor.mock}
	}

	return mmInjectCodeDescriptor.mock
}

//Set uses given function f to mock the Client.InjectCodeDescriptor method
func (mmInjectCodeDescriptor *mClientMockInjectCodeDescriptor) Set(f func(r1 insolar.Reference, c1 CodeDescriptor)) *ClientMock {
	if mmInjectCodeDescriptor.defaultExpectation != nil {
		mmInjectCodeDescriptor.mock.t.Fatalf("Default expectation is already set for the Client.InjectCodeDescriptor method")
	}

	if len(mmInjectCodeDescriptor.expectations) > 0 {
		mmInjectCodeDescriptor.mock.t.Fatalf("Some expectations are already set for the Client.InjectCodeDescriptor method")
	}

	mmInjectCodeDescriptor.mock.funcInjectCodeDescriptor = f
	return mmInjectCodeDescriptor.mock
}

// InjectCodeDescriptor implements Client
func (mmInjectCodeDescriptor *ClientMock) InjectCodeDescriptor(r1 insolar.Reference, c1 CodeDescriptor) {
	mm_atomic.AddUint64(&mmInjectCodeDescriptor.beforeInjectCodeDescriptorCounter, 1)
	defer mm_atomic.AddUint64(&mmInjectCodeDescriptor.afterInjectCodeDescriptorCounter, 1)

	if mmInjectCodeDescriptor.inspectFuncInjectCodeDescriptor != nil {
		mmInjectCodeDescriptor.inspectFuncInjectCodeDescriptor(r1, c1)
	}

	params := &ClientMockInjectCodeDescriptorParams{r1, c1}

	// Record call args
	mmInjectCodeDescriptor.InjectCodeDescriptorMock.mutex.Lock()
	mmInjectCodeDescriptor.InjectCodeDescriptorMock.callArgs = append(mmInjectCodeDescriptor.InjectCodeDescriptorMock.callArgs, params)
	mmInjectCodeDescriptor.InjectCodeDescriptorMock.mutex.Unlock()

	for _, e := range mmInjectCodeDescriptor.InjectCodeDescriptorMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmInjectCodeDescriptor.InjectCodeDescriptorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInjectCodeDescriptor.InjectCodeDescriptorMock.defaultExpectation.Counter, 1)
		want := mmInjectCodeDescriptor.InjectCodeDescriptorMock.defaultExpectation.params
		got := ClientMockInjectCodeDescriptorParams{r1, c1}
		if want != nil && !minimock.Equal(*want, got) {
			mmInjectCodeDescriptor.t.Errorf("ClientMock.InjectCodeDescriptor got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmInjectCodeDescriptor.funcInjectCodeDescriptor != nil {
		mmInjectCodeDescriptor.funcInjectCodeDescriptor(r1, c1)
		return
	}
	mmInjectCodeDescriptor.t.Fatalf("Unexpected call to ClientMock.InjectCodeDescriptor. %v %v", r1, c1)

}

// InjectCodeDescriptorAfterCounter returns a count of finished ClientMock.InjectCodeDescriptor invocations
func (mmInjectCodeDescriptor *ClientMock) InjectCodeDescriptorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInjectCodeDescriptor.afterInjectCodeDescriptorCounter)
}

// InjectCodeDescriptorBeforeCounter returns a count of ClientMock.InjectCodeDescriptor invocations
func (mmInjectCodeDescriptor *ClientMock) InjectCodeDescriptorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInjectCodeDescriptor.beforeInjectCodeDescriptorCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.InjectCodeDescriptor.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInjectCodeDescriptor *mClientMockInjectCodeDescriptor) Calls() []*ClientMockInjectCodeDescriptorParams {
	mmInjectCodeDescriptor.mutex.RLock()

	argCopy := make([]*ClientMockInjectCodeDescriptorParams, len(mmInjectCodeDescriptor.callArgs))
	copy(argCopy, mmInjectCodeDescriptor.callArgs)

	mmInjectCodeDescriptor.mutex.RUnlock()

	return argCopy
}

// MinimockInjectCodeDescriptorDone returns true if the count of the InjectCodeDescriptor invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockInjectCodeDescriptorDone() bool {
	for _, e := range m.InjectCodeDescriptorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InjectCodeDescriptorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInjectCodeDescriptorCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInjectCodeDescriptor != nil && mm_atomic.LoadUint64(&m.afterInjectCodeDescriptorCounter) < 1 {
		return false
	}
	return true
}

// MinimockInjectCodeDescriptorInspect logs each unmet expectation
func (m *ClientMock) MinimockInjectCodeDescriptorInspect() {
	for _, e := range m.InjectCodeDescriptorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.InjectCodeDescriptor with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InjectCodeDescriptorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInjectCodeDescriptorCounter) < 1 {
		if m.InjectCodeDescriptorMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.InjectCodeDescriptor")
		} else {
			m.t.Errorf("Expected call to ClientMock.InjectCodeDescriptor with params: %#v", *m.InjectCodeDescriptorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInjectCodeDescriptor != nil && mm_atomic.LoadUint64(&m.afterInjectCodeDescriptorCounter) < 1 {
		m.t.Error("Expected call to ClientMock.InjectCodeDescriptor")
	}
}

type mClientMockInjectFinish struct {
	mock               *ClientMock
	defaultExpectation *ClientMockInjectFinishExpectation
	expectations       []*ClientMockInjectFinishExpectation
}

// ClientMockInjectFinishExpectation specifies expectation struct of the Client.InjectFinish
type ClientMockInjectFinishExpectation struct {
	mock *ClientMock

	Counter uint64
}

// Expect sets up expected params for Client.InjectFinish
func (mmInjectFinish *mClientMockInjectFinish) Expect() *mClientMockInjectFinish {
	if mmInjectFinish.mock.funcInjectFinish != nil {
		mmInjectFinish.mock.t.Fatalf("ClientMock.InjectFinish mock is already set by Set")
	}

	if mmInjectFinish.defaultExpectation == nil {
		mmInjectFinish.defaultExpectation = &ClientMockInjectFinishExpectation{}
	}

	return mmInjectFinish
}

// Inspect accepts an inspector function that has same arguments as the Client.InjectFinish
func (mmInjectFinish *mClientMockInjectFinish) Inspect(f func()) *mClientMockInjectFinish {
	if mmInjectFinish.mock.inspectFuncInjectFinish != nil {
		mmInjectFinish.mock.t.Fatalf("Inspect function is already set for ClientMock.InjectFinish")
	}

	mmInjectFinish.mock.inspectFuncInjectFinish = f

	return mmInjectFinish
}

// Return sets up results that will be returned by Client.InjectFinish
func (mmInjectFinish *mClientMockInjectFinish) Return() *ClientMock {
	if mmInjectFinish.mock.funcInjectFinish != nil {
		mmInjectFinish.mock.t.Fatalf("ClientMock.InjectFinish mock is already set by Set")
	}

	if mmInjectFinish.defaultExpectation == nil {
		mmInjectFinish.defaultExpectation = &ClientMockInjectFinishExpectation{mock: mmInjectFinish.mock}
	}

	return mmInjectFinish.mock
}

//Set uses given function f to mock the Client.InjectFinish method
func (mmInjectFinish *mClientMockInjectFinish) Set(f func()) *ClientMock {
	if mmInjectFinish.defaultExpectation != nil {
		mmInjectFinish.mock.t.Fatalf("Default expectation is already set for the Client.InjectFinish method")
	}

	if len(mmInjectFinish.expectations) > 0 {
		mmInjectFinish.mock.t.Fatalf("Some expectations are already set for the Client.InjectFinish method")
	}

	mmInjectFinish.mock.funcInjectFinish = f
	return mmInjectFinish.mock
}

// InjectFinish implements Client
func (mmInjectFinish *ClientMock) InjectFinish() {
	mm_atomic.AddUint64(&mmInjectFinish.beforeInjectFinishCounter, 1)
	defer mm_atomic.AddUint64(&mmInjectFinish.afterInjectFinishCounter, 1)

	if mmInjectFinish.inspectFuncInjectFinish != nil {
		mmInjectFinish.inspectFuncInjectFinish()
	}

	if mmInjectFinish.InjectFinishMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInjectFinish.InjectFinishMock.defaultExpectation.Counter, 1)

		return

	}
	if mmInjectFinish.funcInjectFinish != nil {
		mmInjectFinish.funcInjectFinish()
		return
	}
	mmInjectFinish.t.Fatalf("Unexpected call to ClientMock.InjectFinish.")

}

// InjectFinishAfterCounter returns a count of finished ClientMock.InjectFinish invocations
func (mmInjectFinish *ClientMock) InjectFinishAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInjectFinish.afterInjectFinishCounter)
}

// InjectFinishBeforeCounter returns a count of ClientMock.InjectFinish invocations
func (mmInjectFinish *ClientMock) InjectFinishBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInjectFinish.beforeInjectFinishCounter)
}

// MinimockInjectFinishDone returns true if the count of the InjectFinish invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockInjectFinishDone() bool {
	for _, e := range m.InjectFinishMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InjectFinishMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInjectFinishCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInjectFinish != nil && mm_atomic.LoadUint64(&m.afterInjectFinishCounter) < 1 {
		return false
	}
	return true
}

// MinimockInjectFinishInspect logs each unmet expectation
func (m *ClientMock) MinimockInjectFinishInspect() {
	for _, e := range m.InjectFinishMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ClientMock.InjectFinish")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InjectFinishMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInjectFinishCounter) < 1 {
		m.t.Error("Expected call to ClientMock.InjectFinish")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInjectFinish != nil && mm_atomic.LoadUint64(&m.afterInjectFinishCounter) < 1 {
		m.t.Error("Expected call to ClientMock.InjectFinish")
	}
}

type mClientMockInjectObjectDescriptor struct {
	mock               *ClientMock
	defaultExpectation *ClientMockInjectObjectDescriptorExpectation
	expectations       []*ClientMockInjectObjectDescriptorExpectation

	callArgs []*ClientMockInjectObjectDescriptorParams
	mutex    sync.RWMutex
}

// ClientMockInjectObjectDescriptorExpectation specifies expectation struct of the Client.InjectObjectDescriptor
type ClientMockInjectObjectDescriptorExpectation struct {
	mock   *ClientMock
	params *ClientMockInjectObjectDescriptorParams

	Counter uint64
}

// ClientMockInjectObjectDescriptorParams contains parameters of the Client.InjectObjectDescriptor
type ClientMockInjectObjectDescriptorParams struct {
	r1 insolar.Reference
	o1 ObjectDescriptor
}

// Expect sets up expected params for Client.InjectObjectDescriptor
func (mmInjectObjectDescriptor *mClientMockInjectObjectDescriptor) Expect(r1 insolar.Reference, o1 ObjectDescriptor) *mClientMockInjectObjectDescriptor {
	if mmInjectObjectDescriptor.mock.funcInjectObjectDescriptor != nil {
		mmInjectObjectDescriptor.mock.t.Fatalf("ClientMock.InjectObjectDescriptor mock is already set by Set")
	}

	if mmInjectObjectDescriptor.defaultExpectation == nil {
		mmInjectObjectDescriptor.defaultExpectation = &ClientMockInjectObjectDescriptorExpectation{}
	}

	mmInjectObjectDescriptor.defaultExpectation.params = &ClientMockInjectObjectDescriptorParams{r1, o1}
	for _, e := range mmInjectObjectDescriptor.expectations {
		if minimock.Equal(e.params, mmInjectObjectDescriptor.defaultExpectation.params) {
			mmInjectObjectDescriptor.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInjectObjectDescriptor.defaultExpectation.params)
		}
	}

	return mmInjectObjectDescriptor
}

// Inspect accepts an inspector function that has same arguments as the Client.InjectObjectDescriptor
func (mmInjectObjectDescriptor *mClientMockInjectObjectDescriptor) Inspect(f func(r1 insolar.Reference, o1 ObjectDescriptor)) *mClientMockInjectObjectDescriptor {
	if mmInjectObjectDescriptor.mock.inspectFuncInjectObjectDescriptor != nil {
		mmInjectObjectDescriptor.mock.t.Fatalf("Inspect function is already set for ClientMock.InjectObjectDescriptor")
	}

	mmInjectObjectDescriptor.mock.inspectFuncInjectObjectDescriptor = f

	return mmInjectObjectDescriptor
}

// Return sets up results that will be returned by Client.InjectObjectDescriptor
func (mmInjectObjectDescriptor *mClientMockInjectObjectDescriptor) Return() *ClientMock {
	if mmInjectObjectDescriptor.mock.funcInjectObjectDescriptor != nil {
		mmInjectObjectDescriptor.mock.t.Fatalf("ClientMock.InjectObjectDescriptor mock is already set by Set")
	}

	if mmInjectObjectDescriptor.defaultExpectation == nil {
		mmInjectObjectDescriptor.defaultExpectation = &ClientMockInjectObjectDescriptorExpectation{mock: mmInjectObjectDescriptor.mock}
	}

	return mmInjectObjectDescriptor.mock
}

//Set uses given function f to mock the Client.InjectObjectDescriptor method
func (mmInjectObjectDescriptor *mClientMockInjectObjectDescriptor) Set(f func(r1 insolar.Reference, o1 ObjectDescriptor)) *ClientMock {
	if mmInjectObjectDescriptor.defaultExpectation != nil {
		mmInjectObjectDescriptor.mock.t.Fatalf("Default expectation is already set for the Client.InjectObjectDescriptor method")
	}

	if len(mmInjectObjectDescriptor.expectations) > 0 {
		mmInjectObjectDescriptor.mock.t.Fatalf("Some expectations are already set for the Client.InjectObjectDescriptor method")
	}

	mmInjectObjectDescriptor.mock.funcInjectObjectDescriptor = f
	return mmInjectObjectDescriptor.mock
}

// InjectObjectDescriptor implements Client
func (mmInjectObjectDescriptor *ClientMock) InjectObjectDescriptor(r1 insolar.Reference, o1 ObjectDescriptor) {
	mm_atomic.AddUint64(&mmInjectObjectDescriptor.beforeInjectObjectDescriptorCounter, 1)
	defer mm_atomic.AddUint64(&mmInjectObjectDescriptor.afterInjectObjectDescriptorCounter, 1)

	if mmInjectObjectDescriptor.inspectFuncInjectObjectDescriptor != nil {
		mmInjectObjectDescriptor.inspectFuncInjectObjectDescriptor(r1, o1)
	}

	params := &ClientMockInjectObjectDescriptorParams{r1, o1}

	// Record call args
	mmInjectObjectDescriptor.InjectObjectDescriptorMock.mutex.Lock()
	mmInjectObjectDescriptor.InjectObjectDescriptorMock.callArgs = append(mmInjectObjectDescriptor.InjectObjectDescriptorMock.callArgs, params)
	mmInjectObjectDescriptor.InjectObjectDescriptorMock.mutex.Unlock()

	for _, e := range mmInjectObjectDescriptor.InjectObjectDescriptorMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmInjectObjectDescriptor.InjectObjectDescriptorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInjectObjectDescriptor.InjectObjectDescriptorMock.defaultExpectation.Counter, 1)
		want := mmInjectObjectDescriptor.InjectObjectDescriptorMock.defaultExpectation.params
		got := ClientMockInjectObjectDescriptorParams{r1, o1}
		if want != nil && !minimock.Equal(*want, got) {
			mmInjectObjectDescriptor.t.Errorf("ClientMock.InjectObjectDescriptor got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmInjectObjectDescriptor.funcInjectObjectDescriptor != nil {
		mmInjectObjectDescriptor.funcInjectObjectDescriptor(r1, o1)
		return
	}
	mmInjectObjectDescriptor.t.Fatalf("Unexpected call to ClientMock.InjectObjectDescriptor. %v %v", r1, o1)

}

// InjectObjectDescriptorAfterCounter returns a count of finished ClientMock.InjectObjectDescriptor invocations
func (mmInjectObjectDescriptor *ClientMock) InjectObjectDescriptorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInjectObjectDescriptor.afterInjectObjectDescriptorCounter)
}

// InjectObjectDescriptorBeforeCounter returns a count of ClientMock.InjectObjectDescriptor invocations
func (mmInjectObjectDescriptor *ClientMock) InjectObjectDescriptorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInjectObjectDescriptor.beforeInjectObjectDescriptorCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.InjectObjectDescriptor.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInjectObjectDescriptor *mClientMockInjectObjectDescriptor) Calls() []*ClientMockInjectObjectDescriptorParams {
	mmInjectObjectDescriptor.mutex.RLock()

	argCopy := make([]*ClientMockInjectObjectDescriptorParams, len(mmInjectObjectDescriptor.callArgs))
	copy(argCopy, mmInjectObjectDescriptor.callArgs)

	mmInjectObjectDescriptor.mutex.RUnlock()

	return argCopy
}

// MinimockInjectObjectDescriptorDone returns true if the count of the InjectObjectDescriptor invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockInjectObjectDescriptorDone() bool {
	for _, e := range m.InjectObjectDescriptorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InjectObjectDescriptorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInjectObjectDescriptorCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInjectObjectDescriptor != nil && mm_atomic.LoadUint64(&m.afterInjectObjectDescriptorCounter) < 1 {
		return false
	}
	return true
}

// MinimockInjectObjectDescriptorInspect logs each unmet expectation
func (m *ClientMock) MinimockInjectObjectDescriptorInspect() {
	for _, e := range m.InjectObjectDescriptorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.InjectObjectDescriptor with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InjectObjectDescriptorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInjectObjectDescriptorCounter) < 1 {
		if m.InjectObjectDescriptorMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.InjectObjectDescriptor")
		} else {
			m.t.Errorf("Expected call to ClientMock.InjectObjectDescriptor with params: %#v", *m.InjectObjectDescriptorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInjectObjectDescriptor != nil && mm_atomic.LoadUint64(&m.afterInjectObjectDescriptorCounter) < 1 {
		m.t.Error("Expected call to ClientMock.InjectObjectDescriptor")
	}
}

type mClientMockRegisterIncomingRequest struct {
	mock               *ClientMock
	defaultExpectation *ClientMockRegisterIncomingRequestExpectation
	expectations       []*ClientMockRegisterIncomingRequestExpectation

	callArgs []*ClientMockRegisterIncomingRequestParams
	mutex    sync.RWMutex
}

// ClientMockRegisterIncomingRequestExpectation specifies expectation struct of the Client.RegisterIncomingRequest
type ClientMockRegisterIncomingRequestExpectation struct {
	mock    *ClientMock
	params  *ClientMockRegisterIncomingRequestParams
	results *ClientMockRegisterIncomingRequestResults
	Counter uint64
}

// ClientMockRegisterIncomingRequestParams contains parameters of the Client.RegisterIncomingRequest
type ClientMockRegisterIncomingRequestParams struct {
	ctx     context.Context
	request *record.IncomingRequest
}

// ClientMockRegisterIncomingRequestResults contains results of the Client.RegisterIncomingRequest
type ClientMockRegisterIncomingRequestResults struct {
	rp1 *payload.RequestInfo
	err error
}

// Expect sets up expected params for Client.RegisterIncomingRequest
func (mmRegisterIncomingRequest *mClientMockRegisterIncomingRequest) Expect(ctx context.Context, request *record.IncomingRequest) *mClientMockRegisterIncomingRequest {
	if mmRegisterIncomingRequest.mock.funcRegisterIncomingRequest != nil {
		mmRegisterIncomingRequest.mock.t.Fatalf("ClientMock.RegisterIncomingRequest mock is already set by Set")
	}

	if mmRegisterIncomingRequest.defaultExpectation == nil {
		mmRegisterIncomingRequest.defaultExpectation = &ClientMockRegisterIncomingRequestExpectation{}
	}

	mmRegisterIncomingRequest.defaultExpectation.params = &ClientMockRegisterIncomingRequestParams{ctx, request}
	for _, e := range mmRegisterIncomingRequest.expectations {
		if minimock.Equal(e.params, mmRegisterIncomingRequest.defaultExpectation.params) {
			mmRegisterIncomingRequest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegisterIncomingRequest.defaultExpectation.params)
		}
	}

	return mmRegisterIncomingRequest
}

// Inspect accepts an inspector function that has same arguments as the Client.RegisterIncomingRequest
func (mmRegisterIncomingRequest *mClientMockRegisterIncomingRequest) Inspect(f func(ctx context.Context, request *record.IncomingRequest)) *mClientMockRegisterIncomingRequest {
	if mmRegisterIncomingRequest.mock.inspectFuncRegisterIncomingRequest != nil {
		mmRegisterIncomingRequest.mock.t.Fatalf("Inspect function is already set for ClientMock.RegisterIncomingRequest")
	}

	mmRegisterIncomingRequest.mock.inspectFuncRegisterIncomingRequest = f

	return mmRegisterIncomingRequest
}

// Return sets up results that will be returned by Client.RegisterIncomingRequest
func (mmRegisterIncomingRequest *mClientMockRegisterIncomingRequest) Return(rp1 *payload.RequestInfo, err error) *ClientMock {
	if mmRegisterIncomingRequest.mock.funcRegisterIncomingRequest != nil {
		mmRegisterIncomingRequest.mock.t.Fatalf("ClientMock.RegisterIncomingRequest mock is already set by Set")
	}

	if mmRegisterIncomingRequest.defaultExpectation == nil {
		mmRegisterIncomingRequest.defaultExpectation = &ClientMockRegisterIncomingRequestExpectation{mock: mmRegisterIncomingRequest.mock}
	}
	mmRegisterIncomingRequest.defaultExpectation.results = &ClientMockRegisterIncomingRequestResults{rp1, err}
	return mmRegisterIncomingRequest.mock
}

//Set uses given function f to mock the Client.RegisterIncomingRequest method
func (mmRegisterIncomingRequest *mClientMockRegisterIncomingRequest) Set(f func(ctx context.Context, request *record.IncomingRequest) (rp1 *payload.RequestInfo, err error)) *ClientMock {
	if mmRegisterIncomingRequest.defaultExpectation != nil {
		mmRegisterIncomingRequest.mock.t.Fatalf("Default expectation is already set for the Client.RegisterIncomingRequest method")
	}

	if len(mmRegisterIncomingRequest.expectations) > 0 {
		mmRegisterIncomingRequest.mock.t.Fatalf("Some expectations are already set for the Client.RegisterIncomingRequest method")
	}

	mmRegisterIncomingRequest.mock.funcRegisterIncomingRequest = f
	return mmRegisterIncomingRequest.mock
}

// When sets expectation for the Client.RegisterIncomingRequest which will trigger the result defined by the following
// Then helper
func (mmRegisterIncomingRequest *mClientMockRegisterIncomingRequest) When(ctx context.Context, request *record.IncomingRequest) *ClientMockRegisterIncomingRequestExpectation {
	if mmRegisterIncomingRequest.mock.funcRegisterIncomingRequest != nil {
		mmRegisterIncomingRequest.mock.t.Fatalf("ClientMock.RegisterIncomingRequest mock is already set by Set")
	}

	expectation := &ClientMockRegisterIncomingRequestExpectation{
		mock:   mmRegisterIncomingRequest.mock,
		params: &ClientMockRegisterIncomingRequestParams{ctx, request},
	}
	mmRegisterIncomingRequest.expectations = append(mmRegisterIncomingRequest.expectations, expectation)
	return expectation
}

// Then sets up Client.RegisterIncomingRequest return parameters for the expectation previously defined by the When method
func (e *ClientMockRegisterIncomingRequestExpectation) Then(rp1 *payload.RequestInfo, err error) *ClientMock {
	e.results = &ClientMockRegisterIncomingRequestResults{rp1, err}
	return e.mock
}

// RegisterIncomingRequest implements Client
func (mmRegisterIncomingRequest *ClientMock) RegisterIncomingRequest(ctx context.Context, request *record.IncomingRequest) (rp1 *payload.RequestInfo, err error) {
	mm_atomic.AddUint64(&mmRegisterIncomingRequest.beforeRegisterIncomingRequestCounter, 1)
	defer mm_atomic.AddUint64(&mmRegisterIncomingRequest.afterRegisterIncomingRequestCounter, 1)

	if mmRegisterIncomingRequest.inspectFuncRegisterIncomingRequest != nil {
		mmRegisterIncomingRequest.inspectFuncRegisterIncomingRequest(ctx, request)
	}

	params := &ClientMockRegisterIncomingRequestParams{ctx, request}

	// Record call args
	mmRegisterIncomingRequest.RegisterIncomingRequestMock.mutex.Lock()
	mmRegisterIncomingRequest.RegisterIncomingRequestMock.callArgs = append(mmRegisterIncomingRequest.RegisterIncomingRequestMock.callArgs, params)
	mmRegisterIncomingRequest.RegisterIncomingRequestMock.mutex.Unlock()

	for _, e := range mmRegisterIncomingRequest.RegisterIncomingRequestMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmRegisterIncomingRequest.RegisterIncomingRequestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegisterIncomingRequest.RegisterIncomingRequestMock.defaultExpectation.Counter, 1)
		want := mmRegisterIncomingRequest.RegisterIncomingRequestMock.defaultExpectation.params
		got := ClientMockRegisterIncomingRequestParams{ctx, request}
		if want != nil && !minimock.Equal(*want, got) {
			mmRegisterIncomingRequest.t.Errorf("ClientMock.RegisterIncomingRequest got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmRegisterIncomingRequest.RegisterIncomingRequestMock.defaultExpectation.results
		if results == nil {
			mmRegisterIncomingRequest.t.Fatal("No results are set for the ClientMock.RegisterIncomingRequest")
		}
		return (*results).rp1, (*results).err
	}
	if mmRegisterIncomingRequest.funcRegisterIncomingRequest != nil {
		return mmRegisterIncomingRequest.funcRegisterIncomingRequest(ctx, request)
	}
	mmRegisterIncomingRequest.t.Fatalf("Unexpected call to ClientMock.RegisterIncomingRequest. %v %v", ctx, request)
	return
}

// RegisterIncomingRequestAfterCounter returns a count of finished ClientMock.RegisterIncomingRequest invocations
func (mmRegisterIncomingRequest *ClientMock) RegisterIncomingRequestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterIncomingRequest.afterRegisterIncomingRequestCounter)
}

// RegisterIncomingRequestBeforeCounter returns a count of ClientMock.RegisterIncomingRequest invocations
func (mmRegisterIncomingRequest *ClientMock) RegisterIncomingRequestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterIncomingRequest.beforeRegisterIncomingRequestCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.RegisterIncomingRequest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegisterIncomingRequest *mClientMockRegisterIncomingRequest) Calls() []*ClientMockRegisterIncomingRequestParams {
	mmRegisterIncomingRequest.mutex.RLock()

	argCopy := make([]*ClientMockRegisterIncomingRequestParams, len(mmRegisterIncomingRequest.callArgs))
	copy(argCopy, mmRegisterIncomingRequest.callArgs)

	mmRegisterIncomingRequest.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterIncomingRequestDone returns true if the count of the RegisterIncomingRequest invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockRegisterIncomingRequestDone() bool {
	for _, e := range m.RegisterIncomingRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterIncomingRequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterIncomingRequestCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterIncomingRequest != nil && mm_atomic.LoadUint64(&m.afterRegisterIncomingRequestCounter) < 1 {
		return false
	}
	return true
}

// MinimockRegisterIncomingRequestInspect logs each unmet expectation
func (m *ClientMock) MinimockRegisterIncomingRequestInspect() {
	for _, e := range m.RegisterIncomingRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.RegisterIncomingRequest with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterIncomingRequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterIncomingRequestCounter) < 1 {
		if m.RegisterIncomingRequestMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.RegisterIncomingRequest")
		} else {
			m.t.Errorf("Expected call to ClientMock.RegisterIncomingRequest with params: %#v", *m.RegisterIncomingRequestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterIncomingRequest != nil && mm_atomic.LoadUint64(&m.afterRegisterIncomingRequestCounter) < 1 {
		m.t.Error("Expected call to ClientMock.RegisterIncomingRequest")
	}
}

type mClientMockRegisterOutgoingRequest struct {
	mock               *ClientMock
	defaultExpectation *ClientMockRegisterOutgoingRequestExpectation
	expectations       []*ClientMockRegisterOutgoingRequestExpectation

	callArgs []*ClientMockRegisterOutgoingRequestParams
	mutex    sync.RWMutex
}

// ClientMockRegisterOutgoingRequestExpectation specifies expectation struct of the Client.RegisterOutgoingRequest
type ClientMockRegisterOutgoingRequestExpectation struct {
	mock    *ClientMock
	params  *ClientMockRegisterOutgoingRequestParams
	results *ClientMockRegisterOutgoingRequestResults
	Counter uint64
}

// ClientMockRegisterOutgoingRequestParams contains parameters of the Client.RegisterOutgoingRequest
type ClientMockRegisterOutgoingRequestParams struct {
	ctx     context.Context
	request *record.OutgoingRequest
}

// ClientMockRegisterOutgoingRequestResults contains results of the Client.RegisterOutgoingRequest
type ClientMockRegisterOutgoingRequestResults struct {
	rp1 *payload.RequestInfo
	err error
}

// Expect sets up expected params for Client.RegisterOutgoingRequest
func (mmRegisterOutgoingRequest *mClientMockRegisterOutgoingRequest) Expect(ctx context.Context, request *record.OutgoingRequest) *mClientMockRegisterOutgoingRequest {
	if mmRegisterOutgoingRequest.mock.funcRegisterOutgoingRequest != nil {
		mmRegisterOutgoingRequest.mock.t.Fatalf("ClientMock.RegisterOutgoingRequest mock is already set by Set")
	}

	if mmRegisterOutgoingRequest.defaultExpectation == nil {
		mmRegisterOutgoingRequest.defaultExpectation = &ClientMockRegisterOutgoingRequestExpectation{}
	}

	mmRegisterOutgoingRequest.defaultExpectation.params = &ClientMockRegisterOutgoingRequestParams{ctx, request}
	for _, e := range mmRegisterOutgoingRequest.expectations {
		if minimock.Equal(e.params, mmRegisterOutgoingRequest.defaultExpectation.params) {
			mmRegisterOutgoingRequest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegisterOutgoingRequest.defaultExpectation.params)
		}
	}

	return mmRegisterOutgoingRequest
}

// Inspect accepts an inspector function that has same arguments as the Client.RegisterOutgoingRequest
func (mmRegisterOutgoingRequest *mClientMockRegisterOutgoingRequest) Inspect(f func(ctx context.Context, request *record.OutgoingRequest)) *mClientMockRegisterOutgoingRequest {
	if mmRegisterOutgoingRequest.mock.inspectFuncRegisterOutgoingRequest != nil {
		mmRegisterOutgoingRequest.mock.t.Fatalf("Inspect function is already set for ClientMock.RegisterOutgoingRequest")
	}

	mmRegisterOutgoingRequest.mock.inspectFuncRegisterOutgoingRequest = f

	return mmRegisterOutgoingRequest
}

// Return sets up results that will be returned by Client.RegisterOutgoingRequest
func (mmRegisterOutgoingRequest *mClientMockRegisterOutgoingRequest) Return(rp1 *payload.RequestInfo, err error) *ClientMock {
	if mmRegisterOutgoingRequest.mock.funcRegisterOutgoingRequest != nil {
		mmRegisterOutgoingRequest.mock.t.Fatalf("ClientMock.RegisterOutgoingRequest mock is already set by Set")
	}

	if mmRegisterOutgoingRequest.defaultExpectation == nil {
		mmRegisterOutgoingRequest.defaultExpectation = &ClientMockRegisterOutgoingRequestExpectation{mock: mmRegisterOutgoingRequest.mock}
	}
	mmRegisterOutgoingRequest.defaultExpectation.results = &ClientMockRegisterOutgoingRequestResults{rp1, err}
	return mmRegisterOutgoingRequest.mock
}

//Set uses given function f to mock the Client.RegisterOutgoingRequest method
func (mmRegisterOutgoingRequest *mClientMockRegisterOutgoingRequest) Set(f func(ctx context.Context, request *record.OutgoingRequest) (rp1 *payload.RequestInfo, err error)) *ClientMock {
	if mmRegisterOutgoingRequest.defaultExpectation != nil {
		mmRegisterOutgoingRequest.mock.t.Fatalf("Default expectation is already set for the Client.RegisterOutgoingRequest method")
	}

	if len(mmRegisterOutgoingRequest.expectations) > 0 {
		mmRegisterOutgoingRequest.mock.t.Fatalf("Some expectations are already set for the Client.RegisterOutgoingRequest method")
	}

	mmRegisterOutgoingRequest.mock.funcRegisterOutgoingRequest = f
	return mmRegisterOutgoingRequest.mock
}

// When sets expectation for the Client.RegisterOutgoingRequest which will trigger the result defined by the following
// Then helper
func (mmRegisterOutgoingRequest *mClientMockRegisterOutgoingRequest) When(ctx context.Context, request *record.OutgoingRequest) *ClientMockRegisterOutgoingRequestExpectation {
	if mmRegisterOutgoingRequest.mock.funcRegisterOutgoingRequest != nil {
		mmRegisterOutgoingRequest.mock.t.Fatalf("ClientMock.RegisterOutgoingRequest mock is already set by Set")
	}

	expectation := &ClientMockRegisterOutgoingRequestExpectation{
		mock:   mmRegisterOutgoingRequest.mock,
		params: &ClientMockRegisterOutgoingRequestParams{ctx, request},
	}
	mmRegisterOutgoingRequest.expectations = append(mmRegisterOutgoingRequest.expectations, expectation)
	return expectation
}

// Then sets up Client.RegisterOutgoingRequest return parameters for the expectation previously defined by the When method
func (e *ClientMockRegisterOutgoingRequestExpectation) Then(rp1 *payload.RequestInfo, err error) *ClientMock {
	e.results = &ClientMockRegisterOutgoingRequestResults{rp1, err}
	return e.mock
}

// RegisterOutgoingRequest implements Client
func (mmRegisterOutgoingRequest *ClientMock) RegisterOutgoingRequest(ctx context.Context, request *record.OutgoingRequest) (rp1 *payload.RequestInfo, err error) {
	mm_atomic.AddUint64(&mmRegisterOutgoingRequest.beforeRegisterOutgoingRequestCounter, 1)
	defer mm_atomic.AddUint64(&mmRegisterOutgoingRequest.afterRegisterOutgoingRequestCounter, 1)

	if mmRegisterOutgoingRequest.inspectFuncRegisterOutgoingRequest != nil {
		mmRegisterOutgoingRequest.inspectFuncRegisterOutgoingRequest(ctx, request)
	}

	params := &ClientMockRegisterOutgoingRequestParams{ctx, request}

	// Record call args
	mmRegisterOutgoingRequest.RegisterOutgoingRequestMock.mutex.Lock()
	mmRegisterOutgoingRequest.RegisterOutgoingRequestMock.callArgs = append(mmRegisterOutgoingRequest.RegisterOutgoingRequestMock.callArgs, params)
	mmRegisterOutgoingRequest.RegisterOutgoingRequestMock.mutex.Unlock()

	for _, e := range mmRegisterOutgoingRequest.RegisterOutgoingRequestMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmRegisterOutgoingRequest.RegisterOutgoingRequestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegisterOutgoingRequest.RegisterOutgoingRequestMock.defaultExpectation.Counter, 1)
		want := mmRegisterOutgoingRequest.RegisterOutgoingRequestMock.defaultExpectation.params
		got := ClientMockRegisterOutgoingRequestParams{ctx, request}
		if want != nil && !minimock.Equal(*want, got) {
			mmRegisterOutgoingRequest.t.Errorf("ClientMock.RegisterOutgoingRequest got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmRegisterOutgoingRequest.RegisterOutgoingRequestMock.defaultExpectation.results
		if results == nil {
			mmRegisterOutgoingRequest.t.Fatal("No results are set for the ClientMock.RegisterOutgoingRequest")
		}
		return (*results).rp1, (*results).err
	}
	if mmRegisterOutgoingRequest.funcRegisterOutgoingRequest != nil {
		return mmRegisterOutgoingRequest.funcRegisterOutgoingRequest(ctx, request)
	}
	mmRegisterOutgoingRequest.t.Fatalf("Unexpected call to ClientMock.RegisterOutgoingRequest. %v %v", ctx, request)
	return
}

// RegisterOutgoingRequestAfterCounter returns a count of finished ClientMock.RegisterOutgoingRequest invocations
func (mmRegisterOutgoingRequest *ClientMock) RegisterOutgoingRequestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterOutgoingRequest.afterRegisterOutgoingRequestCounter)
}

// RegisterOutgoingRequestBeforeCounter returns a count of ClientMock.RegisterOutgoingRequest invocations
func (mmRegisterOutgoingRequest *ClientMock) RegisterOutgoingRequestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterOutgoingRequest.beforeRegisterOutgoingRequestCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.RegisterOutgoingRequest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegisterOutgoingRequest *mClientMockRegisterOutgoingRequest) Calls() []*ClientMockRegisterOutgoingRequestParams {
	mmRegisterOutgoingRequest.mutex.RLock()

	argCopy := make([]*ClientMockRegisterOutgoingRequestParams, len(mmRegisterOutgoingRequest.callArgs))
	copy(argCopy, mmRegisterOutgoingRequest.callArgs)

	mmRegisterOutgoingRequest.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterOutgoingRequestDone returns true if the count of the RegisterOutgoingRequest invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockRegisterOutgoingRequestDone() bool {
	for _, e := range m.RegisterOutgoingRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterOutgoingRequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterOutgoingRequestCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterOutgoingRequest != nil && mm_atomic.LoadUint64(&m.afterRegisterOutgoingRequestCounter) < 1 {
		return false
	}
	return true
}

// MinimockRegisterOutgoingRequestInspect logs each unmet expectation
func (m *ClientMock) MinimockRegisterOutgoingRequestInspect() {
	for _, e := range m.RegisterOutgoingRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.RegisterOutgoingRequest with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterOutgoingRequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterOutgoingRequestCounter) < 1 {
		if m.RegisterOutgoingRequestMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.RegisterOutgoingRequest")
		} else {
			m.t.Errorf("Expected call to ClientMock.RegisterOutgoingRequest with params: %#v", *m.RegisterOutgoingRequestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterOutgoingRequest != nil && mm_atomic.LoadUint64(&m.afterRegisterOutgoingRequestCounter) < 1 {
		m.t.Error("Expected call to ClientMock.RegisterOutgoingRequest")
	}
}

type mClientMockRegisterResult struct {
	mock               *ClientMock
	defaultExpectation *ClientMockRegisterResultExpectation
	expectations       []*ClientMockRegisterResultExpectation

	callArgs []*ClientMockRegisterResultParams
	mutex    sync.RWMutex
}

// ClientMockRegisterResultExpectation specifies expectation struct of the Client.RegisterResult
type ClientMockRegisterResultExpectation struct {
	mock    *ClientMock
	params  *ClientMockRegisterResultParams
	results *ClientMockRegisterResultResults
	Counter uint64
}

// ClientMockRegisterResultParams contains parameters of the Client.RegisterResult
type ClientMockRegisterResultParams struct {
	ctx     context.Context
	request insolar.Reference
	result  RequestResult
}

// ClientMockRegisterResultResults contains results of the Client.RegisterResult
type ClientMockRegisterResultResults struct {
	err error
}

// Expect sets up expected params for Client.RegisterResult
func (mmRegisterResult *mClientMockRegisterResult) Expect(ctx context.Context, request insolar.Reference, result RequestResult) *mClientMockRegisterResult {
	if mmRegisterResult.mock.funcRegisterResult != nil {
		mmRegisterResult.mock.t.Fatalf("ClientMock.RegisterResult mock is already set by Set")
	}

	if mmRegisterResult.defaultExpectation == nil {
		mmRegisterResult.defaultExpectation = &ClientMockRegisterResultExpectation{}
	}

	mmRegisterResult.defaultExpectation.params = &ClientMockRegisterResultParams{ctx, request, result}
	for _, e := range mmRegisterResult.expectations {
		if minimock.Equal(e.params, mmRegisterResult.defaultExpectation.params) {
			mmRegisterResult.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegisterResult.defaultExpectation.params)
		}
	}

	return mmRegisterResult
}

// Inspect accepts an inspector function that has same arguments as the Client.RegisterResult
func (mmRegisterResult *mClientMockRegisterResult) Inspect(f func(ctx context.Context, request insolar.Reference, result RequestResult)) *mClientMockRegisterResult {
	if mmRegisterResult.mock.inspectFuncRegisterResult != nil {
		mmRegisterResult.mock.t.Fatalf("Inspect function is already set for ClientMock.RegisterResult")
	}

	mmRegisterResult.mock.inspectFuncRegisterResult = f

	return mmRegisterResult
}

// Return sets up results that will be returned by Client.RegisterResult
func (mmRegisterResult *mClientMockRegisterResult) Return(err error) *ClientMock {
	if mmRegisterResult.mock.funcRegisterResult != nil {
		mmRegisterResult.mock.t.Fatalf("ClientMock.RegisterResult mock is already set by Set")
	}

	if mmRegisterResult.defaultExpectation == nil {
		mmRegisterResult.defaultExpectation = &ClientMockRegisterResultExpectation{mock: mmRegisterResult.mock}
	}
	mmRegisterResult.defaultExpectation.results = &ClientMockRegisterResultResults{err}
	return mmRegisterResult.mock
}

//Set uses given function f to mock the Client.RegisterResult method
func (mmRegisterResult *mClientMockRegisterResult) Set(f func(ctx context.Context, request insolar.Reference, result RequestResult) (err error)) *ClientMock {
	if mmRegisterResult.defaultExpectation != nil {
		mmRegisterResult.mock.t.Fatalf("Default expectation is already set for the Client.RegisterResult method")
	}

	if len(mmRegisterResult.expectations) > 0 {
		mmRegisterResult.mock.t.Fatalf("Some expectations are already set for the Client.RegisterResult method")
	}

	mmRegisterResult.mock.funcRegisterResult = f
	return mmRegisterResult.mock
}

// When sets expectation for the Client.RegisterResult which will trigger the result defined by the following
// Then helper
func (mmRegisterResult *mClientMockRegisterResult) When(ctx context.Context, request insolar.Reference, result RequestResult) *ClientMockRegisterResultExpectation {
	if mmRegisterResult.mock.funcRegisterResult != nil {
		mmRegisterResult.mock.t.Fatalf("ClientMock.RegisterResult mock is already set by Set")
	}

	expectation := &ClientMockRegisterResultExpectation{
		mock:   mmRegisterResult.mock,
		params: &ClientMockRegisterResultParams{ctx, request, result},
	}
	mmRegisterResult.expectations = append(mmRegisterResult.expectations, expectation)
	return expectation
}

// Then sets up Client.RegisterResult return parameters for the expectation previously defined by the When method
func (e *ClientMockRegisterResultExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockRegisterResultResults{err}
	return e.mock
}

// RegisterResult implements Client
func (mmRegisterResult *ClientMock) RegisterResult(ctx context.Context, request insolar.Reference, result RequestResult) (err error) {
	mm_atomic.AddUint64(&mmRegisterResult.beforeRegisterResultCounter, 1)
	defer mm_atomic.AddUint64(&mmRegisterResult.afterRegisterResultCounter, 1)

	if mmRegisterResult.inspectFuncRegisterResult != nil {
		mmRegisterResult.inspectFuncRegisterResult(ctx, request, result)
	}

	params := &ClientMockRegisterResultParams{ctx, request, result}

	// Record call args
	mmRegisterResult.RegisterResultMock.mutex.Lock()
	mmRegisterResult.RegisterResultMock.callArgs = append(mmRegisterResult.RegisterResultMock.callArgs, params)
	mmRegisterResult.RegisterResultMock.mutex.Unlock()

	for _, e := range mmRegisterResult.RegisterResultMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRegisterResult.RegisterResultMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegisterResult.RegisterResultMock.defaultExpectation.Counter, 1)
		want := mmRegisterResult.RegisterResultMock.defaultExpectation.params
		got := ClientMockRegisterResultParams{ctx, request, result}
		if want != nil && !minimock.Equal(*want, got) {
			mmRegisterResult.t.Errorf("ClientMock.RegisterResult got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmRegisterResult.RegisterResultMock.defaultExpectation.results
		if results == nil {
			mmRegisterResult.t.Fatal("No results are set for the ClientMock.RegisterResult")
		}
		return (*results).err
	}
	if mmRegisterResult.funcRegisterResult != nil {
		return mmRegisterResult.funcRegisterResult(ctx, request, result)
	}
	mmRegisterResult.t.Fatalf("Unexpected call to ClientMock.RegisterResult. %v %v %v", ctx, request, result)
	return
}

// RegisterResultAfterCounter returns a count of finished ClientMock.RegisterResult invocations
func (mmRegisterResult *ClientMock) RegisterResultAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterResult.afterRegisterResultCounter)
}

// RegisterResultBeforeCounter returns a count of ClientMock.RegisterResult invocations
func (mmRegisterResult *ClientMock) RegisterResultBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterResult.beforeRegisterResultCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.RegisterResult.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegisterResult *mClientMockRegisterResult) Calls() []*ClientMockRegisterResultParams {
	mmRegisterResult.mutex.RLock()

	argCopy := make([]*ClientMockRegisterResultParams, len(mmRegisterResult.callArgs))
	copy(argCopy, mmRegisterResult.callArgs)

	mmRegisterResult.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterResultDone returns true if the count of the RegisterResult invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockRegisterResultDone() bool {
	for _, e := range m.RegisterResultMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterResultMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterResultCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterResult != nil && mm_atomic.LoadUint64(&m.afterRegisterResultCounter) < 1 {
		return false
	}
	return true
}

// MinimockRegisterResultInspect logs each unmet expectation
func (m *ClientMock) MinimockRegisterResultInspect() {
	for _, e := range m.RegisterResultMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.RegisterResult with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterResultMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterResultCounter) < 1 {
		if m.RegisterResultMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.RegisterResult")
		} else {
			m.t.Errorf("Expected call to ClientMock.RegisterResult with params: %#v", *m.RegisterResultMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterResult != nil && mm_atomic.LoadUint64(&m.afterRegisterResultCounter) < 1 {
		m.t.Error("Expected call to ClientMock.RegisterResult")
	}
}

type mClientMockState struct {
	mock               *ClientMock
	defaultExpectation *ClientMockStateExpectation
	expectations       []*ClientMockStateExpectation
}

// ClientMockStateExpectation specifies expectation struct of the Client.State
type ClientMockStateExpectation struct {
	mock *ClientMock

	results *ClientMockStateResults
	Counter uint64
}

// ClientMockStateResults contains results of the Client.State
type ClientMockStateResults struct {
	ba1 []byte
}

// Expect sets up expected params for Client.State
func (mmState *mClientMockState) Expect() *mClientMockState {
	if mmState.mock.funcState != nil {
		mmState.mock.t.Fatalf("ClientMock.State mock is already set by Set")
	}

	if mmState.defaultExpectation == nil {
		mmState.defaultExpectation = &ClientMockStateExpectation{}
	}

	return mmState
}

// Inspect accepts an inspector function that has same arguments as the Client.State
func (mmState *mClientMockState) Inspect(f func()) *mClientMockState {
	if mmState.mock.inspectFuncState != nil {
		mmState.mock.t.Fatalf("Inspect function is already set for ClientMock.State")
	}

	mmState.mock.inspectFuncState = f

	return mmState
}

// Return sets up results that will be returned by Client.State
func (mmState *mClientMockState) Return(ba1 []byte) *ClientMock {
	if mmState.mock.funcState != nil {
		mmState.mock.t.Fatalf("ClientMock.State mock is already set by Set")
	}

	if mmState.defaultExpectation == nil {
		mmState.defaultExpectation = &ClientMockStateExpectation{mock: mmState.mock}
	}
	mmState.defaultExpectation.results = &ClientMockStateResults{ba1}
	return mmState.mock
}

//Set uses given function f to mock the Client.State method
func (mmState *mClientMockState) Set(f func() (ba1 []byte)) *ClientMock {
	if mmState.defaultExpectation != nil {
		mmState.mock.t.Fatalf("Default expectation is already set for the Client.State method")
	}

	if len(mmState.expectations) > 0 {
		mmState.mock.t.Fatalf("Some expectations are already set for the Client.State method")
	}

	mmState.mock.funcState = f
	return mmState.mock
}

// State implements Client
func (mmState *ClientMock) State() (ba1 []byte) {
	mm_atomic.AddUint64(&mmState.beforeStateCounter, 1)
	defer mm_atomic.AddUint64(&mmState.afterStateCounter, 1)

	if mmState.inspectFuncState != nil {
		mmState.inspectFuncState()
	}

	if mmState.StateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmState.StateMock.defaultExpectation.Counter, 1)

		results := mmState.StateMock.defaultExpectation.results
		if results == nil {
			mmState.t.Fatal("No results are set for the ClientMock.State")
		}
		return (*results).ba1
	}
	if mmState.funcState != nil {
		return mmState.funcState()
	}
	mmState.t.Fatalf("Unexpected call to ClientMock.State.")
	return
}

// StateAfterCounter returns a count of finished ClientMock.State invocations
func (mmState *ClientMock) StateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmState.afterStateCounter)
}

// StateBeforeCounter returns a count of ClientMock.State invocations
func (mmState *ClientMock) StateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmState.beforeStateCounter)
}

// MinimockStateDone returns true if the count of the State invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockStateDone() bool {
	for _, e := range m.StateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcState != nil && mm_atomic.LoadUint64(&m.afterStateCounter) < 1 {
		return false
	}
	return true
}

// MinimockStateInspect logs each unmet expectation
func (m *ClientMock) MinimockStateInspect() {
	for _, e := range m.StateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ClientMock.State")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStateCounter) < 1 {
		m.t.Error("Expected call to ClientMock.State")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcState != nil && mm_atomic.LoadUint64(&m.afterStateCounter) < 1 {
		m.t.Error("Expected call to ClientMock.State")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ClientMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockActivatePrototypeInspect()

		m.MinimockDeployCodeInspect()

		m.MinimockGetAbandonedRequestInspect()

		m.MinimockGetCodeInspect()

		m.MinimockGetObjectInspect()

		m.MinimockGetPendingsInspect()

		m.MinimockHasPendingsInspect()

		m.MinimockInjectCodeDescriptorInspect()

		m.MinimockInjectFinishInspect()

		m.MinimockInjectObjectDescriptorInspect()

		m.MinimockRegisterIncomingRequestInspect()

		m.MinimockRegisterOutgoingRequestInspect()

		m.MinimockRegisterResultInspect()

		m.MinimockStateInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockActivatePrototypeDone() &&
		m.MinimockDeployCodeDone() &&
		m.MinimockGetAbandonedRequestDone() &&
		m.MinimockGetCodeDone() &&
		m.MinimockGetObjectDone() &&
		m.MinimockGetPendingsDone() &&
		m.MinimockHasPendingsDone() &&
		m.MinimockInjectCodeDescriptorDone() &&
		m.MinimockInjectFinishDone() &&
		m.MinimockInjectObjectDescriptorDone() &&
		m.MinimockRegisterIncomingRequestDone() &&
		m.MinimockRegisterOutgoingRequestDone() &&
		m.MinimockRegisterResultDone() &&
		m.MinimockStateDone()
}
