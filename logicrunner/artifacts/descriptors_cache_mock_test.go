package artifacts

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/insolar"
)

// DescriptorsCacheMock implements DescriptorsCache
type DescriptorsCacheMock struct {
	t minimock.Tester

	funcByObjectDescriptor          func(ctx context.Context, obj ObjectDescriptor) (p1 PrototypeDescriptor, c2 CodeDescriptor, err error)
	inspectFuncByObjectDescriptor   func(ctx context.Context, obj ObjectDescriptor)
	afterByObjectDescriptorCounter  uint64
	beforeByObjectDescriptorCounter uint64
	ByObjectDescriptorMock          mDescriptorsCacheMockByObjectDescriptor

	funcByPrototypeRef          func(ctx context.Context, protoRef insolar.Reference) (p1 PrototypeDescriptor, c2 CodeDescriptor, err error)
	inspectFuncByPrototypeRef   func(ctx context.Context, protoRef insolar.Reference)
	afterByPrototypeRefCounter  uint64
	beforeByPrototypeRefCounter uint64
	ByPrototypeRefMock          mDescriptorsCacheMockByPrototypeRef

	funcGetCode          func(ctx context.Context, ref insolar.Reference) (c2 CodeDescriptor, err error)
	inspectFuncGetCode   func(ctx context.Context, ref insolar.Reference)
	afterGetCodeCounter  uint64
	beforeGetCodeCounter uint64
	GetCodeMock          mDescriptorsCacheMockGetCode

	funcGetPrototype          func(ctx context.Context, ref insolar.Reference) (p1 PrototypeDescriptor, err error)
	inspectFuncGetPrototype   func(ctx context.Context, ref insolar.Reference)
	afterGetPrototypeCounter  uint64
	beforeGetPrototypeCounter uint64
	GetPrototypeMock          mDescriptorsCacheMockGetPrototype
}

// NewDescriptorsCacheMock returns a mock for DescriptorsCache
func NewDescriptorsCacheMock(t minimock.Tester) *DescriptorsCacheMock {
	m := &DescriptorsCacheMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ByObjectDescriptorMock = mDescriptorsCacheMockByObjectDescriptor{mock: m}
	m.ByObjectDescriptorMock.callArgs = []*DescriptorsCacheMockByObjectDescriptorParams{}

	m.ByPrototypeRefMock = mDescriptorsCacheMockByPrototypeRef{mock: m}
	m.ByPrototypeRefMock.callArgs = []*DescriptorsCacheMockByPrototypeRefParams{}

	m.GetCodeMock = mDescriptorsCacheMockGetCode{mock: m}
	m.GetCodeMock.callArgs = []*DescriptorsCacheMockGetCodeParams{}

	m.GetPrototypeMock = mDescriptorsCacheMockGetPrototype{mock: m}
	m.GetPrototypeMock.callArgs = []*DescriptorsCacheMockGetPrototypeParams{}

	return m
}

type mDescriptorsCacheMockByObjectDescriptor struct {
	mock               *DescriptorsCacheMock
	defaultExpectation *DescriptorsCacheMockByObjectDescriptorExpectation
	expectations       []*DescriptorsCacheMockByObjectDescriptorExpectation

	callArgs []*DescriptorsCacheMockByObjectDescriptorParams
	mutex    sync.RWMutex
}

// DescriptorsCacheMockByObjectDescriptorExpectation specifies expectation struct of the DescriptorsCache.ByObjectDescriptor
type DescriptorsCacheMockByObjectDescriptorExpectation struct {
	mock    *DescriptorsCacheMock
	params  *DescriptorsCacheMockByObjectDescriptorParams
	results *DescriptorsCacheMockByObjectDescriptorResults
	Counter uint64
}

// DescriptorsCacheMockByObjectDescriptorParams contains parameters of the DescriptorsCache.ByObjectDescriptor
type DescriptorsCacheMockByObjectDescriptorParams struct {
	ctx context.Context
	obj ObjectDescriptor
}

// DescriptorsCacheMockByObjectDescriptorResults contains results of the DescriptorsCache.ByObjectDescriptor
type DescriptorsCacheMockByObjectDescriptorResults struct {
	p1  PrototypeDescriptor
	c2  CodeDescriptor
	err error
}

// Expect sets up expected params for DescriptorsCache.ByObjectDescriptor
func (mmByObjectDescriptor *mDescriptorsCacheMockByObjectDescriptor) Expect(ctx context.Context, obj ObjectDescriptor) *mDescriptorsCacheMockByObjectDescriptor {
	if mmByObjectDescriptor.mock.funcByObjectDescriptor != nil {
		mmByObjectDescriptor.mock.t.Fatalf("DescriptorsCacheMock.ByObjectDescriptor mock is already set by Set")
	}

	if mmByObjectDescriptor.defaultExpectation == nil {
		mmByObjectDescriptor.defaultExpectation = &DescriptorsCacheMockByObjectDescriptorExpectation{}
	}

	mmByObjectDescriptor.defaultExpectation.params = &DescriptorsCacheMockByObjectDescriptorParams{ctx, obj}
	for _, e := range mmByObjectDescriptor.expectations {
		if minimock.Equal(e.params, mmByObjectDescriptor.defaultExpectation.params) {
			mmByObjectDescriptor.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmByObjectDescriptor.defaultExpectation.params)
		}
	}

	return mmByObjectDescriptor
}

// Inspect accepts an inspector function that has same arguments as the DescriptorsCache.ByObjectDescriptor
func (mmByObjectDescriptor *mDescriptorsCacheMockByObjectDescriptor) Inspect(f func(ctx context.Context, obj ObjectDescriptor)) *mDescriptorsCacheMockByObjectDescriptor {
	if mmByObjectDescriptor.mock.inspectFuncByObjectDescriptor != nil {
		mmByObjectDescriptor.mock.t.Fatalf("Inspect function is already set for DescriptorsCacheMock.ByObjectDescriptor")
	}

	mmByObjectDescriptor.mock.inspectFuncByObjectDescriptor = f

	return mmByObjectDescriptor
}

// Return sets up results that will be returned by DescriptorsCache.ByObjectDescriptor
func (mmByObjectDescriptor *mDescriptorsCacheMockByObjectDescriptor) Return(p1 PrototypeDescriptor, c2 CodeDescriptor, err error) *DescriptorsCacheMock {
	if mmByObjectDescriptor.mock.funcByObjectDescriptor != nil {
		mmByObjectDescriptor.mock.t.Fatalf("DescriptorsCacheMock.ByObjectDescriptor mock is already set by Set")
	}

	if mmByObjectDescriptor.defaultExpectation == nil {
		mmByObjectDescriptor.defaultExpectation = &DescriptorsCacheMockByObjectDescriptorExpectation{mock: mmByObjectDescriptor.mock}
	}
	mmByObjectDescriptor.defaultExpectation.results = &DescriptorsCacheMockByObjectDescriptorResults{p1, c2, err}
	return mmByObjectDescriptor.mock
}

//Set uses given function f to mock the DescriptorsCache.ByObjectDescriptor method
func (mmByObjectDescriptor *mDescriptorsCacheMockByObjectDescriptor) Set(f func(ctx context.Context, obj ObjectDescriptor) (p1 PrototypeDescriptor, c2 CodeDescriptor, err error)) *DescriptorsCacheMock {
	if mmByObjectDescriptor.defaultExpectation != nil {
		mmByObjectDescriptor.mock.t.Fatalf("Default expectation is already set for the DescriptorsCache.ByObjectDescriptor method")
	}

	if len(mmByObjectDescriptor.expectations) > 0 {
		mmByObjectDescriptor.mock.t.Fatalf("Some expectations are already set for the DescriptorsCache.ByObjectDescriptor method")
	}

	mmByObjectDescriptor.mock.funcByObjectDescriptor = f
	return mmByObjectDescriptor.mock
}

// When sets expectation for the DescriptorsCache.ByObjectDescriptor which will trigger the result defined by the following
// Then helper
func (mmByObjectDescriptor *mDescriptorsCacheMockByObjectDescriptor) When(ctx context.Context, obj ObjectDescriptor) *DescriptorsCacheMockByObjectDescriptorExpectation {
	if mmByObjectDescriptor.mock.funcByObjectDescriptor != nil {
		mmByObjectDescriptor.mock.t.Fatalf("DescriptorsCacheMock.ByObjectDescriptor mock is already set by Set")
	}

	expectation := &DescriptorsCacheMockByObjectDescriptorExpectation{
		mock:   mmByObjectDescriptor.mock,
		params: &DescriptorsCacheMockByObjectDescriptorParams{ctx, obj},
	}
	mmByObjectDescriptor.expectations = append(mmByObjectDescriptor.expectations, expectation)
	return expectation
}

// Then sets up DescriptorsCache.ByObjectDescriptor return parameters for the expectation previously defined by the When method
func (e *DescriptorsCacheMockByObjectDescriptorExpectation) Then(p1 PrototypeDescriptor, c2 CodeDescriptor, err error) *DescriptorsCacheMock {
	e.results = &DescriptorsCacheMockByObjectDescriptorResults{p1, c2, err}
	return e.mock
}

// ByObjectDescriptor implements DescriptorsCache
func (mmByObjectDescriptor *DescriptorsCacheMock) ByObjectDescriptor(ctx context.Context, obj ObjectDescriptor) (p1 PrototypeDescriptor, c2 CodeDescriptor, err error) {
	mm_atomic.AddUint64(&mmByObjectDescriptor.beforeByObjectDescriptorCounter, 1)
	defer mm_atomic.AddUint64(&mmByObjectDescriptor.afterByObjectDescriptorCounter, 1)

	if mmByObjectDescriptor.inspectFuncByObjectDescriptor != nil {
		mmByObjectDescriptor.inspectFuncByObjectDescriptor(ctx, obj)
	}

	params := &DescriptorsCacheMockByObjectDescriptorParams{ctx, obj}

	// Record call args
	mmByObjectDescriptor.ByObjectDescriptorMock.mutex.Lock()
	mmByObjectDescriptor.ByObjectDescriptorMock.callArgs = append(mmByObjectDescriptor.ByObjectDescriptorMock.callArgs, params)
	mmByObjectDescriptor.ByObjectDescriptorMock.mutex.Unlock()

	for _, e := range mmByObjectDescriptor.ByObjectDescriptorMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.c2, e.results.err
		}
	}

	if mmByObjectDescriptor.ByObjectDescriptorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmByObjectDescriptor.ByObjectDescriptorMock.defaultExpectation.Counter, 1)
		want := mmByObjectDescriptor.ByObjectDescriptorMock.defaultExpectation.params
		got := DescriptorsCacheMockByObjectDescriptorParams{ctx, obj}
		if want != nil && !minimock.Equal(*want, got) {
			mmByObjectDescriptor.t.Errorf("DescriptorsCacheMock.ByObjectDescriptor got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmByObjectDescriptor.ByObjectDescriptorMock.defaultExpectation.results
		if results == nil {
			mmByObjectDescriptor.t.Fatal("No results are set for the DescriptorsCacheMock.ByObjectDescriptor")
		}
		return (*results).p1, (*results).c2, (*results).err
	}
	if mmByObjectDescriptor.funcByObjectDescriptor != nil {
		return mmByObjectDescriptor.funcByObjectDescriptor(ctx, obj)
	}
	mmByObjectDescriptor.t.Fatalf("Unexpected call to DescriptorsCacheMock.ByObjectDescriptor. %v %v", ctx, obj)
	return
}

// ByObjectDescriptorAfterCounter returns a count of finished DescriptorsCacheMock.ByObjectDescriptor invocations
func (mmByObjectDescriptor *DescriptorsCacheMock) ByObjectDescriptorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmByObjectDescriptor.afterByObjectDescriptorCounter)
}

// ByObjectDescriptorBeforeCounter returns a count of DescriptorsCacheMock.ByObjectDescriptor invocations
func (mmByObjectDescriptor *DescriptorsCacheMock) ByObjectDescriptorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmByObjectDescriptor.beforeByObjectDescriptorCounter)
}

// Calls returns a list of arguments used in each call to DescriptorsCacheMock.ByObjectDescriptor.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmByObjectDescriptor *mDescriptorsCacheMockByObjectDescriptor) Calls() []*DescriptorsCacheMockByObjectDescriptorParams {
	mmByObjectDescriptor.mutex.RLock()

	argCopy := make([]*DescriptorsCacheMockByObjectDescriptorParams, len(mmByObjectDescriptor.callArgs))
	copy(argCopy, mmByObjectDescriptor.callArgs)

	mmByObjectDescriptor.mutex.RUnlock()

	return argCopy
}

// MinimockByObjectDescriptorDone returns true if the count of the ByObjectDescriptor invocations corresponds
// the number of defined expectations
func (m *DescriptorsCacheMock) MinimockByObjectDescriptorDone() bool {
	for _, e := range m.ByObjectDescriptorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ByObjectDescriptorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterByObjectDescriptorCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcByObjectDescriptor != nil && mm_atomic.LoadUint64(&m.afterByObjectDescriptorCounter) < 1 {
		return false
	}
	return true
}

// MinimockByObjectDescriptorInspect logs each unmet expectation
func (m *DescriptorsCacheMock) MinimockByObjectDescriptorInspect() {
	for _, e := range m.ByObjectDescriptorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DescriptorsCacheMock.ByObjectDescriptor with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ByObjectDescriptorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterByObjectDescriptorCounter) < 1 {
		if m.ByObjectDescriptorMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DescriptorsCacheMock.ByObjectDescriptor")
		} else {
			m.t.Errorf("Expected call to DescriptorsCacheMock.ByObjectDescriptor with params: %#v", *m.ByObjectDescriptorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcByObjectDescriptor != nil && mm_atomic.LoadUint64(&m.afterByObjectDescriptorCounter) < 1 {
		m.t.Error("Expected call to DescriptorsCacheMock.ByObjectDescriptor")
	}
}

type mDescriptorsCacheMockByPrototypeRef struct {
	mock               *DescriptorsCacheMock
	defaultExpectation *DescriptorsCacheMockByPrototypeRefExpectation
	expectations       []*DescriptorsCacheMockByPrototypeRefExpectation

	callArgs []*DescriptorsCacheMockByPrototypeRefParams
	mutex    sync.RWMutex
}

// DescriptorsCacheMockByPrototypeRefExpectation specifies expectation struct of the DescriptorsCache.ByPrototypeRef
type DescriptorsCacheMockByPrototypeRefExpectation struct {
	mock    *DescriptorsCacheMock
	params  *DescriptorsCacheMockByPrototypeRefParams
	results *DescriptorsCacheMockByPrototypeRefResults
	Counter uint64
}

// DescriptorsCacheMockByPrototypeRefParams contains parameters of the DescriptorsCache.ByPrototypeRef
type DescriptorsCacheMockByPrototypeRefParams struct {
	ctx      context.Context
	protoRef insolar.Reference
}

// DescriptorsCacheMockByPrototypeRefResults contains results of the DescriptorsCache.ByPrototypeRef
type DescriptorsCacheMockByPrototypeRefResults struct {
	p1  PrototypeDescriptor
	c2  CodeDescriptor
	err error
}

// Expect sets up expected params for DescriptorsCache.ByPrototypeRef
func (mmByPrototypeRef *mDescriptorsCacheMockByPrototypeRef) Expect(ctx context.Context, protoRef insolar.Reference) *mDescriptorsCacheMockByPrototypeRef {
	if mmByPrototypeRef.mock.funcByPrototypeRef != nil {
		mmByPrototypeRef.mock.t.Fatalf("DescriptorsCacheMock.ByPrototypeRef mock is already set by Set")
	}

	if mmByPrototypeRef.defaultExpectation == nil {
		mmByPrototypeRef.defaultExpectation = &DescriptorsCacheMockByPrototypeRefExpectation{}
	}

	mmByPrototypeRef.defaultExpectation.params = &DescriptorsCacheMockByPrototypeRefParams{ctx, protoRef}
	for _, e := range mmByPrototypeRef.expectations {
		if minimock.Equal(e.params, mmByPrototypeRef.defaultExpectation.params) {
			mmByPrototypeRef.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmByPrototypeRef.defaultExpectation.params)
		}
	}

	return mmByPrototypeRef
}

// Inspect accepts an inspector function that has same arguments as the DescriptorsCache.ByPrototypeRef
func (mmByPrototypeRef *mDescriptorsCacheMockByPrototypeRef) Inspect(f func(ctx context.Context, protoRef insolar.Reference)) *mDescriptorsCacheMockByPrototypeRef {
	if mmByPrototypeRef.mock.inspectFuncByPrototypeRef != nil {
		mmByPrototypeRef.mock.t.Fatalf("Inspect function is already set for DescriptorsCacheMock.ByPrototypeRef")
	}

	mmByPrototypeRef.mock.inspectFuncByPrototypeRef = f

	return mmByPrototypeRef
}

// Return sets up results that will be returned by DescriptorsCache.ByPrototypeRef
func (mmByPrototypeRef *mDescriptorsCacheMockByPrototypeRef) Return(p1 PrototypeDescriptor, c2 CodeDescriptor, err error) *DescriptorsCacheMock {
	if mmByPrototypeRef.mock.funcByPrototypeRef != nil {
		mmByPrototypeRef.mock.t.Fatalf("DescriptorsCacheMock.ByPrototypeRef mock is already set by Set")
	}

	if mmByPrototypeRef.defaultExpectation == nil {
		mmByPrototypeRef.defaultExpectation = &DescriptorsCacheMockByPrototypeRefExpectation{mock: mmByPrototypeRef.mock}
	}
	mmByPrototypeRef.defaultExpectation.results = &DescriptorsCacheMockByPrototypeRefResults{p1, c2, err}
	return mmByPrototypeRef.mock
}

//Set uses given function f to mock the DescriptorsCache.ByPrototypeRef method
func (mmByPrototypeRef *mDescriptorsCacheMockByPrototypeRef) Set(f func(ctx context.Context, protoRef insolar.Reference) (p1 PrototypeDescriptor, c2 CodeDescriptor, err error)) *DescriptorsCacheMock {
	if mmByPrototypeRef.defaultExpectation != nil {
		mmByPrototypeRef.mock.t.Fatalf("Default expectation is already set for the DescriptorsCache.ByPrototypeRef method")
	}

	if len(mmByPrototypeRef.expectations) > 0 {
		mmByPrototypeRef.mock.t.Fatalf("Some expectations are already set for the DescriptorsCache.ByPrototypeRef method")
	}

	mmByPrototypeRef.mock.funcByPrototypeRef = f
	return mmByPrototypeRef.mock
}

// When sets expectation for the DescriptorsCache.ByPrototypeRef which will trigger the result defined by the following
// Then helper
func (mmByPrototypeRef *mDescriptorsCacheMockByPrototypeRef) When(ctx context.Context, protoRef insolar.Reference) *DescriptorsCacheMockByPrototypeRefExpectation {
	if mmByPrototypeRef.mock.funcByPrototypeRef != nil {
		mmByPrototypeRef.mock.t.Fatalf("DescriptorsCacheMock.ByPrototypeRef mock is already set by Set")
	}

	expectation := &DescriptorsCacheMockByPrototypeRefExpectation{
		mock:   mmByPrototypeRef.mock,
		params: &DescriptorsCacheMockByPrototypeRefParams{ctx, protoRef},
	}
	mmByPrototypeRef.expectations = append(mmByPrototypeRef.expectations, expectation)
	return expectation
}

// Then sets up DescriptorsCache.ByPrototypeRef return parameters for the expectation previously defined by the When method
func (e *DescriptorsCacheMockByPrototypeRefExpectation) Then(p1 PrototypeDescriptor, c2 CodeDescriptor, err error) *DescriptorsCacheMock {
	e.results = &DescriptorsCacheMockByPrototypeRefResults{p1, c2, err}
	return e.mock
}

// ByPrototypeRef implements DescriptorsCache
func (mmByPrototypeRef *DescriptorsCacheMock) ByPrototypeRef(ctx context.Context, protoRef insolar.Reference) (p1 PrototypeDescriptor, c2 CodeDescriptor, err error) {
	mm_atomic.AddUint64(&mmByPrototypeRef.beforeByPrototypeRefCounter, 1)
	defer mm_atomic.AddUint64(&mmByPrototypeRef.afterByPrototypeRefCounter, 1)

	if mmByPrototypeRef.inspectFuncByPrototypeRef != nil {
		mmByPrototypeRef.inspectFuncByPrototypeRef(ctx, protoRef)
	}

	params := &DescriptorsCacheMockByPrototypeRefParams{ctx, protoRef}

	// Record call args
	mmByPrototypeRef.ByPrototypeRefMock.mutex.Lock()
	mmByPrototypeRef.ByPrototypeRefMock.callArgs = append(mmByPrototypeRef.ByPrototypeRefMock.callArgs, params)
	mmByPrototypeRef.ByPrototypeRefMock.mutex.Unlock()

	for _, e := range mmByPrototypeRef.ByPrototypeRefMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.c2, e.results.err
		}
	}

	if mmByPrototypeRef.ByPrototypeRefMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmByPrototypeRef.ByPrototypeRefMock.defaultExpectation.Counter, 1)
		want := mmByPrototypeRef.ByPrototypeRefMock.defaultExpectation.params
		got := DescriptorsCacheMockByPrototypeRefParams{ctx, protoRef}
		if want != nil && !minimock.Equal(*want, got) {
			mmByPrototypeRef.t.Errorf("DescriptorsCacheMock.ByPrototypeRef got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmByPrototypeRef.ByPrototypeRefMock.defaultExpectation.results
		if results == nil {
			mmByPrototypeRef.t.Fatal("No results are set for the DescriptorsCacheMock.ByPrototypeRef")
		}
		return (*results).p1, (*results).c2, (*results).err
	}
	if mmByPrototypeRef.funcByPrototypeRef != nil {
		return mmByPrototypeRef.funcByPrototypeRef(ctx, protoRef)
	}
	mmByPrototypeRef.t.Fatalf("Unexpected call to DescriptorsCacheMock.ByPrototypeRef. %v %v", ctx, protoRef)
	return
}

// ByPrototypeRefAfterCounter returns a count of finished DescriptorsCacheMock.ByPrototypeRef invocations
func (mmByPrototypeRef *DescriptorsCacheMock) ByPrototypeRefAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmByPrototypeRef.afterByPrototypeRefCounter)
}

// ByPrototypeRefBeforeCounter returns a count of DescriptorsCacheMock.ByPrototypeRef invocations
func (mmByPrototypeRef *DescriptorsCacheMock) ByPrototypeRefBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmByPrototypeRef.beforeByPrototypeRefCounter)
}

// Calls returns a list of arguments used in each call to DescriptorsCacheMock.ByPrototypeRef.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmByPrototypeRef *mDescriptorsCacheMockByPrototypeRef) Calls() []*DescriptorsCacheMockByPrototypeRefParams {
	mmByPrototypeRef.mutex.RLock()

	argCopy := make([]*DescriptorsCacheMockByPrototypeRefParams, len(mmByPrototypeRef.callArgs))
	copy(argCopy, mmByPrototypeRef.callArgs)

	mmByPrototypeRef.mutex.RUnlock()

	return argCopy
}

// MinimockByPrototypeRefDone returns true if the count of the ByPrototypeRef invocations corresponds
// the number of defined expectations
func (m *DescriptorsCacheMock) MinimockByPrototypeRefDone() bool {
	for _, e := range m.ByPrototypeRefMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ByPrototypeRefMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterByPrototypeRefCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcByPrototypeRef != nil && mm_atomic.LoadUint64(&m.afterByPrototypeRefCounter) < 1 {
		return false
	}
	return true
}

// MinimockByPrototypeRefInspect logs each unmet expectation
func (m *DescriptorsCacheMock) MinimockByPrototypeRefInspect() {
	for _, e := range m.ByPrototypeRefMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DescriptorsCacheMock.ByPrototypeRef with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ByPrototypeRefMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterByPrototypeRefCounter) < 1 {
		if m.ByPrototypeRefMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DescriptorsCacheMock.ByPrototypeRef")
		} else {
			m.t.Errorf("Expected call to DescriptorsCacheMock.ByPrototypeRef with params: %#v", *m.ByPrototypeRefMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcByPrototypeRef != nil && mm_atomic.LoadUint64(&m.afterByPrototypeRefCounter) < 1 {
		m.t.Error("Expected call to DescriptorsCacheMock.ByPrototypeRef")
	}
}

type mDescriptorsCacheMockGetCode struct {
	mock               *DescriptorsCacheMock
	defaultExpectation *DescriptorsCacheMockGetCodeExpectation
	expectations       []*DescriptorsCacheMockGetCodeExpectation

	callArgs []*DescriptorsCacheMockGetCodeParams
	mutex    sync.RWMutex
}

// DescriptorsCacheMockGetCodeExpectation specifies expectation struct of the DescriptorsCache.GetCode
type DescriptorsCacheMockGetCodeExpectation struct {
	mock    *DescriptorsCacheMock
	params  *DescriptorsCacheMockGetCodeParams
	results *DescriptorsCacheMockGetCodeResults
	Counter uint64
}

// DescriptorsCacheMockGetCodeParams contains parameters of the DescriptorsCache.GetCode
type DescriptorsCacheMockGetCodeParams struct {
	ctx context.Context
	ref insolar.Reference
}

// DescriptorsCacheMockGetCodeResults contains results of the DescriptorsCache.GetCode
type DescriptorsCacheMockGetCodeResults struct {
	c2  CodeDescriptor
	err error
}

// Expect sets up expected params for DescriptorsCache.GetCode
func (mmGetCode *mDescriptorsCacheMockGetCode) Expect(ctx context.Context, ref insolar.Reference) *mDescriptorsCacheMockGetCode {
	if mmGetCode.mock.funcGetCode != nil {
		mmGetCode.mock.t.Fatalf("DescriptorsCacheMock.GetCode mock is already set by Set")
	}

	if mmGetCode.defaultExpectation == nil {
		mmGetCode.defaultExpectation = &DescriptorsCacheMockGetCodeExpectation{}
	}

	mmGetCode.defaultExpectation.params = &DescriptorsCacheMockGetCodeParams{ctx, ref}
	for _, e := range mmGetCode.expectations {
		if minimock.Equal(e.params, mmGetCode.defaultExpectation.params) {
			mmGetCode.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCode.defaultExpectation.params)
		}
	}

	return mmGetCode
}

// Inspect accepts an inspector function that has same arguments as the DescriptorsCache.GetCode
func (mmGetCode *mDescriptorsCacheMockGetCode) Inspect(f func(ctx context.Context, ref insolar.Reference)) *mDescriptorsCacheMockGetCode {
	if mmGetCode.mock.inspectFuncGetCode != nil {
		mmGetCode.mock.t.Fatalf("Inspect function is already set for DescriptorsCacheMock.GetCode")
	}

	mmGetCode.mock.inspectFuncGetCode = f

	return mmGetCode
}

// Return sets up results that will be returned by DescriptorsCache.GetCode
func (mmGetCode *mDescriptorsCacheMockGetCode) Return(c2 CodeDescriptor, err error) *DescriptorsCacheMock {
	if mmGetCode.mock.funcGetCode != nil {
		mmGetCode.mock.t.Fatalf("DescriptorsCacheMock.GetCode mock is already set by Set")
	}

	if mmGetCode.defaultExpectation == nil {
		mmGetCode.defaultExpectation = &DescriptorsCacheMockGetCodeExpectation{mock: mmGetCode.mock}
	}
	mmGetCode.defaultExpectation.results = &DescriptorsCacheMockGetCodeResults{c2, err}
	return mmGetCode.mock
}

//Set uses given function f to mock the DescriptorsCache.GetCode method
func (mmGetCode *mDescriptorsCacheMockGetCode) Set(f func(ctx context.Context, ref insolar.Reference) (c2 CodeDescriptor, err error)) *DescriptorsCacheMock {
	if mmGetCode.defaultExpectation != nil {
		mmGetCode.mock.t.Fatalf("Default expectation is already set for the DescriptorsCache.GetCode method")
	}

	if len(mmGetCode.expectations) > 0 {
		mmGetCode.mock.t.Fatalf("Some expectations are already set for the DescriptorsCache.GetCode method")
	}

	mmGetCode.mock.funcGetCode = f
	return mmGetCode.mock
}

// When sets expectation for the DescriptorsCache.GetCode which will trigger the result defined by the following
// Then helper
func (mmGetCode *mDescriptorsCacheMockGetCode) When(ctx context.Context, ref insolar.Reference) *DescriptorsCacheMockGetCodeExpectation {
	if mmGetCode.mock.funcGetCode != nil {
		mmGetCode.mock.t.Fatalf("DescriptorsCacheMock.GetCode mock is already set by Set")
	}

	expectation := &DescriptorsCacheMockGetCodeExpectation{
		mock:   mmGetCode.mock,
		params: &DescriptorsCacheMockGetCodeParams{ctx, ref},
	}
	mmGetCode.expectations = append(mmGetCode.expectations, expectation)
	return expectation
}

// Then sets up DescriptorsCache.GetCode return parameters for the expectation previously defined by the When method
func (e *DescriptorsCacheMockGetCodeExpectation) Then(c2 CodeDescriptor, err error) *DescriptorsCacheMock {
	e.results = &DescriptorsCacheMockGetCodeResults{c2, err}
	return e.mock
}

// GetCode implements DescriptorsCache
func (mmGetCode *DescriptorsCacheMock) GetCode(ctx context.Context, ref insolar.Reference) (c2 CodeDescriptor, err error) {
	mm_atomic.AddUint64(&mmGetCode.beforeGetCodeCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCode.afterGetCodeCounter, 1)

	if mmGetCode.inspectFuncGetCode != nil {
		mmGetCode.inspectFuncGetCode(ctx, ref)
	}

	params := &DescriptorsCacheMockGetCodeParams{ctx, ref}

	// Record call args
	mmGetCode.GetCodeMock.mutex.Lock()
	mmGetCode.GetCodeMock.callArgs = append(mmGetCode.GetCodeMock.callArgs, params)
	mmGetCode.GetCodeMock.mutex.Unlock()

	for _, e := range mmGetCode.GetCodeMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.err
		}
	}

	if mmGetCode.GetCodeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCode.GetCodeMock.defaultExpectation.Counter, 1)
		want := mmGetCode.GetCodeMock.defaultExpectation.params
		got := DescriptorsCacheMockGetCodeParams{ctx, ref}
		if want != nil && !minimock.Equal(*want, got) {
			mmGetCode.t.Errorf("DescriptorsCacheMock.GetCode got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmGetCode.GetCodeMock.defaultExpectation.results
		if results == nil {
			mmGetCode.t.Fatal("No results are set for the DescriptorsCacheMock.GetCode")
		}
		return (*results).c2, (*results).err
	}
	if mmGetCode.funcGetCode != nil {
		return mmGetCode.funcGetCode(ctx, ref)
	}
	mmGetCode.t.Fatalf("Unexpected call to DescriptorsCacheMock.GetCode. %v %v", ctx, ref)
	return
}

// GetCodeAfterCounter returns a count of finished DescriptorsCacheMock.GetCode invocations
func (mmGetCode *DescriptorsCacheMock) GetCodeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCode.afterGetCodeCounter)
}

// GetCodeBeforeCounter returns a count of DescriptorsCacheMock.GetCode invocations
func (mmGetCode *DescriptorsCacheMock) GetCodeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCode.beforeGetCodeCounter)
}

// Calls returns a list of arguments used in each call to DescriptorsCacheMock.GetCode.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCode *mDescriptorsCacheMockGetCode) Calls() []*DescriptorsCacheMockGetCodeParams {
	mmGetCode.mutex.RLock()

	argCopy := make([]*DescriptorsCacheMockGetCodeParams, len(mmGetCode.callArgs))
	copy(argCopy, mmGetCode.callArgs)

	mmGetCode.mutex.RUnlock()

	return argCopy
}

// MinimockGetCodeDone returns true if the count of the GetCode invocations corresponds
// the number of defined expectations
func (m *DescriptorsCacheMock) MinimockGetCodeDone() bool {
	for _, e := range m.GetCodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCodeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCode != nil && mm_atomic.LoadUint64(&m.afterGetCodeCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCodeInspect logs each unmet expectation
func (m *DescriptorsCacheMock) MinimockGetCodeInspect() {
	for _, e := range m.GetCodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DescriptorsCacheMock.GetCode with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCodeCounter) < 1 {
		if m.GetCodeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DescriptorsCacheMock.GetCode")
		} else {
			m.t.Errorf("Expected call to DescriptorsCacheMock.GetCode with params: %#v", *m.GetCodeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCode != nil && mm_atomic.LoadUint64(&m.afterGetCodeCounter) < 1 {
		m.t.Error("Expected call to DescriptorsCacheMock.GetCode")
	}
}

type mDescriptorsCacheMockGetPrototype struct {
	mock               *DescriptorsCacheMock
	defaultExpectation *DescriptorsCacheMockGetPrototypeExpectation
	expectations       []*DescriptorsCacheMockGetPrototypeExpectation

	callArgs []*DescriptorsCacheMockGetPrototypeParams
	mutex    sync.RWMutex
}

// DescriptorsCacheMockGetPrototypeExpectation specifies expectation struct of the DescriptorsCache.GetPrototype
type DescriptorsCacheMockGetPrototypeExpectation struct {
	mock    *DescriptorsCacheMock
	params  *DescriptorsCacheMockGetPrototypeParams
	results *DescriptorsCacheMockGetPrototypeResults
	Counter uint64
}

// DescriptorsCacheMockGetPrototypeParams contains parameters of the DescriptorsCache.GetPrototype
type DescriptorsCacheMockGetPrototypeParams struct {
	ctx context.Context
	ref insolar.Reference
}

// DescriptorsCacheMockGetPrototypeResults contains results of the DescriptorsCache.GetPrototype
type DescriptorsCacheMockGetPrototypeResults struct {
	p1  PrototypeDescriptor
	err error
}

// Expect sets up expected params for DescriptorsCache.GetPrototype
func (mmGetPrototype *mDescriptorsCacheMockGetPrototype) Expect(ctx context.Context, ref insolar.Reference) *mDescriptorsCacheMockGetPrototype {
	if mmGetPrototype.mock.funcGetPrototype != nil {
		mmGetPrototype.mock.t.Fatalf("DescriptorsCacheMock.GetPrototype mock is already set by Set")
	}

	if mmGetPrototype.defaultExpectation == nil {
		mmGetPrototype.defaultExpectation = &DescriptorsCacheMockGetPrototypeExpectation{}
	}

	mmGetPrototype.defaultExpectation.params = &DescriptorsCacheMockGetPrototypeParams{ctx, ref}
	for _, e := range mmGetPrototype.expectations {
		if minimock.Equal(e.params, mmGetPrototype.defaultExpectation.params) {
			mmGetPrototype.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPrototype.defaultExpectation.params)
		}
	}

	return mmGetPrototype
}

// Inspect accepts an inspector function that has same arguments as the DescriptorsCache.GetPrototype
func (mmGetPrototype *mDescriptorsCacheMockGetPrototype) Inspect(f func(ctx context.Context, ref insolar.Reference)) *mDescriptorsCacheMockGetPrototype {
	if mmGetPrototype.mock.inspectFuncGetPrototype != nil {
		mmGetPrototype.mock.t.Fatalf("Inspect function is already set for DescriptorsCacheMock.GetPrototype")
	}

	mmGetPrototype.mock.inspectFuncGetPrototype = f

	return mmGetPrototype
}

// Return sets up results that will be returned by DescriptorsCache.GetPrototype
func (mmGetPrototype *mDescriptorsCacheMockGetPrototype) Return(p1 PrototypeDescriptor, err error) *DescriptorsCacheMock {
	if mmGetPrototype.mock.funcGetPrototype != nil {
		mmGetPrototype.mock.t.Fatalf("DescriptorsCacheMock.GetPrototype mock is already set by Set")
	}

	if mmGetPrototype.defaultExpectation == nil {
		mmGetPrototype.defaultExpectation = &DescriptorsCacheMockGetPrototypeExpectation{mock: mmGetPrototype.mock}
	}
	mmGetPrototype.defaultExpectation.results = &DescriptorsCacheMockGetPrototypeResults{p1, err}
	return mmGetPrototype.mock
}

//Set uses given function f to mock the DescriptorsCache.GetPrototype method
func (mmGetPrototype *mDescriptorsCacheMockGetPrototype) Set(f func(ctx context.Context, ref insolar.Reference) (p1 PrototypeDescriptor, err error)) *DescriptorsCacheMock {
	if mmGetPrototype.defaultExpectation != nil {
		mmGetPrototype.mock.t.Fatalf("Default expectation is already set for the DescriptorsCache.GetPrototype method")
	}

	if len(mmGetPrototype.expectations) > 0 {
		mmGetPrototype.mock.t.Fatalf("Some expectations are already set for the DescriptorsCache.GetPrototype method")
	}

	mmGetPrototype.mock.funcGetPrototype = f
	return mmGetPrototype.mock
}

// When sets expectation for the DescriptorsCache.GetPrototype which will trigger the result defined by the following
// Then helper
func (mmGetPrototype *mDescriptorsCacheMockGetPrototype) When(ctx context.Context, ref insolar.Reference) *DescriptorsCacheMockGetPrototypeExpectation {
	if mmGetPrototype.mock.funcGetPrototype != nil {
		mmGetPrototype.mock.t.Fatalf("DescriptorsCacheMock.GetPrototype mock is already set by Set")
	}

	expectation := &DescriptorsCacheMockGetPrototypeExpectation{
		mock:   mmGetPrototype.mock,
		params: &DescriptorsCacheMockGetPrototypeParams{ctx, ref},
	}
	mmGetPrototype.expectations = append(mmGetPrototype.expectations, expectation)
	return expectation
}

// Then sets up DescriptorsCache.GetPrototype return parameters for the expectation previously defined by the When method
func (e *DescriptorsCacheMockGetPrototypeExpectation) Then(p1 PrototypeDescriptor, err error) *DescriptorsCacheMock {
	e.results = &DescriptorsCacheMockGetPrototypeResults{p1, err}
	return e.mock
}

// GetPrototype implements DescriptorsCache
func (mmGetPrototype *DescriptorsCacheMock) GetPrototype(ctx context.Context, ref insolar.Reference) (p1 PrototypeDescriptor, err error) {
	mm_atomic.AddUint64(&mmGetPrototype.beforeGetPrototypeCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPrototype.afterGetPrototypeCounter, 1)

	if mmGetPrototype.inspectFuncGetPrototype != nil {
		mmGetPrototype.inspectFuncGetPrototype(ctx, ref)
	}

	params := &DescriptorsCacheMockGetPrototypeParams{ctx, ref}

	// Record call args
	mmGetPrototype.GetPrototypeMock.mutex.Lock()
	mmGetPrototype.GetPrototypeMock.callArgs = append(mmGetPrototype.GetPrototypeMock.callArgs, params)
	mmGetPrototype.GetPrototypeMock.mutex.Unlock()

	for _, e := range mmGetPrototype.GetPrototypeMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmGetPrototype.GetPrototypeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPrototype.GetPrototypeMock.defaultExpectation.Counter, 1)
		want := mmGetPrototype.GetPrototypeMock.defaultExpectation.params
		got := DescriptorsCacheMockGetPrototypeParams{ctx, ref}
		if want != nil && !minimock.Equal(*want, got) {
			mmGetPrototype.t.Errorf("DescriptorsCacheMock.GetPrototype got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmGetPrototype.GetPrototypeMock.defaultExpectation.results
		if results == nil {
			mmGetPrototype.t.Fatal("No results are set for the DescriptorsCacheMock.GetPrototype")
		}
		return (*results).p1, (*results).err
	}
	if mmGetPrototype.funcGetPrototype != nil {
		return mmGetPrototype.funcGetPrototype(ctx, ref)
	}
	mmGetPrototype.t.Fatalf("Unexpected call to DescriptorsCacheMock.GetPrototype. %v %v", ctx, ref)
	return
}

// GetPrototypeAfterCounter returns a count of finished DescriptorsCacheMock.GetPrototype invocations
func (mmGetPrototype *DescriptorsCacheMock) GetPrototypeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPrototype.afterGetPrototypeCounter)
}

// GetPrototypeBeforeCounter returns a count of DescriptorsCacheMock.GetPrototype invocations
func (mmGetPrototype *DescriptorsCacheMock) GetPrototypeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPrototype.beforeGetPrototypeCounter)
}

// Calls returns a list of arguments used in each call to DescriptorsCacheMock.GetPrototype.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPrototype *mDescriptorsCacheMockGetPrototype) Calls() []*DescriptorsCacheMockGetPrototypeParams {
	mmGetPrototype.mutex.RLock()

	argCopy := make([]*DescriptorsCacheMockGetPrototypeParams, len(mmGetPrototype.callArgs))
	copy(argCopy, mmGetPrototype.callArgs)

	mmGetPrototype.mutex.RUnlock()

	return argCopy
}

// MinimockGetPrototypeDone returns true if the count of the GetPrototype invocations corresponds
// the number of defined expectations
func (m *DescriptorsCacheMock) MinimockGetPrototypeDone() bool {
	for _, e := range m.GetPrototypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPrototypeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPrototypeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPrototype != nil && mm_atomic.LoadUint64(&m.afterGetPrototypeCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPrototypeInspect logs each unmet expectation
func (m *DescriptorsCacheMock) MinimockGetPrototypeInspect() {
	for _, e := range m.GetPrototypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DescriptorsCacheMock.GetPrototype with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPrototypeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPrototypeCounter) < 1 {
		if m.GetPrototypeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DescriptorsCacheMock.GetPrototype")
		} else {
			m.t.Errorf("Expected call to DescriptorsCacheMock.GetPrototype with params: %#v", *m.GetPrototypeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPrototype != nil && mm_atomic.LoadUint64(&m.afterGetPrototypeCounter) < 1 {
		m.t.Error("Expected call to DescriptorsCacheMock.GetPrototype")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *DescriptorsCacheMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockByObjectDescriptorInspect()

		m.MinimockByPrototypeRefInspect()

		m.MinimockGetCodeInspect()

		m.MinimockGetPrototypeInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *DescriptorsCacheMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *DescriptorsCacheMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockByObjectDescriptorDone() &&
		m.MinimockByPrototypeRefDone() &&
		m.MinimockGetCodeDone() &&
		m.MinimockGetPrototypeDone()
}
