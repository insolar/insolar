package artifacts

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/insolar"
	"github.com/insolar/insolar/insolar/payload"
	"github.com/insolar/insolar/insolar/record"
)

// ClientMock implements Client
type ClientMock struct {
	t minimock.Tester

	funcActivatePrototype          func(ctx context.Context, request insolar.Reference, parent insolar.Reference, code insolar.Reference, memory []byte) (err error)
	inspectFuncActivatePrototype   func(ctx context.Context, request insolar.Reference, parent insolar.Reference, code insolar.Reference, memory []byte)
	afterActivatePrototypeCounter  uint64
	beforeActivatePrototypeCounter uint64
	ActivatePrototypeMock          mClientMockActivatePrototype

	funcDeployCode          func(ctx context.Context, code []byte, machineType insolar.MachineType) (ip1 *insolar.ID, err error)
	inspectFuncDeployCode   func(ctx context.Context, code []byte, machineType insolar.MachineType)
	afterDeployCodeCounter  uint64
	beforeDeployCodeCounter uint64
	DeployCodeMock          mClientMockDeployCode

	funcGetCode          func(ctx context.Context, ref insolar.Reference) (c2 CodeDescriptor, err error)
	inspectFuncGetCode   func(ctx context.Context, ref insolar.Reference)
	afterGetCodeCounter  uint64
	beforeGetCodeCounter uint64
	GetCodeMock          mClientMockGetCode

	funcGetObject          func(ctx context.Context, head insolar.Reference, request *insolar.Reference) (o1 ObjectDescriptor, err error)
	inspectFuncGetObject   func(ctx context.Context, head insolar.Reference, request *insolar.Reference)
	afterGetObjectCounter  uint64
	beforeGetObjectCounter uint64
	GetObjectMock          mClientMockGetObject

	funcGetPendings          func(ctx context.Context, objectRef insolar.Reference, skip []insolar.ID) (ra1 []insolar.Reference, err error)
	inspectFuncGetPendings   func(ctx context.Context, objectRef insolar.Reference, skip []insolar.ID)
	afterGetPendingsCounter  uint64
	beforeGetPendingsCounter uint64
	GetPendingsMock          mClientMockGetPendings

	funcGetPrototype          func(ctx context.Context, head insolar.Reference) (p1 PrototypeDescriptor, err error)
	inspectFuncGetPrototype   func(ctx context.Context, head insolar.Reference)
	afterGetPrototypeCounter  uint64
	beforeGetPrototypeCounter uint64
	GetPrototypeMock          mClientMockGetPrototype

	funcGetRequest          func(ctx context.Context, objectRef insolar.Reference, reqRef insolar.Reference) (r1 record.Request, err error)
	inspectFuncGetRequest   func(ctx context.Context, objectRef insolar.Reference, reqRef insolar.Reference)
	afterGetRequestCounter  uint64
	beforeGetRequestCounter uint64
	GetRequestMock          mClientMockGetRequest

	funcHasPendings          func(ctx context.Context, object insolar.Reference) (b1 bool, err error)
	inspectFuncHasPendings   func(ctx context.Context, object insolar.Reference)
	afterHasPendingsCounter  uint64
	beforeHasPendingsCounter uint64
	HasPendingsMock          mClientMockHasPendings

	funcInjectCodeDescriptor          func(r1 insolar.Reference, c1 CodeDescriptor)
	inspectFuncInjectCodeDescriptor   func(r1 insolar.Reference, c1 CodeDescriptor)
	afterInjectCodeDescriptorCounter  uint64
	beforeInjectCodeDescriptorCounter uint64
	InjectCodeDescriptorMock          mClientMockInjectCodeDescriptor

	funcInjectFinish          func()
	inspectFuncInjectFinish   func()
	afterInjectFinishCounter  uint64
	beforeInjectFinishCounter uint64
	InjectFinishMock          mClientMockInjectFinish

	funcInjectPrototypeDescriptor          func(r1 insolar.Reference, p1 PrototypeDescriptor)
	inspectFuncInjectPrototypeDescriptor   func(r1 insolar.Reference, p1 PrototypeDescriptor)
	afterInjectPrototypeDescriptorCounter  uint64
	beforeInjectPrototypeDescriptorCounter uint64
	InjectPrototypeDescriptorMock          mClientMockInjectPrototypeDescriptor

	funcRegisterIncomingRequest          func(ctx context.Context, request *record.IncomingRequest) (rp1 *payload.RequestInfo, err error)
	inspectFuncRegisterIncomingRequest   func(ctx context.Context, request *record.IncomingRequest)
	afterRegisterIncomingRequestCounter  uint64
	beforeRegisterIncomingRequestCounter uint64
	RegisterIncomingRequestMock          mClientMockRegisterIncomingRequest

	funcRegisterOutgoingRequest          func(ctx context.Context, request *record.OutgoingRequest) (rp1 *payload.RequestInfo, err error)
	inspectFuncRegisterOutgoingRequest   func(ctx context.Context, request *record.OutgoingRequest)
	afterRegisterOutgoingRequestCounter  uint64
	beforeRegisterOutgoingRequestCounter uint64
	RegisterOutgoingRequestMock          mClientMockRegisterOutgoingRequest

	funcRegisterResult          func(ctx context.Context, request insolar.Reference, result RequestResult) (err error)
	inspectFuncRegisterResult   func(ctx context.Context, request insolar.Reference, result RequestResult)
	afterRegisterResultCounter  uint64
	beforeRegisterResultCounter uint64
	RegisterResultMock          mClientMockRegisterResult
}

// NewClientMock returns a mock for Client
func NewClientMock(t minimock.Tester) *ClientMock {
	m := &ClientMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ActivatePrototypeMock = mClientMockActivatePrototype{mock: m}
	m.ActivatePrototypeMock.callArgs = []*ClientMockActivatePrototypeParams{}

	m.DeployCodeMock = mClientMockDeployCode{mock: m}
	m.DeployCodeMock.callArgs = []*ClientMockDeployCodeParams{}

	m.GetCodeMock = mClientMockGetCode{mock: m}
	m.GetCodeMock.callArgs = []*ClientMockGetCodeParams{}

	m.GetObjectMock = mClientMockGetObject{mock: m}
	m.GetObjectMock.callArgs = []*ClientMockGetObjectParams{}

	m.GetPendingsMock = mClientMockGetPendings{mock: m}
	m.GetPendingsMock.callArgs = []*ClientMockGetPendingsParams{}

	m.GetPrototypeMock = mClientMockGetPrototype{mock: m}
	m.GetPrototypeMock.callArgs = []*ClientMockGetPrototypeParams{}

	m.GetRequestMock = mClientMockGetRequest{mock: m}
	m.GetRequestMock.callArgs = []*ClientMockGetRequestParams{}

	m.HasPendingsMock = mClientMockHasPendings{mock: m}
	m.HasPendingsMock.callArgs = []*ClientMockHasPendingsParams{}

	m.InjectCodeDescriptorMock = mClientMockInjectCodeDescriptor{mock: m}
	m.InjectCodeDescriptorMock.callArgs = []*ClientMockInjectCodeDescriptorParams{}

	m.InjectFinishMock = mClientMockInjectFinish{mock: m}

	m.InjectPrototypeDescriptorMock = mClientMockInjectPrototypeDescriptor{mock: m}
	m.InjectPrototypeDescriptorMock.callArgs = []*ClientMockInjectPrototypeDescriptorParams{}

	m.RegisterIncomingRequestMock = mClientMockRegisterIncomingRequest{mock: m}
	m.RegisterIncomingRequestMock.callArgs = []*ClientMockRegisterIncomingRequestParams{}

	m.RegisterOutgoingRequestMock = mClientMockRegisterOutgoingRequest{mock: m}
	m.RegisterOutgoingRequestMock.callArgs = []*ClientMockRegisterOutgoingRequestParams{}

	m.RegisterResultMock = mClientMockRegisterResult{mock: m}
	m.RegisterResultMock.callArgs = []*ClientMockRegisterResultParams{}

	return m
}

type mClientMockActivatePrototype struct {
	mock               *ClientMock
	defaultExpectation *ClientMockActivatePrototypeExpectation
	expectations       []*ClientMockActivatePrototypeExpectation

	callArgs []*ClientMockActivatePrototypeParams
	mutex    sync.RWMutex
}

// ClientMockActivatePrototypeExpectation specifies expectation struct of the Client.ActivatePrototype
type ClientMockActivatePrototypeExpectation struct {
	mock    *ClientMock
	params  *ClientMockActivatePrototypeParams
	results *ClientMockActivatePrototypeResults
	Counter uint64
}

// ClientMockActivatePrototypeParams contains parameters of the Client.ActivatePrototype
type ClientMockActivatePrototypeParams struct {
	ctx     context.Context
	request insolar.Reference
	parent  insolar.Reference
	code    insolar.Reference
	memory  []byte
}

// ClientMockActivatePrototypeResults contains results of the Client.ActivatePrototype
type ClientMockActivatePrototypeResults struct {
	err error
}

// Expect sets up expected params for Client.ActivatePrototype
func (mmActivatePrototype *mClientMockActivatePrototype) Expect(ctx context.Context, request insolar.Reference, parent insolar.Reference, code insolar.Reference, memory []byte) *mClientMockActivatePrototype {
	if mmActivatePrototype.mock.funcActivatePrototype != nil {
		mmActivatePrototype.mock.t.Fatalf("ClientMock.ActivatePrototype mock is already set by Set")
	}

	if mmActivatePrototype.defaultExpectation == nil {
		mmActivatePrototype.defaultExpectation = &ClientMockActivatePrototypeExpectation{}
	}

	mmActivatePrototype.defaultExpectation.params = &ClientMockActivatePrototypeParams{ctx, request, parent, code, memory}
	for _, e := range mmActivatePrototype.expectations {
		if minimock.Equal(e.params, mmActivatePrototype.defaultExpectation.params) {
			mmActivatePrototype.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmActivatePrototype.defaultExpectation.params)
		}
	}

	return mmActivatePrototype
}

// Inspect accepts an inspector function that has same arguments as the Client.ActivatePrototype
func (mmActivatePrototype *mClientMockActivatePrototype) Inspect(f func(ctx context.Context, request insolar.Reference, parent insolar.Reference, code insolar.Reference, memory []byte)) *mClientMockActivatePrototype {
	if mmActivatePrototype.mock.inspectFuncActivatePrototype != nil {
		mmActivatePrototype.mock.t.Fatalf("Inspect function is already set for ClientMock.ActivatePrototype")
	}

	mmActivatePrototype.mock.inspectFuncActivatePrototype = f

	return mmActivatePrototype
}

// Return sets up results that will be returned by Client.ActivatePrototype
func (mmActivatePrototype *mClientMockActivatePrototype) Return(err error) *ClientMock {
	if mmActivatePrototype.mock.funcActivatePrototype != nil {
		mmActivatePrototype.mock.t.Fatalf("ClientMock.ActivatePrototype mock is already set by Set")
	}

	if mmActivatePrototype.defaultExpectation == nil {
		mmActivatePrototype.defaultExpectation = &ClientMockActivatePrototypeExpectation{mock: mmActivatePrototype.mock}
	}
	mmActivatePrototype.defaultExpectation.results = &ClientMockActivatePrototypeResults{err}
	return mmActivatePrototype.mock
}

//Set uses given function f to mock the Client.ActivatePrototype method
func (mmActivatePrototype *mClientMockActivatePrototype) Set(f func(ctx context.Context, request insolar.Reference, parent insolar.Reference, code insolar.Reference, memory []byte) (err error)) *ClientMock {
	if mmActivatePrototype.defaultExpectation != nil {
		mmActivatePrototype.mock.t.Fatalf("Default expectation is already set for the Client.ActivatePrototype method")
	}

	if len(mmActivatePrototype.expectations) > 0 {
		mmActivatePrototype.mock.t.Fatalf("Some expectations are already set for the Client.ActivatePrototype method")
	}

	mmActivatePrototype.mock.funcActivatePrototype = f
	return mmActivatePrototype.mock
}

// When sets expectation for the Client.ActivatePrototype which will trigger the result defined by the following
// Then helper
func (mmActivatePrototype *mClientMockActivatePrototype) When(ctx context.Context, request insolar.Reference, parent insolar.Reference, code insolar.Reference, memory []byte) *ClientMockActivatePrototypeExpectation {
	if mmActivatePrototype.mock.funcActivatePrototype != nil {
		mmActivatePrototype.mock.t.Fatalf("ClientMock.ActivatePrototype mock is already set by Set")
	}

	expectation := &ClientMockActivatePrototypeExpectation{
		mock:   mmActivatePrototype.mock,
		params: &ClientMockActivatePrototypeParams{ctx, request, parent, code, memory},
	}
	mmActivatePrototype.expectations = append(mmActivatePrototype.expectations, expectation)
	return expectation
}

// Then sets up Client.ActivatePrototype return parameters for the expectation previously defined by the When method
func (e *ClientMockActivatePrototypeExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockActivatePrototypeResults{err}
	return e.mock
}

// ActivatePrototype implements Client
func (mmActivatePrototype *ClientMock) ActivatePrototype(ctx context.Context, request insolar.Reference, parent insolar.Reference, code insolar.Reference, memory []byte) (err error) {
	mm_atomic.AddUint64(&mmActivatePrototype.beforeActivatePrototypeCounter, 1)
	defer mm_atomic.AddUint64(&mmActivatePrototype.afterActivatePrototypeCounter, 1)

	if mmActivatePrototype.inspectFuncActivatePrototype != nil {
		mmActivatePrototype.inspectFuncActivatePrototype(ctx, request, parent, code, memory)
	}

	params := &ClientMockActivatePrototypeParams{ctx, request, parent, code, memory}

	// Record call args
	mmActivatePrototype.ActivatePrototypeMock.mutex.Lock()
	mmActivatePrototype.ActivatePrototypeMock.callArgs = append(mmActivatePrototype.ActivatePrototypeMock.callArgs, params)
	mmActivatePrototype.ActivatePrototypeMock.mutex.Unlock()

	for _, e := range mmActivatePrototype.ActivatePrototypeMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmActivatePrototype.ActivatePrototypeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmActivatePrototype.ActivatePrototypeMock.defaultExpectation.Counter, 1)
		want := mmActivatePrototype.ActivatePrototypeMock.defaultExpectation.params
		got := ClientMockActivatePrototypeParams{ctx, request, parent, code, memory}
		if want != nil && !minimock.Equal(*want, got) {
			mmActivatePrototype.t.Errorf("ClientMock.ActivatePrototype got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmActivatePrototype.ActivatePrototypeMock.defaultExpectation.results
		if results == nil {
			mmActivatePrototype.t.Fatal("No results are set for the ClientMock.ActivatePrototype")
		}
		return (*results).err
	}
	if mmActivatePrototype.funcActivatePrototype != nil {
		return mmActivatePrototype.funcActivatePrototype(ctx, request, parent, code, memory)
	}
	mmActivatePrototype.t.Fatalf("Unexpected call to ClientMock.ActivatePrototype. %v %v %v %v %v", ctx, request, parent, code, memory)
	return
}

// ActivatePrototypeAfterCounter returns a count of finished ClientMock.ActivatePrototype invocations
func (mmActivatePrototype *ClientMock) ActivatePrototypeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmActivatePrototype.afterActivatePrototypeCounter)
}

// ActivatePrototypeBeforeCounter returns a count of ClientMock.ActivatePrototype invocations
func (mmActivatePrototype *ClientMock) ActivatePrototypeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmActivatePrototype.beforeActivatePrototypeCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.ActivatePrototype.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmActivatePrototype *mClientMockActivatePrototype) Calls() []*ClientMockActivatePrototypeParams {
	mmActivatePrototype.mutex.RLock()

	argCopy := make([]*ClientMockActivatePrototypeParams, len(mmActivatePrototype.callArgs))
	copy(argCopy, mmActivatePrototype.callArgs)

	mmActivatePrototype.mutex.RUnlock()

	return argCopy
}

// MinimockActivatePrototypeDone returns true if the count of the ActivatePrototype invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockActivatePrototypeDone() bool {
	for _, e := range m.ActivatePrototypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ActivatePrototypeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterActivatePrototypeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcActivatePrototype != nil && mm_atomic.LoadUint64(&m.afterActivatePrototypeCounter) < 1 {
		return false
	}
	return true
}

// MinimockActivatePrototypeInspect logs each unmet expectation
func (m *ClientMock) MinimockActivatePrototypeInspect() {
	for _, e := range m.ActivatePrototypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.ActivatePrototype with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ActivatePrototypeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterActivatePrototypeCounter) < 1 {
		if m.ActivatePrototypeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.ActivatePrototype")
		} else {
			m.t.Errorf("Expected call to ClientMock.ActivatePrototype with params: %#v", *m.ActivatePrototypeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcActivatePrototype != nil && mm_atomic.LoadUint64(&m.afterActivatePrototypeCounter) < 1 {
		m.t.Error("Expected call to ClientMock.ActivatePrototype")
	}
}

type mClientMockDeployCode struct {
	mock               *ClientMock
	defaultExpectation *ClientMockDeployCodeExpectation
	expectations       []*ClientMockDeployCodeExpectation

	callArgs []*ClientMockDeployCodeParams
	mutex    sync.RWMutex
}

// ClientMockDeployCodeExpectation specifies expectation struct of the Client.DeployCode
type ClientMockDeployCodeExpectation struct {
	mock    *ClientMock
	params  *ClientMockDeployCodeParams
	results *ClientMockDeployCodeResults
	Counter uint64
}

// ClientMockDeployCodeParams contains parameters of the Client.DeployCode
type ClientMockDeployCodeParams struct {
	ctx         context.Context
	code        []byte
	machineType insolar.MachineType
}

// ClientMockDeployCodeResults contains results of the Client.DeployCode
type ClientMockDeployCodeResults struct {
	ip1 *insolar.ID
	err error
}

// Expect sets up expected params for Client.DeployCode
func (mmDeployCode *mClientMockDeployCode) Expect(ctx context.Context, code []byte, machineType insolar.MachineType) *mClientMockDeployCode {
	if mmDeployCode.mock.funcDeployCode != nil {
		mmDeployCode.mock.t.Fatalf("ClientMock.DeployCode mock is already set by Set")
	}

	if mmDeployCode.defaultExpectation == nil {
		mmDeployCode.defaultExpectation = &ClientMockDeployCodeExpectation{}
	}

	mmDeployCode.defaultExpectation.params = &ClientMockDeployCodeParams{ctx, code, machineType}
	for _, e := range mmDeployCode.expectations {
		if minimock.Equal(e.params, mmDeployCode.defaultExpectation.params) {
			mmDeployCode.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeployCode.defaultExpectation.params)
		}
	}

	return mmDeployCode
}

// Inspect accepts an inspector function that has same arguments as the Client.DeployCode
func (mmDeployCode *mClientMockDeployCode) Inspect(f func(ctx context.Context, code []byte, machineType insolar.MachineType)) *mClientMockDeployCode {
	if mmDeployCode.mock.inspectFuncDeployCode != nil {
		mmDeployCode.mock.t.Fatalf("Inspect function is already set for ClientMock.DeployCode")
	}

	mmDeployCode.mock.inspectFuncDeployCode = f

	return mmDeployCode
}

// Return sets up results that will be returned by Client.DeployCode
func (mmDeployCode *mClientMockDeployCode) Return(ip1 *insolar.ID, err error) *ClientMock {
	if mmDeployCode.mock.funcDeployCode != nil {
		mmDeployCode.mock.t.Fatalf("ClientMock.DeployCode mock is already set by Set")
	}

	if mmDeployCode.defaultExpectation == nil {
		mmDeployCode.defaultExpectation = &ClientMockDeployCodeExpectation{mock: mmDeployCode.mock}
	}
	mmDeployCode.defaultExpectation.results = &ClientMockDeployCodeResults{ip1, err}
	return mmDeployCode.mock
}

//Set uses given function f to mock the Client.DeployCode method
func (mmDeployCode *mClientMockDeployCode) Set(f func(ctx context.Context, code []byte, machineType insolar.MachineType) (ip1 *insolar.ID, err error)) *ClientMock {
	if mmDeployCode.defaultExpectation != nil {
		mmDeployCode.mock.t.Fatalf("Default expectation is already set for the Client.DeployCode method")
	}

	if len(mmDeployCode.expectations) > 0 {
		mmDeployCode.mock.t.Fatalf("Some expectations are already set for the Client.DeployCode method")
	}

	mmDeployCode.mock.funcDeployCode = f
	return mmDeployCode.mock
}

// When sets expectation for the Client.DeployCode which will trigger the result defined by the following
// Then helper
func (mmDeployCode *mClientMockDeployCode) When(ctx context.Context, code []byte, machineType insolar.MachineType) *ClientMockDeployCodeExpectation {
	if mmDeployCode.mock.funcDeployCode != nil {
		mmDeployCode.mock.t.Fatalf("ClientMock.DeployCode mock is already set by Set")
	}

	expectation := &ClientMockDeployCodeExpectation{
		mock:   mmDeployCode.mock,
		params: &ClientMockDeployCodeParams{ctx, code, machineType},
	}
	mmDeployCode.expectations = append(mmDeployCode.expectations, expectation)
	return expectation
}

// Then sets up Client.DeployCode return parameters for the expectation previously defined by the When method
func (e *ClientMockDeployCodeExpectation) Then(ip1 *insolar.ID, err error) *ClientMock {
	e.results = &ClientMockDeployCodeResults{ip1, err}
	return e.mock
}

// DeployCode implements Client
func (mmDeployCode *ClientMock) DeployCode(ctx context.Context, code []byte, machineType insolar.MachineType) (ip1 *insolar.ID, err error) {
	mm_atomic.AddUint64(&mmDeployCode.beforeDeployCodeCounter, 1)
	defer mm_atomic.AddUint64(&mmDeployCode.afterDeployCodeCounter, 1)

	if mmDeployCode.inspectFuncDeployCode != nil {
		mmDeployCode.inspectFuncDeployCode(ctx, code, machineType)
	}

	params := &ClientMockDeployCodeParams{ctx, code, machineType}

	// Record call args
	mmDeployCode.DeployCodeMock.mutex.Lock()
	mmDeployCode.DeployCodeMock.callArgs = append(mmDeployCode.DeployCodeMock.callArgs, params)
	mmDeployCode.DeployCodeMock.mutex.Unlock()

	for _, e := range mmDeployCode.DeployCodeMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ip1, e.results.err
		}
	}

	if mmDeployCode.DeployCodeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeployCode.DeployCodeMock.defaultExpectation.Counter, 1)
		want := mmDeployCode.DeployCodeMock.defaultExpectation.params
		got := ClientMockDeployCodeParams{ctx, code, machineType}
		if want != nil && !minimock.Equal(*want, got) {
			mmDeployCode.t.Errorf("ClientMock.DeployCode got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmDeployCode.DeployCodeMock.defaultExpectation.results
		if results == nil {
			mmDeployCode.t.Fatal("No results are set for the ClientMock.DeployCode")
		}
		return (*results).ip1, (*results).err
	}
	if mmDeployCode.funcDeployCode != nil {
		return mmDeployCode.funcDeployCode(ctx, code, machineType)
	}
	mmDeployCode.t.Fatalf("Unexpected call to ClientMock.DeployCode. %v %v %v", ctx, code, machineType)
	return
}

// DeployCodeAfterCounter returns a count of finished ClientMock.DeployCode invocations
func (mmDeployCode *ClientMock) DeployCodeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeployCode.afterDeployCodeCounter)
}

// DeployCodeBeforeCounter returns a count of ClientMock.DeployCode invocations
func (mmDeployCode *ClientMock) DeployCodeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeployCode.beforeDeployCodeCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.DeployCode.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeployCode *mClientMockDeployCode) Calls() []*ClientMockDeployCodeParams {
	mmDeployCode.mutex.RLock()

	argCopy := make([]*ClientMockDeployCodeParams, len(mmDeployCode.callArgs))
	copy(argCopy, mmDeployCode.callArgs)

	mmDeployCode.mutex.RUnlock()

	return argCopy
}

// MinimockDeployCodeDone returns true if the count of the DeployCode invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockDeployCodeDone() bool {
	for _, e := range m.DeployCodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeployCodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeployCodeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeployCode != nil && mm_atomic.LoadUint64(&m.afterDeployCodeCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeployCodeInspect logs each unmet expectation
func (m *ClientMock) MinimockDeployCodeInspect() {
	for _, e := range m.DeployCodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.DeployCode with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeployCodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeployCodeCounter) < 1 {
		if m.DeployCodeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.DeployCode")
		} else {
			m.t.Errorf("Expected call to ClientMock.DeployCode with params: %#v", *m.DeployCodeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeployCode != nil && mm_atomic.LoadUint64(&m.afterDeployCodeCounter) < 1 {
		m.t.Error("Expected call to ClientMock.DeployCode")
	}
}

type mClientMockGetCode struct {
	mock               *ClientMock
	defaultExpectation *ClientMockGetCodeExpectation
	expectations       []*ClientMockGetCodeExpectation

	callArgs []*ClientMockGetCodeParams
	mutex    sync.RWMutex
}

// ClientMockGetCodeExpectation specifies expectation struct of the Client.GetCode
type ClientMockGetCodeExpectation struct {
	mock    *ClientMock
	params  *ClientMockGetCodeParams
	results *ClientMockGetCodeResults
	Counter uint64
}

// ClientMockGetCodeParams contains parameters of the Client.GetCode
type ClientMockGetCodeParams struct {
	ctx context.Context
	ref insolar.Reference
}

// ClientMockGetCodeResults contains results of the Client.GetCode
type ClientMockGetCodeResults struct {
	c2  CodeDescriptor
	err error
}

// Expect sets up expected params for Client.GetCode
func (mmGetCode *mClientMockGetCode) Expect(ctx context.Context, ref insolar.Reference) *mClientMockGetCode {
	if mmGetCode.mock.funcGetCode != nil {
		mmGetCode.mock.t.Fatalf("ClientMock.GetCode mock is already set by Set")
	}

	if mmGetCode.defaultExpectation == nil {
		mmGetCode.defaultExpectation = &ClientMockGetCodeExpectation{}
	}

	mmGetCode.defaultExpectation.params = &ClientMockGetCodeParams{ctx, ref}
	for _, e := range mmGetCode.expectations {
		if minimock.Equal(e.params, mmGetCode.defaultExpectation.params) {
			mmGetCode.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCode.defaultExpectation.params)
		}
	}

	return mmGetCode
}

// Inspect accepts an inspector function that has same arguments as the Client.GetCode
func (mmGetCode *mClientMockGetCode) Inspect(f func(ctx context.Context, ref insolar.Reference)) *mClientMockGetCode {
	if mmGetCode.mock.inspectFuncGetCode != nil {
		mmGetCode.mock.t.Fatalf("Inspect function is already set for ClientMock.GetCode")
	}

	mmGetCode.mock.inspectFuncGetCode = f

	return mmGetCode
}

// Return sets up results that will be returned by Client.GetCode
func (mmGetCode *mClientMockGetCode) Return(c2 CodeDescriptor, err error) *ClientMock {
	if mmGetCode.mock.funcGetCode != nil {
		mmGetCode.mock.t.Fatalf("ClientMock.GetCode mock is already set by Set")
	}

	if mmGetCode.defaultExpectation == nil {
		mmGetCode.defaultExpectation = &ClientMockGetCodeExpectation{mock: mmGetCode.mock}
	}
	mmGetCode.defaultExpectation.results = &ClientMockGetCodeResults{c2, err}
	return mmGetCode.mock
}

//Set uses given function f to mock the Client.GetCode method
func (mmGetCode *mClientMockGetCode) Set(f func(ctx context.Context, ref insolar.Reference) (c2 CodeDescriptor, err error)) *ClientMock {
	if mmGetCode.defaultExpectation != nil {
		mmGetCode.mock.t.Fatalf("Default expectation is already set for the Client.GetCode method")
	}

	if len(mmGetCode.expectations) > 0 {
		mmGetCode.mock.t.Fatalf("Some expectations are already set for the Client.GetCode method")
	}

	mmGetCode.mock.funcGetCode = f
	return mmGetCode.mock
}

// When sets expectation for the Client.GetCode which will trigger the result defined by the following
// Then helper
func (mmGetCode *mClientMockGetCode) When(ctx context.Context, ref insolar.Reference) *ClientMockGetCodeExpectation {
	if mmGetCode.mock.funcGetCode != nil {
		mmGetCode.mock.t.Fatalf("ClientMock.GetCode mock is already set by Set")
	}

	expectation := &ClientMockGetCodeExpectation{
		mock:   mmGetCode.mock,
		params: &ClientMockGetCodeParams{ctx, ref},
	}
	mmGetCode.expectations = append(mmGetCode.expectations, expectation)
	return expectation
}

// Then sets up Client.GetCode return parameters for the expectation previously defined by the When method
func (e *ClientMockGetCodeExpectation) Then(c2 CodeDescriptor, err error) *ClientMock {
	e.results = &ClientMockGetCodeResults{c2, err}
	return e.mock
}

// GetCode implements Client
func (mmGetCode *ClientMock) GetCode(ctx context.Context, ref insolar.Reference) (c2 CodeDescriptor, err error) {
	mm_atomic.AddUint64(&mmGetCode.beforeGetCodeCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCode.afterGetCodeCounter, 1)

	if mmGetCode.inspectFuncGetCode != nil {
		mmGetCode.inspectFuncGetCode(ctx, ref)
	}

	params := &ClientMockGetCodeParams{ctx, ref}

	// Record call args
	mmGetCode.GetCodeMock.mutex.Lock()
	mmGetCode.GetCodeMock.callArgs = append(mmGetCode.GetCodeMock.callArgs, params)
	mmGetCode.GetCodeMock.mutex.Unlock()

	for _, e := range mmGetCode.GetCodeMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.err
		}
	}

	if mmGetCode.GetCodeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCode.GetCodeMock.defaultExpectation.Counter, 1)
		want := mmGetCode.GetCodeMock.defaultExpectation.params
		got := ClientMockGetCodeParams{ctx, ref}
		if want != nil && !minimock.Equal(*want, got) {
			mmGetCode.t.Errorf("ClientMock.GetCode got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmGetCode.GetCodeMock.defaultExpectation.results
		if results == nil {
			mmGetCode.t.Fatal("No results are set for the ClientMock.GetCode")
		}
		return (*results).c2, (*results).err
	}
	if mmGetCode.funcGetCode != nil {
		return mmGetCode.funcGetCode(ctx, ref)
	}
	mmGetCode.t.Fatalf("Unexpected call to ClientMock.GetCode. %v %v", ctx, ref)
	return
}

// GetCodeAfterCounter returns a count of finished ClientMock.GetCode invocations
func (mmGetCode *ClientMock) GetCodeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCode.afterGetCodeCounter)
}

// GetCodeBeforeCounter returns a count of ClientMock.GetCode invocations
func (mmGetCode *ClientMock) GetCodeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCode.beforeGetCodeCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetCode.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCode *mClientMockGetCode) Calls() []*ClientMockGetCodeParams {
	mmGetCode.mutex.RLock()

	argCopy := make([]*ClientMockGetCodeParams, len(mmGetCode.callArgs))
	copy(argCopy, mmGetCode.callArgs)

	mmGetCode.mutex.RUnlock()

	return argCopy
}

// MinimockGetCodeDone returns true if the count of the GetCode invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetCodeDone() bool {
	for _, e := range m.GetCodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCodeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCode != nil && mm_atomic.LoadUint64(&m.afterGetCodeCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCodeInspect logs each unmet expectation
func (m *ClientMock) MinimockGetCodeInspect() {
	for _, e := range m.GetCodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetCode with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCodeCounter) < 1 {
		if m.GetCodeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetCode")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetCode with params: %#v", *m.GetCodeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCode != nil && mm_atomic.LoadUint64(&m.afterGetCodeCounter) < 1 {
		m.t.Error("Expected call to ClientMock.GetCode")
	}
}

type mClientMockGetObject struct {
	mock               *ClientMock
	defaultExpectation *ClientMockGetObjectExpectation
	expectations       []*ClientMockGetObjectExpectation

	callArgs []*ClientMockGetObjectParams
	mutex    sync.RWMutex
}

// ClientMockGetObjectExpectation specifies expectation struct of the Client.GetObject
type ClientMockGetObjectExpectation struct {
	mock    *ClientMock
	params  *ClientMockGetObjectParams
	results *ClientMockGetObjectResults
	Counter uint64
}

// ClientMockGetObjectParams contains parameters of the Client.GetObject
type ClientMockGetObjectParams struct {
	ctx     context.Context
	head    insolar.Reference
	request *insolar.Reference
}

// ClientMockGetObjectResults contains results of the Client.GetObject
type ClientMockGetObjectResults struct {
	o1  ObjectDescriptor
	err error
}

// Expect sets up expected params for Client.GetObject
func (mmGetObject *mClientMockGetObject) Expect(ctx context.Context, head insolar.Reference, request *insolar.Reference) *mClientMockGetObject {
	if mmGetObject.mock.funcGetObject != nil {
		mmGetObject.mock.t.Fatalf("ClientMock.GetObject mock is already set by Set")
	}

	if mmGetObject.defaultExpectation == nil {
		mmGetObject.defaultExpectation = &ClientMockGetObjectExpectation{}
	}

	mmGetObject.defaultExpectation.params = &ClientMockGetObjectParams{ctx, head, request}
	for _, e := range mmGetObject.expectations {
		if minimock.Equal(e.params, mmGetObject.defaultExpectation.params) {
			mmGetObject.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetObject.defaultExpectation.params)
		}
	}

	return mmGetObject
}

// Inspect accepts an inspector function that has same arguments as the Client.GetObject
func (mmGetObject *mClientMockGetObject) Inspect(f func(ctx context.Context, head insolar.Reference, request *insolar.Reference)) *mClientMockGetObject {
	if mmGetObject.mock.inspectFuncGetObject != nil {
		mmGetObject.mock.t.Fatalf("Inspect function is already set for ClientMock.GetObject")
	}

	mmGetObject.mock.inspectFuncGetObject = f

	return mmGetObject
}

// Return sets up results that will be returned by Client.GetObject
func (mmGetObject *mClientMockGetObject) Return(o1 ObjectDescriptor, err error) *ClientMock {
	if mmGetObject.mock.funcGetObject != nil {
		mmGetObject.mock.t.Fatalf("ClientMock.GetObject mock is already set by Set")
	}

	if mmGetObject.defaultExpectation == nil {
		mmGetObject.defaultExpectation = &ClientMockGetObjectExpectation{mock: mmGetObject.mock}
	}
	mmGetObject.defaultExpectation.results = &ClientMockGetObjectResults{o1, err}
	return mmGetObject.mock
}

//Set uses given function f to mock the Client.GetObject method
func (mmGetObject *mClientMockGetObject) Set(f func(ctx context.Context, head insolar.Reference, request *insolar.Reference) (o1 ObjectDescriptor, err error)) *ClientMock {
	if mmGetObject.defaultExpectation != nil {
		mmGetObject.mock.t.Fatalf("Default expectation is already set for the Client.GetObject method")
	}

	if len(mmGetObject.expectations) > 0 {
		mmGetObject.mock.t.Fatalf("Some expectations are already set for the Client.GetObject method")
	}

	mmGetObject.mock.funcGetObject = f
	return mmGetObject.mock
}

// When sets expectation for the Client.GetObject which will trigger the result defined by the following
// Then helper
func (mmGetObject *mClientMockGetObject) When(ctx context.Context, head insolar.Reference, request *insolar.Reference) *ClientMockGetObjectExpectation {
	if mmGetObject.mock.funcGetObject != nil {
		mmGetObject.mock.t.Fatalf("ClientMock.GetObject mock is already set by Set")
	}

	expectation := &ClientMockGetObjectExpectation{
		mock:   mmGetObject.mock,
		params: &ClientMockGetObjectParams{ctx, head, request},
	}
	mmGetObject.expectations = append(mmGetObject.expectations, expectation)
	return expectation
}

// Then sets up Client.GetObject return parameters for the expectation previously defined by the When method
func (e *ClientMockGetObjectExpectation) Then(o1 ObjectDescriptor, err error) *ClientMock {
	e.results = &ClientMockGetObjectResults{o1, err}
	return e.mock
}

// GetObject implements Client
func (mmGetObject *ClientMock) GetObject(ctx context.Context, head insolar.Reference, request *insolar.Reference) (o1 ObjectDescriptor, err error) {
	mm_atomic.AddUint64(&mmGetObject.beforeGetObjectCounter, 1)
	defer mm_atomic.AddUint64(&mmGetObject.afterGetObjectCounter, 1)

	if mmGetObject.inspectFuncGetObject != nil {
		mmGetObject.inspectFuncGetObject(ctx, head, request)
	}

	params := &ClientMockGetObjectParams{ctx, head, request}

	// Record call args
	mmGetObject.GetObjectMock.mutex.Lock()
	mmGetObject.GetObjectMock.callArgs = append(mmGetObject.GetObjectMock.callArgs, params)
	mmGetObject.GetObjectMock.mutex.Unlock()

	for _, e := range mmGetObject.GetObjectMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o1, e.results.err
		}
	}

	if mmGetObject.GetObjectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetObject.GetObjectMock.defaultExpectation.Counter, 1)
		want := mmGetObject.GetObjectMock.defaultExpectation.params
		got := ClientMockGetObjectParams{ctx, head, request}
		if want != nil && !minimock.Equal(*want, got) {
			mmGetObject.t.Errorf("ClientMock.GetObject got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmGetObject.GetObjectMock.defaultExpectation.results
		if results == nil {
			mmGetObject.t.Fatal("No results are set for the ClientMock.GetObject")
		}
		return (*results).o1, (*results).err
	}
	if mmGetObject.funcGetObject != nil {
		return mmGetObject.funcGetObject(ctx, head, request)
	}
	mmGetObject.t.Fatalf("Unexpected call to ClientMock.GetObject. %v %v %v", ctx, head, request)
	return
}

// GetObjectAfterCounter returns a count of finished ClientMock.GetObject invocations
func (mmGetObject *ClientMock) GetObjectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObject.afterGetObjectCounter)
}

// GetObjectBeforeCounter returns a count of ClientMock.GetObject invocations
func (mmGetObject *ClientMock) GetObjectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObject.beforeGetObjectCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetObject.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetObject *mClientMockGetObject) Calls() []*ClientMockGetObjectParams {
	mmGetObject.mutex.RLock()

	argCopy := make([]*ClientMockGetObjectParams, len(mmGetObject.callArgs))
	copy(argCopy, mmGetObject.callArgs)

	mmGetObject.mutex.RUnlock()

	return argCopy
}

// MinimockGetObjectDone returns true if the count of the GetObject invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetObjectDone() bool {
	for _, e := range m.GetObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetObjectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetObjectCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetObject != nil && mm_atomic.LoadUint64(&m.afterGetObjectCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetObjectInspect logs each unmet expectation
func (m *ClientMock) MinimockGetObjectInspect() {
	for _, e := range m.GetObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetObject with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetObjectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetObjectCounter) < 1 {
		if m.GetObjectMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetObject")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetObject with params: %#v", *m.GetObjectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetObject != nil && mm_atomic.LoadUint64(&m.afterGetObjectCounter) < 1 {
		m.t.Error("Expected call to ClientMock.GetObject")
	}
}

type mClientMockGetPendings struct {
	mock               *ClientMock
	defaultExpectation *ClientMockGetPendingsExpectation
	expectations       []*ClientMockGetPendingsExpectation

	callArgs []*ClientMockGetPendingsParams
	mutex    sync.RWMutex
}

// ClientMockGetPendingsExpectation specifies expectation struct of the Client.GetPendings
type ClientMockGetPendingsExpectation struct {
	mock    *ClientMock
	params  *ClientMockGetPendingsParams
	results *ClientMockGetPendingsResults
	Counter uint64
}

// ClientMockGetPendingsParams contains parameters of the Client.GetPendings
type ClientMockGetPendingsParams struct {
	ctx       context.Context
	objectRef insolar.Reference
	skip      []insolar.ID
}

// ClientMockGetPendingsResults contains results of the Client.GetPendings
type ClientMockGetPendingsResults struct {
	ra1 []insolar.Reference
	err error
}

// Expect sets up expected params for Client.GetPendings
func (mmGetPendings *mClientMockGetPendings) Expect(ctx context.Context, objectRef insolar.Reference, skip []insolar.ID) *mClientMockGetPendings {
	if mmGetPendings.mock.funcGetPendings != nil {
		mmGetPendings.mock.t.Fatalf("ClientMock.GetPendings mock is already set by Set")
	}

	if mmGetPendings.defaultExpectation == nil {
		mmGetPendings.defaultExpectation = &ClientMockGetPendingsExpectation{}
	}

	mmGetPendings.defaultExpectation.params = &ClientMockGetPendingsParams{ctx, objectRef, skip}
	for _, e := range mmGetPendings.expectations {
		if minimock.Equal(e.params, mmGetPendings.defaultExpectation.params) {
			mmGetPendings.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPendings.defaultExpectation.params)
		}
	}

	return mmGetPendings
}

// Inspect accepts an inspector function that has same arguments as the Client.GetPendings
func (mmGetPendings *mClientMockGetPendings) Inspect(f func(ctx context.Context, objectRef insolar.Reference, skip []insolar.ID)) *mClientMockGetPendings {
	if mmGetPendings.mock.inspectFuncGetPendings != nil {
		mmGetPendings.mock.t.Fatalf("Inspect function is already set for ClientMock.GetPendings")
	}

	mmGetPendings.mock.inspectFuncGetPendings = f

	return mmGetPendings
}

// Return sets up results that will be returned by Client.GetPendings
func (mmGetPendings *mClientMockGetPendings) Return(ra1 []insolar.Reference, err error) *ClientMock {
	if mmGetPendings.mock.funcGetPendings != nil {
		mmGetPendings.mock.t.Fatalf("ClientMock.GetPendings mock is already set by Set")
	}

	if mmGetPendings.defaultExpectation == nil {
		mmGetPendings.defaultExpectation = &ClientMockGetPendingsExpectation{mock: mmGetPendings.mock}
	}
	mmGetPendings.defaultExpectation.results = &ClientMockGetPendingsResults{ra1, err}
	return mmGetPendings.mock
}

//Set uses given function f to mock the Client.GetPendings method
func (mmGetPendings *mClientMockGetPendings) Set(f func(ctx context.Context, objectRef insolar.Reference, skip []insolar.ID) (ra1 []insolar.Reference, err error)) *ClientMock {
	if mmGetPendings.defaultExpectation != nil {
		mmGetPendings.mock.t.Fatalf("Default expectation is already set for the Client.GetPendings method")
	}

	if len(mmGetPendings.expectations) > 0 {
		mmGetPendings.mock.t.Fatalf("Some expectations are already set for the Client.GetPendings method")
	}

	mmGetPendings.mock.funcGetPendings = f
	return mmGetPendings.mock
}

// When sets expectation for the Client.GetPendings which will trigger the result defined by the following
// Then helper
func (mmGetPendings *mClientMockGetPendings) When(ctx context.Context, objectRef insolar.Reference, skip []insolar.ID) *ClientMockGetPendingsExpectation {
	if mmGetPendings.mock.funcGetPendings != nil {
		mmGetPendings.mock.t.Fatalf("ClientMock.GetPendings mock is already set by Set")
	}

	expectation := &ClientMockGetPendingsExpectation{
		mock:   mmGetPendings.mock,
		params: &ClientMockGetPendingsParams{ctx, objectRef, skip},
	}
	mmGetPendings.expectations = append(mmGetPendings.expectations, expectation)
	return expectation
}

// Then sets up Client.GetPendings return parameters for the expectation previously defined by the When method
func (e *ClientMockGetPendingsExpectation) Then(ra1 []insolar.Reference, err error) *ClientMock {
	e.results = &ClientMockGetPendingsResults{ra1, err}
	return e.mock
}

// GetPendings implements Client
func (mmGetPendings *ClientMock) GetPendings(ctx context.Context, objectRef insolar.Reference, skip []insolar.ID) (ra1 []insolar.Reference, err error) {
	mm_atomic.AddUint64(&mmGetPendings.beforeGetPendingsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPendings.afterGetPendingsCounter, 1)

	if mmGetPendings.inspectFuncGetPendings != nil {
		mmGetPendings.inspectFuncGetPendings(ctx, objectRef, skip)
	}

	params := &ClientMockGetPendingsParams{ctx, objectRef, skip}

	// Record call args
	mmGetPendings.GetPendingsMock.mutex.Lock()
	mmGetPendings.GetPendingsMock.callArgs = append(mmGetPendings.GetPendingsMock.callArgs, params)
	mmGetPendings.GetPendingsMock.mutex.Unlock()

	for _, e := range mmGetPendings.GetPendingsMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ra1, e.results.err
		}
	}

	if mmGetPendings.GetPendingsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPendings.GetPendingsMock.defaultExpectation.Counter, 1)
		want := mmGetPendings.GetPendingsMock.defaultExpectation.params
		got := ClientMockGetPendingsParams{ctx, objectRef, skip}
		if want != nil && !minimock.Equal(*want, got) {
			mmGetPendings.t.Errorf("ClientMock.GetPendings got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmGetPendings.GetPendingsMock.defaultExpectation.results
		if results == nil {
			mmGetPendings.t.Fatal("No results are set for the ClientMock.GetPendings")
		}
		return (*results).ra1, (*results).err
	}
	if mmGetPendings.funcGetPendings != nil {
		return mmGetPendings.funcGetPendings(ctx, objectRef, skip)
	}
	mmGetPendings.t.Fatalf("Unexpected call to ClientMock.GetPendings. %v %v %v", ctx, objectRef, skip)
	return
}

// GetPendingsAfterCounter returns a count of finished ClientMock.GetPendings invocations
func (mmGetPendings *ClientMock) GetPendingsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPendings.afterGetPendingsCounter)
}

// GetPendingsBeforeCounter returns a count of ClientMock.GetPendings invocations
func (mmGetPendings *ClientMock) GetPendingsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPendings.beforeGetPendingsCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetPendings.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPendings *mClientMockGetPendings) Calls() []*ClientMockGetPendingsParams {
	mmGetPendings.mutex.RLock()

	argCopy := make([]*ClientMockGetPendingsParams, len(mmGetPendings.callArgs))
	copy(argCopy, mmGetPendings.callArgs)

	mmGetPendings.mutex.RUnlock()

	return argCopy
}

// MinimockGetPendingsDone returns true if the count of the GetPendings invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetPendingsDone() bool {
	for _, e := range m.GetPendingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPendingsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPendingsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPendings != nil && mm_atomic.LoadUint64(&m.afterGetPendingsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPendingsInspect logs each unmet expectation
func (m *ClientMock) MinimockGetPendingsInspect() {
	for _, e := range m.GetPendingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetPendings with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPendingsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPendingsCounter) < 1 {
		if m.GetPendingsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetPendings")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetPendings with params: %#v", *m.GetPendingsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPendings != nil && mm_atomic.LoadUint64(&m.afterGetPendingsCounter) < 1 {
		m.t.Error("Expected call to ClientMock.GetPendings")
	}
}

type mClientMockGetPrototype struct {
	mock               *ClientMock
	defaultExpectation *ClientMockGetPrototypeExpectation
	expectations       []*ClientMockGetPrototypeExpectation

	callArgs []*ClientMockGetPrototypeParams
	mutex    sync.RWMutex
}

// ClientMockGetPrototypeExpectation specifies expectation struct of the Client.GetPrototype
type ClientMockGetPrototypeExpectation struct {
	mock    *ClientMock
	params  *ClientMockGetPrototypeParams
	results *ClientMockGetPrototypeResults
	Counter uint64
}

// ClientMockGetPrototypeParams contains parameters of the Client.GetPrototype
type ClientMockGetPrototypeParams struct {
	ctx  context.Context
	head insolar.Reference
}

// ClientMockGetPrototypeResults contains results of the Client.GetPrototype
type ClientMockGetPrototypeResults struct {
	p1  PrototypeDescriptor
	err error
}

// Expect sets up expected params for Client.GetPrototype
func (mmGetPrototype *mClientMockGetPrototype) Expect(ctx context.Context, head insolar.Reference) *mClientMockGetPrototype {
	if mmGetPrototype.mock.funcGetPrototype != nil {
		mmGetPrototype.mock.t.Fatalf("ClientMock.GetPrototype mock is already set by Set")
	}

	if mmGetPrototype.defaultExpectation == nil {
		mmGetPrototype.defaultExpectation = &ClientMockGetPrototypeExpectation{}
	}

	mmGetPrototype.defaultExpectation.params = &ClientMockGetPrototypeParams{ctx, head}
	for _, e := range mmGetPrototype.expectations {
		if minimock.Equal(e.params, mmGetPrototype.defaultExpectation.params) {
			mmGetPrototype.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPrototype.defaultExpectation.params)
		}
	}

	return mmGetPrototype
}

// Inspect accepts an inspector function that has same arguments as the Client.GetPrototype
func (mmGetPrototype *mClientMockGetPrototype) Inspect(f func(ctx context.Context, head insolar.Reference)) *mClientMockGetPrototype {
	if mmGetPrototype.mock.inspectFuncGetPrototype != nil {
		mmGetPrototype.mock.t.Fatalf("Inspect function is already set for ClientMock.GetPrototype")
	}

	mmGetPrototype.mock.inspectFuncGetPrototype = f

	return mmGetPrototype
}

// Return sets up results that will be returned by Client.GetPrototype
func (mmGetPrototype *mClientMockGetPrototype) Return(p1 PrototypeDescriptor, err error) *ClientMock {
	if mmGetPrototype.mock.funcGetPrototype != nil {
		mmGetPrototype.mock.t.Fatalf("ClientMock.GetPrototype mock is already set by Set")
	}

	if mmGetPrototype.defaultExpectation == nil {
		mmGetPrototype.defaultExpectation = &ClientMockGetPrototypeExpectation{mock: mmGetPrototype.mock}
	}
	mmGetPrototype.defaultExpectation.results = &ClientMockGetPrototypeResults{p1, err}
	return mmGetPrototype.mock
}

//Set uses given function f to mock the Client.GetPrototype method
func (mmGetPrototype *mClientMockGetPrototype) Set(f func(ctx context.Context, head insolar.Reference) (p1 PrototypeDescriptor, err error)) *ClientMock {
	if mmGetPrototype.defaultExpectation != nil {
		mmGetPrototype.mock.t.Fatalf("Default expectation is already set for the Client.GetPrototype method")
	}

	if len(mmGetPrototype.expectations) > 0 {
		mmGetPrototype.mock.t.Fatalf("Some expectations are already set for the Client.GetPrototype method")
	}

	mmGetPrototype.mock.funcGetPrototype = f
	return mmGetPrototype.mock
}

// When sets expectation for the Client.GetPrototype which will trigger the result defined by the following
// Then helper
func (mmGetPrototype *mClientMockGetPrototype) When(ctx context.Context, head insolar.Reference) *ClientMockGetPrototypeExpectation {
	if mmGetPrototype.mock.funcGetPrototype != nil {
		mmGetPrototype.mock.t.Fatalf("ClientMock.GetPrototype mock is already set by Set")
	}

	expectation := &ClientMockGetPrototypeExpectation{
		mock:   mmGetPrototype.mock,
		params: &ClientMockGetPrototypeParams{ctx, head},
	}
	mmGetPrototype.expectations = append(mmGetPrototype.expectations, expectation)
	return expectation
}

// Then sets up Client.GetPrototype return parameters for the expectation previously defined by the When method
func (e *ClientMockGetPrototypeExpectation) Then(p1 PrototypeDescriptor, err error) *ClientMock {
	e.results = &ClientMockGetPrototypeResults{p1, err}
	return e.mock
}

// GetPrototype implements Client
func (mmGetPrototype *ClientMock) GetPrototype(ctx context.Context, head insolar.Reference) (p1 PrototypeDescriptor, err error) {
	mm_atomic.AddUint64(&mmGetPrototype.beforeGetPrototypeCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPrototype.afterGetPrototypeCounter, 1)

	if mmGetPrototype.inspectFuncGetPrototype != nil {
		mmGetPrototype.inspectFuncGetPrototype(ctx, head)
	}

	params := &ClientMockGetPrototypeParams{ctx, head}

	// Record call args
	mmGetPrototype.GetPrototypeMock.mutex.Lock()
	mmGetPrototype.GetPrototypeMock.callArgs = append(mmGetPrototype.GetPrototypeMock.callArgs, params)
	mmGetPrototype.GetPrototypeMock.mutex.Unlock()

	for _, e := range mmGetPrototype.GetPrototypeMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmGetPrototype.GetPrototypeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPrototype.GetPrototypeMock.defaultExpectation.Counter, 1)
		want := mmGetPrototype.GetPrototypeMock.defaultExpectation.params
		got := ClientMockGetPrototypeParams{ctx, head}
		if want != nil && !minimock.Equal(*want, got) {
			mmGetPrototype.t.Errorf("ClientMock.GetPrototype got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmGetPrototype.GetPrototypeMock.defaultExpectation.results
		if results == nil {
			mmGetPrototype.t.Fatal("No results are set for the ClientMock.GetPrototype")
		}
		return (*results).p1, (*results).err
	}
	if mmGetPrototype.funcGetPrototype != nil {
		return mmGetPrototype.funcGetPrototype(ctx, head)
	}
	mmGetPrototype.t.Fatalf("Unexpected call to ClientMock.GetPrototype. %v %v", ctx, head)
	return
}

// GetPrototypeAfterCounter returns a count of finished ClientMock.GetPrototype invocations
func (mmGetPrototype *ClientMock) GetPrototypeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPrototype.afterGetPrototypeCounter)
}

// GetPrototypeBeforeCounter returns a count of ClientMock.GetPrototype invocations
func (mmGetPrototype *ClientMock) GetPrototypeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPrototype.beforeGetPrototypeCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetPrototype.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPrototype *mClientMockGetPrototype) Calls() []*ClientMockGetPrototypeParams {
	mmGetPrototype.mutex.RLock()

	argCopy := make([]*ClientMockGetPrototypeParams, len(mmGetPrototype.callArgs))
	copy(argCopy, mmGetPrototype.callArgs)

	mmGetPrototype.mutex.RUnlock()

	return argCopy
}

// MinimockGetPrototypeDone returns true if the count of the GetPrototype invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetPrototypeDone() bool {
	for _, e := range m.GetPrototypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPrototypeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPrototypeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPrototype != nil && mm_atomic.LoadUint64(&m.afterGetPrototypeCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPrototypeInspect logs each unmet expectation
func (m *ClientMock) MinimockGetPrototypeInspect() {
	for _, e := range m.GetPrototypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetPrototype with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPrototypeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPrototypeCounter) < 1 {
		if m.GetPrototypeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetPrototype")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetPrototype with params: %#v", *m.GetPrototypeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPrototype != nil && mm_atomic.LoadUint64(&m.afterGetPrototypeCounter) < 1 {
		m.t.Error("Expected call to ClientMock.GetPrototype")
	}
}

type mClientMockGetRequest struct {
	mock               *ClientMock
	defaultExpectation *ClientMockGetRequestExpectation
	expectations       []*ClientMockGetRequestExpectation

	callArgs []*ClientMockGetRequestParams
	mutex    sync.RWMutex
}

// ClientMockGetRequestExpectation specifies expectation struct of the Client.GetRequest
type ClientMockGetRequestExpectation struct {
	mock    *ClientMock
	params  *ClientMockGetRequestParams
	results *ClientMockGetRequestResults
	Counter uint64
}

// ClientMockGetRequestParams contains parameters of the Client.GetRequest
type ClientMockGetRequestParams struct {
	ctx       context.Context
	objectRef insolar.Reference
	reqRef    insolar.Reference
}

// ClientMockGetRequestResults contains results of the Client.GetRequest
type ClientMockGetRequestResults struct {
	r1  record.Request
	err error
}

// Expect sets up expected params for Client.GetRequest
func (mmGetRequest *mClientMockGetRequest) Expect(ctx context.Context, objectRef insolar.Reference, reqRef insolar.Reference) *mClientMockGetRequest {
	if mmGetRequest.mock.funcGetRequest != nil {
		mmGetRequest.mock.t.Fatalf("ClientMock.GetRequest mock is already set by Set")
	}

	if mmGetRequest.defaultExpectation == nil {
		mmGetRequest.defaultExpectation = &ClientMockGetRequestExpectation{}
	}

	mmGetRequest.defaultExpectation.params = &ClientMockGetRequestParams{ctx, objectRef, reqRef}
	for _, e := range mmGetRequest.expectations {
		if minimock.Equal(e.params, mmGetRequest.defaultExpectation.params) {
			mmGetRequest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRequest.defaultExpectation.params)
		}
	}

	return mmGetRequest
}

// Inspect accepts an inspector function that has same arguments as the Client.GetRequest
func (mmGetRequest *mClientMockGetRequest) Inspect(f func(ctx context.Context, objectRef insolar.Reference, reqRef insolar.Reference)) *mClientMockGetRequest {
	if mmGetRequest.mock.inspectFuncGetRequest != nil {
		mmGetRequest.mock.t.Fatalf("Inspect function is already set for ClientMock.GetRequest")
	}

	mmGetRequest.mock.inspectFuncGetRequest = f

	return mmGetRequest
}

// Return sets up results that will be returned by Client.GetRequest
func (mmGetRequest *mClientMockGetRequest) Return(r1 record.Request, err error) *ClientMock {
	if mmGetRequest.mock.funcGetRequest != nil {
		mmGetRequest.mock.t.Fatalf("ClientMock.GetRequest mock is already set by Set")
	}

	if mmGetRequest.defaultExpectation == nil {
		mmGetRequest.defaultExpectation = &ClientMockGetRequestExpectation{mock: mmGetRequest.mock}
	}
	mmGetRequest.defaultExpectation.results = &ClientMockGetRequestResults{r1, err}
	return mmGetRequest.mock
}

//Set uses given function f to mock the Client.GetRequest method
func (mmGetRequest *mClientMockGetRequest) Set(f func(ctx context.Context, objectRef insolar.Reference, reqRef insolar.Reference) (r1 record.Request, err error)) *ClientMock {
	if mmGetRequest.defaultExpectation != nil {
		mmGetRequest.mock.t.Fatalf("Default expectation is already set for the Client.GetRequest method")
	}

	if len(mmGetRequest.expectations) > 0 {
		mmGetRequest.mock.t.Fatalf("Some expectations are already set for the Client.GetRequest method")
	}

	mmGetRequest.mock.funcGetRequest = f
	return mmGetRequest.mock
}

// When sets expectation for the Client.GetRequest which will trigger the result defined by the following
// Then helper
func (mmGetRequest *mClientMockGetRequest) When(ctx context.Context, objectRef insolar.Reference, reqRef insolar.Reference) *ClientMockGetRequestExpectation {
	if mmGetRequest.mock.funcGetRequest != nil {
		mmGetRequest.mock.t.Fatalf("ClientMock.GetRequest mock is already set by Set")
	}

	expectation := &ClientMockGetRequestExpectation{
		mock:   mmGetRequest.mock,
		params: &ClientMockGetRequestParams{ctx, objectRef, reqRef},
	}
	mmGetRequest.expectations = append(mmGetRequest.expectations, expectation)
	return expectation
}

// Then sets up Client.GetRequest return parameters for the expectation previously defined by the When method
func (e *ClientMockGetRequestExpectation) Then(r1 record.Request, err error) *ClientMock {
	e.results = &ClientMockGetRequestResults{r1, err}
	return e.mock
}

// GetRequest implements Client
func (mmGetRequest *ClientMock) GetRequest(ctx context.Context, objectRef insolar.Reference, reqRef insolar.Reference) (r1 record.Request, err error) {
	mm_atomic.AddUint64(&mmGetRequest.beforeGetRequestCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRequest.afterGetRequestCounter, 1)

	if mmGetRequest.inspectFuncGetRequest != nil {
		mmGetRequest.inspectFuncGetRequest(ctx, objectRef, reqRef)
	}

	params := &ClientMockGetRequestParams{ctx, objectRef, reqRef}

	// Record call args
	mmGetRequest.GetRequestMock.mutex.Lock()
	mmGetRequest.GetRequestMock.callArgs = append(mmGetRequest.GetRequestMock.callArgs, params)
	mmGetRequest.GetRequestMock.mutex.Unlock()

	for _, e := range mmGetRequest.GetRequestMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmGetRequest.GetRequestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRequest.GetRequestMock.defaultExpectation.Counter, 1)
		want := mmGetRequest.GetRequestMock.defaultExpectation.params
		got := ClientMockGetRequestParams{ctx, objectRef, reqRef}
		if want != nil && !minimock.Equal(*want, got) {
			mmGetRequest.t.Errorf("ClientMock.GetRequest got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmGetRequest.GetRequestMock.defaultExpectation.results
		if results == nil {
			mmGetRequest.t.Fatal("No results are set for the ClientMock.GetRequest")
		}
		return (*results).r1, (*results).err
	}
	if mmGetRequest.funcGetRequest != nil {
		return mmGetRequest.funcGetRequest(ctx, objectRef, reqRef)
	}
	mmGetRequest.t.Fatalf("Unexpected call to ClientMock.GetRequest. %v %v %v", ctx, objectRef, reqRef)
	return
}

// GetRequestAfterCounter returns a count of finished ClientMock.GetRequest invocations
func (mmGetRequest *ClientMock) GetRequestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRequest.afterGetRequestCounter)
}

// GetRequestBeforeCounter returns a count of ClientMock.GetRequest invocations
func (mmGetRequest *ClientMock) GetRequestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRequest.beforeGetRequestCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetRequest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRequest *mClientMockGetRequest) Calls() []*ClientMockGetRequestParams {
	mmGetRequest.mutex.RLock()

	argCopy := make([]*ClientMockGetRequestParams, len(mmGetRequest.callArgs))
	copy(argCopy, mmGetRequest.callArgs)

	mmGetRequest.mutex.RUnlock()

	return argCopy
}

// MinimockGetRequestDone returns true if the count of the GetRequest invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetRequestDone() bool {
	for _, e := range m.GetRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRequestCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRequest != nil && mm_atomic.LoadUint64(&m.afterGetRequestCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetRequestInspect logs each unmet expectation
func (m *ClientMock) MinimockGetRequestInspect() {
	for _, e := range m.GetRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetRequest with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRequestCounter) < 1 {
		if m.GetRequestMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetRequest")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetRequest with params: %#v", *m.GetRequestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRequest != nil && mm_atomic.LoadUint64(&m.afterGetRequestCounter) < 1 {
		m.t.Error("Expected call to ClientMock.GetRequest")
	}
}

type mClientMockHasPendings struct {
	mock               *ClientMock
	defaultExpectation *ClientMockHasPendingsExpectation
	expectations       []*ClientMockHasPendingsExpectation

	callArgs []*ClientMockHasPendingsParams
	mutex    sync.RWMutex
}

// ClientMockHasPendingsExpectation specifies expectation struct of the Client.HasPendings
type ClientMockHasPendingsExpectation struct {
	mock    *ClientMock
	params  *ClientMockHasPendingsParams
	results *ClientMockHasPendingsResults
	Counter uint64
}

// ClientMockHasPendingsParams contains parameters of the Client.HasPendings
type ClientMockHasPendingsParams struct {
	ctx    context.Context
	object insolar.Reference
}

// ClientMockHasPendingsResults contains results of the Client.HasPendings
type ClientMockHasPendingsResults struct {
	b1  bool
	err error
}

// Expect sets up expected params for Client.HasPendings
func (mmHasPendings *mClientMockHasPendings) Expect(ctx context.Context, object insolar.Reference) *mClientMockHasPendings {
	if mmHasPendings.mock.funcHasPendings != nil {
		mmHasPendings.mock.t.Fatalf("ClientMock.HasPendings mock is already set by Set")
	}

	if mmHasPendings.defaultExpectation == nil {
		mmHasPendings.defaultExpectation = &ClientMockHasPendingsExpectation{}
	}

	mmHasPendings.defaultExpectation.params = &ClientMockHasPendingsParams{ctx, object}
	for _, e := range mmHasPendings.expectations {
		if minimock.Equal(e.params, mmHasPendings.defaultExpectation.params) {
			mmHasPendings.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHasPendings.defaultExpectation.params)
		}
	}

	return mmHasPendings
}

// Inspect accepts an inspector function that has same arguments as the Client.HasPendings
func (mmHasPendings *mClientMockHasPendings) Inspect(f func(ctx context.Context, object insolar.Reference)) *mClientMockHasPendings {
	if mmHasPendings.mock.inspectFuncHasPendings != nil {
		mmHasPendings.mock.t.Fatalf("Inspect function is already set for ClientMock.HasPendings")
	}

	mmHasPendings.mock.inspectFuncHasPendings = f

	return mmHasPendings
}

// Return sets up results that will be returned by Client.HasPendings
func (mmHasPendings *mClientMockHasPendings) Return(b1 bool, err error) *ClientMock {
	if mmHasPendings.mock.funcHasPendings != nil {
		mmHasPendings.mock.t.Fatalf("ClientMock.HasPendings mock is already set by Set")
	}

	if mmHasPendings.defaultExpectation == nil {
		mmHasPendings.defaultExpectation = &ClientMockHasPendingsExpectation{mock: mmHasPendings.mock}
	}
	mmHasPendings.defaultExpectation.results = &ClientMockHasPendingsResults{b1, err}
	return mmHasPendings.mock
}

//Set uses given function f to mock the Client.HasPendings method
func (mmHasPendings *mClientMockHasPendings) Set(f func(ctx context.Context, object insolar.Reference) (b1 bool, err error)) *ClientMock {
	if mmHasPendings.defaultExpectation != nil {
		mmHasPendings.mock.t.Fatalf("Default expectation is already set for the Client.HasPendings method")
	}

	if len(mmHasPendings.expectations) > 0 {
		mmHasPendings.mock.t.Fatalf("Some expectations are already set for the Client.HasPendings method")
	}

	mmHasPendings.mock.funcHasPendings = f
	return mmHasPendings.mock
}

// When sets expectation for the Client.HasPendings which will trigger the result defined by the following
// Then helper
func (mmHasPendings *mClientMockHasPendings) When(ctx context.Context, object insolar.Reference) *ClientMockHasPendingsExpectation {
	if mmHasPendings.mock.funcHasPendings != nil {
		mmHasPendings.mock.t.Fatalf("ClientMock.HasPendings mock is already set by Set")
	}

	expectation := &ClientMockHasPendingsExpectation{
		mock:   mmHasPendings.mock,
		params: &ClientMockHasPendingsParams{ctx, object},
	}
	mmHasPendings.expectations = append(mmHasPendings.expectations, expectation)
	return expectation
}

// Then sets up Client.HasPendings return parameters for the expectation previously defined by the When method
func (e *ClientMockHasPendingsExpectation) Then(b1 bool, err error) *ClientMock {
	e.results = &ClientMockHasPendingsResults{b1, err}
	return e.mock
}

// HasPendings implements Client
func (mmHasPendings *ClientMock) HasPendings(ctx context.Context, object insolar.Reference) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmHasPendings.beforeHasPendingsCounter, 1)
	defer mm_atomic.AddUint64(&mmHasPendings.afterHasPendingsCounter, 1)

	if mmHasPendings.inspectFuncHasPendings != nil {
		mmHasPendings.inspectFuncHasPendings(ctx, object)
	}

	params := &ClientMockHasPendingsParams{ctx, object}

	// Record call args
	mmHasPendings.HasPendingsMock.mutex.Lock()
	mmHasPendings.HasPendingsMock.callArgs = append(mmHasPendings.HasPendingsMock.callArgs, params)
	mmHasPendings.HasPendingsMock.mutex.Unlock()

	for _, e := range mmHasPendings.HasPendingsMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmHasPendings.HasPendingsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHasPendings.HasPendingsMock.defaultExpectation.Counter, 1)
		want := mmHasPendings.HasPendingsMock.defaultExpectation.params
		got := ClientMockHasPendingsParams{ctx, object}
		if want != nil && !minimock.Equal(*want, got) {
			mmHasPendings.t.Errorf("ClientMock.HasPendings got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmHasPendings.HasPendingsMock.defaultExpectation.results
		if results == nil {
			mmHasPendings.t.Fatal("No results are set for the ClientMock.HasPendings")
		}
		return (*results).b1, (*results).err
	}
	if mmHasPendings.funcHasPendings != nil {
		return mmHasPendings.funcHasPendings(ctx, object)
	}
	mmHasPendings.t.Fatalf("Unexpected call to ClientMock.HasPendings. %v %v", ctx, object)
	return
}

// HasPendingsAfterCounter returns a count of finished ClientMock.HasPendings invocations
func (mmHasPendings *ClientMock) HasPendingsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHasPendings.afterHasPendingsCounter)
}

// HasPendingsBeforeCounter returns a count of ClientMock.HasPendings invocations
func (mmHasPendings *ClientMock) HasPendingsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHasPendings.beforeHasPendingsCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.HasPendings.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHasPendings *mClientMockHasPendings) Calls() []*ClientMockHasPendingsParams {
	mmHasPendings.mutex.RLock()

	argCopy := make([]*ClientMockHasPendingsParams, len(mmHasPendings.callArgs))
	copy(argCopy, mmHasPendings.callArgs)

	mmHasPendings.mutex.RUnlock()

	return argCopy
}

// MinimockHasPendingsDone returns true if the count of the HasPendings invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockHasPendingsDone() bool {
	for _, e := range m.HasPendingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HasPendingsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHasPendingsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHasPendings != nil && mm_atomic.LoadUint64(&m.afterHasPendingsCounter) < 1 {
		return false
	}
	return true
}

// MinimockHasPendingsInspect logs each unmet expectation
func (m *ClientMock) MinimockHasPendingsInspect() {
	for _, e := range m.HasPendingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.HasPendings with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HasPendingsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHasPendingsCounter) < 1 {
		if m.HasPendingsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.HasPendings")
		} else {
			m.t.Errorf("Expected call to ClientMock.HasPendings with params: %#v", *m.HasPendingsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHasPendings != nil && mm_atomic.LoadUint64(&m.afterHasPendingsCounter) < 1 {
		m.t.Error("Expected call to ClientMock.HasPendings")
	}
}

type mClientMockInjectCodeDescriptor struct {
	mock               *ClientMock
	defaultExpectation *ClientMockInjectCodeDescriptorExpectation
	expectations       []*ClientMockInjectCodeDescriptorExpectation

	callArgs []*ClientMockInjectCodeDescriptorParams
	mutex    sync.RWMutex
}

// ClientMockInjectCodeDescriptorExpectation specifies expectation struct of the Client.InjectCodeDescriptor
type ClientMockInjectCodeDescriptorExpectation struct {
	mock   *ClientMock
	params *ClientMockInjectCodeDescriptorParams

	Counter uint64
}

// ClientMockInjectCodeDescriptorParams contains parameters of the Client.InjectCodeDescriptor
type ClientMockInjectCodeDescriptorParams struct {
	r1 insolar.Reference
	c1 CodeDescriptor
}

// Expect sets up expected params for Client.InjectCodeDescriptor
func (mmInjectCodeDescriptor *mClientMockInjectCodeDescriptor) Expect(r1 insolar.Reference, c1 CodeDescriptor) *mClientMockInjectCodeDescriptor {
	if mmInjectCodeDescriptor.mock.funcInjectCodeDescriptor != nil {
		mmInjectCodeDescriptor.mock.t.Fatalf("ClientMock.InjectCodeDescriptor mock is already set by Set")
	}

	if mmInjectCodeDescriptor.defaultExpectation == nil {
		mmInjectCodeDescriptor.defaultExpectation = &ClientMockInjectCodeDescriptorExpectation{}
	}

	mmInjectCodeDescriptor.defaultExpectation.params = &ClientMockInjectCodeDescriptorParams{r1, c1}
	for _, e := range mmInjectCodeDescriptor.expectations {
		if minimock.Equal(e.params, mmInjectCodeDescriptor.defaultExpectation.params) {
			mmInjectCodeDescriptor.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInjectCodeDescriptor.defaultExpectation.params)
		}
	}

	return mmInjectCodeDescriptor
}

// Inspect accepts an inspector function that has same arguments as the Client.InjectCodeDescriptor
func (mmInjectCodeDescriptor *mClientMockInjectCodeDescriptor) Inspect(f func(r1 insolar.Reference, c1 CodeDescriptor)) *mClientMockInjectCodeDescriptor {
	if mmInjectCodeDescriptor.mock.inspectFuncInjectCodeDescriptor != nil {
		mmInjectCodeDescriptor.mock.t.Fatalf("Inspect function is already set for ClientMock.InjectCodeDescriptor")
	}

	mmInjectCodeDescriptor.mock.inspectFuncInjectCodeDescriptor = f

	return mmInjectCodeDescriptor
}

// Return sets up results that will be returned by Client.InjectCodeDescriptor
func (mmInjectCodeDescriptor *mClientMockInjectCodeDescriptor) Return() *ClientMock {
	if mmInjectCodeDescriptor.mock.funcInjectCodeDescriptor != nil {
		mmInjectCodeDescriptor.mock.t.Fatalf("ClientMock.InjectCodeDescriptor mock is already set by Set")
	}

	if mmInjectCodeDescriptor.defaultExpectation == nil {
		mmInjectCodeDescriptor.defaultExpectation = &ClientMockInjectCodeDescriptorExpectation{mock: mmInjectCodeDescriptor.mock}
	}

	return mmInjectCodeDescriptor.mock
}

//Set uses given function f to mock the Client.InjectCodeDescriptor method
func (mmInjectCodeDescriptor *mClientMockInjectCodeDescriptor) Set(f func(r1 insolar.Reference, c1 CodeDescriptor)) *ClientMock {
	if mmInjectCodeDescriptor.defaultExpectation != nil {
		mmInjectCodeDescriptor.mock.t.Fatalf("Default expectation is already set for the Client.InjectCodeDescriptor method")
	}

	if len(mmInjectCodeDescriptor.expectations) > 0 {
		mmInjectCodeDescriptor.mock.t.Fatalf("Some expectations are already set for the Client.InjectCodeDescriptor method")
	}

	mmInjectCodeDescriptor.mock.funcInjectCodeDescriptor = f
	return mmInjectCodeDescriptor.mock
}

// InjectCodeDescriptor implements Client
func (mmInjectCodeDescriptor *ClientMock) InjectCodeDescriptor(r1 insolar.Reference, c1 CodeDescriptor) {
	mm_atomic.AddUint64(&mmInjectCodeDescriptor.beforeInjectCodeDescriptorCounter, 1)
	defer mm_atomic.AddUint64(&mmInjectCodeDescriptor.afterInjectCodeDescriptorCounter, 1)

	if mmInjectCodeDescriptor.inspectFuncInjectCodeDescriptor != nil {
		mmInjectCodeDescriptor.inspectFuncInjectCodeDescriptor(r1, c1)
	}

	params := &ClientMockInjectCodeDescriptorParams{r1, c1}

	// Record call args
	mmInjectCodeDescriptor.InjectCodeDescriptorMock.mutex.Lock()
	mmInjectCodeDescriptor.InjectCodeDescriptorMock.callArgs = append(mmInjectCodeDescriptor.InjectCodeDescriptorMock.callArgs, params)
	mmInjectCodeDescriptor.InjectCodeDescriptorMock.mutex.Unlock()

	for _, e := range mmInjectCodeDescriptor.InjectCodeDescriptorMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmInjectCodeDescriptor.InjectCodeDescriptorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInjectCodeDescriptor.InjectCodeDescriptorMock.defaultExpectation.Counter, 1)
		want := mmInjectCodeDescriptor.InjectCodeDescriptorMock.defaultExpectation.params
		got := ClientMockInjectCodeDescriptorParams{r1, c1}
		if want != nil && !minimock.Equal(*want, got) {
			mmInjectCodeDescriptor.t.Errorf("ClientMock.InjectCodeDescriptor got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmInjectCodeDescriptor.funcInjectCodeDescriptor != nil {
		mmInjectCodeDescriptor.funcInjectCodeDescriptor(r1, c1)
		return
	}
	mmInjectCodeDescriptor.t.Fatalf("Unexpected call to ClientMock.InjectCodeDescriptor. %v %v", r1, c1)

}

// InjectCodeDescriptorAfterCounter returns a count of finished ClientMock.InjectCodeDescriptor invocations
func (mmInjectCodeDescriptor *ClientMock) InjectCodeDescriptorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInjectCodeDescriptor.afterInjectCodeDescriptorCounter)
}

// InjectCodeDescriptorBeforeCounter returns a count of ClientMock.InjectCodeDescriptor invocations
func (mmInjectCodeDescriptor *ClientMock) InjectCodeDescriptorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInjectCodeDescriptor.beforeInjectCodeDescriptorCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.InjectCodeDescriptor.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInjectCodeDescriptor *mClientMockInjectCodeDescriptor) Calls() []*ClientMockInjectCodeDescriptorParams {
	mmInjectCodeDescriptor.mutex.RLock()

	argCopy := make([]*ClientMockInjectCodeDescriptorParams, len(mmInjectCodeDescriptor.callArgs))
	copy(argCopy, mmInjectCodeDescriptor.callArgs)

	mmInjectCodeDescriptor.mutex.RUnlock()

	return argCopy
}

// MinimockInjectCodeDescriptorDone returns true if the count of the InjectCodeDescriptor invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockInjectCodeDescriptorDone() bool {
	for _, e := range m.InjectCodeDescriptorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InjectCodeDescriptorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInjectCodeDescriptorCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInjectCodeDescriptor != nil && mm_atomic.LoadUint64(&m.afterInjectCodeDescriptorCounter) < 1 {
		return false
	}
	return true
}

// MinimockInjectCodeDescriptorInspect logs each unmet expectation
func (m *ClientMock) MinimockInjectCodeDescriptorInspect() {
	for _, e := range m.InjectCodeDescriptorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.InjectCodeDescriptor with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InjectCodeDescriptorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInjectCodeDescriptorCounter) < 1 {
		if m.InjectCodeDescriptorMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.InjectCodeDescriptor")
		} else {
			m.t.Errorf("Expected call to ClientMock.InjectCodeDescriptor with params: %#v", *m.InjectCodeDescriptorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInjectCodeDescriptor != nil && mm_atomic.LoadUint64(&m.afterInjectCodeDescriptorCounter) < 1 {
		m.t.Error("Expected call to ClientMock.InjectCodeDescriptor")
	}
}

type mClientMockInjectFinish struct {
	mock               *ClientMock
	defaultExpectation *ClientMockInjectFinishExpectation
	expectations       []*ClientMockInjectFinishExpectation
}

// ClientMockInjectFinishExpectation specifies expectation struct of the Client.InjectFinish
type ClientMockInjectFinishExpectation struct {
	mock *ClientMock

	Counter uint64
}

// Expect sets up expected params for Client.InjectFinish
func (mmInjectFinish *mClientMockInjectFinish) Expect() *mClientMockInjectFinish {
	if mmInjectFinish.mock.funcInjectFinish != nil {
		mmInjectFinish.mock.t.Fatalf("ClientMock.InjectFinish mock is already set by Set")
	}

	if mmInjectFinish.defaultExpectation == nil {
		mmInjectFinish.defaultExpectation = &ClientMockInjectFinishExpectation{}
	}

	return mmInjectFinish
}

// Inspect accepts an inspector function that has same arguments as the Client.InjectFinish
func (mmInjectFinish *mClientMockInjectFinish) Inspect(f func()) *mClientMockInjectFinish {
	if mmInjectFinish.mock.inspectFuncInjectFinish != nil {
		mmInjectFinish.mock.t.Fatalf("Inspect function is already set for ClientMock.InjectFinish")
	}

	mmInjectFinish.mock.inspectFuncInjectFinish = f

	return mmInjectFinish
}

// Return sets up results that will be returned by Client.InjectFinish
func (mmInjectFinish *mClientMockInjectFinish) Return() *ClientMock {
	if mmInjectFinish.mock.funcInjectFinish != nil {
		mmInjectFinish.mock.t.Fatalf("ClientMock.InjectFinish mock is already set by Set")
	}

	if mmInjectFinish.defaultExpectation == nil {
		mmInjectFinish.defaultExpectation = &ClientMockInjectFinishExpectation{mock: mmInjectFinish.mock}
	}

	return mmInjectFinish.mock
}

//Set uses given function f to mock the Client.InjectFinish method
func (mmInjectFinish *mClientMockInjectFinish) Set(f func()) *ClientMock {
	if mmInjectFinish.defaultExpectation != nil {
		mmInjectFinish.mock.t.Fatalf("Default expectation is already set for the Client.InjectFinish method")
	}

	if len(mmInjectFinish.expectations) > 0 {
		mmInjectFinish.mock.t.Fatalf("Some expectations are already set for the Client.InjectFinish method")
	}

	mmInjectFinish.mock.funcInjectFinish = f
	return mmInjectFinish.mock
}

// InjectFinish implements Client
func (mmInjectFinish *ClientMock) InjectFinish() {
	mm_atomic.AddUint64(&mmInjectFinish.beforeInjectFinishCounter, 1)
	defer mm_atomic.AddUint64(&mmInjectFinish.afterInjectFinishCounter, 1)

	if mmInjectFinish.inspectFuncInjectFinish != nil {
		mmInjectFinish.inspectFuncInjectFinish()
	}

	if mmInjectFinish.InjectFinishMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInjectFinish.InjectFinishMock.defaultExpectation.Counter, 1)

		return

	}
	if mmInjectFinish.funcInjectFinish != nil {
		mmInjectFinish.funcInjectFinish()
		return
	}
	mmInjectFinish.t.Fatalf("Unexpected call to ClientMock.InjectFinish.")

}

// InjectFinishAfterCounter returns a count of finished ClientMock.InjectFinish invocations
func (mmInjectFinish *ClientMock) InjectFinishAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInjectFinish.afterInjectFinishCounter)
}

// InjectFinishBeforeCounter returns a count of ClientMock.InjectFinish invocations
func (mmInjectFinish *ClientMock) InjectFinishBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInjectFinish.beforeInjectFinishCounter)
}

// MinimockInjectFinishDone returns true if the count of the InjectFinish invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockInjectFinishDone() bool {
	for _, e := range m.InjectFinishMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InjectFinishMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInjectFinishCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInjectFinish != nil && mm_atomic.LoadUint64(&m.afterInjectFinishCounter) < 1 {
		return false
	}
	return true
}

// MinimockInjectFinishInspect logs each unmet expectation
func (m *ClientMock) MinimockInjectFinishInspect() {
	for _, e := range m.InjectFinishMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ClientMock.InjectFinish")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InjectFinishMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInjectFinishCounter) < 1 {
		m.t.Error("Expected call to ClientMock.InjectFinish")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInjectFinish != nil && mm_atomic.LoadUint64(&m.afterInjectFinishCounter) < 1 {
		m.t.Error("Expected call to ClientMock.InjectFinish")
	}
}

type mClientMockInjectPrototypeDescriptor struct {
	mock               *ClientMock
	defaultExpectation *ClientMockInjectPrototypeDescriptorExpectation
	expectations       []*ClientMockInjectPrototypeDescriptorExpectation

	callArgs []*ClientMockInjectPrototypeDescriptorParams
	mutex    sync.RWMutex
}

// ClientMockInjectPrototypeDescriptorExpectation specifies expectation struct of the Client.InjectPrototypeDescriptor
type ClientMockInjectPrototypeDescriptorExpectation struct {
	mock   *ClientMock
	params *ClientMockInjectPrototypeDescriptorParams

	Counter uint64
}

// ClientMockInjectPrototypeDescriptorParams contains parameters of the Client.InjectPrototypeDescriptor
type ClientMockInjectPrototypeDescriptorParams struct {
	r1 insolar.Reference
	p1 PrototypeDescriptor
}

// Expect sets up expected params for Client.InjectPrototypeDescriptor
func (mmInjectPrototypeDescriptor *mClientMockInjectPrototypeDescriptor) Expect(r1 insolar.Reference, p1 PrototypeDescriptor) *mClientMockInjectPrototypeDescriptor {
	if mmInjectPrototypeDescriptor.mock.funcInjectPrototypeDescriptor != nil {
		mmInjectPrototypeDescriptor.mock.t.Fatalf("ClientMock.InjectPrototypeDescriptor mock is already set by Set")
	}

	if mmInjectPrototypeDescriptor.defaultExpectation == nil {
		mmInjectPrototypeDescriptor.defaultExpectation = &ClientMockInjectPrototypeDescriptorExpectation{}
	}

	mmInjectPrototypeDescriptor.defaultExpectation.params = &ClientMockInjectPrototypeDescriptorParams{r1, p1}
	for _, e := range mmInjectPrototypeDescriptor.expectations {
		if minimock.Equal(e.params, mmInjectPrototypeDescriptor.defaultExpectation.params) {
			mmInjectPrototypeDescriptor.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInjectPrototypeDescriptor.defaultExpectation.params)
		}
	}

	return mmInjectPrototypeDescriptor
}

// Inspect accepts an inspector function that has same arguments as the Client.InjectPrototypeDescriptor
func (mmInjectPrototypeDescriptor *mClientMockInjectPrototypeDescriptor) Inspect(f func(r1 insolar.Reference, p1 PrototypeDescriptor)) *mClientMockInjectPrototypeDescriptor {
	if mmInjectPrototypeDescriptor.mock.inspectFuncInjectPrototypeDescriptor != nil {
		mmInjectPrototypeDescriptor.mock.t.Fatalf("Inspect function is already set for ClientMock.InjectPrototypeDescriptor")
	}

	mmInjectPrototypeDescriptor.mock.inspectFuncInjectPrototypeDescriptor = f

	return mmInjectPrototypeDescriptor
}

// Return sets up results that will be returned by Client.InjectPrototypeDescriptor
func (mmInjectPrototypeDescriptor *mClientMockInjectPrototypeDescriptor) Return() *ClientMock {
	if mmInjectPrototypeDescriptor.mock.funcInjectPrototypeDescriptor != nil {
		mmInjectPrototypeDescriptor.mock.t.Fatalf("ClientMock.InjectPrototypeDescriptor mock is already set by Set")
	}

	if mmInjectPrototypeDescriptor.defaultExpectation == nil {
		mmInjectPrototypeDescriptor.defaultExpectation = &ClientMockInjectPrototypeDescriptorExpectation{mock: mmInjectPrototypeDescriptor.mock}
	}

	return mmInjectPrototypeDescriptor.mock
}

//Set uses given function f to mock the Client.InjectPrototypeDescriptor method
func (mmInjectPrototypeDescriptor *mClientMockInjectPrototypeDescriptor) Set(f func(r1 insolar.Reference, p1 PrototypeDescriptor)) *ClientMock {
	if mmInjectPrototypeDescriptor.defaultExpectation != nil {
		mmInjectPrototypeDescriptor.mock.t.Fatalf("Default expectation is already set for the Client.InjectPrototypeDescriptor method")
	}

	if len(mmInjectPrototypeDescriptor.expectations) > 0 {
		mmInjectPrototypeDescriptor.mock.t.Fatalf("Some expectations are already set for the Client.InjectPrototypeDescriptor method")
	}

	mmInjectPrototypeDescriptor.mock.funcInjectPrototypeDescriptor = f
	return mmInjectPrototypeDescriptor.mock
}

// InjectPrototypeDescriptor implements Client
func (mmInjectPrototypeDescriptor *ClientMock) InjectPrototypeDescriptor(r1 insolar.Reference, p1 PrototypeDescriptor) {
	mm_atomic.AddUint64(&mmInjectPrototypeDescriptor.beforeInjectPrototypeDescriptorCounter, 1)
	defer mm_atomic.AddUint64(&mmInjectPrototypeDescriptor.afterInjectPrototypeDescriptorCounter, 1)

	if mmInjectPrototypeDescriptor.inspectFuncInjectPrototypeDescriptor != nil {
		mmInjectPrototypeDescriptor.inspectFuncInjectPrototypeDescriptor(r1, p1)
	}

	params := &ClientMockInjectPrototypeDescriptorParams{r1, p1}

	// Record call args
	mmInjectPrototypeDescriptor.InjectPrototypeDescriptorMock.mutex.Lock()
	mmInjectPrototypeDescriptor.InjectPrototypeDescriptorMock.callArgs = append(mmInjectPrototypeDescriptor.InjectPrototypeDescriptorMock.callArgs, params)
	mmInjectPrototypeDescriptor.InjectPrototypeDescriptorMock.mutex.Unlock()

	for _, e := range mmInjectPrototypeDescriptor.InjectPrototypeDescriptorMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmInjectPrototypeDescriptor.InjectPrototypeDescriptorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInjectPrototypeDescriptor.InjectPrototypeDescriptorMock.defaultExpectation.Counter, 1)
		want := mmInjectPrototypeDescriptor.InjectPrototypeDescriptorMock.defaultExpectation.params
		got := ClientMockInjectPrototypeDescriptorParams{r1, p1}
		if want != nil && !minimock.Equal(*want, got) {
			mmInjectPrototypeDescriptor.t.Errorf("ClientMock.InjectPrototypeDescriptor got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmInjectPrototypeDescriptor.funcInjectPrototypeDescriptor != nil {
		mmInjectPrototypeDescriptor.funcInjectPrototypeDescriptor(r1, p1)
		return
	}
	mmInjectPrototypeDescriptor.t.Fatalf("Unexpected call to ClientMock.InjectPrototypeDescriptor. %v %v", r1, p1)

}

// InjectPrototypeDescriptorAfterCounter returns a count of finished ClientMock.InjectPrototypeDescriptor invocations
func (mmInjectPrototypeDescriptor *ClientMock) InjectPrototypeDescriptorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInjectPrototypeDescriptor.afterInjectPrototypeDescriptorCounter)
}

// InjectPrototypeDescriptorBeforeCounter returns a count of ClientMock.InjectPrototypeDescriptor invocations
func (mmInjectPrototypeDescriptor *ClientMock) InjectPrototypeDescriptorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInjectPrototypeDescriptor.beforeInjectPrototypeDescriptorCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.InjectPrototypeDescriptor.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInjectPrototypeDescriptor *mClientMockInjectPrototypeDescriptor) Calls() []*ClientMockInjectPrototypeDescriptorParams {
	mmInjectPrototypeDescriptor.mutex.RLock()

	argCopy := make([]*ClientMockInjectPrototypeDescriptorParams, len(mmInjectPrototypeDescriptor.callArgs))
	copy(argCopy, mmInjectPrototypeDescriptor.callArgs)

	mmInjectPrototypeDescriptor.mutex.RUnlock()

	return argCopy
}

// MinimockInjectPrototypeDescriptorDone returns true if the count of the InjectPrototypeDescriptor invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockInjectPrototypeDescriptorDone() bool {
	for _, e := range m.InjectPrototypeDescriptorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InjectPrototypeDescriptorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInjectPrototypeDescriptorCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInjectPrototypeDescriptor != nil && mm_atomic.LoadUint64(&m.afterInjectPrototypeDescriptorCounter) < 1 {
		return false
	}
	return true
}

// MinimockInjectPrototypeDescriptorInspect logs each unmet expectation
func (m *ClientMock) MinimockInjectPrototypeDescriptorInspect() {
	for _, e := range m.InjectPrototypeDescriptorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.InjectPrototypeDescriptor with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InjectPrototypeDescriptorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInjectPrototypeDescriptorCounter) < 1 {
		if m.InjectPrototypeDescriptorMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.InjectPrototypeDescriptor")
		} else {
			m.t.Errorf("Expected call to ClientMock.InjectPrototypeDescriptor with params: %#v", *m.InjectPrototypeDescriptorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInjectPrototypeDescriptor != nil && mm_atomic.LoadUint64(&m.afterInjectPrototypeDescriptorCounter) < 1 {
		m.t.Error("Expected call to ClientMock.InjectPrototypeDescriptor")
	}
}

type mClientMockRegisterIncomingRequest struct {
	mock               *ClientMock
	defaultExpectation *ClientMockRegisterIncomingRequestExpectation
	expectations       []*ClientMockRegisterIncomingRequestExpectation

	callArgs []*ClientMockRegisterIncomingRequestParams
	mutex    sync.RWMutex
}

// ClientMockRegisterIncomingRequestExpectation specifies expectation struct of the Client.RegisterIncomingRequest
type ClientMockRegisterIncomingRequestExpectation struct {
	mock    *ClientMock
	params  *ClientMockRegisterIncomingRequestParams
	results *ClientMockRegisterIncomingRequestResults
	Counter uint64
}

// ClientMockRegisterIncomingRequestParams contains parameters of the Client.RegisterIncomingRequest
type ClientMockRegisterIncomingRequestParams struct {
	ctx     context.Context
	request *record.IncomingRequest
}

// ClientMockRegisterIncomingRequestResults contains results of the Client.RegisterIncomingRequest
type ClientMockRegisterIncomingRequestResults struct {
	rp1 *payload.RequestInfo
	err error
}

// Expect sets up expected params for Client.RegisterIncomingRequest
func (mmRegisterIncomingRequest *mClientMockRegisterIncomingRequest) Expect(ctx context.Context, request *record.IncomingRequest) *mClientMockRegisterIncomingRequest {
	if mmRegisterIncomingRequest.mock.funcRegisterIncomingRequest != nil {
		mmRegisterIncomingRequest.mock.t.Fatalf("ClientMock.RegisterIncomingRequest mock is already set by Set")
	}

	if mmRegisterIncomingRequest.defaultExpectation == nil {
		mmRegisterIncomingRequest.defaultExpectation = &ClientMockRegisterIncomingRequestExpectation{}
	}

	mmRegisterIncomingRequest.defaultExpectation.params = &ClientMockRegisterIncomingRequestParams{ctx, request}
	for _, e := range mmRegisterIncomingRequest.expectations {
		if minimock.Equal(e.params, mmRegisterIncomingRequest.defaultExpectation.params) {
			mmRegisterIncomingRequest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegisterIncomingRequest.defaultExpectation.params)
		}
	}

	return mmRegisterIncomingRequest
}

// Inspect accepts an inspector function that has same arguments as the Client.RegisterIncomingRequest
func (mmRegisterIncomingRequest *mClientMockRegisterIncomingRequest) Inspect(f func(ctx context.Context, request *record.IncomingRequest)) *mClientMockRegisterIncomingRequest {
	if mmRegisterIncomingRequest.mock.inspectFuncRegisterIncomingRequest != nil {
		mmRegisterIncomingRequest.mock.t.Fatalf("Inspect function is already set for ClientMock.RegisterIncomingRequest")
	}

	mmRegisterIncomingRequest.mock.inspectFuncRegisterIncomingRequest = f

	return mmRegisterIncomingRequest
}

// Return sets up results that will be returned by Client.RegisterIncomingRequest
func (mmRegisterIncomingRequest *mClientMockRegisterIncomingRequest) Return(rp1 *payload.RequestInfo, err error) *ClientMock {
	if mmRegisterIncomingRequest.mock.funcRegisterIncomingRequest != nil {
		mmRegisterIncomingRequest.mock.t.Fatalf("ClientMock.RegisterIncomingRequest mock is already set by Set")
	}

	if mmRegisterIncomingRequest.defaultExpectation == nil {
		mmRegisterIncomingRequest.defaultExpectation = &ClientMockRegisterIncomingRequestExpectation{mock: mmRegisterIncomingRequest.mock}
	}
	mmRegisterIncomingRequest.defaultExpectation.results = &ClientMockRegisterIncomingRequestResults{rp1, err}
	return mmRegisterIncomingRequest.mock
}

//Set uses given function f to mock the Client.RegisterIncomingRequest method
func (mmRegisterIncomingRequest *mClientMockRegisterIncomingRequest) Set(f func(ctx context.Context, request *record.IncomingRequest) (rp1 *payload.RequestInfo, err error)) *ClientMock {
	if mmRegisterIncomingRequest.defaultExpectation != nil {
		mmRegisterIncomingRequest.mock.t.Fatalf("Default expectation is already set for the Client.RegisterIncomingRequest method")
	}

	if len(mmRegisterIncomingRequest.expectations) > 0 {
		mmRegisterIncomingRequest.mock.t.Fatalf("Some expectations are already set for the Client.RegisterIncomingRequest method")
	}

	mmRegisterIncomingRequest.mock.funcRegisterIncomingRequest = f
	return mmRegisterIncomingRequest.mock
}

// When sets expectation for the Client.RegisterIncomingRequest which will trigger the result defined by the following
// Then helper
func (mmRegisterIncomingRequest *mClientMockRegisterIncomingRequest) When(ctx context.Context, request *record.IncomingRequest) *ClientMockRegisterIncomingRequestExpectation {
	if mmRegisterIncomingRequest.mock.funcRegisterIncomingRequest != nil {
		mmRegisterIncomingRequest.mock.t.Fatalf("ClientMock.RegisterIncomingRequest mock is already set by Set")
	}

	expectation := &ClientMockRegisterIncomingRequestExpectation{
		mock:   mmRegisterIncomingRequest.mock,
		params: &ClientMockRegisterIncomingRequestParams{ctx, request},
	}
	mmRegisterIncomingRequest.expectations = append(mmRegisterIncomingRequest.expectations, expectation)
	return expectation
}

// Then sets up Client.RegisterIncomingRequest return parameters for the expectation previously defined by the When method
func (e *ClientMockRegisterIncomingRequestExpectation) Then(rp1 *payload.RequestInfo, err error) *ClientMock {
	e.results = &ClientMockRegisterIncomingRequestResults{rp1, err}
	return e.mock
}

// RegisterIncomingRequest implements Client
func (mmRegisterIncomingRequest *ClientMock) RegisterIncomingRequest(ctx context.Context, request *record.IncomingRequest) (rp1 *payload.RequestInfo, err error) {
	mm_atomic.AddUint64(&mmRegisterIncomingRequest.beforeRegisterIncomingRequestCounter, 1)
	defer mm_atomic.AddUint64(&mmRegisterIncomingRequest.afterRegisterIncomingRequestCounter, 1)

	if mmRegisterIncomingRequest.inspectFuncRegisterIncomingRequest != nil {
		mmRegisterIncomingRequest.inspectFuncRegisterIncomingRequest(ctx, request)
	}

	params := &ClientMockRegisterIncomingRequestParams{ctx, request}

	// Record call args
	mmRegisterIncomingRequest.RegisterIncomingRequestMock.mutex.Lock()
	mmRegisterIncomingRequest.RegisterIncomingRequestMock.callArgs = append(mmRegisterIncomingRequest.RegisterIncomingRequestMock.callArgs, params)
	mmRegisterIncomingRequest.RegisterIncomingRequestMock.mutex.Unlock()

	for _, e := range mmRegisterIncomingRequest.RegisterIncomingRequestMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmRegisterIncomingRequest.RegisterIncomingRequestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegisterIncomingRequest.RegisterIncomingRequestMock.defaultExpectation.Counter, 1)
		want := mmRegisterIncomingRequest.RegisterIncomingRequestMock.defaultExpectation.params
		got := ClientMockRegisterIncomingRequestParams{ctx, request}
		if want != nil && !minimock.Equal(*want, got) {
			mmRegisterIncomingRequest.t.Errorf("ClientMock.RegisterIncomingRequest got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmRegisterIncomingRequest.RegisterIncomingRequestMock.defaultExpectation.results
		if results == nil {
			mmRegisterIncomingRequest.t.Fatal("No results are set for the ClientMock.RegisterIncomingRequest")
		}
		return (*results).rp1, (*results).err
	}
	if mmRegisterIncomingRequest.funcRegisterIncomingRequest != nil {
		return mmRegisterIncomingRequest.funcRegisterIncomingRequest(ctx, request)
	}
	mmRegisterIncomingRequest.t.Fatalf("Unexpected call to ClientMock.RegisterIncomingRequest. %v %v", ctx, request)
	return
}

// RegisterIncomingRequestAfterCounter returns a count of finished ClientMock.RegisterIncomingRequest invocations
func (mmRegisterIncomingRequest *ClientMock) RegisterIncomingRequestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterIncomingRequest.afterRegisterIncomingRequestCounter)
}

// RegisterIncomingRequestBeforeCounter returns a count of ClientMock.RegisterIncomingRequest invocations
func (mmRegisterIncomingRequest *ClientMock) RegisterIncomingRequestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterIncomingRequest.beforeRegisterIncomingRequestCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.RegisterIncomingRequest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegisterIncomingRequest *mClientMockRegisterIncomingRequest) Calls() []*ClientMockRegisterIncomingRequestParams {
	mmRegisterIncomingRequest.mutex.RLock()

	argCopy := make([]*ClientMockRegisterIncomingRequestParams, len(mmRegisterIncomingRequest.callArgs))
	copy(argCopy, mmRegisterIncomingRequest.callArgs)

	mmRegisterIncomingRequest.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterIncomingRequestDone returns true if the count of the RegisterIncomingRequest invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockRegisterIncomingRequestDone() bool {
	for _, e := range m.RegisterIncomingRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterIncomingRequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterIncomingRequestCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterIncomingRequest != nil && mm_atomic.LoadUint64(&m.afterRegisterIncomingRequestCounter) < 1 {
		return false
	}
	return true
}

// MinimockRegisterIncomingRequestInspect logs each unmet expectation
func (m *ClientMock) MinimockRegisterIncomingRequestInspect() {
	for _, e := range m.RegisterIncomingRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.RegisterIncomingRequest with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterIncomingRequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterIncomingRequestCounter) < 1 {
		if m.RegisterIncomingRequestMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.RegisterIncomingRequest")
		} else {
			m.t.Errorf("Expected call to ClientMock.RegisterIncomingRequest with params: %#v", *m.RegisterIncomingRequestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterIncomingRequest != nil && mm_atomic.LoadUint64(&m.afterRegisterIncomingRequestCounter) < 1 {
		m.t.Error("Expected call to ClientMock.RegisterIncomingRequest")
	}
}

type mClientMockRegisterOutgoingRequest struct {
	mock               *ClientMock
	defaultExpectation *ClientMockRegisterOutgoingRequestExpectation
	expectations       []*ClientMockRegisterOutgoingRequestExpectation

	callArgs []*ClientMockRegisterOutgoingRequestParams
	mutex    sync.RWMutex
}

// ClientMockRegisterOutgoingRequestExpectation specifies expectation struct of the Client.RegisterOutgoingRequest
type ClientMockRegisterOutgoingRequestExpectation struct {
	mock    *ClientMock
	params  *ClientMockRegisterOutgoingRequestParams
	results *ClientMockRegisterOutgoingRequestResults
	Counter uint64
}

// ClientMockRegisterOutgoingRequestParams contains parameters of the Client.RegisterOutgoingRequest
type ClientMockRegisterOutgoingRequestParams struct {
	ctx     context.Context
	request *record.OutgoingRequest
}

// ClientMockRegisterOutgoingRequestResults contains results of the Client.RegisterOutgoingRequest
type ClientMockRegisterOutgoingRequestResults struct {
	rp1 *payload.RequestInfo
	err error
}

// Expect sets up expected params for Client.RegisterOutgoingRequest
func (mmRegisterOutgoingRequest *mClientMockRegisterOutgoingRequest) Expect(ctx context.Context, request *record.OutgoingRequest) *mClientMockRegisterOutgoingRequest {
	if mmRegisterOutgoingRequest.mock.funcRegisterOutgoingRequest != nil {
		mmRegisterOutgoingRequest.mock.t.Fatalf("ClientMock.RegisterOutgoingRequest mock is already set by Set")
	}

	if mmRegisterOutgoingRequest.defaultExpectation == nil {
		mmRegisterOutgoingRequest.defaultExpectation = &ClientMockRegisterOutgoingRequestExpectation{}
	}

	mmRegisterOutgoingRequest.defaultExpectation.params = &ClientMockRegisterOutgoingRequestParams{ctx, request}
	for _, e := range mmRegisterOutgoingRequest.expectations {
		if minimock.Equal(e.params, mmRegisterOutgoingRequest.defaultExpectation.params) {
			mmRegisterOutgoingRequest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegisterOutgoingRequest.defaultExpectation.params)
		}
	}

	return mmRegisterOutgoingRequest
}

// Inspect accepts an inspector function that has same arguments as the Client.RegisterOutgoingRequest
func (mmRegisterOutgoingRequest *mClientMockRegisterOutgoingRequest) Inspect(f func(ctx context.Context, request *record.OutgoingRequest)) *mClientMockRegisterOutgoingRequest {
	if mmRegisterOutgoingRequest.mock.inspectFuncRegisterOutgoingRequest != nil {
		mmRegisterOutgoingRequest.mock.t.Fatalf("Inspect function is already set for ClientMock.RegisterOutgoingRequest")
	}

	mmRegisterOutgoingRequest.mock.inspectFuncRegisterOutgoingRequest = f

	return mmRegisterOutgoingRequest
}

// Return sets up results that will be returned by Client.RegisterOutgoingRequest
func (mmRegisterOutgoingRequest *mClientMockRegisterOutgoingRequest) Return(rp1 *payload.RequestInfo, err error) *ClientMock {
	if mmRegisterOutgoingRequest.mock.funcRegisterOutgoingRequest != nil {
		mmRegisterOutgoingRequest.mock.t.Fatalf("ClientMock.RegisterOutgoingRequest mock is already set by Set")
	}

	if mmRegisterOutgoingRequest.defaultExpectation == nil {
		mmRegisterOutgoingRequest.defaultExpectation = &ClientMockRegisterOutgoingRequestExpectation{mock: mmRegisterOutgoingRequest.mock}
	}
	mmRegisterOutgoingRequest.defaultExpectation.results = &ClientMockRegisterOutgoingRequestResults{rp1, err}
	return mmRegisterOutgoingRequest.mock
}

//Set uses given function f to mock the Client.RegisterOutgoingRequest method
func (mmRegisterOutgoingRequest *mClientMockRegisterOutgoingRequest) Set(f func(ctx context.Context, request *record.OutgoingRequest) (rp1 *payload.RequestInfo, err error)) *ClientMock {
	if mmRegisterOutgoingRequest.defaultExpectation != nil {
		mmRegisterOutgoingRequest.mock.t.Fatalf("Default expectation is already set for the Client.RegisterOutgoingRequest method")
	}

	if len(mmRegisterOutgoingRequest.expectations) > 0 {
		mmRegisterOutgoingRequest.mock.t.Fatalf("Some expectations are already set for the Client.RegisterOutgoingRequest method")
	}

	mmRegisterOutgoingRequest.mock.funcRegisterOutgoingRequest = f
	return mmRegisterOutgoingRequest.mock
}

// When sets expectation for the Client.RegisterOutgoingRequest which will trigger the result defined by the following
// Then helper
func (mmRegisterOutgoingRequest *mClientMockRegisterOutgoingRequest) When(ctx context.Context, request *record.OutgoingRequest) *ClientMockRegisterOutgoingRequestExpectation {
	if mmRegisterOutgoingRequest.mock.funcRegisterOutgoingRequest != nil {
		mmRegisterOutgoingRequest.mock.t.Fatalf("ClientMock.RegisterOutgoingRequest mock is already set by Set")
	}

	expectation := &ClientMockRegisterOutgoingRequestExpectation{
		mock:   mmRegisterOutgoingRequest.mock,
		params: &ClientMockRegisterOutgoingRequestParams{ctx, request},
	}
	mmRegisterOutgoingRequest.expectations = append(mmRegisterOutgoingRequest.expectations, expectation)
	return expectation
}

// Then sets up Client.RegisterOutgoingRequest return parameters for the expectation previously defined by the When method
func (e *ClientMockRegisterOutgoingRequestExpectation) Then(rp1 *payload.RequestInfo, err error) *ClientMock {
	e.results = &ClientMockRegisterOutgoingRequestResults{rp1, err}
	return e.mock
}

// RegisterOutgoingRequest implements Client
func (mmRegisterOutgoingRequest *ClientMock) RegisterOutgoingRequest(ctx context.Context, request *record.OutgoingRequest) (rp1 *payload.RequestInfo, err error) {
	mm_atomic.AddUint64(&mmRegisterOutgoingRequest.beforeRegisterOutgoingRequestCounter, 1)
	defer mm_atomic.AddUint64(&mmRegisterOutgoingRequest.afterRegisterOutgoingRequestCounter, 1)

	if mmRegisterOutgoingRequest.inspectFuncRegisterOutgoingRequest != nil {
		mmRegisterOutgoingRequest.inspectFuncRegisterOutgoingRequest(ctx, request)
	}

	params := &ClientMockRegisterOutgoingRequestParams{ctx, request}

	// Record call args
	mmRegisterOutgoingRequest.RegisterOutgoingRequestMock.mutex.Lock()
	mmRegisterOutgoingRequest.RegisterOutgoingRequestMock.callArgs = append(mmRegisterOutgoingRequest.RegisterOutgoingRequestMock.callArgs, params)
	mmRegisterOutgoingRequest.RegisterOutgoingRequestMock.mutex.Unlock()

	for _, e := range mmRegisterOutgoingRequest.RegisterOutgoingRequestMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmRegisterOutgoingRequest.RegisterOutgoingRequestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegisterOutgoingRequest.RegisterOutgoingRequestMock.defaultExpectation.Counter, 1)
		want := mmRegisterOutgoingRequest.RegisterOutgoingRequestMock.defaultExpectation.params
		got := ClientMockRegisterOutgoingRequestParams{ctx, request}
		if want != nil && !minimock.Equal(*want, got) {
			mmRegisterOutgoingRequest.t.Errorf("ClientMock.RegisterOutgoingRequest got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmRegisterOutgoingRequest.RegisterOutgoingRequestMock.defaultExpectation.results
		if results == nil {
			mmRegisterOutgoingRequest.t.Fatal("No results are set for the ClientMock.RegisterOutgoingRequest")
		}
		return (*results).rp1, (*results).err
	}
	if mmRegisterOutgoingRequest.funcRegisterOutgoingRequest != nil {
		return mmRegisterOutgoingRequest.funcRegisterOutgoingRequest(ctx, request)
	}
	mmRegisterOutgoingRequest.t.Fatalf("Unexpected call to ClientMock.RegisterOutgoingRequest. %v %v", ctx, request)
	return
}

// RegisterOutgoingRequestAfterCounter returns a count of finished ClientMock.RegisterOutgoingRequest invocations
func (mmRegisterOutgoingRequest *ClientMock) RegisterOutgoingRequestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterOutgoingRequest.afterRegisterOutgoingRequestCounter)
}

// RegisterOutgoingRequestBeforeCounter returns a count of ClientMock.RegisterOutgoingRequest invocations
func (mmRegisterOutgoingRequest *ClientMock) RegisterOutgoingRequestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterOutgoingRequest.beforeRegisterOutgoingRequestCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.RegisterOutgoingRequest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegisterOutgoingRequest *mClientMockRegisterOutgoingRequest) Calls() []*ClientMockRegisterOutgoingRequestParams {
	mmRegisterOutgoingRequest.mutex.RLock()

	argCopy := make([]*ClientMockRegisterOutgoingRequestParams, len(mmRegisterOutgoingRequest.callArgs))
	copy(argCopy, mmRegisterOutgoingRequest.callArgs)

	mmRegisterOutgoingRequest.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterOutgoingRequestDone returns true if the count of the RegisterOutgoingRequest invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockRegisterOutgoingRequestDone() bool {
	for _, e := range m.RegisterOutgoingRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterOutgoingRequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterOutgoingRequestCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterOutgoingRequest != nil && mm_atomic.LoadUint64(&m.afterRegisterOutgoingRequestCounter) < 1 {
		return false
	}
	return true
}

// MinimockRegisterOutgoingRequestInspect logs each unmet expectation
func (m *ClientMock) MinimockRegisterOutgoingRequestInspect() {
	for _, e := range m.RegisterOutgoingRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.RegisterOutgoingRequest with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterOutgoingRequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterOutgoingRequestCounter) < 1 {
		if m.RegisterOutgoingRequestMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.RegisterOutgoingRequest")
		} else {
			m.t.Errorf("Expected call to ClientMock.RegisterOutgoingRequest with params: %#v", *m.RegisterOutgoingRequestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterOutgoingRequest != nil && mm_atomic.LoadUint64(&m.afterRegisterOutgoingRequestCounter) < 1 {
		m.t.Error("Expected call to ClientMock.RegisterOutgoingRequest")
	}
}

type mClientMockRegisterResult struct {
	mock               *ClientMock
	defaultExpectation *ClientMockRegisterResultExpectation
	expectations       []*ClientMockRegisterResultExpectation

	callArgs []*ClientMockRegisterResultParams
	mutex    sync.RWMutex
}

// ClientMockRegisterResultExpectation specifies expectation struct of the Client.RegisterResult
type ClientMockRegisterResultExpectation struct {
	mock    *ClientMock
	params  *ClientMockRegisterResultParams
	results *ClientMockRegisterResultResults
	Counter uint64
}

// ClientMockRegisterResultParams contains parameters of the Client.RegisterResult
type ClientMockRegisterResultParams struct {
	ctx     context.Context
	request insolar.Reference
	result  RequestResult
}

// ClientMockRegisterResultResults contains results of the Client.RegisterResult
type ClientMockRegisterResultResults struct {
	err error
}

// Expect sets up expected params for Client.RegisterResult
func (mmRegisterResult *mClientMockRegisterResult) Expect(ctx context.Context, request insolar.Reference, result RequestResult) *mClientMockRegisterResult {
	if mmRegisterResult.mock.funcRegisterResult != nil {
		mmRegisterResult.mock.t.Fatalf("ClientMock.RegisterResult mock is already set by Set")
	}

	if mmRegisterResult.defaultExpectation == nil {
		mmRegisterResult.defaultExpectation = &ClientMockRegisterResultExpectation{}
	}

	mmRegisterResult.defaultExpectation.params = &ClientMockRegisterResultParams{ctx, request, result}
	for _, e := range mmRegisterResult.expectations {
		if minimock.Equal(e.params, mmRegisterResult.defaultExpectation.params) {
			mmRegisterResult.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegisterResult.defaultExpectation.params)
		}
	}

	return mmRegisterResult
}

// Inspect accepts an inspector function that has same arguments as the Client.RegisterResult
func (mmRegisterResult *mClientMockRegisterResult) Inspect(f func(ctx context.Context, request insolar.Reference, result RequestResult)) *mClientMockRegisterResult {
	if mmRegisterResult.mock.inspectFuncRegisterResult != nil {
		mmRegisterResult.mock.t.Fatalf("Inspect function is already set for ClientMock.RegisterResult")
	}

	mmRegisterResult.mock.inspectFuncRegisterResult = f

	return mmRegisterResult
}

// Return sets up results that will be returned by Client.RegisterResult
func (mmRegisterResult *mClientMockRegisterResult) Return(err error) *ClientMock {
	if mmRegisterResult.mock.funcRegisterResult != nil {
		mmRegisterResult.mock.t.Fatalf("ClientMock.RegisterResult mock is already set by Set")
	}

	if mmRegisterResult.defaultExpectation == nil {
		mmRegisterResult.defaultExpectation = &ClientMockRegisterResultExpectation{mock: mmRegisterResult.mock}
	}
	mmRegisterResult.defaultExpectation.results = &ClientMockRegisterResultResults{err}
	return mmRegisterResult.mock
}

//Set uses given function f to mock the Client.RegisterResult method
func (mmRegisterResult *mClientMockRegisterResult) Set(f func(ctx context.Context, request insolar.Reference, result RequestResult) (err error)) *ClientMock {
	if mmRegisterResult.defaultExpectation != nil {
		mmRegisterResult.mock.t.Fatalf("Default expectation is already set for the Client.RegisterResult method")
	}

	if len(mmRegisterResult.expectations) > 0 {
		mmRegisterResult.mock.t.Fatalf("Some expectations are already set for the Client.RegisterResult method")
	}

	mmRegisterResult.mock.funcRegisterResult = f
	return mmRegisterResult.mock
}

// When sets expectation for the Client.RegisterResult which will trigger the result defined by the following
// Then helper
func (mmRegisterResult *mClientMockRegisterResult) When(ctx context.Context, request insolar.Reference, result RequestResult) *ClientMockRegisterResultExpectation {
	if mmRegisterResult.mock.funcRegisterResult != nil {
		mmRegisterResult.mock.t.Fatalf("ClientMock.RegisterResult mock is already set by Set")
	}

	expectation := &ClientMockRegisterResultExpectation{
		mock:   mmRegisterResult.mock,
		params: &ClientMockRegisterResultParams{ctx, request, result},
	}
	mmRegisterResult.expectations = append(mmRegisterResult.expectations, expectation)
	return expectation
}

// Then sets up Client.RegisterResult return parameters for the expectation previously defined by the When method
func (e *ClientMockRegisterResultExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockRegisterResultResults{err}
	return e.mock
}

// RegisterResult implements Client
func (mmRegisterResult *ClientMock) RegisterResult(ctx context.Context, request insolar.Reference, result RequestResult) (err error) {
	mm_atomic.AddUint64(&mmRegisterResult.beforeRegisterResultCounter, 1)
	defer mm_atomic.AddUint64(&mmRegisterResult.afterRegisterResultCounter, 1)

	if mmRegisterResult.inspectFuncRegisterResult != nil {
		mmRegisterResult.inspectFuncRegisterResult(ctx, request, result)
	}

	params := &ClientMockRegisterResultParams{ctx, request, result}

	// Record call args
	mmRegisterResult.RegisterResultMock.mutex.Lock()
	mmRegisterResult.RegisterResultMock.callArgs = append(mmRegisterResult.RegisterResultMock.callArgs, params)
	mmRegisterResult.RegisterResultMock.mutex.Unlock()

	for _, e := range mmRegisterResult.RegisterResultMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRegisterResult.RegisterResultMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegisterResult.RegisterResultMock.defaultExpectation.Counter, 1)
		want := mmRegisterResult.RegisterResultMock.defaultExpectation.params
		got := ClientMockRegisterResultParams{ctx, request, result}
		if want != nil && !minimock.Equal(*want, got) {
			mmRegisterResult.t.Errorf("ClientMock.RegisterResult got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmRegisterResult.RegisterResultMock.defaultExpectation.results
		if results == nil {
			mmRegisterResult.t.Fatal("No results are set for the ClientMock.RegisterResult")
		}
		return (*results).err
	}
	if mmRegisterResult.funcRegisterResult != nil {
		return mmRegisterResult.funcRegisterResult(ctx, request, result)
	}
	mmRegisterResult.t.Fatalf("Unexpected call to ClientMock.RegisterResult. %v %v %v", ctx, request, result)
	return
}

// RegisterResultAfterCounter returns a count of finished ClientMock.RegisterResult invocations
func (mmRegisterResult *ClientMock) RegisterResultAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterResult.afterRegisterResultCounter)
}

// RegisterResultBeforeCounter returns a count of ClientMock.RegisterResult invocations
func (mmRegisterResult *ClientMock) RegisterResultBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterResult.beforeRegisterResultCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.RegisterResult.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegisterResult *mClientMockRegisterResult) Calls() []*ClientMockRegisterResultParams {
	mmRegisterResult.mutex.RLock()

	argCopy := make([]*ClientMockRegisterResultParams, len(mmRegisterResult.callArgs))
	copy(argCopy, mmRegisterResult.callArgs)

	mmRegisterResult.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterResultDone returns true if the count of the RegisterResult invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockRegisterResultDone() bool {
	for _, e := range m.RegisterResultMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterResultMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterResultCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterResult != nil && mm_atomic.LoadUint64(&m.afterRegisterResultCounter) < 1 {
		return false
	}
	return true
}

// MinimockRegisterResultInspect logs each unmet expectation
func (m *ClientMock) MinimockRegisterResultInspect() {
	for _, e := range m.RegisterResultMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.RegisterResult with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterResultMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterResultCounter) < 1 {
		if m.RegisterResultMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.RegisterResult")
		} else {
			m.t.Errorf("Expected call to ClientMock.RegisterResult with params: %#v", *m.RegisterResultMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterResult != nil && mm_atomic.LoadUint64(&m.afterRegisterResultCounter) < 1 {
		m.t.Error("Expected call to ClientMock.RegisterResult")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ClientMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockActivatePrototypeInspect()

		m.MinimockDeployCodeInspect()

		m.MinimockGetCodeInspect()

		m.MinimockGetObjectInspect()

		m.MinimockGetPendingsInspect()

		m.MinimockGetPrototypeInspect()

		m.MinimockGetRequestInspect()

		m.MinimockHasPendingsInspect()

		m.MinimockInjectCodeDescriptorInspect()

		m.MinimockInjectFinishInspect()

		m.MinimockInjectPrototypeDescriptorInspect()

		m.MinimockRegisterIncomingRequestInspect()

		m.MinimockRegisterOutgoingRequestInspect()

		m.MinimockRegisterResultInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockActivatePrototypeDone() &&
		m.MinimockDeployCodeDone() &&
		m.MinimockGetCodeDone() &&
		m.MinimockGetObjectDone() &&
		m.MinimockGetPendingsDone() &&
		m.MinimockGetPrototypeDone() &&
		m.MinimockGetRequestDone() &&
		m.MinimockHasPendingsDone() &&
		m.MinimockInjectCodeDescriptorDone() &&
		m.MinimockInjectFinishDone() &&
		m.MinimockInjectPrototypeDescriptorDone() &&
		m.MinimockRegisterIncomingRequestDone() &&
		m.MinimockRegisterOutgoingRequestDone() &&
		m.MinimockRegisterResultDone()
}
