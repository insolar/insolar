package machinesmanager

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/insolar"
)

// MachinesManagerMock implements MachinesManager
type MachinesManagerMock struct {
	t minimock.Tester

	funcGetExecutor          func(t insolar.MachineType) (m1 insolar.MachineLogicExecutor, err error)
	inspectFuncGetExecutor   func(t insolar.MachineType)
	afterGetExecutorCounter  uint64
	beforeGetExecutorCounter uint64
	GetExecutorMock          mMachinesManagerMockGetExecutor

	funcRegisterExecutor          func(t insolar.MachineType, e insolar.MachineLogicExecutor) (err error)
	inspectFuncRegisterExecutor   func(t insolar.MachineType, e insolar.MachineLogicExecutor)
	afterRegisterExecutorCounter  uint64
	beforeRegisterExecutorCounter uint64
	RegisterExecutorMock          mMachinesManagerMockRegisterExecutor
}

// NewMachinesManagerMock returns a mock for MachinesManager
func NewMachinesManagerMock(t minimock.Tester) *MachinesManagerMock {
	m := &MachinesManagerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetExecutorMock = mMachinesManagerMockGetExecutor{mock: m}
	m.GetExecutorMock.callArgs = []*MachinesManagerMockGetExecutorParams{}

	m.RegisterExecutorMock = mMachinesManagerMockRegisterExecutor{mock: m}
	m.RegisterExecutorMock.callArgs = []*MachinesManagerMockRegisterExecutorParams{}

	return m
}

type mMachinesManagerMockGetExecutor struct {
	mock               *MachinesManagerMock
	defaultExpectation *MachinesManagerMockGetExecutorExpectation
	expectations       []*MachinesManagerMockGetExecutorExpectation

	callArgs []*MachinesManagerMockGetExecutorParams
	mutex    sync.RWMutex
}

// MachinesManagerMockGetExecutorExpectation specifies expectation struct of the MachinesManager.GetExecutor
type MachinesManagerMockGetExecutorExpectation struct {
	mock    *MachinesManagerMock
	params  *MachinesManagerMockGetExecutorParams
	results *MachinesManagerMockGetExecutorResults
	Counter uint64
}

// MachinesManagerMockGetExecutorParams contains parameters of the MachinesManager.GetExecutor
type MachinesManagerMockGetExecutorParams struct {
	t insolar.MachineType
}

// MachinesManagerMockGetExecutorResults contains results of the MachinesManager.GetExecutor
type MachinesManagerMockGetExecutorResults struct {
	m1  insolar.MachineLogicExecutor
	err error
}

// Expect sets up expected params for MachinesManager.GetExecutor
func (mmGetExecutor *mMachinesManagerMockGetExecutor) Expect(t insolar.MachineType) *mMachinesManagerMockGetExecutor {
	if mmGetExecutor.mock.funcGetExecutor != nil {
		mmGetExecutor.mock.t.Fatalf("MachinesManagerMock.GetExecutor mock is already set by Set")
	}

	if mmGetExecutor.defaultExpectation == nil {
		mmGetExecutor.defaultExpectation = &MachinesManagerMockGetExecutorExpectation{}
	}

	mmGetExecutor.defaultExpectation.params = &MachinesManagerMockGetExecutorParams{t}
	for _, e := range mmGetExecutor.expectations {
		if minimock.Equal(e.params, mmGetExecutor.defaultExpectation.params) {
			mmGetExecutor.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetExecutor.defaultExpectation.params)
		}
	}

	return mmGetExecutor
}

// Inspect accepts an inspector function that has same arguments as the MachinesManager.GetExecutor
func (mmGetExecutor *mMachinesManagerMockGetExecutor) Inspect(f func(t insolar.MachineType)) *mMachinesManagerMockGetExecutor {
	if mmGetExecutor.mock.inspectFuncGetExecutor != nil {
		mmGetExecutor.mock.t.Fatalf("Inspect function is already set for MachinesManagerMock.GetExecutor")
	}

	mmGetExecutor.mock.inspectFuncGetExecutor = f

	return mmGetExecutor
}

// Return sets up results that will be returned by MachinesManager.GetExecutor
func (mmGetExecutor *mMachinesManagerMockGetExecutor) Return(m1 insolar.MachineLogicExecutor, err error) *MachinesManagerMock {
	if mmGetExecutor.mock.funcGetExecutor != nil {
		mmGetExecutor.mock.t.Fatalf("MachinesManagerMock.GetExecutor mock is already set by Set")
	}

	if mmGetExecutor.defaultExpectation == nil {
		mmGetExecutor.defaultExpectation = &MachinesManagerMockGetExecutorExpectation{mock: mmGetExecutor.mock}
	}
	mmGetExecutor.defaultExpectation.results = &MachinesManagerMockGetExecutorResults{m1, err}
	return mmGetExecutor.mock
}

//Set uses given function f to mock the MachinesManager.GetExecutor method
func (mmGetExecutor *mMachinesManagerMockGetExecutor) Set(f func(t insolar.MachineType) (m1 insolar.MachineLogicExecutor, err error)) *MachinesManagerMock {
	if mmGetExecutor.defaultExpectation != nil {
		mmGetExecutor.mock.t.Fatalf("Default expectation is already set for the MachinesManager.GetExecutor method")
	}

	if len(mmGetExecutor.expectations) > 0 {
		mmGetExecutor.mock.t.Fatalf("Some expectations are already set for the MachinesManager.GetExecutor method")
	}

	mmGetExecutor.mock.funcGetExecutor = f
	return mmGetExecutor.mock
}

// When sets expectation for the MachinesManager.GetExecutor which will trigger the result defined by the following
// Then helper
func (mmGetExecutor *mMachinesManagerMockGetExecutor) When(t insolar.MachineType) *MachinesManagerMockGetExecutorExpectation {
	if mmGetExecutor.mock.funcGetExecutor != nil {
		mmGetExecutor.mock.t.Fatalf("MachinesManagerMock.GetExecutor mock is already set by Set")
	}

	expectation := &MachinesManagerMockGetExecutorExpectation{
		mock:   mmGetExecutor.mock,
		params: &MachinesManagerMockGetExecutorParams{t},
	}
	mmGetExecutor.expectations = append(mmGetExecutor.expectations, expectation)
	return expectation
}

// Then sets up MachinesManager.GetExecutor return parameters for the expectation previously defined by the When method
func (e *MachinesManagerMockGetExecutorExpectation) Then(m1 insolar.MachineLogicExecutor, err error) *MachinesManagerMock {
	e.results = &MachinesManagerMockGetExecutorResults{m1, err}
	return e.mock
}

// GetExecutor implements MachinesManager
func (mmGetExecutor *MachinesManagerMock) GetExecutor(t insolar.MachineType) (m1 insolar.MachineLogicExecutor, err error) {
	mm_atomic.AddUint64(&mmGetExecutor.beforeGetExecutorCounter, 1)
	defer mm_atomic.AddUint64(&mmGetExecutor.afterGetExecutorCounter, 1)

	if mmGetExecutor.inspectFuncGetExecutor != nil {
		mmGetExecutor.inspectFuncGetExecutor(t)
	}

	params := &MachinesManagerMockGetExecutorParams{t}

	// Record call args
	mmGetExecutor.GetExecutorMock.mutex.Lock()
	mmGetExecutor.GetExecutorMock.callArgs = append(mmGetExecutor.GetExecutorMock.callArgs, params)
	mmGetExecutor.GetExecutorMock.mutex.Unlock()

	for _, e := range mmGetExecutor.GetExecutorMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmGetExecutor.GetExecutorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetExecutor.GetExecutorMock.defaultExpectation.Counter, 1)
		want := mmGetExecutor.GetExecutorMock.defaultExpectation.params
		got := MachinesManagerMockGetExecutorParams{t}
		if want != nil && !minimock.Equal(*want, got) {
			mmGetExecutor.t.Errorf("MachinesManagerMock.GetExecutor got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmGetExecutor.GetExecutorMock.defaultExpectation.results
		if results == nil {
			mmGetExecutor.t.Fatal("No results are set for the MachinesManagerMock.GetExecutor")
		}
		return (*results).m1, (*results).err
	}
	if mmGetExecutor.funcGetExecutor != nil {
		return mmGetExecutor.funcGetExecutor(t)
	}
	mmGetExecutor.t.Fatalf("Unexpected call to MachinesManagerMock.GetExecutor. %v", t)
	return
}

// GetExecutorAfterCounter returns a count of finished MachinesManagerMock.GetExecutor invocations
func (mmGetExecutor *MachinesManagerMock) GetExecutorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetExecutor.afterGetExecutorCounter)
}

// GetExecutorBeforeCounter returns a count of MachinesManagerMock.GetExecutor invocations
func (mmGetExecutor *MachinesManagerMock) GetExecutorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetExecutor.beforeGetExecutorCounter)
}

// Calls returns a list of arguments used in each call to MachinesManagerMock.GetExecutor.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetExecutor *mMachinesManagerMockGetExecutor) Calls() []*MachinesManagerMockGetExecutorParams {
	mmGetExecutor.mutex.RLock()

	argCopy := make([]*MachinesManagerMockGetExecutorParams, len(mmGetExecutor.callArgs))
	copy(argCopy, mmGetExecutor.callArgs)

	mmGetExecutor.mutex.RUnlock()

	return argCopy
}

// MinimockGetExecutorDone returns true if the count of the GetExecutor invocations corresponds
// the number of defined expectations
func (m *MachinesManagerMock) MinimockGetExecutorDone() bool {
	for _, e := range m.GetExecutorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetExecutorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetExecutorCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetExecutor != nil && mm_atomic.LoadUint64(&m.afterGetExecutorCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetExecutorInspect logs each unmet expectation
func (m *MachinesManagerMock) MinimockGetExecutorInspect() {
	for _, e := range m.GetExecutorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MachinesManagerMock.GetExecutor with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetExecutorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetExecutorCounter) < 1 {
		if m.GetExecutorMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MachinesManagerMock.GetExecutor")
		} else {
			m.t.Errorf("Expected call to MachinesManagerMock.GetExecutor with params: %#v", *m.GetExecutorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetExecutor != nil && mm_atomic.LoadUint64(&m.afterGetExecutorCounter) < 1 {
		m.t.Error("Expected call to MachinesManagerMock.GetExecutor")
	}
}

type mMachinesManagerMockRegisterExecutor struct {
	mock               *MachinesManagerMock
	defaultExpectation *MachinesManagerMockRegisterExecutorExpectation
	expectations       []*MachinesManagerMockRegisterExecutorExpectation

	callArgs []*MachinesManagerMockRegisterExecutorParams
	mutex    sync.RWMutex
}

// MachinesManagerMockRegisterExecutorExpectation specifies expectation struct of the MachinesManager.RegisterExecutor
type MachinesManagerMockRegisterExecutorExpectation struct {
	mock    *MachinesManagerMock
	params  *MachinesManagerMockRegisterExecutorParams
	results *MachinesManagerMockRegisterExecutorResults
	Counter uint64
}

// MachinesManagerMockRegisterExecutorParams contains parameters of the MachinesManager.RegisterExecutor
type MachinesManagerMockRegisterExecutorParams struct {
	t insolar.MachineType
	e insolar.MachineLogicExecutor
}

// MachinesManagerMockRegisterExecutorResults contains results of the MachinesManager.RegisterExecutor
type MachinesManagerMockRegisterExecutorResults struct {
	err error
}

// Expect sets up expected params for MachinesManager.RegisterExecutor
func (mmRegisterExecutor *mMachinesManagerMockRegisterExecutor) Expect(t insolar.MachineType, e insolar.MachineLogicExecutor) *mMachinesManagerMockRegisterExecutor {
	if mmRegisterExecutor.mock.funcRegisterExecutor != nil {
		mmRegisterExecutor.mock.t.Fatalf("MachinesManagerMock.RegisterExecutor mock is already set by Set")
	}

	if mmRegisterExecutor.defaultExpectation == nil {
		mmRegisterExecutor.defaultExpectation = &MachinesManagerMockRegisterExecutorExpectation{}
	}

	mmRegisterExecutor.defaultExpectation.params = &MachinesManagerMockRegisterExecutorParams{t, e}
	for _, e := range mmRegisterExecutor.expectations {
		if minimock.Equal(e.params, mmRegisterExecutor.defaultExpectation.params) {
			mmRegisterExecutor.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegisterExecutor.defaultExpectation.params)
		}
	}

	return mmRegisterExecutor
}

// Inspect accepts an inspector function that has same arguments as the MachinesManager.RegisterExecutor
func (mmRegisterExecutor *mMachinesManagerMockRegisterExecutor) Inspect(f func(t insolar.MachineType, e insolar.MachineLogicExecutor)) *mMachinesManagerMockRegisterExecutor {
	if mmRegisterExecutor.mock.inspectFuncRegisterExecutor != nil {
		mmRegisterExecutor.mock.t.Fatalf("Inspect function is already set for MachinesManagerMock.RegisterExecutor")
	}

	mmRegisterExecutor.mock.inspectFuncRegisterExecutor = f

	return mmRegisterExecutor
}

// Return sets up results that will be returned by MachinesManager.RegisterExecutor
func (mmRegisterExecutor *mMachinesManagerMockRegisterExecutor) Return(err error) *MachinesManagerMock {
	if mmRegisterExecutor.mock.funcRegisterExecutor != nil {
		mmRegisterExecutor.mock.t.Fatalf("MachinesManagerMock.RegisterExecutor mock is already set by Set")
	}

	if mmRegisterExecutor.defaultExpectation == nil {
		mmRegisterExecutor.defaultExpectation = &MachinesManagerMockRegisterExecutorExpectation{mock: mmRegisterExecutor.mock}
	}
	mmRegisterExecutor.defaultExpectation.results = &MachinesManagerMockRegisterExecutorResults{err}
	return mmRegisterExecutor.mock
}

//Set uses given function f to mock the MachinesManager.RegisterExecutor method
func (mmRegisterExecutor *mMachinesManagerMockRegisterExecutor) Set(f func(t insolar.MachineType, e insolar.MachineLogicExecutor) (err error)) *MachinesManagerMock {
	if mmRegisterExecutor.defaultExpectation != nil {
		mmRegisterExecutor.mock.t.Fatalf("Default expectation is already set for the MachinesManager.RegisterExecutor method")
	}

	if len(mmRegisterExecutor.expectations) > 0 {
		mmRegisterExecutor.mock.t.Fatalf("Some expectations are already set for the MachinesManager.RegisterExecutor method")
	}

	mmRegisterExecutor.mock.funcRegisterExecutor = f
	return mmRegisterExecutor.mock
}

// When sets expectation for the MachinesManager.RegisterExecutor which will trigger the result defined by the following
// Then helper
func (mmRegisterExecutor *mMachinesManagerMockRegisterExecutor) When(t insolar.MachineType, e insolar.MachineLogicExecutor) *MachinesManagerMockRegisterExecutorExpectation {
	if mmRegisterExecutor.mock.funcRegisterExecutor != nil {
		mmRegisterExecutor.mock.t.Fatalf("MachinesManagerMock.RegisterExecutor mock is already set by Set")
	}

	expectation := &MachinesManagerMockRegisterExecutorExpectation{
		mock:   mmRegisterExecutor.mock,
		params: &MachinesManagerMockRegisterExecutorParams{t, e},
	}
	mmRegisterExecutor.expectations = append(mmRegisterExecutor.expectations, expectation)
	return expectation
}

// Then sets up MachinesManager.RegisterExecutor return parameters for the expectation previously defined by the When method
func (e *MachinesManagerMockRegisterExecutorExpectation) Then(err error) *MachinesManagerMock {
	e.results = &MachinesManagerMockRegisterExecutorResults{err}
	return e.mock
}

// RegisterExecutor implements MachinesManager
func (mmRegisterExecutor *MachinesManagerMock) RegisterExecutor(t insolar.MachineType, e insolar.MachineLogicExecutor) (err error) {
	mm_atomic.AddUint64(&mmRegisterExecutor.beforeRegisterExecutorCounter, 1)
	defer mm_atomic.AddUint64(&mmRegisterExecutor.afterRegisterExecutorCounter, 1)

	if mmRegisterExecutor.inspectFuncRegisterExecutor != nil {
		mmRegisterExecutor.inspectFuncRegisterExecutor(t, e)
	}

	params := &MachinesManagerMockRegisterExecutorParams{t, e}

	// Record call args
	mmRegisterExecutor.RegisterExecutorMock.mutex.Lock()
	mmRegisterExecutor.RegisterExecutorMock.callArgs = append(mmRegisterExecutor.RegisterExecutorMock.callArgs, params)
	mmRegisterExecutor.RegisterExecutorMock.mutex.Unlock()

	for _, e := range mmRegisterExecutor.RegisterExecutorMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRegisterExecutor.RegisterExecutorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegisterExecutor.RegisterExecutorMock.defaultExpectation.Counter, 1)
		want := mmRegisterExecutor.RegisterExecutorMock.defaultExpectation.params
		got := MachinesManagerMockRegisterExecutorParams{t, e}
		if want != nil && !minimock.Equal(*want, got) {
			mmRegisterExecutor.t.Errorf("MachinesManagerMock.RegisterExecutor got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmRegisterExecutor.RegisterExecutorMock.defaultExpectation.results
		if results == nil {
			mmRegisterExecutor.t.Fatal("No results are set for the MachinesManagerMock.RegisterExecutor")
		}
		return (*results).err
	}
	if mmRegisterExecutor.funcRegisterExecutor != nil {
		return mmRegisterExecutor.funcRegisterExecutor(t, e)
	}
	mmRegisterExecutor.t.Fatalf("Unexpected call to MachinesManagerMock.RegisterExecutor. %v %v", t, e)
	return
}

// RegisterExecutorAfterCounter returns a count of finished MachinesManagerMock.RegisterExecutor invocations
func (mmRegisterExecutor *MachinesManagerMock) RegisterExecutorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterExecutor.afterRegisterExecutorCounter)
}

// RegisterExecutorBeforeCounter returns a count of MachinesManagerMock.RegisterExecutor invocations
func (mmRegisterExecutor *MachinesManagerMock) RegisterExecutorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterExecutor.beforeRegisterExecutorCounter)
}

// Calls returns a list of arguments used in each call to MachinesManagerMock.RegisterExecutor.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegisterExecutor *mMachinesManagerMockRegisterExecutor) Calls() []*MachinesManagerMockRegisterExecutorParams {
	mmRegisterExecutor.mutex.RLock()

	argCopy := make([]*MachinesManagerMockRegisterExecutorParams, len(mmRegisterExecutor.callArgs))
	copy(argCopy, mmRegisterExecutor.callArgs)

	mmRegisterExecutor.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterExecutorDone returns true if the count of the RegisterExecutor invocations corresponds
// the number of defined expectations
func (m *MachinesManagerMock) MinimockRegisterExecutorDone() bool {
	for _, e := range m.RegisterExecutorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterExecutorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterExecutorCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterExecutor != nil && mm_atomic.LoadUint64(&m.afterRegisterExecutorCounter) < 1 {
		return false
	}
	return true
}

// MinimockRegisterExecutorInspect logs each unmet expectation
func (m *MachinesManagerMock) MinimockRegisterExecutorInspect() {
	for _, e := range m.RegisterExecutorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MachinesManagerMock.RegisterExecutor with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterExecutorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterExecutorCounter) < 1 {
		if m.RegisterExecutorMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MachinesManagerMock.RegisterExecutor")
		} else {
			m.t.Errorf("Expected call to MachinesManagerMock.RegisterExecutor with params: %#v", *m.RegisterExecutorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterExecutor != nil && mm_atomic.LoadUint64(&m.afterRegisterExecutorCounter) < 1 {
		m.t.Error("Expected call to MachinesManagerMock.RegisterExecutor")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *MachinesManagerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetExecutorInspect()

		m.MinimockRegisterExecutorInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *MachinesManagerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *MachinesManagerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetExecutorDone() &&
		m.MinimockRegisterExecutorDone()
}
