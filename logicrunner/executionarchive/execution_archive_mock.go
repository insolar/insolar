package executionarchive

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/insolar/insolar/logicrunner/executionarchive.ExecutionArchive -o ./execution_archive_mock.go

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/insolar"
	"github.com/insolar/insolar/logicrunner/transcript"
)

// ExecutionArchiveMock implements ExecutionArchive
type ExecutionArchiveMock struct {
	t minimock.Tester

	funcArchive          func(ctx context.Context, transcript *transcript.Transcript)
	inspectFuncArchive   func(ctx context.Context, transcript *transcript.Transcript)
	afterArchiveCounter  uint64
	beforeArchiveCounter uint64
	ArchiveMock          mExecutionArchiveMockArchive

	funcDone          func(transcript *transcript.Transcript) (b1 bool)
	inspectFuncDone   func(transcript *transcript.Transcript)
	afterDoneCounter  uint64
	beforeDoneCounter uint64
	DoneMock          mExecutionArchiveMockDone

	funcFindRequestLoop          func(ctx context.Context, reqRef insolar.Reference, apiRequestID string) (b1 bool)
	inspectFuncFindRequestLoop   func(ctx context.Context, reqRef insolar.Reference, apiRequestID string)
	afterFindRequestLoopCounter  uint64
	beforeFindRequestLoopCounter uint64
	FindRequestLoopMock          mExecutionArchiveMockFindRequestLoop

	funcGetActiveTranscript          func(req insolar.Reference) (tp1 *transcript.Transcript)
	inspectFuncGetActiveTranscript   func(req insolar.Reference)
	afterGetActiveTranscriptCounter  uint64
	beforeGetActiveTranscriptCounter uint64
	GetActiveTranscriptMock          mExecutionArchiveMockGetActiveTranscript

	funcIsEmpty          func() (b1 bool)
	inspectFuncIsEmpty   func()
	afterIsEmptyCounter  uint64
	beforeIsEmptyCounter uint64
	IsEmptyMock          mExecutionArchiveMockIsEmpty

	funcOnPulse          func(ctx context.Context) (ma1 []insolar.Message)
	inspectFuncOnPulse   func(ctx context.Context)
	afterOnPulseCounter  uint64
	beforeOnPulseCounter uint64
	OnPulseMock          mExecutionArchiveMockOnPulse
}

// NewExecutionArchiveMock returns a mock for ExecutionArchive
func NewExecutionArchiveMock(t minimock.Tester) *ExecutionArchiveMock {
	m := &ExecutionArchiveMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ArchiveMock = mExecutionArchiveMockArchive{mock: m}
	m.ArchiveMock.callArgs = []*ExecutionArchiveMockArchiveParams{}

	m.DoneMock = mExecutionArchiveMockDone{mock: m}
	m.DoneMock.callArgs = []*ExecutionArchiveMockDoneParams{}

	m.FindRequestLoopMock = mExecutionArchiveMockFindRequestLoop{mock: m}
	m.FindRequestLoopMock.callArgs = []*ExecutionArchiveMockFindRequestLoopParams{}

	m.GetActiveTranscriptMock = mExecutionArchiveMockGetActiveTranscript{mock: m}
	m.GetActiveTranscriptMock.callArgs = []*ExecutionArchiveMockGetActiveTranscriptParams{}

	m.IsEmptyMock = mExecutionArchiveMockIsEmpty{mock: m}

	m.OnPulseMock = mExecutionArchiveMockOnPulse{mock: m}
	m.OnPulseMock.callArgs = []*ExecutionArchiveMockOnPulseParams{}

	return m
}

type mExecutionArchiveMockArchive struct {
	mock               *ExecutionArchiveMock
	defaultExpectation *ExecutionArchiveMockArchiveExpectation
	expectations       []*ExecutionArchiveMockArchiveExpectation

	callArgs []*ExecutionArchiveMockArchiveParams
	mutex    sync.RWMutex
}

// ExecutionArchiveMockArchiveExpectation specifies expectation struct of the ExecutionArchive.Archive
type ExecutionArchiveMockArchiveExpectation struct {
	mock   *ExecutionArchiveMock
	params *ExecutionArchiveMockArchiveParams

	Counter uint64
}

// ExecutionArchiveMockArchiveParams contains parameters of the ExecutionArchive.Archive
type ExecutionArchiveMockArchiveParams struct {
	ctx        context.Context
	transcript *transcript.Transcript
}

// Expect sets up expected params for ExecutionArchive.Archive
func (mmArchive *mExecutionArchiveMockArchive) Expect(ctx context.Context, transcript *transcript.Transcript) *mExecutionArchiveMockArchive {
	if mmArchive.mock.funcArchive != nil {
		mmArchive.mock.t.Fatalf("ExecutionArchiveMock.Archive mock is already set by Set")
	}

	if mmArchive.defaultExpectation == nil {
		mmArchive.defaultExpectation = &ExecutionArchiveMockArchiveExpectation{}
	}

	mmArchive.defaultExpectation.params = &ExecutionArchiveMockArchiveParams{ctx, transcript}
	for _, e := range mmArchive.expectations {
		if minimock.Equal(e.params, mmArchive.defaultExpectation.params) {
			mmArchive.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmArchive.defaultExpectation.params)
		}
	}

	return mmArchive
}

// Inspect accepts an inspector function that has same arguments as the ExecutionArchive.Archive
func (mmArchive *mExecutionArchiveMockArchive) Inspect(f func(ctx context.Context, transcript *transcript.Transcript)) *mExecutionArchiveMockArchive {
	if mmArchive.mock.inspectFuncArchive != nil {
		mmArchive.mock.t.Fatalf("Inspect function is already set for ExecutionArchiveMock.Archive")
	}

	mmArchive.mock.inspectFuncArchive = f

	return mmArchive
}

// Return sets up results that will be returned by ExecutionArchive.Archive
func (mmArchive *mExecutionArchiveMockArchive) Return() *ExecutionArchiveMock {
	if mmArchive.mock.funcArchive != nil {
		mmArchive.mock.t.Fatalf("ExecutionArchiveMock.Archive mock is already set by Set")
	}

	if mmArchive.defaultExpectation == nil {
		mmArchive.defaultExpectation = &ExecutionArchiveMockArchiveExpectation{mock: mmArchive.mock}
	}

	return mmArchive.mock
}

//Set uses given function f to mock the ExecutionArchive.Archive method
func (mmArchive *mExecutionArchiveMockArchive) Set(f func(ctx context.Context, transcript *transcript.Transcript)) *ExecutionArchiveMock {
	if mmArchive.defaultExpectation != nil {
		mmArchive.mock.t.Fatalf("Default expectation is already set for the ExecutionArchive.Archive method")
	}

	if len(mmArchive.expectations) > 0 {
		mmArchive.mock.t.Fatalf("Some expectations are already set for the ExecutionArchive.Archive method")
	}

	mmArchive.mock.funcArchive = f
	return mmArchive.mock
}

// Archive implements ExecutionArchive
func (mmArchive *ExecutionArchiveMock) Archive(ctx context.Context, transcript *transcript.Transcript) {
	mm_atomic.AddUint64(&mmArchive.beforeArchiveCounter, 1)
	defer mm_atomic.AddUint64(&mmArchive.afterArchiveCounter, 1)

	if mmArchive.inspectFuncArchive != nil {
		mmArchive.inspectFuncArchive(ctx, transcript)
	}

	params := &ExecutionArchiveMockArchiveParams{ctx, transcript}

	// Record call args
	mmArchive.ArchiveMock.mutex.Lock()
	mmArchive.ArchiveMock.callArgs = append(mmArchive.ArchiveMock.callArgs, params)
	mmArchive.ArchiveMock.mutex.Unlock()

	for _, e := range mmArchive.ArchiveMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmArchive.ArchiveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmArchive.ArchiveMock.defaultExpectation.Counter, 1)
		want := mmArchive.ArchiveMock.defaultExpectation.params
		got := ExecutionArchiveMockArchiveParams{ctx, transcript}
		if want != nil && !minimock.Equal(*want, got) {
			mmArchive.t.Errorf("ExecutionArchiveMock.Archive got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmArchive.funcArchive != nil {
		mmArchive.funcArchive(ctx, transcript)
		return
	}
	mmArchive.t.Fatalf("Unexpected call to ExecutionArchiveMock.Archive. %v %v", ctx, transcript)

}

// ArchiveAfterCounter returns a count of finished ExecutionArchiveMock.Archive invocations
func (mmArchive *ExecutionArchiveMock) ArchiveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmArchive.afterArchiveCounter)
}

// ArchiveBeforeCounter returns a count of ExecutionArchiveMock.Archive invocations
func (mmArchive *ExecutionArchiveMock) ArchiveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmArchive.beforeArchiveCounter)
}

// Calls returns a list of arguments used in each call to ExecutionArchiveMock.Archive.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmArchive *mExecutionArchiveMockArchive) Calls() []*ExecutionArchiveMockArchiveParams {
	mmArchive.mutex.RLock()

	argCopy := make([]*ExecutionArchiveMockArchiveParams, len(mmArchive.callArgs))
	copy(argCopy, mmArchive.callArgs)

	mmArchive.mutex.RUnlock()

	return argCopy
}

// MinimockArchiveDone returns true if the count of the Archive invocations corresponds
// the number of defined expectations
func (m *ExecutionArchiveMock) MinimockArchiveDone() bool {
	for _, e := range m.ArchiveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ArchiveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterArchiveCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcArchive != nil && mm_atomic.LoadUint64(&m.afterArchiveCounter) < 1 {
		return false
	}
	return true
}

// MinimockArchiveInspect logs each unmet expectation
func (m *ExecutionArchiveMock) MinimockArchiveInspect() {
	for _, e := range m.ArchiveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionArchiveMock.Archive with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ArchiveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterArchiveCounter) < 1 {
		if m.ArchiveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionArchiveMock.Archive")
		} else {
			m.t.Errorf("Expected call to ExecutionArchiveMock.Archive with params: %#v", *m.ArchiveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcArchive != nil && mm_atomic.LoadUint64(&m.afterArchiveCounter) < 1 {
		m.t.Error("Expected call to ExecutionArchiveMock.Archive")
	}
}

type mExecutionArchiveMockDone struct {
	mock               *ExecutionArchiveMock
	defaultExpectation *ExecutionArchiveMockDoneExpectation
	expectations       []*ExecutionArchiveMockDoneExpectation

	callArgs []*ExecutionArchiveMockDoneParams
	mutex    sync.RWMutex
}

// ExecutionArchiveMockDoneExpectation specifies expectation struct of the ExecutionArchive.Done
type ExecutionArchiveMockDoneExpectation struct {
	mock    *ExecutionArchiveMock
	params  *ExecutionArchiveMockDoneParams
	results *ExecutionArchiveMockDoneResults
	Counter uint64
}

// ExecutionArchiveMockDoneParams contains parameters of the ExecutionArchive.Done
type ExecutionArchiveMockDoneParams struct {
	transcript *transcript.Transcript
}

// ExecutionArchiveMockDoneResults contains results of the ExecutionArchive.Done
type ExecutionArchiveMockDoneResults struct {
	b1 bool
}

// Expect sets up expected params for ExecutionArchive.Done
func (mmDone *mExecutionArchiveMockDone) Expect(transcript *transcript.Transcript) *mExecutionArchiveMockDone {
	if mmDone.mock.funcDone != nil {
		mmDone.mock.t.Fatalf("ExecutionArchiveMock.Done mock is already set by Set")
	}

	if mmDone.defaultExpectation == nil {
		mmDone.defaultExpectation = &ExecutionArchiveMockDoneExpectation{}
	}

	mmDone.defaultExpectation.params = &ExecutionArchiveMockDoneParams{transcript}
	for _, e := range mmDone.expectations {
		if minimock.Equal(e.params, mmDone.defaultExpectation.params) {
			mmDone.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDone.defaultExpectation.params)
		}
	}

	return mmDone
}

// Inspect accepts an inspector function that has same arguments as the ExecutionArchive.Done
func (mmDone *mExecutionArchiveMockDone) Inspect(f func(transcript *transcript.Transcript)) *mExecutionArchiveMockDone {
	if mmDone.mock.inspectFuncDone != nil {
		mmDone.mock.t.Fatalf("Inspect function is already set for ExecutionArchiveMock.Done")
	}

	mmDone.mock.inspectFuncDone = f

	return mmDone
}

// Return sets up results that will be returned by ExecutionArchive.Done
func (mmDone *mExecutionArchiveMockDone) Return(b1 bool) *ExecutionArchiveMock {
	if mmDone.mock.funcDone != nil {
		mmDone.mock.t.Fatalf("ExecutionArchiveMock.Done mock is already set by Set")
	}

	if mmDone.defaultExpectation == nil {
		mmDone.defaultExpectation = &ExecutionArchiveMockDoneExpectation{mock: mmDone.mock}
	}
	mmDone.defaultExpectation.results = &ExecutionArchiveMockDoneResults{b1}
	return mmDone.mock
}

//Set uses given function f to mock the ExecutionArchive.Done method
func (mmDone *mExecutionArchiveMockDone) Set(f func(transcript *transcript.Transcript) (b1 bool)) *ExecutionArchiveMock {
	if mmDone.defaultExpectation != nil {
		mmDone.mock.t.Fatalf("Default expectation is already set for the ExecutionArchive.Done method")
	}

	if len(mmDone.expectations) > 0 {
		mmDone.mock.t.Fatalf("Some expectations are already set for the ExecutionArchive.Done method")
	}

	mmDone.mock.funcDone = f
	return mmDone.mock
}

// When sets expectation for the ExecutionArchive.Done which will trigger the result defined by the following
// Then helper
func (mmDone *mExecutionArchiveMockDone) When(transcript *transcript.Transcript) *ExecutionArchiveMockDoneExpectation {
	if mmDone.mock.funcDone != nil {
		mmDone.mock.t.Fatalf("ExecutionArchiveMock.Done mock is already set by Set")
	}

	expectation := &ExecutionArchiveMockDoneExpectation{
		mock:   mmDone.mock,
		params: &ExecutionArchiveMockDoneParams{transcript},
	}
	mmDone.expectations = append(mmDone.expectations, expectation)
	return expectation
}

// Then sets up ExecutionArchive.Done return parameters for the expectation previously defined by the When method
func (e *ExecutionArchiveMockDoneExpectation) Then(b1 bool) *ExecutionArchiveMock {
	e.results = &ExecutionArchiveMockDoneResults{b1}
	return e.mock
}

// Done implements ExecutionArchive
func (mmDone *ExecutionArchiveMock) Done(transcript *transcript.Transcript) (b1 bool) {
	mm_atomic.AddUint64(&mmDone.beforeDoneCounter, 1)
	defer mm_atomic.AddUint64(&mmDone.afterDoneCounter, 1)

	if mmDone.inspectFuncDone != nil {
		mmDone.inspectFuncDone(transcript)
	}

	params := &ExecutionArchiveMockDoneParams{transcript}

	// Record call args
	mmDone.DoneMock.mutex.Lock()
	mmDone.DoneMock.callArgs = append(mmDone.DoneMock.callArgs, params)
	mmDone.DoneMock.mutex.Unlock()

	for _, e := range mmDone.DoneMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmDone.DoneMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDone.DoneMock.defaultExpectation.Counter, 1)
		want := mmDone.DoneMock.defaultExpectation.params
		got := ExecutionArchiveMockDoneParams{transcript}
		if want != nil && !minimock.Equal(*want, got) {
			mmDone.t.Errorf("ExecutionArchiveMock.Done got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmDone.DoneMock.defaultExpectation.results
		if results == nil {
			mmDone.t.Fatal("No results are set for the ExecutionArchiveMock.Done")
		}
		return (*results).b1
	}
	if mmDone.funcDone != nil {
		return mmDone.funcDone(transcript)
	}
	mmDone.t.Fatalf("Unexpected call to ExecutionArchiveMock.Done. %v", transcript)
	return
}

// DoneAfterCounter returns a count of finished ExecutionArchiveMock.Done invocations
func (mmDone *ExecutionArchiveMock) DoneAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDone.afterDoneCounter)
}

// DoneBeforeCounter returns a count of ExecutionArchiveMock.Done invocations
func (mmDone *ExecutionArchiveMock) DoneBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDone.beforeDoneCounter)
}

// Calls returns a list of arguments used in each call to ExecutionArchiveMock.Done.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDone *mExecutionArchiveMockDone) Calls() []*ExecutionArchiveMockDoneParams {
	mmDone.mutex.RLock()

	argCopy := make([]*ExecutionArchiveMockDoneParams, len(mmDone.callArgs))
	copy(argCopy, mmDone.callArgs)

	mmDone.mutex.RUnlock()

	return argCopy
}

// MinimockDoneDone returns true if the count of the Done invocations corresponds
// the number of defined expectations
func (m *ExecutionArchiveMock) MinimockDoneDone() bool {
	for _, e := range m.DoneMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DoneMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDoneCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDone != nil && mm_atomic.LoadUint64(&m.afterDoneCounter) < 1 {
		return false
	}
	return true
}

// MinimockDoneInspect logs each unmet expectation
func (m *ExecutionArchiveMock) MinimockDoneInspect() {
	for _, e := range m.DoneMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionArchiveMock.Done with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DoneMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDoneCounter) < 1 {
		if m.DoneMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionArchiveMock.Done")
		} else {
			m.t.Errorf("Expected call to ExecutionArchiveMock.Done with params: %#v", *m.DoneMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDone != nil && mm_atomic.LoadUint64(&m.afterDoneCounter) < 1 {
		m.t.Error("Expected call to ExecutionArchiveMock.Done")
	}
}

type mExecutionArchiveMockFindRequestLoop struct {
	mock               *ExecutionArchiveMock
	defaultExpectation *ExecutionArchiveMockFindRequestLoopExpectation
	expectations       []*ExecutionArchiveMockFindRequestLoopExpectation

	callArgs []*ExecutionArchiveMockFindRequestLoopParams
	mutex    sync.RWMutex
}

// ExecutionArchiveMockFindRequestLoopExpectation specifies expectation struct of the ExecutionArchive.FindRequestLoop
type ExecutionArchiveMockFindRequestLoopExpectation struct {
	mock    *ExecutionArchiveMock
	params  *ExecutionArchiveMockFindRequestLoopParams
	results *ExecutionArchiveMockFindRequestLoopResults
	Counter uint64
}

// ExecutionArchiveMockFindRequestLoopParams contains parameters of the ExecutionArchive.FindRequestLoop
type ExecutionArchiveMockFindRequestLoopParams struct {
	ctx          context.Context
	reqRef       insolar.Reference
	apiRequestID string
}

// ExecutionArchiveMockFindRequestLoopResults contains results of the ExecutionArchive.FindRequestLoop
type ExecutionArchiveMockFindRequestLoopResults struct {
	b1 bool
}

// Expect sets up expected params for ExecutionArchive.FindRequestLoop
func (mmFindRequestLoop *mExecutionArchiveMockFindRequestLoop) Expect(ctx context.Context, reqRef insolar.Reference, apiRequestID string) *mExecutionArchiveMockFindRequestLoop {
	if mmFindRequestLoop.mock.funcFindRequestLoop != nil {
		mmFindRequestLoop.mock.t.Fatalf("ExecutionArchiveMock.FindRequestLoop mock is already set by Set")
	}

	if mmFindRequestLoop.defaultExpectation == nil {
		mmFindRequestLoop.defaultExpectation = &ExecutionArchiveMockFindRequestLoopExpectation{}
	}

	mmFindRequestLoop.defaultExpectation.params = &ExecutionArchiveMockFindRequestLoopParams{ctx, reqRef, apiRequestID}
	for _, e := range mmFindRequestLoop.expectations {
		if minimock.Equal(e.params, mmFindRequestLoop.defaultExpectation.params) {
			mmFindRequestLoop.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindRequestLoop.defaultExpectation.params)
		}
	}

	return mmFindRequestLoop
}

// Inspect accepts an inspector function that has same arguments as the ExecutionArchive.FindRequestLoop
func (mmFindRequestLoop *mExecutionArchiveMockFindRequestLoop) Inspect(f func(ctx context.Context, reqRef insolar.Reference, apiRequestID string)) *mExecutionArchiveMockFindRequestLoop {
	if mmFindRequestLoop.mock.inspectFuncFindRequestLoop != nil {
		mmFindRequestLoop.mock.t.Fatalf("Inspect function is already set for ExecutionArchiveMock.FindRequestLoop")
	}

	mmFindRequestLoop.mock.inspectFuncFindRequestLoop = f

	return mmFindRequestLoop
}

// Return sets up results that will be returned by ExecutionArchive.FindRequestLoop
func (mmFindRequestLoop *mExecutionArchiveMockFindRequestLoop) Return(b1 bool) *ExecutionArchiveMock {
	if mmFindRequestLoop.mock.funcFindRequestLoop != nil {
		mmFindRequestLoop.mock.t.Fatalf("ExecutionArchiveMock.FindRequestLoop mock is already set by Set")
	}

	if mmFindRequestLoop.defaultExpectation == nil {
		mmFindRequestLoop.defaultExpectation = &ExecutionArchiveMockFindRequestLoopExpectation{mock: mmFindRequestLoop.mock}
	}
	mmFindRequestLoop.defaultExpectation.results = &ExecutionArchiveMockFindRequestLoopResults{b1}
	return mmFindRequestLoop.mock
}

//Set uses given function f to mock the ExecutionArchive.FindRequestLoop method
func (mmFindRequestLoop *mExecutionArchiveMockFindRequestLoop) Set(f func(ctx context.Context, reqRef insolar.Reference, apiRequestID string) (b1 bool)) *ExecutionArchiveMock {
	if mmFindRequestLoop.defaultExpectation != nil {
		mmFindRequestLoop.mock.t.Fatalf("Default expectation is already set for the ExecutionArchive.FindRequestLoop method")
	}

	if len(mmFindRequestLoop.expectations) > 0 {
		mmFindRequestLoop.mock.t.Fatalf("Some expectations are already set for the ExecutionArchive.FindRequestLoop method")
	}

	mmFindRequestLoop.mock.funcFindRequestLoop = f
	return mmFindRequestLoop.mock
}

// When sets expectation for the ExecutionArchive.FindRequestLoop which will trigger the result defined by the following
// Then helper
func (mmFindRequestLoop *mExecutionArchiveMockFindRequestLoop) When(ctx context.Context, reqRef insolar.Reference, apiRequestID string) *ExecutionArchiveMockFindRequestLoopExpectation {
	if mmFindRequestLoop.mock.funcFindRequestLoop != nil {
		mmFindRequestLoop.mock.t.Fatalf("ExecutionArchiveMock.FindRequestLoop mock is already set by Set")
	}

	expectation := &ExecutionArchiveMockFindRequestLoopExpectation{
		mock:   mmFindRequestLoop.mock,
		params: &ExecutionArchiveMockFindRequestLoopParams{ctx, reqRef, apiRequestID},
	}
	mmFindRequestLoop.expectations = append(mmFindRequestLoop.expectations, expectation)
	return expectation
}

// Then sets up ExecutionArchive.FindRequestLoop return parameters for the expectation previously defined by the When method
func (e *ExecutionArchiveMockFindRequestLoopExpectation) Then(b1 bool) *ExecutionArchiveMock {
	e.results = &ExecutionArchiveMockFindRequestLoopResults{b1}
	return e.mock
}

// FindRequestLoop implements ExecutionArchive
func (mmFindRequestLoop *ExecutionArchiveMock) FindRequestLoop(ctx context.Context, reqRef insolar.Reference, apiRequestID string) (b1 bool) {
	mm_atomic.AddUint64(&mmFindRequestLoop.beforeFindRequestLoopCounter, 1)
	defer mm_atomic.AddUint64(&mmFindRequestLoop.afterFindRequestLoopCounter, 1)

	if mmFindRequestLoop.inspectFuncFindRequestLoop != nil {
		mmFindRequestLoop.inspectFuncFindRequestLoop(ctx, reqRef, apiRequestID)
	}

	params := &ExecutionArchiveMockFindRequestLoopParams{ctx, reqRef, apiRequestID}

	// Record call args
	mmFindRequestLoop.FindRequestLoopMock.mutex.Lock()
	mmFindRequestLoop.FindRequestLoopMock.callArgs = append(mmFindRequestLoop.FindRequestLoopMock.callArgs, params)
	mmFindRequestLoop.FindRequestLoopMock.mutex.Unlock()

	for _, e := range mmFindRequestLoop.FindRequestLoopMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmFindRequestLoop.FindRequestLoopMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFindRequestLoop.FindRequestLoopMock.defaultExpectation.Counter, 1)
		want := mmFindRequestLoop.FindRequestLoopMock.defaultExpectation.params
		got := ExecutionArchiveMockFindRequestLoopParams{ctx, reqRef, apiRequestID}
		if want != nil && !minimock.Equal(*want, got) {
			mmFindRequestLoop.t.Errorf("ExecutionArchiveMock.FindRequestLoop got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmFindRequestLoop.FindRequestLoopMock.defaultExpectation.results
		if results == nil {
			mmFindRequestLoop.t.Fatal("No results are set for the ExecutionArchiveMock.FindRequestLoop")
		}
		return (*results).b1
	}
	if mmFindRequestLoop.funcFindRequestLoop != nil {
		return mmFindRequestLoop.funcFindRequestLoop(ctx, reqRef, apiRequestID)
	}
	mmFindRequestLoop.t.Fatalf("Unexpected call to ExecutionArchiveMock.FindRequestLoop. %v %v %v", ctx, reqRef, apiRequestID)
	return
}

// FindRequestLoopAfterCounter returns a count of finished ExecutionArchiveMock.FindRequestLoop invocations
func (mmFindRequestLoop *ExecutionArchiveMock) FindRequestLoopAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindRequestLoop.afterFindRequestLoopCounter)
}

// FindRequestLoopBeforeCounter returns a count of ExecutionArchiveMock.FindRequestLoop invocations
func (mmFindRequestLoop *ExecutionArchiveMock) FindRequestLoopBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindRequestLoop.beforeFindRequestLoopCounter)
}

// Calls returns a list of arguments used in each call to ExecutionArchiveMock.FindRequestLoop.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindRequestLoop *mExecutionArchiveMockFindRequestLoop) Calls() []*ExecutionArchiveMockFindRequestLoopParams {
	mmFindRequestLoop.mutex.RLock()

	argCopy := make([]*ExecutionArchiveMockFindRequestLoopParams, len(mmFindRequestLoop.callArgs))
	copy(argCopy, mmFindRequestLoop.callArgs)

	mmFindRequestLoop.mutex.RUnlock()

	return argCopy
}

// MinimockFindRequestLoopDone returns true if the count of the FindRequestLoop invocations corresponds
// the number of defined expectations
func (m *ExecutionArchiveMock) MinimockFindRequestLoopDone() bool {
	for _, e := range m.FindRequestLoopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FindRequestLoopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFindRequestLoopCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindRequestLoop != nil && mm_atomic.LoadUint64(&m.afterFindRequestLoopCounter) < 1 {
		return false
	}
	return true
}

// MinimockFindRequestLoopInspect logs each unmet expectation
func (m *ExecutionArchiveMock) MinimockFindRequestLoopInspect() {
	for _, e := range m.FindRequestLoopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionArchiveMock.FindRequestLoop with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FindRequestLoopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFindRequestLoopCounter) < 1 {
		if m.FindRequestLoopMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionArchiveMock.FindRequestLoop")
		} else {
			m.t.Errorf("Expected call to ExecutionArchiveMock.FindRequestLoop with params: %#v", *m.FindRequestLoopMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindRequestLoop != nil && mm_atomic.LoadUint64(&m.afterFindRequestLoopCounter) < 1 {
		m.t.Error("Expected call to ExecutionArchiveMock.FindRequestLoop")
	}
}

type mExecutionArchiveMockGetActiveTranscript struct {
	mock               *ExecutionArchiveMock
	defaultExpectation *ExecutionArchiveMockGetActiveTranscriptExpectation
	expectations       []*ExecutionArchiveMockGetActiveTranscriptExpectation

	callArgs []*ExecutionArchiveMockGetActiveTranscriptParams
	mutex    sync.RWMutex
}

// ExecutionArchiveMockGetActiveTranscriptExpectation specifies expectation struct of the ExecutionArchive.GetActiveTranscript
type ExecutionArchiveMockGetActiveTranscriptExpectation struct {
	mock    *ExecutionArchiveMock
	params  *ExecutionArchiveMockGetActiveTranscriptParams
	results *ExecutionArchiveMockGetActiveTranscriptResults
	Counter uint64
}

// ExecutionArchiveMockGetActiveTranscriptParams contains parameters of the ExecutionArchive.GetActiveTranscript
type ExecutionArchiveMockGetActiveTranscriptParams struct {
	req insolar.Reference
}

// ExecutionArchiveMockGetActiveTranscriptResults contains results of the ExecutionArchive.GetActiveTranscript
type ExecutionArchiveMockGetActiveTranscriptResults struct {
	tp1 *transcript.Transcript
}

// Expect sets up expected params for ExecutionArchive.GetActiveTranscript
func (mmGetActiveTranscript *mExecutionArchiveMockGetActiveTranscript) Expect(req insolar.Reference) *mExecutionArchiveMockGetActiveTranscript {
	if mmGetActiveTranscript.mock.funcGetActiveTranscript != nil {
		mmGetActiveTranscript.mock.t.Fatalf("ExecutionArchiveMock.GetActiveTranscript mock is already set by Set")
	}

	if mmGetActiveTranscript.defaultExpectation == nil {
		mmGetActiveTranscript.defaultExpectation = &ExecutionArchiveMockGetActiveTranscriptExpectation{}
	}

	mmGetActiveTranscript.defaultExpectation.params = &ExecutionArchiveMockGetActiveTranscriptParams{req}
	for _, e := range mmGetActiveTranscript.expectations {
		if minimock.Equal(e.params, mmGetActiveTranscript.defaultExpectation.params) {
			mmGetActiveTranscript.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetActiveTranscript.defaultExpectation.params)
		}
	}

	return mmGetActiveTranscript
}

// Inspect accepts an inspector function that has same arguments as the ExecutionArchive.GetActiveTranscript
func (mmGetActiveTranscript *mExecutionArchiveMockGetActiveTranscript) Inspect(f func(req insolar.Reference)) *mExecutionArchiveMockGetActiveTranscript {
	if mmGetActiveTranscript.mock.inspectFuncGetActiveTranscript != nil {
		mmGetActiveTranscript.mock.t.Fatalf("Inspect function is already set for ExecutionArchiveMock.GetActiveTranscript")
	}

	mmGetActiveTranscript.mock.inspectFuncGetActiveTranscript = f

	return mmGetActiveTranscript
}

// Return sets up results that will be returned by ExecutionArchive.GetActiveTranscript
func (mmGetActiveTranscript *mExecutionArchiveMockGetActiveTranscript) Return(tp1 *transcript.Transcript) *ExecutionArchiveMock {
	if mmGetActiveTranscript.mock.funcGetActiveTranscript != nil {
		mmGetActiveTranscript.mock.t.Fatalf("ExecutionArchiveMock.GetActiveTranscript mock is already set by Set")
	}

	if mmGetActiveTranscript.defaultExpectation == nil {
		mmGetActiveTranscript.defaultExpectation = &ExecutionArchiveMockGetActiveTranscriptExpectation{mock: mmGetActiveTranscript.mock}
	}
	mmGetActiveTranscript.defaultExpectation.results = &ExecutionArchiveMockGetActiveTranscriptResults{tp1}
	return mmGetActiveTranscript.mock
}

//Set uses given function f to mock the ExecutionArchive.GetActiveTranscript method
func (mmGetActiveTranscript *mExecutionArchiveMockGetActiveTranscript) Set(f func(req insolar.Reference) (tp1 *transcript.Transcript)) *ExecutionArchiveMock {
	if mmGetActiveTranscript.defaultExpectation != nil {
		mmGetActiveTranscript.mock.t.Fatalf("Default expectation is already set for the ExecutionArchive.GetActiveTranscript method")
	}

	if len(mmGetActiveTranscript.expectations) > 0 {
		mmGetActiveTranscript.mock.t.Fatalf("Some expectations are already set for the ExecutionArchive.GetActiveTranscript method")
	}

	mmGetActiveTranscript.mock.funcGetActiveTranscript = f
	return mmGetActiveTranscript.mock
}

// When sets expectation for the ExecutionArchive.GetActiveTranscript which will trigger the result defined by the following
// Then helper
func (mmGetActiveTranscript *mExecutionArchiveMockGetActiveTranscript) When(req insolar.Reference) *ExecutionArchiveMockGetActiveTranscriptExpectation {
	if mmGetActiveTranscript.mock.funcGetActiveTranscript != nil {
		mmGetActiveTranscript.mock.t.Fatalf("ExecutionArchiveMock.GetActiveTranscript mock is already set by Set")
	}

	expectation := &ExecutionArchiveMockGetActiveTranscriptExpectation{
		mock:   mmGetActiveTranscript.mock,
		params: &ExecutionArchiveMockGetActiveTranscriptParams{req},
	}
	mmGetActiveTranscript.expectations = append(mmGetActiveTranscript.expectations, expectation)
	return expectation
}

// Then sets up ExecutionArchive.GetActiveTranscript return parameters for the expectation previously defined by the When method
func (e *ExecutionArchiveMockGetActiveTranscriptExpectation) Then(tp1 *transcript.Transcript) *ExecutionArchiveMock {
	e.results = &ExecutionArchiveMockGetActiveTranscriptResults{tp1}
	return e.mock
}

// GetActiveTranscript implements ExecutionArchive
func (mmGetActiveTranscript *ExecutionArchiveMock) GetActiveTranscript(req insolar.Reference) (tp1 *transcript.Transcript) {
	mm_atomic.AddUint64(&mmGetActiveTranscript.beforeGetActiveTranscriptCounter, 1)
	defer mm_atomic.AddUint64(&mmGetActiveTranscript.afterGetActiveTranscriptCounter, 1)

	if mmGetActiveTranscript.inspectFuncGetActiveTranscript != nil {
		mmGetActiveTranscript.inspectFuncGetActiveTranscript(req)
	}

	params := &ExecutionArchiveMockGetActiveTranscriptParams{req}

	// Record call args
	mmGetActiveTranscript.GetActiveTranscriptMock.mutex.Lock()
	mmGetActiveTranscript.GetActiveTranscriptMock.callArgs = append(mmGetActiveTranscript.GetActiveTranscriptMock.callArgs, params)
	mmGetActiveTranscript.GetActiveTranscriptMock.mutex.Unlock()

	for _, e := range mmGetActiveTranscript.GetActiveTranscriptMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp1
		}
	}

	if mmGetActiveTranscript.GetActiveTranscriptMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetActiveTranscript.GetActiveTranscriptMock.defaultExpectation.Counter, 1)
		want := mmGetActiveTranscript.GetActiveTranscriptMock.defaultExpectation.params
		got := ExecutionArchiveMockGetActiveTranscriptParams{req}
		if want != nil && !minimock.Equal(*want, got) {
			mmGetActiveTranscript.t.Errorf("ExecutionArchiveMock.GetActiveTranscript got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmGetActiveTranscript.GetActiveTranscriptMock.defaultExpectation.results
		if results == nil {
			mmGetActiveTranscript.t.Fatal("No results are set for the ExecutionArchiveMock.GetActiveTranscript")
		}
		return (*results).tp1
	}
	if mmGetActiveTranscript.funcGetActiveTranscript != nil {
		return mmGetActiveTranscript.funcGetActiveTranscript(req)
	}
	mmGetActiveTranscript.t.Fatalf("Unexpected call to ExecutionArchiveMock.GetActiveTranscript. %v", req)
	return
}

// GetActiveTranscriptAfterCounter returns a count of finished ExecutionArchiveMock.GetActiveTranscript invocations
func (mmGetActiveTranscript *ExecutionArchiveMock) GetActiveTranscriptAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetActiveTranscript.afterGetActiveTranscriptCounter)
}

// GetActiveTranscriptBeforeCounter returns a count of ExecutionArchiveMock.GetActiveTranscript invocations
func (mmGetActiveTranscript *ExecutionArchiveMock) GetActiveTranscriptBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetActiveTranscript.beforeGetActiveTranscriptCounter)
}

// Calls returns a list of arguments used in each call to ExecutionArchiveMock.GetActiveTranscript.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetActiveTranscript *mExecutionArchiveMockGetActiveTranscript) Calls() []*ExecutionArchiveMockGetActiveTranscriptParams {
	mmGetActiveTranscript.mutex.RLock()

	argCopy := make([]*ExecutionArchiveMockGetActiveTranscriptParams, len(mmGetActiveTranscript.callArgs))
	copy(argCopy, mmGetActiveTranscript.callArgs)

	mmGetActiveTranscript.mutex.RUnlock()

	return argCopy
}

// MinimockGetActiveTranscriptDone returns true if the count of the GetActiveTranscript invocations corresponds
// the number of defined expectations
func (m *ExecutionArchiveMock) MinimockGetActiveTranscriptDone() bool {
	for _, e := range m.GetActiveTranscriptMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetActiveTranscriptMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetActiveTranscriptCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetActiveTranscript != nil && mm_atomic.LoadUint64(&m.afterGetActiveTranscriptCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetActiveTranscriptInspect logs each unmet expectation
func (m *ExecutionArchiveMock) MinimockGetActiveTranscriptInspect() {
	for _, e := range m.GetActiveTranscriptMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionArchiveMock.GetActiveTranscript with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetActiveTranscriptMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetActiveTranscriptCounter) < 1 {
		if m.GetActiveTranscriptMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionArchiveMock.GetActiveTranscript")
		} else {
			m.t.Errorf("Expected call to ExecutionArchiveMock.GetActiveTranscript with params: %#v", *m.GetActiveTranscriptMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetActiveTranscript != nil && mm_atomic.LoadUint64(&m.afterGetActiveTranscriptCounter) < 1 {
		m.t.Error("Expected call to ExecutionArchiveMock.GetActiveTranscript")
	}
}

type mExecutionArchiveMockIsEmpty struct {
	mock               *ExecutionArchiveMock
	defaultExpectation *ExecutionArchiveMockIsEmptyExpectation
	expectations       []*ExecutionArchiveMockIsEmptyExpectation
}

// ExecutionArchiveMockIsEmptyExpectation specifies expectation struct of the ExecutionArchive.IsEmpty
type ExecutionArchiveMockIsEmptyExpectation struct {
	mock *ExecutionArchiveMock

	results *ExecutionArchiveMockIsEmptyResults
	Counter uint64
}

// ExecutionArchiveMockIsEmptyResults contains results of the ExecutionArchive.IsEmpty
type ExecutionArchiveMockIsEmptyResults struct {
	b1 bool
}

// Expect sets up expected params for ExecutionArchive.IsEmpty
func (mmIsEmpty *mExecutionArchiveMockIsEmpty) Expect() *mExecutionArchiveMockIsEmpty {
	if mmIsEmpty.mock.funcIsEmpty != nil {
		mmIsEmpty.mock.t.Fatalf("ExecutionArchiveMock.IsEmpty mock is already set by Set")
	}

	if mmIsEmpty.defaultExpectation == nil {
		mmIsEmpty.defaultExpectation = &ExecutionArchiveMockIsEmptyExpectation{}
	}

	return mmIsEmpty
}

// Inspect accepts an inspector function that has same arguments as the ExecutionArchive.IsEmpty
func (mmIsEmpty *mExecutionArchiveMockIsEmpty) Inspect(f func()) *mExecutionArchiveMockIsEmpty {
	if mmIsEmpty.mock.inspectFuncIsEmpty != nil {
		mmIsEmpty.mock.t.Fatalf("Inspect function is already set for ExecutionArchiveMock.IsEmpty")
	}

	mmIsEmpty.mock.inspectFuncIsEmpty = f

	return mmIsEmpty
}

// Return sets up results that will be returned by ExecutionArchive.IsEmpty
func (mmIsEmpty *mExecutionArchiveMockIsEmpty) Return(b1 bool) *ExecutionArchiveMock {
	if mmIsEmpty.mock.funcIsEmpty != nil {
		mmIsEmpty.mock.t.Fatalf("ExecutionArchiveMock.IsEmpty mock is already set by Set")
	}

	if mmIsEmpty.defaultExpectation == nil {
		mmIsEmpty.defaultExpectation = &ExecutionArchiveMockIsEmptyExpectation{mock: mmIsEmpty.mock}
	}
	mmIsEmpty.defaultExpectation.results = &ExecutionArchiveMockIsEmptyResults{b1}
	return mmIsEmpty.mock
}

//Set uses given function f to mock the ExecutionArchive.IsEmpty method
func (mmIsEmpty *mExecutionArchiveMockIsEmpty) Set(f func() (b1 bool)) *ExecutionArchiveMock {
	if mmIsEmpty.defaultExpectation != nil {
		mmIsEmpty.mock.t.Fatalf("Default expectation is already set for the ExecutionArchive.IsEmpty method")
	}

	if len(mmIsEmpty.expectations) > 0 {
		mmIsEmpty.mock.t.Fatalf("Some expectations are already set for the ExecutionArchive.IsEmpty method")
	}

	mmIsEmpty.mock.funcIsEmpty = f
	return mmIsEmpty.mock
}

// IsEmpty implements ExecutionArchive
func (mmIsEmpty *ExecutionArchiveMock) IsEmpty() (b1 bool) {
	mm_atomic.AddUint64(&mmIsEmpty.beforeIsEmptyCounter, 1)
	defer mm_atomic.AddUint64(&mmIsEmpty.afterIsEmptyCounter, 1)

	if mmIsEmpty.inspectFuncIsEmpty != nil {
		mmIsEmpty.inspectFuncIsEmpty()
	}

	if mmIsEmpty.IsEmptyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsEmpty.IsEmptyMock.defaultExpectation.Counter, 1)

		results := mmIsEmpty.IsEmptyMock.defaultExpectation.results
		if results == nil {
			mmIsEmpty.t.Fatal("No results are set for the ExecutionArchiveMock.IsEmpty")
		}
		return (*results).b1
	}
	if mmIsEmpty.funcIsEmpty != nil {
		return mmIsEmpty.funcIsEmpty()
	}
	mmIsEmpty.t.Fatalf("Unexpected call to ExecutionArchiveMock.IsEmpty.")
	return
}

// IsEmptyAfterCounter returns a count of finished ExecutionArchiveMock.IsEmpty invocations
func (mmIsEmpty *ExecutionArchiveMock) IsEmptyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsEmpty.afterIsEmptyCounter)
}

// IsEmptyBeforeCounter returns a count of ExecutionArchiveMock.IsEmpty invocations
func (mmIsEmpty *ExecutionArchiveMock) IsEmptyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsEmpty.beforeIsEmptyCounter)
}

// MinimockIsEmptyDone returns true if the count of the IsEmpty invocations corresponds
// the number of defined expectations
func (m *ExecutionArchiveMock) MinimockIsEmptyDone() bool {
	for _, e := range m.IsEmptyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsEmptyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsEmptyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsEmpty != nil && mm_atomic.LoadUint64(&m.afterIsEmptyCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsEmptyInspect logs each unmet expectation
func (m *ExecutionArchiveMock) MinimockIsEmptyInspect() {
	for _, e := range m.IsEmptyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ExecutionArchiveMock.IsEmpty")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsEmptyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsEmptyCounter) < 1 {
		m.t.Error("Expected call to ExecutionArchiveMock.IsEmpty")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsEmpty != nil && mm_atomic.LoadUint64(&m.afterIsEmptyCounter) < 1 {
		m.t.Error("Expected call to ExecutionArchiveMock.IsEmpty")
	}
}

type mExecutionArchiveMockOnPulse struct {
	mock               *ExecutionArchiveMock
	defaultExpectation *ExecutionArchiveMockOnPulseExpectation
	expectations       []*ExecutionArchiveMockOnPulseExpectation

	callArgs []*ExecutionArchiveMockOnPulseParams
	mutex    sync.RWMutex
}

// ExecutionArchiveMockOnPulseExpectation specifies expectation struct of the ExecutionArchive.OnPulse
type ExecutionArchiveMockOnPulseExpectation struct {
	mock    *ExecutionArchiveMock
	params  *ExecutionArchiveMockOnPulseParams
	results *ExecutionArchiveMockOnPulseResults
	Counter uint64
}

// ExecutionArchiveMockOnPulseParams contains parameters of the ExecutionArchive.OnPulse
type ExecutionArchiveMockOnPulseParams struct {
	ctx context.Context
}

// ExecutionArchiveMockOnPulseResults contains results of the ExecutionArchive.OnPulse
type ExecutionArchiveMockOnPulseResults struct {
	ma1 []insolar.Message
}

// Expect sets up expected params for ExecutionArchive.OnPulse
func (mmOnPulse *mExecutionArchiveMockOnPulse) Expect(ctx context.Context) *mExecutionArchiveMockOnPulse {
	if mmOnPulse.mock.funcOnPulse != nil {
		mmOnPulse.mock.t.Fatalf("ExecutionArchiveMock.OnPulse mock is already set by Set")
	}

	if mmOnPulse.defaultExpectation == nil {
		mmOnPulse.defaultExpectation = &ExecutionArchiveMockOnPulseExpectation{}
	}

	mmOnPulse.defaultExpectation.params = &ExecutionArchiveMockOnPulseParams{ctx}
	for _, e := range mmOnPulse.expectations {
		if minimock.Equal(e.params, mmOnPulse.defaultExpectation.params) {
			mmOnPulse.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOnPulse.defaultExpectation.params)
		}
	}

	return mmOnPulse
}

// Inspect accepts an inspector function that has same arguments as the ExecutionArchive.OnPulse
func (mmOnPulse *mExecutionArchiveMockOnPulse) Inspect(f func(ctx context.Context)) *mExecutionArchiveMockOnPulse {
	if mmOnPulse.mock.inspectFuncOnPulse != nil {
		mmOnPulse.mock.t.Fatalf("Inspect function is already set for ExecutionArchiveMock.OnPulse")
	}

	mmOnPulse.mock.inspectFuncOnPulse = f

	return mmOnPulse
}

// Return sets up results that will be returned by ExecutionArchive.OnPulse
func (mmOnPulse *mExecutionArchiveMockOnPulse) Return(ma1 []insolar.Message) *ExecutionArchiveMock {
	if mmOnPulse.mock.funcOnPulse != nil {
		mmOnPulse.mock.t.Fatalf("ExecutionArchiveMock.OnPulse mock is already set by Set")
	}

	if mmOnPulse.defaultExpectation == nil {
		mmOnPulse.defaultExpectation = &ExecutionArchiveMockOnPulseExpectation{mock: mmOnPulse.mock}
	}
	mmOnPulse.defaultExpectation.results = &ExecutionArchiveMockOnPulseResults{ma1}
	return mmOnPulse.mock
}

//Set uses given function f to mock the ExecutionArchive.OnPulse method
func (mmOnPulse *mExecutionArchiveMockOnPulse) Set(f func(ctx context.Context) (ma1 []insolar.Message)) *ExecutionArchiveMock {
	if mmOnPulse.defaultExpectation != nil {
		mmOnPulse.mock.t.Fatalf("Default expectation is already set for the ExecutionArchive.OnPulse method")
	}

	if len(mmOnPulse.expectations) > 0 {
		mmOnPulse.mock.t.Fatalf("Some expectations are already set for the ExecutionArchive.OnPulse method")
	}

	mmOnPulse.mock.funcOnPulse = f
	return mmOnPulse.mock
}

// When sets expectation for the ExecutionArchive.OnPulse which will trigger the result defined by the following
// Then helper
func (mmOnPulse *mExecutionArchiveMockOnPulse) When(ctx context.Context) *ExecutionArchiveMockOnPulseExpectation {
	if mmOnPulse.mock.funcOnPulse != nil {
		mmOnPulse.mock.t.Fatalf("ExecutionArchiveMock.OnPulse mock is already set by Set")
	}

	expectation := &ExecutionArchiveMockOnPulseExpectation{
		mock:   mmOnPulse.mock,
		params: &ExecutionArchiveMockOnPulseParams{ctx},
	}
	mmOnPulse.expectations = append(mmOnPulse.expectations, expectation)
	return expectation
}

// Then sets up ExecutionArchive.OnPulse return parameters for the expectation previously defined by the When method
func (e *ExecutionArchiveMockOnPulseExpectation) Then(ma1 []insolar.Message) *ExecutionArchiveMock {
	e.results = &ExecutionArchiveMockOnPulseResults{ma1}
	return e.mock
}

// OnPulse implements ExecutionArchive
func (mmOnPulse *ExecutionArchiveMock) OnPulse(ctx context.Context) (ma1 []insolar.Message) {
	mm_atomic.AddUint64(&mmOnPulse.beforeOnPulseCounter, 1)
	defer mm_atomic.AddUint64(&mmOnPulse.afterOnPulseCounter, 1)

	if mmOnPulse.inspectFuncOnPulse != nil {
		mmOnPulse.inspectFuncOnPulse(ctx)
	}

	params := &ExecutionArchiveMockOnPulseParams{ctx}

	// Record call args
	mmOnPulse.OnPulseMock.mutex.Lock()
	mmOnPulse.OnPulseMock.callArgs = append(mmOnPulse.OnPulseMock.callArgs, params)
	mmOnPulse.OnPulseMock.mutex.Unlock()

	for _, e := range mmOnPulse.OnPulseMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ma1
		}
	}

	if mmOnPulse.OnPulseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOnPulse.OnPulseMock.defaultExpectation.Counter, 1)
		want := mmOnPulse.OnPulseMock.defaultExpectation.params
		got := ExecutionArchiveMockOnPulseParams{ctx}
		if want != nil && !minimock.Equal(*want, got) {
			mmOnPulse.t.Errorf("ExecutionArchiveMock.OnPulse got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmOnPulse.OnPulseMock.defaultExpectation.results
		if results == nil {
			mmOnPulse.t.Fatal("No results are set for the ExecutionArchiveMock.OnPulse")
		}
		return (*results).ma1
	}
	if mmOnPulse.funcOnPulse != nil {
		return mmOnPulse.funcOnPulse(ctx)
	}
	mmOnPulse.t.Fatalf("Unexpected call to ExecutionArchiveMock.OnPulse. %v", ctx)
	return
}

// OnPulseAfterCounter returns a count of finished ExecutionArchiveMock.OnPulse invocations
func (mmOnPulse *ExecutionArchiveMock) OnPulseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOnPulse.afterOnPulseCounter)
}

// OnPulseBeforeCounter returns a count of ExecutionArchiveMock.OnPulse invocations
func (mmOnPulse *ExecutionArchiveMock) OnPulseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOnPulse.beforeOnPulseCounter)
}

// Calls returns a list of arguments used in each call to ExecutionArchiveMock.OnPulse.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOnPulse *mExecutionArchiveMockOnPulse) Calls() []*ExecutionArchiveMockOnPulseParams {
	mmOnPulse.mutex.RLock()

	argCopy := make([]*ExecutionArchiveMockOnPulseParams, len(mmOnPulse.callArgs))
	copy(argCopy, mmOnPulse.callArgs)

	mmOnPulse.mutex.RUnlock()

	return argCopy
}

// MinimockOnPulseDone returns true if the count of the OnPulse invocations corresponds
// the number of defined expectations
func (m *ExecutionArchiveMock) MinimockOnPulseDone() bool {
	for _, e := range m.OnPulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OnPulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOnPulseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOnPulse != nil && mm_atomic.LoadUint64(&m.afterOnPulseCounter) < 1 {
		return false
	}
	return true
}

// MinimockOnPulseInspect logs each unmet expectation
func (m *ExecutionArchiveMock) MinimockOnPulseInspect() {
	for _, e := range m.OnPulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExecutionArchiveMock.OnPulse with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OnPulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOnPulseCounter) < 1 {
		if m.OnPulseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExecutionArchiveMock.OnPulse")
		} else {
			m.t.Errorf("Expected call to ExecutionArchiveMock.OnPulse with params: %#v", *m.OnPulseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOnPulse != nil && mm_atomic.LoadUint64(&m.afterOnPulseCounter) < 1 {
		m.t.Error("Expected call to ExecutionArchiveMock.OnPulse")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ExecutionArchiveMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockArchiveInspect()

		m.MinimockDoneInspect()

		m.MinimockFindRequestLoopInspect()

		m.MinimockGetActiveTranscriptInspect()

		m.MinimockIsEmptyInspect()

		m.MinimockOnPulseInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ExecutionArchiveMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ExecutionArchiveMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockArchiveDone() &&
		m.MinimockDoneDone() &&
		m.MinimockFindRequestLoopDone() &&
		m.MinimockGetActiveTranscriptDone() &&
		m.MinimockIsEmptyDone() &&
		m.MinimockOnPulseDone()
}
