package writecontroller

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/insolar"
)

// WriteControllerMock implements WriteController
type WriteControllerMock struct {
	t minimock.Tester

	funcBegin          func(ctx context.Context, pulse insolar.PulseNumber) (f1 func(), err error)
	inspectFuncBegin   func(ctx context.Context, pulse insolar.PulseNumber)
	afterBeginCounter  uint64
	beforeBeginCounter uint64
	BeginMock          mWriteControllerMockBegin

	funcCloseAndWait          func(ctx context.Context, pulse insolar.PulseNumber) (err error)
	inspectFuncCloseAndWait   func(ctx context.Context, pulse insolar.PulseNumber)
	afterCloseAndWaitCounter  uint64
	beforeCloseAndWaitCounter uint64
	CloseAndWaitMock          mWriteControllerMockCloseAndWait

	funcOpen          func(ctx context.Context, pulse insolar.PulseNumber) (err error)
	inspectFuncOpen   func(ctx context.Context, pulse insolar.PulseNumber)
	afterOpenCounter  uint64
	beforeOpenCounter uint64
	OpenMock          mWriteControllerMockOpen

	funcWaitOpened          func(ctx context.Context)
	inspectFuncWaitOpened   func(ctx context.Context)
	afterWaitOpenedCounter  uint64
	beforeWaitOpenedCounter uint64
	WaitOpenedMock          mWriteControllerMockWaitOpened
}

// NewWriteControllerMock returns a mock for WriteController
func NewWriteControllerMock(t minimock.Tester) *WriteControllerMock {
	m := &WriteControllerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BeginMock = mWriteControllerMockBegin{mock: m}
	m.BeginMock.callArgs = []*WriteControllerMockBeginParams{}

	m.CloseAndWaitMock = mWriteControllerMockCloseAndWait{mock: m}
	m.CloseAndWaitMock.callArgs = []*WriteControllerMockCloseAndWaitParams{}

	m.OpenMock = mWriteControllerMockOpen{mock: m}
	m.OpenMock.callArgs = []*WriteControllerMockOpenParams{}

	m.WaitOpenedMock = mWriteControllerMockWaitOpened{mock: m}
	m.WaitOpenedMock.callArgs = []*WriteControllerMockWaitOpenedParams{}

	return m
}

type mWriteControllerMockBegin struct {
	mock               *WriteControllerMock
	defaultExpectation *WriteControllerMockBeginExpectation
	expectations       []*WriteControllerMockBeginExpectation

	callArgs []*WriteControllerMockBeginParams
	mutex    sync.RWMutex
}

// WriteControllerMockBeginExpectation specifies expectation struct of the WriteController.Begin
type WriteControllerMockBeginExpectation struct {
	mock    *WriteControllerMock
	params  *WriteControllerMockBeginParams
	results *WriteControllerMockBeginResults
	Counter uint64
}

// WriteControllerMockBeginParams contains parameters of the WriteController.Begin
type WriteControllerMockBeginParams struct {
	ctx   context.Context
	pulse insolar.PulseNumber
}

// WriteControllerMockBeginResults contains results of the WriteController.Begin
type WriteControllerMockBeginResults struct {
	f1  func()
	err error
}

// Expect sets up expected params for WriteController.Begin
func (mmBegin *mWriteControllerMockBegin) Expect(ctx context.Context, pulse insolar.PulseNumber) *mWriteControllerMockBegin {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("WriteControllerMock.Begin mock is already set by Set")
	}

	if mmBegin.defaultExpectation == nil {
		mmBegin.defaultExpectation = &WriteControllerMockBeginExpectation{}
	}

	mmBegin.defaultExpectation.params = &WriteControllerMockBeginParams{ctx, pulse}
	for _, e := range mmBegin.expectations {
		if minimock.Equal(e.params, mmBegin.defaultExpectation.params) {
			mmBegin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBegin.defaultExpectation.params)
		}
	}

	return mmBegin
}

// Inspect accepts an inspector function that has same arguments as the WriteController.Begin
func (mmBegin *mWriteControllerMockBegin) Inspect(f func(ctx context.Context, pulse insolar.PulseNumber)) *mWriteControllerMockBegin {
	if mmBegin.mock.inspectFuncBegin != nil {
		mmBegin.mock.t.Fatalf("Inspect function is already set for WriteControllerMock.Begin")
	}

	mmBegin.mock.inspectFuncBegin = f

	return mmBegin
}

// Return sets up results that will be returned by WriteController.Begin
func (mmBegin *mWriteControllerMockBegin) Return(f1 func(), err error) *WriteControllerMock {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("WriteControllerMock.Begin mock is already set by Set")
	}

	if mmBegin.defaultExpectation == nil {
		mmBegin.defaultExpectation = &WriteControllerMockBeginExpectation{mock: mmBegin.mock}
	}
	mmBegin.defaultExpectation.results = &WriteControllerMockBeginResults{f1, err}
	return mmBegin.mock
}

//Set uses given function f to mock the WriteController.Begin method
func (mmBegin *mWriteControllerMockBegin) Set(f func(ctx context.Context, pulse insolar.PulseNumber) (f1 func(), err error)) *WriteControllerMock {
	if mmBegin.defaultExpectation != nil {
		mmBegin.mock.t.Fatalf("Default expectation is already set for the WriteController.Begin method")
	}

	if len(mmBegin.expectations) > 0 {
		mmBegin.mock.t.Fatalf("Some expectations are already set for the WriteController.Begin method")
	}

	mmBegin.mock.funcBegin = f
	return mmBegin.mock
}

// When sets expectation for the WriteController.Begin which will trigger the result defined by the following
// Then helper
func (mmBegin *mWriteControllerMockBegin) When(ctx context.Context, pulse insolar.PulseNumber) *WriteControllerMockBeginExpectation {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("WriteControllerMock.Begin mock is already set by Set")
	}

	expectation := &WriteControllerMockBeginExpectation{
		mock:   mmBegin.mock,
		params: &WriteControllerMockBeginParams{ctx, pulse},
	}
	mmBegin.expectations = append(mmBegin.expectations, expectation)
	return expectation
}

// Then sets up WriteController.Begin return parameters for the expectation previously defined by the When method
func (e *WriteControllerMockBeginExpectation) Then(f1 func(), err error) *WriteControllerMock {
	e.results = &WriteControllerMockBeginResults{f1, err}
	return e.mock
}

// Begin implements WriteController
func (mmBegin *WriteControllerMock) Begin(ctx context.Context, pulse insolar.PulseNumber) (f1 func(), err error) {
	mm_atomic.AddUint64(&mmBegin.beforeBeginCounter, 1)
	defer mm_atomic.AddUint64(&mmBegin.afterBeginCounter, 1)

	if mmBegin.inspectFuncBegin != nil {
		mmBegin.inspectFuncBegin(ctx, pulse)
	}

	params := &WriteControllerMockBeginParams{ctx, pulse}

	// Record call args
	mmBegin.BeginMock.mutex.Lock()
	mmBegin.BeginMock.callArgs = append(mmBegin.BeginMock.callArgs, params)
	mmBegin.BeginMock.mutex.Unlock()

	for _, e := range mmBegin.BeginMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.f1, e.results.err
		}
	}

	if mmBegin.BeginMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBegin.BeginMock.defaultExpectation.Counter, 1)
		want := mmBegin.BeginMock.defaultExpectation.params
		got := WriteControllerMockBeginParams{ctx, pulse}
		if want != nil && !minimock.Equal(*want, got) {
			mmBegin.t.Errorf("WriteControllerMock.Begin got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmBegin.BeginMock.defaultExpectation.results
		if results == nil {
			mmBegin.t.Fatal("No results are set for the WriteControllerMock.Begin")
		}
		return (*results).f1, (*results).err
	}
	if mmBegin.funcBegin != nil {
		return mmBegin.funcBegin(ctx, pulse)
	}
	mmBegin.t.Fatalf("Unexpected call to WriteControllerMock.Begin. %v %v", ctx, pulse)
	return
}

// BeginAfterCounter returns a count of finished WriteControllerMock.Begin invocations
func (mmBegin *WriteControllerMock) BeginAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBegin.afterBeginCounter)
}

// BeginBeforeCounter returns a count of WriteControllerMock.Begin invocations
func (mmBegin *WriteControllerMock) BeginBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBegin.beforeBeginCounter)
}

// Calls returns a list of arguments used in each call to WriteControllerMock.Begin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBegin *mWriteControllerMockBegin) Calls() []*WriteControllerMockBeginParams {
	mmBegin.mutex.RLock()

	argCopy := make([]*WriteControllerMockBeginParams, len(mmBegin.callArgs))
	copy(argCopy, mmBegin.callArgs)

	mmBegin.mutex.RUnlock()

	return argCopy
}

// MinimockBeginDone returns true if the count of the Begin invocations corresponds
// the number of defined expectations
func (m *WriteControllerMock) MinimockBeginDone() bool {
	for _, e := range m.BeginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BeginMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBeginCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBegin != nil && mm_atomic.LoadUint64(&m.afterBeginCounter) < 1 {
		return false
	}
	return true
}

// MinimockBeginInspect logs each unmet expectation
func (m *WriteControllerMock) MinimockBeginInspect() {
	for _, e := range m.BeginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to WriteControllerMock.Begin with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BeginMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBeginCounter) < 1 {
		if m.BeginMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to WriteControllerMock.Begin")
		} else {
			m.t.Errorf("Expected call to WriteControllerMock.Begin with params: %#v", *m.BeginMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBegin != nil && mm_atomic.LoadUint64(&m.afterBeginCounter) < 1 {
		m.t.Error("Expected call to WriteControllerMock.Begin")
	}
}

type mWriteControllerMockCloseAndWait struct {
	mock               *WriteControllerMock
	defaultExpectation *WriteControllerMockCloseAndWaitExpectation
	expectations       []*WriteControllerMockCloseAndWaitExpectation

	callArgs []*WriteControllerMockCloseAndWaitParams
	mutex    sync.RWMutex
}

// WriteControllerMockCloseAndWaitExpectation specifies expectation struct of the WriteController.CloseAndWait
type WriteControllerMockCloseAndWaitExpectation struct {
	mock    *WriteControllerMock
	params  *WriteControllerMockCloseAndWaitParams
	results *WriteControllerMockCloseAndWaitResults
	Counter uint64
}

// WriteControllerMockCloseAndWaitParams contains parameters of the WriteController.CloseAndWait
type WriteControllerMockCloseAndWaitParams struct {
	ctx   context.Context
	pulse insolar.PulseNumber
}

// WriteControllerMockCloseAndWaitResults contains results of the WriteController.CloseAndWait
type WriteControllerMockCloseAndWaitResults struct {
	err error
}

// Expect sets up expected params for WriteController.CloseAndWait
func (mmCloseAndWait *mWriteControllerMockCloseAndWait) Expect(ctx context.Context, pulse insolar.PulseNumber) *mWriteControllerMockCloseAndWait {
	if mmCloseAndWait.mock.funcCloseAndWait != nil {
		mmCloseAndWait.mock.t.Fatalf("WriteControllerMock.CloseAndWait mock is already set by Set")
	}

	if mmCloseAndWait.defaultExpectation == nil {
		mmCloseAndWait.defaultExpectation = &WriteControllerMockCloseAndWaitExpectation{}
	}

	mmCloseAndWait.defaultExpectation.params = &WriteControllerMockCloseAndWaitParams{ctx, pulse}
	for _, e := range mmCloseAndWait.expectations {
		if minimock.Equal(e.params, mmCloseAndWait.defaultExpectation.params) {
			mmCloseAndWait.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCloseAndWait.defaultExpectation.params)
		}
	}

	return mmCloseAndWait
}

// Inspect accepts an inspector function that has same arguments as the WriteController.CloseAndWait
func (mmCloseAndWait *mWriteControllerMockCloseAndWait) Inspect(f func(ctx context.Context, pulse insolar.PulseNumber)) *mWriteControllerMockCloseAndWait {
	if mmCloseAndWait.mock.inspectFuncCloseAndWait != nil {
		mmCloseAndWait.mock.t.Fatalf("Inspect function is already set for WriteControllerMock.CloseAndWait")
	}

	mmCloseAndWait.mock.inspectFuncCloseAndWait = f

	return mmCloseAndWait
}

// Return sets up results that will be returned by WriteController.CloseAndWait
func (mmCloseAndWait *mWriteControllerMockCloseAndWait) Return(err error) *WriteControllerMock {
	if mmCloseAndWait.mock.funcCloseAndWait != nil {
		mmCloseAndWait.mock.t.Fatalf("WriteControllerMock.CloseAndWait mock is already set by Set")
	}

	if mmCloseAndWait.defaultExpectation == nil {
		mmCloseAndWait.defaultExpectation = &WriteControllerMockCloseAndWaitExpectation{mock: mmCloseAndWait.mock}
	}
	mmCloseAndWait.defaultExpectation.results = &WriteControllerMockCloseAndWaitResults{err}
	return mmCloseAndWait.mock
}

//Set uses given function f to mock the WriteController.CloseAndWait method
func (mmCloseAndWait *mWriteControllerMockCloseAndWait) Set(f func(ctx context.Context, pulse insolar.PulseNumber) (err error)) *WriteControllerMock {
	if mmCloseAndWait.defaultExpectation != nil {
		mmCloseAndWait.mock.t.Fatalf("Default expectation is already set for the WriteController.CloseAndWait method")
	}

	if len(mmCloseAndWait.expectations) > 0 {
		mmCloseAndWait.mock.t.Fatalf("Some expectations are already set for the WriteController.CloseAndWait method")
	}

	mmCloseAndWait.mock.funcCloseAndWait = f
	return mmCloseAndWait.mock
}

// When sets expectation for the WriteController.CloseAndWait which will trigger the result defined by the following
// Then helper
func (mmCloseAndWait *mWriteControllerMockCloseAndWait) When(ctx context.Context, pulse insolar.PulseNumber) *WriteControllerMockCloseAndWaitExpectation {
	if mmCloseAndWait.mock.funcCloseAndWait != nil {
		mmCloseAndWait.mock.t.Fatalf("WriteControllerMock.CloseAndWait mock is already set by Set")
	}

	expectation := &WriteControllerMockCloseAndWaitExpectation{
		mock:   mmCloseAndWait.mock,
		params: &WriteControllerMockCloseAndWaitParams{ctx, pulse},
	}
	mmCloseAndWait.expectations = append(mmCloseAndWait.expectations, expectation)
	return expectation
}

// Then sets up WriteController.CloseAndWait return parameters for the expectation previously defined by the When method
func (e *WriteControllerMockCloseAndWaitExpectation) Then(err error) *WriteControllerMock {
	e.results = &WriteControllerMockCloseAndWaitResults{err}
	return e.mock
}

// CloseAndWait implements WriteController
func (mmCloseAndWait *WriteControllerMock) CloseAndWait(ctx context.Context, pulse insolar.PulseNumber) (err error) {
	mm_atomic.AddUint64(&mmCloseAndWait.beforeCloseAndWaitCounter, 1)
	defer mm_atomic.AddUint64(&mmCloseAndWait.afterCloseAndWaitCounter, 1)

	if mmCloseAndWait.inspectFuncCloseAndWait != nil {
		mmCloseAndWait.inspectFuncCloseAndWait(ctx, pulse)
	}

	params := &WriteControllerMockCloseAndWaitParams{ctx, pulse}

	// Record call args
	mmCloseAndWait.CloseAndWaitMock.mutex.Lock()
	mmCloseAndWait.CloseAndWaitMock.callArgs = append(mmCloseAndWait.CloseAndWaitMock.callArgs, params)
	mmCloseAndWait.CloseAndWaitMock.mutex.Unlock()

	for _, e := range mmCloseAndWait.CloseAndWaitMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCloseAndWait.CloseAndWaitMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCloseAndWait.CloseAndWaitMock.defaultExpectation.Counter, 1)
		want := mmCloseAndWait.CloseAndWaitMock.defaultExpectation.params
		got := WriteControllerMockCloseAndWaitParams{ctx, pulse}
		if want != nil && !minimock.Equal(*want, got) {
			mmCloseAndWait.t.Errorf("WriteControllerMock.CloseAndWait got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmCloseAndWait.CloseAndWaitMock.defaultExpectation.results
		if results == nil {
			mmCloseAndWait.t.Fatal("No results are set for the WriteControllerMock.CloseAndWait")
		}
		return (*results).err
	}
	if mmCloseAndWait.funcCloseAndWait != nil {
		return mmCloseAndWait.funcCloseAndWait(ctx, pulse)
	}
	mmCloseAndWait.t.Fatalf("Unexpected call to WriteControllerMock.CloseAndWait. %v %v", ctx, pulse)
	return
}

// CloseAndWaitAfterCounter returns a count of finished WriteControllerMock.CloseAndWait invocations
func (mmCloseAndWait *WriteControllerMock) CloseAndWaitAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCloseAndWait.afterCloseAndWaitCounter)
}

// CloseAndWaitBeforeCounter returns a count of WriteControllerMock.CloseAndWait invocations
func (mmCloseAndWait *WriteControllerMock) CloseAndWaitBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCloseAndWait.beforeCloseAndWaitCounter)
}

// Calls returns a list of arguments used in each call to WriteControllerMock.CloseAndWait.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCloseAndWait *mWriteControllerMockCloseAndWait) Calls() []*WriteControllerMockCloseAndWaitParams {
	mmCloseAndWait.mutex.RLock()

	argCopy := make([]*WriteControllerMockCloseAndWaitParams, len(mmCloseAndWait.callArgs))
	copy(argCopy, mmCloseAndWait.callArgs)

	mmCloseAndWait.mutex.RUnlock()

	return argCopy
}

// MinimockCloseAndWaitDone returns true if the count of the CloseAndWait invocations corresponds
// the number of defined expectations
func (m *WriteControllerMock) MinimockCloseAndWaitDone() bool {
	for _, e := range m.CloseAndWaitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseAndWaitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseAndWaitCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCloseAndWait != nil && mm_atomic.LoadUint64(&m.afterCloseAndWaitCounter) < 1 {
		return false
	}
	return true
}

// MinimockCloseAndWaitInspect logs each unmet expectation
func (m *WriteControllerMock) MinimockCloseAndWaitInspect() {
	for _, e := range m.CloseAndWaitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to WriteControllerMock.CloseAndWait with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseAndWaitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseAndWaitCounter) < 1 {
		if m.CloseAndWaitMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to WriteControllerMock.CloseAndWait")
		} else {
			m.t.Errorf("Expected call to WriteControllerMock.CloseAndWait with params: %#v", *m.CloseAndWaitMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCloseAndWait != nil && mm_atomic.LoadUint64(&m.afterCloseAndWaitCounter) < 1 {
		m.t.Error("Expected call to WriteControllerMock.CloseAndWait")
	}
}

type mWriteControllerMockOpen struct {
	mock               *WriteControllerMock
	defaultExpectation *WriteControllerMockOpenExpectation
	expectations       []*WriteControllerMockOpenExpectation

	callArgs []*WriteControllerMockOpenParams
	mutex    sync.RWMutex
}

// WriteControllerMockOpenExpectation specifies expectation struct of the WriteController.Open
type WriteControllerMockOpenExpectation struct {
	mock    *WriteControllerMock
	params  *WriteControllerMockOpenParams
	results *WriteControllerMockOpenResults
	Counter uint64
}

// WriteControllerMockOpenParams contains parameters of the WriteController.Open
type WriteControllerMockOpenParams struct {
	ctx   context.Context
	pulse insolar.PulseNumber
}

// WriteControllerMockOpenResults contains results of the WriteController.Open
type WriteControllerMockOpenResults struct {
	err error
}

// Expect sets up expected params for WriteController.Open
func (mmOpen *mWriteControllerMockOpen) Expect(ctx context.Context, pulse insolar.PulseNumber) *mWriteControllerMockOpen {
	if mmOpen.mock.funcOpen != nil {
		mmOpen.mock.t.Fatalf("WriteControllerMock.Open mock is already set by Set")
	}

	if mmOpen.defaultExpectation == nil {
		mmOpen.defaultExpectation = &WriteControllerMockOpenExpectation{}
	}

	mmOpen.defaultExpectation.params = &WriteControllerMockOpenParams{ctx, pulse}
	for _, e := range mmOpen.expectations {
		if minimock.Equal(e.params, mmOpen.defaultExpectation.params) {
			mmOpen.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOpen.defaultExpectation.params)
		}
	}

	return mmOpen
}

// Inspect accepts an inspector function that has same arguments as the WriteController.Open
func (mmOpen *mWriteControllerMockOpen) Inspect(f func(ctx context.Context, pulse insolar.PulseNumber)) *mWriteControllerMockOpen {
	if mmOpen.mock.inspectFuncOpen != nil {
		mmOpen.mock.t.Fatalf("Inspect function is already set for WriteControllerMock.Open")
	}

	mmOpen.mock.inspectFuncOpen = f

	return mmOpen
}

// Return sets up results that will be returned by WriteController.Open
func (mmOpen *mWriteControllerMockOpen) Return(err error) *WriteControllerMock {
	if mmOpen.mock.funcOpen != nil {
		mmOpen.mock.t.Fatalf("WriteControllerMock.Open mock is already set by Set")
	}

	if mmOpen.defaultExpectation == nil {
		mmOpen.defaultExpectation = &WriteControllerMockOpenExpectation{mock: mmOpen.mock}
	}
	mmOpen.defaultExpectation.results = &WriteControllerMockOpenResults{err}
	return mmOpen.mock
}

//Set uses given function f to mock the WriteController.Open method
func (mmOpen *mWriteControllerMockOpen) Set(f func(ctx context.Context, pulse insolar.PulseNumber) (err error)) *WriteControllerMock {
	if mmOpen.defaultExpectation != nil {
		mmOpen.mock.t.Fatalf("Default expectation is already set for the WriteController.Open method")
	}

	if len(mmOpen.expectations) > 0 {
		mmOpen.mock.t.Fatalf("Some expectations are already set for the WriteController.Open method")
	}

	mmOpen.mock.funcOpen = f
	return mmOpen.mock
}

// When sets expectation for the WriteController.Open which will trigger the result defined by the following
// Then helper
func (mmOpen *mWriteControllerMockOpen) When(ctx context.Context, pulse insolar.PulseNumber) *WriteControllerMockOpenExpectation {
	if mmOpen.mock.funcOpen != nil {
		mmOpen.mock.t.Fatalf("WriteControllerMock.Open mock is already set by Set")
	}

	expectation := &WriteControllerMockOpenExpectation{
		mock:   mmOpen.mock,
		params: &WriteControllerMockOpenParams{ctx, pulse},
	}
	mmOpen.expectations = append(mmOpen.expectations, expectation)
	return expectation
}

// Then sets up WriteController.Open return parameters for the expectation previously defined by the When method
func (e *WriteControllerMockOpenExpectation) Then(err error) *WriteControllerMock {
	e.results = &WriteControllerMockOpenResults{err}
	return e.mock
}

// Open implements WriteController
func (mmOpen *WriteControllerMock) Open(ctx context.Context, pulse insolar.PulseNumber) (err error) {
	mm_atomic.AddUint64(&mmOpen.beforeOpenCounter, 1)
	defer mm_atomic.AddUint64(&mmOpen.afterOpenCounter, 1)

	if mmOpen.inspectFuncOpen != nil {
		mmOpen.inspectFuncOpen(ctx, pulse)
	}

	params := &WriteControllerMockOpenParams{ctx, pulse}

	// Record call args
	mmOpen.OpenMock.mutex.Lock()
	mmOpen.OpenMock.callArgs = append(mmOpen.OpenMock.callArgs, params)
	mmOpen.OpenMock.mutex.Unlock()

	for _, e := range mmOpen.OpenMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmOpen.OpenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOpen.OpenMock.defaultExpectation.Counter, 1)
		want := mmOpen.OpenMock.defaultExpectation.params
		got := WriteControllerMockOpenParams{ctx, pulse}
		if want != nil && !minimock.Equal(*want, got) {
			mmOpen.t.Errorf("WriteControllerMock.Open got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmOpen.OpenMock.defaultExpectation.results
		if results == nil {
			mmOpen.t.Fatal("No results are set for the WriteControllerMock.Open")
		}
		return (*results).err
	}
	if mmOpen.funcOpen != nil {
		return mmOpen.funcOpen(ctx, pulse)
	}
	mmOpen.t.Fatalf("Unexpected call to WriteControllerMock.Open. %v %v", ctx, pulse)
	return
}

// OpenAfterCounter returns a count of finished WriteControllerMock.Open invocations
func (mmOpen *WriteControllerMock) OpenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpen.afterOpenCounter)
}

// OpenBeforeCounter returns a count of WriteControllerMock.Open invocations
func (mmOpen *WriteControllerMock) OpenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpen.beforeOpenCounter)
}

// Calls returns a list of arguments used in each call to WriteControllerMock.Open.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOpen *mWriteControllerMockOpen) Calls() []*WriteControllerMockOpenParams {
	mmOpen.mutex.RLock()

	argCopy := make([]*WriteControllerMockOpenParams, len(mmOpen.callArgs))
	copy(argCopy, mmOpen.callArgs)

	mmOpen.mutex.RUnlock()

	return argCopy
}

// MinimockOpenDone returns true if the count of the Open invocations corresponds
// the number of defined expectations
func (m *WriteControllerMock) MinimockOpenDone() bool {
	for _, e := range m.OpenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OpenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOpen != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		return false
	}
	return true
}

// MinimockOpenInspect logs each unmet expectation
func (m *WriteControllerMock) MinimockOpenInspect() {
	for _, e := range m.OpenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to WriteControllerMock.Open with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OpenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		if m.OpenMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to WriteControllerMock.Open")
		} else {
			m.t.Errorf("Expected call to WriteControllerMock.Open with params: %#v", *m.OpenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOpen != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		m.t.Error("Expected call to WriteControllerMock.Open")
	}
}

type mWriteControllerMockWaitOpened struct {
	mock               *WriteControllerMock
	defaultExpectation *WriteControllerMockWaitOpenedExpectation
	expectations       []*WriteControllerMockWaitOpenedExpectation

	callArgs []*WriteControllerMockWaitOpenedParams
	mutex    sync.RWMutex
}

// WriteControllerMockWaitOpenedExpectation specifies expectation struct of the WriteController.WaitOpened
type WriteControllerMockWaitOpenedExpectation struct {
	mock   *WriteControllerMock
	params *WriteControllerMockWaitOpenedParams

	Counter uint64
}

// WriteControllerMockWaitOpenedParams contains parameters of the WriteController.WaitOpened
type WriteControllerMockWaitOpenedParams struct {
	ctx context.Context
}

// Expect sets up expected params for WriteController.WaitOpened
func (mmWaitOpened *mWriteControllerMockWaitOpened) Expect(ctx context.Context) *mWriteControllerMockWaitOpened {
	if mmWaitOpened.mock.funcWaitOpened != nil {
		mmWaitOpened.mock.t.Fatalf("WriteControllerMock.WaitOpened mock is already set by Set")
	}

	if mmWaitOpened.defaultExpectation == nil {
		mmWaitOpened.defaultExpectation = &WriteControllerMockWaitOpenedExpectation{}
	}

	mmWaitOpened.defaultExpectation.params = &WriteControllerMockWaitOpenedParams{ctx}
	for _, e := range mmWaitOpened.expectations {
		if minimock.Equal(e.params, mmWaitOpened.defaultExpectation.params) {
			mmWaitOpened.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWaitOpened.defaultExpectation.params)
		}
	}

	return mmWaitOpened
}

// Inspect accepts an inspector function that has same arguments as the WriteController.WaitOpened
func (mmWaitOpened *mWriteControllerMockWaitOpened) Inspect(f func(ctx context.Context)) *mWriteControllerMockWaitOpened {
	if mmWaitOpened.mock.inspectFuncWaitOpened != nil {
		mmWaitOpened.mock.t.Fatalf("Inspect function is already set for WriteControllerMock.WaitOpened")
	}

	mmWaitOpened.mock.inspectFuncWaitOpened = f

	return mmWaitOpened
}

// Return sets up results that will be returned by WriteController.WaitOpened
func (mmWaitOpened *mWriteControllerMockWaitOpened) Return() *WriteControllerMock {
	if mmWaitOpened.mock.funcWaitOpened != nil {
		mmWaitOpened.mock.t.Fatalf("WriteControllerMock.WaitOpened mock is already set by Set")
	}

	if mmWaitOpened.defaultExpectation == nil {
		mmWaitOpened.defaultExpectation = &WriteControllerMockWaitOpenedExpectation{mock: mmWaitOpened.mock}
	}

	return mmWaitOpened.mock
}

//Set uses given function f to mock the WriteController.WaitOpened method
func (mmWaitOpened *mWriteControllerMockWaitOpened) Set(f func(ctx context.Context)) *WriteControllerMock {
	if mmWaitOpened.defaultExpectation != nil {
		mmWaitOpened.mock.t.Fatalf("Default expectation is already set for the WriteController.WaitOpened method")
	}

	if len(mmWaitOpened.expectations) > 0 {
		mmWaitOpened.mock.t.Fatalf("Some expectations are already set for the WriteController.WaitOpened method")
	}

	mmWaitOpened.mock.funcWaitOpened = f
	return mmWaitOpened.mock
}

// WaitOpened implements WriteController
func (mmWaitOpened *WriteControllerMock) WaitOpened(ctx context.Context) {
	mm_atomic.AddUint64(&mmWaitOpened.beforeWaitOpenedCounter, 1)
	defer mm_atomic.AddUint64(&mmWaitOpened.afterWaitOpenedCounter, 1)

	if mmWaitOpened.inspectFuncWaitOpened != nil {
		mmWaitOpened.inspectFuncWaitOpened(ctx)
	}

	params := &WriteControllerMockWaitOpenedParams{ctx}

	// Record call args
	mmWaitOpened.WaitOpenedMock.mutex.Lock()
	mmWaitOpened.WaitOpenedMock.callArgs = append(mmWaitOpened.WaitOpenedMock.callArgs, params)
	mmWaitOpened.WaitOpenedMock.mutex.Unlock()

	for _, e := range mmWaitOpened.WaitOpenedMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmWaitOpened.WaitOpenedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWaitOpened.WaitOpenedMock.defaultExpectation.Counter, 1)
		want := mmWaitOpened.WaitOpenedMock.defaultExpectation.params
		got := WriteControllerMockWaitOpenedParams{ctx}
		if want != nil && !minimock.Equal(*want, got) {
			mmWaitOpened.t.Errorf("WriteControllerMock.WaitOpened got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmWaitOpened.funcWaitOpened != nil {
		mmWaitOpened.funcWaitOpened(ctx)
		return
	}
	mmWaitOpened.t.Fatalf("Unexpected call to WriteControllerMock.WaitOpened. %v", ctx)

}

// WaitOpenedAfterCounter returns a count of finished WriteControllerMock.WaitOpened invocations
func (mmWaitOpened *WriteControllerMock) WaitOpenedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWaitOpened.afterWaitOpenedCounter)
}

// WaitOpenedBeforeCounter returns a count of WriteControllerMock.WaitOpened invocations
func (mmWaitOpened *WriteControllerMock) WaitOpenedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWaitOpened.beforeWaitOpenedCounter)
}

// Calls returns a list of arguments used in each call to WriteControllerMock.WaitOpened.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWaitOpened *mWriteControllerMockWaitOpened) Calls() []*WriteControllerMockWaitOpenedParams {
	mmWaitOpened.mutex.RLock()

	argCopy := make([]*WriteControllerMockWaitOpenedParams, len(mmWaitOpened.callArgs))
	copy(argCopy, mmWaitOpened.callArgs)

	mmWaitOpened.mutex.RUnlock()

	return argCopy
}

// MinimockWaitOpenedDone returns true if the count of the WaitOpened invocations corresponds
// the number of defined expectations
func (m *WriteControllerMock) MinimockWaitOpenedDone() bool {
	for _, e := range m.WaitOpenedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WaitOpenedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWaitOpenedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWaitOpened != nil && mm_atomic.LoadUint64(&m.afterWaitOpenedCounter) < 1 {
		return false
	}
	return true
}

// MinimockWaitOpenedInspect logs each unmet expectation
func (m *WriteControllerMock) MinimockWaitOpenedInspect() {
	for _, e := range m.WaitOpenedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to WriteControllerMock.WaitOpened with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WaitOpenedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWaitOpenedCounter) < 1 {
		if m.WaitOpenedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to WriteControllerMock.WaitOpened")
		} else {
			m.t.Errorf("Expected call to WriteControllerMock.WaitOpened with params: %#v", *m.WaitOpenedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWaitOpened != nil && mm_atomic.LoadUint64(&m.afterWaitOpenedCounter) < 1 {
		m.t.Error("Expected call to WriteControllerMock.WaitOpened")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *WriteControllerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockBeginInspect()

		m.MinimockCloseAndWaitInspect()

		m.MinimockOpenInspect()

		m.MinimockWaitOpenedInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *WriteControllerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *WriteControllerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBeginDone() &&
		m.MinimockCloseAndWaitDone() &&
		m.MinimockOpenDone() &&
		m.MinimockWaitOpenedDone()
}
