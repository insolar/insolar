package writecontroller

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/insolar"
)

// ManagerMock implements Manager
type ManagerMock struct {
	t minimock.Tester

	funcCloseAndWait          func(ctx context.Context, p1 insolar.PulseNumber) (err error)
	inspectFuncCloseAndWait   func(ctx context.Context, p1 insolar.PulseNumber)
	afterCloseAndWaitCounter  uint64
	beforeCloseAndWaitCounter uint64
	CloseAndWaitMock          mManagerMockCloseAndWait

	funcOpen          func(ctx context.Context, p1 insolar.PulseNumber) (err error)
	inspectFuncOpen   func(ctx context.Context, p1 insolar.PulseNumber)
	afterOpenCounter  uint64
	beforeOpenCounter uint64
	OpenMock          mManagerMockOpen
}

// NewManagerMock returns a mock for Manager
func NewManagerMock(t minimock.Tester) *ManagerMock {
	m := &ManagerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CloseAndWaitMock = mManagerMockCloseAndWait{mock: m}
	m.CloseAndWaitMock.callArgs = []*ManagerMockCloseAndWaitParams{}

	m.OpenMock = mManagerMockOpen{mock: m}
	m.OpenMock.callArgs = []*ManagerMockOpenParams{}

	return m
}

type mManagerMockCloseAndWait struct {
	mock               *ManagerMock
	defaultExpectation *ManagerMockCloseAndWaitExpectation
	expectations       []*ManagerMockCloseAndWaitExpectation

	callArgs []*ManagerMockCloseAndWaitParams
	mutex    sync.RWMutex
}

// ManagerMockCloseAndWaitExpectation specifies expectation struct of the Manager.CloseAndWait
type ManagerMockCloseAndWaitExpectation struct {
	mock    *ManagerMock
	params  *ManagerMockCloseAndWaitParams
	results *ManagerMockCloseAndWaitResults
	Counter uint64
}

// ManagerMockCloseAndWaitParams contains parameters of the Manager.CloseAndWait
type ManagerMockCloseAndWaitParams struct {
	ctx context.Context
	p1  insolar.PulseNumber
}

// ManagerMockCloseAndWaitResults contains results of the Manager.CloseAndWait
type ManagerMockCloseAndWaitResults struct {
	err error
}

// Expect sets up expected params for Manager.CloseAndWait
func (mmCloseAndWait *mManagerMockCloseAndWait) Expect(ctx context.Context, p1 insolar.PulseNumber) *mManagerMockCloseAndWait {
	if mmCloseAndWait.mock.funcCloseAndWait != nil {
		mmCloseAndWait.mock.t.Fatalf("ManagerMock.CloseAndWait mock is already set by Set")
	}

	if mmCloseAndWait.defaultExpectation == nil {
		mmCloseAndWait.defaultExpectation = &ManagerMockCloseAndWaitExpectation{}
	}

	mmCloseAndWait.defaultExpectation.params = &ManagerMockCloseAndWaitParams{ctx, p1}
	for _, e := range mmCloseAndWait.expectations {
		if minimock.Equal(e.params, mmCloseAndWait.defaultExpectation.params) {
			mmCloseAndWait.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCloseAndWait.defaultExpectation.params)
		}
	}

	return mmCloseAndWait
}

// Inspect accepts an inspector function that has same arguments as the Manager.CloseAndWait
func (mmCloseAndWait *mManagerMockCloseAndWait) Inspect(f func(ctx context.Context, p1 insolar.PulseNumber)) *mManagerMockCloseAndWait {
	if mmCloseAndWait.mock.inspectFuncCloseAndWait != nil {
		mmCloseAndWait.mock.t.Fatalf("Inspect function is already set for ManagerMock.CloseAndWait")
	}

	mmCloseAndWait.mock.inspectFuncCloseAndWait = f

	return mmCloseAndWait
}

// Return sets up results that will be returned by Manager.CloseAndWait
func (mmCloseAndWait *mManagerMockCloseAndWait) Return(err error) *ManagerMock {
	if mmCloseAndWait.mock.funcCloseAndWait != nil {
		mmCloseAndWait.mock.t.Fatalf("ManagerMock.CloseAndWait mock is already set by Set")
	}

	if mmCloseAndWait.defaultExpectation == nil {
		mmCloseAndWait.defaultExpectation = &ManagerMockCloseAndWaitExpectation{mock: mmCloseAndWait.mock}
	}
	mmCloseAndWait.defaultExpectation.results = &ManagerMockCloseAndWaitResults{err}
	return mmCloseAndWait.mock
}

//Set uses given function f to mock the Manager.CloseAndWait method
func (mmCloseAndWait *mManagerMockCloseAndWait) Set(f func(ctx context.Context, p1 insolar.PulseNumber) (err error)) *ManagerMock {
	if mmCloseAndWait.defaultExpectation != nil {
		mmCloseAndWait.mock.t.Fatalf("Default expectation is already set for the Manager.CloseAndWait method")
	}

	if len(mmCloseAndWait.expectations) > 0 {
		mmCloseAndWait.mock.t.Fatalf("Some expectations are already set for the Manager.CloseAndWait method")
	}

	mmCloseAndWait.mock.funcCloseAndWait = f
	return mmCloseAndWait.mock
}

// When sets expectation for the Manager.CloseAndWait which will trigger the result defined by the following
// Then helper
func (mmCloseAndWait *mManagerMockCloseAndWait) When(ctx context.Context, p1 insolar.PulseNumber) *ManagerMockCloseAndWaitExpectation {
	if mmCloseAndWait.mock.funcCloseAndWait != nil {
		mmCloseAndWait.mock.t.Fatalf("ManagerMock.CloseAndWait mock is already set by Set")
	}

	expectation := &ManagerMockCloseAndWaitExpectation{
		mock:   mmCloseAndWait.mock,
		params: &ManagerMockCloseAndWaitParams{ctx, p1},
	}
	mmCloseAndWait.expectations = append(mmCloseAndWait.expectations, expectation)
	return expectation
}

// Then sets up Manager.CloseAndWait return parameters for the expectation previously defined by the When method
func (e *ManagerMockCloseAndWaitExpectation) Then(err error) *ManagerMock {
	e.results = &ManagerMockCloseAndWaitResults{err}
	return e.mock
}

// CloseAndWait implements Manager
func (mmCloseAndWait *ManagerMock) CloseAndWait(ctx context.Context, p1 insolar.PulseNumber) (err error) {
	mm_atomic.AddUint64(&mmCloseAndWait.beforeCloseAndWaitCounter, 1)
	defer mm_atomic.AddUint64(&mmCloseAndWait.afterCloseAndWaitCounter, 1)

	if mmCloseAndWait.inspectFuncCloseAndWait != nil {
		mmCloseAndWait.inspectFuncCloseAndWait(ctx, p1)
	}

	params := &ManagerMockCloseAndWaitParams{ctx, p1}

	// Record call args
	mmCloseAndWait.CloseAndWaitMock.mutex.Lock()
	mmCloseAndWait.CloseAndWaitMock.callArgs = append(mmCloseAndWait.CloseAndWaitMock.callArgs, params)
	mmCloseAndWait.CloseAndWaitMock.mutex.Unlock()

	for _, e := range mmCloseAndWait.CloseAndWaitMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCloseAndWait.CloseAndWaitMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCloseAndWait.CloseAndWaitMock.defaultExpectation.Counter, 1)
		want := mmCloseAndWait.CloseAndWaitMock.defaultExpectation.params
		got := ManagerMockCloseAndWaitParams{ctx, p1}
		if want != nil && !minimock.Equal(*want, got) {
			mmCloseAndWait.t.Errorf("ManagerMock.CloseAndWait got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmCloseAndWait.CloseAndWaitMock.defaultExpectation.results
		if results == nil {
			mmCloseAndWait.t.Fatal("No results are set for the ManagerMock.CloseAndWait")
		}
		return (*results).err
	}
	if mmCloseAndWait.funcCloseAndWait != nil {
		return mmCloseAndWait.funcCloseAndWait(ctx, p1)
	}
	mmCloseAndWait.t.Fatalf("Unexpected call to ManagerMock.CloseAndWait. %v %v", ctx, p1)
	return
}

// CloseAndWaitAfterCounter returns a count of finished ManagerMock.CloseAndWait invocations
func (mmCloseAndWait *ManagerMock) CloseAndWaitAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCloseAndWait.afterCloseAndWaitCounter)
}

// CloseAndWaitBeforeCounter returns a count of ManagerMock.CloseAndWait invocations
func (mmCloseAndWait *ManagerMock) CloseAndWaitBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCloseAndWait.beforeCloseAndWaitCounter)
}

// Calls returns a list of arguments used in each call to ManagerMock.CloseAndWait.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCloseAndWait *mManagerMockCloseAndWait) Calls() []*ManagerMockCloseAndWaitParams {
	mmCloseAndWait.mutex.RLock()

	argCopy := make([]*ManagerMockCloseAndWaitParams, len(mmCloseAndWait.callArgs))
	copy(argCopy, mmCloseAndWait.callArgs)

	mmCloseAndWait.mutex.RUnlock()

	return argCopy
}

// MinimockCloseAndWaitDone returns true if the count of the CloseAndWait invocations corresponds
// the number of defined expectations
func (m *ManagerMock) MinimockCloseAndWaitDone() bool {
	for _, e := range m.CloseAndWaitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseAndWaitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseAndWaitCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCloseAndWait != nil && mm_atomic.LoadUint64(&m.afterCloseAndWaitCounter) < 1 {
		return false
	}
	return true
}

// MinimockCloseAndWaitInspect logs each unmet expectation
func (m *ManagerMock) MinimockCloseAndWaitInspect() {
	for _, e := range m.CloseAndWaitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ManagerMock.CloseAndWait with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseAndWaitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseAndWaitCounter) < 1 {
		if m.CloseAndWaitMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ManagerMock.CloseAndWait")
		} else {
			m.t.Errorf("Expected call to ManagerMock.CloseAndWait with params: %#v", *m.CloseAndWaitMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCloseAndWait != nil && mm_atomic.LoadUint64(&m.afterCloseAndWaitCounter) < 1 {
		m.t.Error("Expected call to ManagerMock.CloseAndWait")
	}
}

type mManagerMockOpen struct {
	mock               *ManagerMock
	defaultExpectation *ManagerMockOpenExpectation
	expectations       []*ManagerMockOpenExpectation

	callArgs []*ManagerMockOpenParams
	mutex    sync.RWMutex
}

// ManagerMockOpenExpectation specifies expectation struct of the Manager.Open
type ManagerMockOpenExpectation struct {
	mock    *ManagerMock
	params  *ManagerMockOpenParams
	results *ManagerMockOpenResults
	Counter uint64
}

// ManagerMockOpenParams contains parameters of the Manager.Open
type ManagerMockOpenParams struct {
	ctx context.Context
	p1  insolar.PulseNumber
}

// ManagerMockOpenResults contains results of the Manager.Open
type ManagerMockOpenResults struct {
	err error
}

// Expect sets up expected params for Manager.Open
func (mmOpen *mManagerMockOpen) Expect(ctx context.Context, p1 insolar.PulseNumber) *mManagerMockOpen {
	if mmOpen.mock.funcOpen != nil {
		mmOpen.mock.t.Fatalf("ManagerMock.Open mock is already set by Set")
	}

	if mmOpen.defaultExpectation == nil {
		mmOpen.defaultExpectation = &ManagerMockOpenExpectation{}
	}

	mmOpen.defaultExpectation.params = &ManagerMockOpenParams{ctx, p1}
	for _, e := range mmOpen.expectations {
		if minimock.Equal(e.params, mmOpen.defaultExpectation.params) {
			mmOpen.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOpen.defaultExpectation.params)
		}
	}

	return mmOpen
}

// Inspect accepts an inspector function that has same arguments as the Manager.Open
func (mmOpen *mManagerMockOpen) Inspect(f func(ctx context.Context, p1 insolar.PulseNumber)) *mManagerMockOpen {
	if mmOpen.mock.inspectFuncOpen != nil {
		mmOpen.mock.t.Fatalf("Inspect function is already set for ManagerMock.Open")
	}

	mmOpen.mock.inspectFuncOpen = f

	return mmOpen
}

// Return sets up results that will be returned by Manager.Open
func (mmOpen *mManagerMockOpen) Return(err error) *ManagerMock {
	if mmOpen.mock.funcOpen != nil {
		mmOpen.mock.t.Fatalf("ManagerMock.Open mock is already set by Set")
	}

	if mmOpen.defaultExpectation == nil {
		mmOpen.defaultExpectation = &ManagerMockOpenExpectation{mock: mmOpen.mock}
	}
	mmOpen.defaultExpectation.results = &ManagerMockOpenResults{err}
	return mmOpen.mock
}

//Set uses given function f to mock the Manager.Open method
func (mmOpen *mManagerMockOpen) Set(f func(ctx context.Context, p1 insolar.PulseNumber) (err error)) *ManagerMock {
	if mmOpen.defaultExpectation != nil {
		mmOpen.mock.t.Fatalf("Default expectation is already set for the Manager.Open method")
	}

	if len(mmOpen.expectations) > 0 {
		mmOpen.mock.t.Fatalf("Some expectations are already set for the Manager.Open method")
	}

	mmOpen.mock.funcOpen = f
	return mmOpen.mock
}

// When sets expectation for the Manager.Open which will trigger the result defined by the following
// Then helper
func (mmOpen *mManagerMockOpen) When(ctx context.Context, p1 insolar.PulseNumber) *ManagerMockOpenExpectation {
	if mmOpen.mock.funcOpen != nil {
		mmOpen.mock.t.Fatalf("ManagerMock.Open mock is already set by Set")
	}

	expectation := &ManagerMockOpenExpectation{
		mock:   mmOpen.mock,
		params: &ManagerMockOpenParams{ctx, p1},
	}
	mmOpen.expectations = append(mmOpen.expectations, expectation)
	return expectation
}

// Then sets up Manager.Open return parameters for the expectation previously defined by the When method
func (e *ManagerMockOpenExpectation) Then(err error) *ManagerMock {
	e.results = &ManagerMockOpenResults{err}
	return e.mock
}

// Open implements Manager
func (mmOpen *ManagerMock) Open(ctx context.Context, p1 insolar.PulseNumber) (err error) {
	mm_atomic.AddUint64(&mmOpen.beforeOpenCounter, 1)
	defer mm_atomic.AddUint64(&mmOpen.afterOpenCounter, 1)

	if mmOpen.inspectFuncOpen != nil {
		mmOpen.inspectFuncOpen(ctx, p1)
	}

	params := &ManagerMockOpenParams{ctx, p1}

	// Record call args
	mmOpen.OpenMock.mutex.Lock()
	mmOpen.OpenMock.callArgs = append(mmOpen.OpenMock.callArgs, params)
	mmOpen.OpenMock.mutex.Unlock()

	for _, e := range mmOpen.OpenMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmOpen.OpenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOpen.OpenMock.defaultExpectation.Counter, 1)
		want := mmOpen.OpenMock.defaultExpectation.params
		got := ManagerMockOpenParams{ctx, p1}
		if want != nil && !minimock.Equal(*want, got) {
			mmOpen.t.Errorf("ManagerMock.Open got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmOpen.OpenMock.defaultExpectation.results
		if results == nil {
			mmOpen.t.Fatal("No results are set for the ManagerMock.Open")
		}
		return (*results).err
	}
	if mmOpen.funcOpen != nil {
		return mmOpen.funcOpen(ctx, p1)
	}
	mmOpen.t.Fatalf("Unexpected call to ManagerMock.Open. %v %v", ctx, p1)
	return
}

// OpenAfterCounter returns a count of finished ManagerMock.Open invocations
func (mmOpen *ManagerMock) OpenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpen.afterOpenCounter)
}

// OpenBeforeCounter returns a count of ManagerMock.Open invocations
func (mmOpen *ManagerMock) OpenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpen.beforeOpenCounter)
}

// Calls returns a list of arguments used in each call to ManagerMock.Open.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOpen *mManagerMockOpen) Calls() []*ManagerMockOpenParams {
	mmOpen.mutex.RLock()

	argCopy := make([]*ManagerMockOpenParams, len(mmOpen.callArgs))
	copy(argCopy, mmOpen.callArgs)

	mmOpen.mutex.RUnlock()

	return argCopy
}

// MinimockOpenDone returns true if the count of the Open invocations corresponds
// the number of defined expectations
func (m *ManagerMock) MinimockOpenDone() bool {
	for _, e := range m.OpenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OpenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOpen != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		return false
	}
	return true
}

// MinimockOpenInspect logs each unmet expectation
func (m *ManagerMock) MinimockOpenInspect() {
	for _, e := range m.OpenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ManagerMock.Open with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OpenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		if m.OpenMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ManagerMock.Open")
		} else {
			m.t.Errorf("Expected call to ManagerMock.Open with params: %#v", *m.OpenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOpen != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		m.t.Error("Expected call to ManagerMock.Open")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ManagerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCloseAndWaitInspect()

		m.MinimockOpenInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ManagerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ManagerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCloseAndWaitDone() &&
		m.MinimockOpenDone()
}
