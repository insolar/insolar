package statestorage

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/insolar"
	"github.com/insolar/insolar/logicrunner/executionarchive"
	"github.com/insolar/insolar/logicrunner/executionbroker"
)

// StateStorageMock implements StateStorage
type StateStorageMock struct {
	t minimock.Tester

	funcGetExecutionArchive          func(ref insolar.Reference) (e1 executionarchive.ExecutionArchive)
	inspectFuncGetExecutionArchive   func(ref insolar.Reference)
	afterGetExecutionArchiveCounter  uint64
	beforeGetExecutionArchiveCounter uint64
	GetExecutionArchiveMock          mStateStorageMockGetExecutionArchive

	funcGetExecutionState          func(ref insolar.Reference) (b1 executionbroker.BrokerI)
	inspectFuncGetExecutionState   func(ref insolar.Reference)
	afterGetExecutionStateCounter  uint64
	beforeGetExecutionStateCounter uint64
	GetExecutionStateMock          mStateStorageMockGetExecutionState

	funcIsEmpty          func() (b1 bool)
	inspectFuncIsEmpty   func()
	afterIsEmptyCounter  uint64
	beforeIsEmptyCounter uint64
	IsEmptyMock          mStateStorageMockIsEmpty

	funcLock          func()
	inspectFuncLock   func()
	afterLockCounter  uint64
	beforeLockCounter uint64
	LockMock          mStateStorageMockLock

	funcOnPulse          func(ctx context.Context, pulse insolar.Pulse) (ma1 []insolar.Message)
	inspectFuncOnPulse   func(ctx context.Context, pulse insolar.Pulse)
	afterOnPulseCounter  uint64
	beforeOnPulseCounter uint64
	OnPulseMock          mStateStorageMockOnPulse

	funcUnlock          func()
	inspectFuncUnlock   func()
	afterUnlockCounter  uint64
	beforeUnlockCounter uint64
	UnlockMock          mStateStorageMockUnlock

	funcUpsertExecutionState          func(ref insolar.Reference) (b1 executionbroker.BrokerI)
	inspectFuncUpsertExecutionState   func(ref insolar.Reference)
	afterUpsertExecutionStateCounter  uint64
	beforeUpsertExecutionStateCounter uint64
	UpsertExecutionStateMock          mStateStorageMockUpsertExecutionState
}

// NewStateStorageMock returns a mock for StateStorage
func NewStateStorageMock(t minimock.Tester) *StateStorageMock {
	m := &StateStorageMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetExecutionArchiveMock = mStateStorageMockGetExecutionArchive{mock: m}
	m.GetExecutionArchiveMock.callArgs = []*StateStorageMockGetExecutionArchiveParams{}

	m.GetExecutionStateMock = mStateStorageMockGetExecutionState{mock: m}
	m.GetExecutionStateMock.callArgs = []*StateStorageMockGetExecutionStateParams{}

	m.IsEmptyMock = mStateStorageMockIsEmpty{mock: m}

	m.LockMock = mStateStorageMockLock{mock: m}

	m.OnPulseMock = mStateStorageMockOnPulse{mock: m}
	m.OnPulseMock.callArgs = []*StateStorageMockOnPulseParams{}

	m.UnlockMock = mStateStorageMockUnlock{mock: m}

	m.UpsertExecutionStateMock = mStateStorageMockUpsertExecutionState{mock: m}
	m.UpsertExecutionStateMock.callArgs = []*StateStorageMockUpsertExecutionStateParams{}

	return m
}

type mStateStorageMockGetExecutionArchive struct {
	mock               *StateStorageMock
	defaultExpectation *StateStorageMockGetExecutionArchiveExpectation
	expectations       []*StateStorageMockGetExecutionArchiveExpectation

	callArgs []*StateStorageMockGetExecutionArchiveParams
	mutex    sync.RWMutex
}

// StateStorageMockGetExecutionArchiveExpectation specifies expectation struct of the StateStorage.GetExecutionArchive
type StateStorageMockGetExecutionArchiveExpectation struct {
	mock    *StateStorageMock
	params  *StateStorageMockGetExecutionArchiveParams
	results *StateStorageMockGetExecutionArchiveResults
	Counter uint64
}

// StateStorageMockGetExecutionArchiveParams contains parameters of the StateStorage.GetExecutionArchive
type StateStorageMockGetExecutionArchiveParams struct {
	ref insolar.Reference
}

// StateStorageMockGetExecutionArchiveResults contains results of the StateStorage.GetExecutionArchive
type StateStorageMockGetExecutionArchiveResults struct {
	e1 executionarchive.ExecutionArchive
}

// Expect sets up expected params for StateStorage.GetExecutionArchive
func (mmGetExecutionArchive *mStateStorageMockGetExecutionArchive) Expect(ref insolar.Reference) *mStateStorageMockGetExecutionArchive {
	if mmGetExecutionArchive.mock.funcGetExecutionArchive != nil {
		mmGetExecutionArchive.mock.t.Fatalf("StateStorageMock.GetExecutionArchive mock is already set by Set")
	}

	if mmGetExecutionArchive.defaultExpectation == nil {
		mmGetExecutionArchive.defaultExpectation = &StateStorageMockGetExecutionArchiveExpectation{}
	}

	mmGetExecutionArchive.defaultExpectation.params = &StateStorageMockGetExecutionArchiveParams{ref}
	for _, e := range mmGetExecutionArchive.expectations {
		if minimock.Equal(e.params, mmGetExecutionArchive.defaultExpectation.params) {
			mmGetExecutionArchive.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetExecutionArchive.defaultExpectation.params)
		}
	}

	return mmGetExecutionArchive
}

// Inspect accepts an inspector function that has same arguments as the StateStorage.GetExecutionArchive
func (mmGetExecutionArchive *mStateStorageMockGetExecutionArchive) Inspect(f func(ref insolar.Reference)) *mStateStorageMockGetExecutionArchive {
	if mmGetExecutionArchive.mock.inspectFuncGetExecutionArchive != nil {
		mmGetExecutionArchive.mock.t.Fatalf("Inspect function is already set for StateStorageMock.GetExecutionArchive")
	}

	mmGetExecutionArchive.mock.inspectFuncGetExecutionArchive = f

	return mmGetExecutionArchive
}

// Return sets up results that will be returned by StateStorage.GetExecutionArchive
func (mmGetExecutionArchive *mStateStorageMockGetExecutionArchive) Return(e1 executionarchive.ExecutionArchive) *StateStorageMock {
	if mmGetExecutionArchive.mock.funcGetExecutionArchive != nil {
		mmGetExecutionArchive.mock.t.Fatalf("StateStorageMock.GetExecutionArchive mock is already set by Set")
	}

	if mmGetExecutionArchive.defaultExpectation == nil {
		mmGetExecutionArchive.defaultExpectation = &StateStorageMockGetExecutionArchiveExpectation{mock: mmGetExecutionArchive.mock}
	}
	mmGetExecutionArchive.defaultExpectation.results = &StateStorageMockGetExecutionArchiveResults{e1}
	return mmGetExecutionArchive.mock
}

//Set uses given function f to mock the StateStorage.GetExecutionArchive method
func (mmGetExecutionArchive *mStateStorageMockGetExecutionArchive) Set(f func(ref insolar.Reference) (e1 executionarchive.ExecutionArchive)) *StateStorageMock {
	if mmGetExecutionArchive.defaultExpectation != nil {
		mmGetExecutionArchive.mock.t.Fatalf("Default expectation is already set for the StateStorage.GetExecutionArchive method")
	}

	if len(mmGetExecutionArchive.expectations) > 0 {
		mmGetExecutionArchive.mock.t.Fatalf("Some expectations are already set for the StateStorage.GetExecutionArchive method")
	}

	mmGetExecutionArchive.mock.funcGetExecutionArchive = f
	return mmGetExecutionArchive.mock
}

// When sets expectation for the StateStorage.GetExecutionArchive which will trigger the result defined by the following
// Then helper
func (mmGetExecutionArchive *mStateStorageMockGetExecutionArchive) When(ref insolar.Reference) *StateStorageMockGetExecutionArchiveExpectation {
	if mmGetExecutionArchive.mock.funcGetExecutionArchive != nil {
		mmGetExecutionArchive.mock.t.Fatalf("StateStorageMock.GetExecutionArchive mock is already set by Set")
	}

	expectation := &StateStorageMockGetExecutionArchiveExpectation{
		mock:   mmGetExecutionArchive.mock,
		params: &StateStorageMockGetExecutionArchiveParams{ref},
	}
	mmGetExecutionArchive.expectations = append(mmGetExecutionArchive.expectations, expectation)
	return expectation
}

// Then sets up StateStorage.GetExecutionArchive return parameters for the expectation previously defined by the When method
func (e *StateStorageMockGetExecutionArchiveExpectation) Then(e1 executionarchive.ExecutionArchive) *StateStorageMock {
	e.results = &StateStorageMockGetExecutionArchiveResults{e1}
	return e.mock
}

// GetExecutionArchive implements StateStorage
func (mmGetExecutionArchive *StateStorageMock) GetExecutionArchive(ref insolar.Reference) (e1 executionarchive.ExecutionArchive) {
	mm_atomic.AddUint64(&mmGetExecutionArchive.beforeGetExecutionArchiveCounter, 1)
	defer mm_atomic.AddUint64(&mmGetExecutionArchive.afterGetExecutionArchiveCounter, 1)

	if mmGetExecutionArchive.inspectFuncGetExecutionArchive != nil {
		mmGetExecutionArchive.inspectFuncGetExecutionArchive(ref)
	}

	params := &StateStorageMockGetExecutionArchiveParams{ref}

	// Record call args
	mmGetExecutionArchive.GetExecutionArchiveMock.mutex.Lock()
	mmGetExecutionArchive.GetExecutionArchiveMock.callArgs = append(mmGetExecutionArchive.GetExecutionArchiveMock.callArgs, params)
	mmGetExecutionArchive.GetExecutionArchiveMock.mutex.Unlock()

	for _, e := range mmGetExecutionArchive.GetExecutionArchiveMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.e1
		}
	}

	if mmGetExecutionArchive.GetExecutionArchiveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetExecutionArchive.GetExecutionArchiveMock.defaultExpectation.Counter, 1)
		want := mmGetExecutionArchive.GetExecutionArchiveMock.defaultExpectation.params
		got := StateStorageMockGetExecutionArchiveParams{ref}
		if want != nil && !minimock.Equal(*want, got) {
			mmGetExecutionArchive.t.Errorf("StateStorageMock.GetExecutionArchive got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmGetExecutionArchive.GetExecutionArchiveMock.defaultExpectation.results
		if results == nil {
			mmGetExecutionArchive.t.Fatal("No results are set for the StateStorageMock.GetExecutionArchive")
		}
		return (*results).e1
	}
	if mmGetExecutionArchive.funcGetExecutionArchive != nil {
		return mmGetExecutionArchive.funcGetExecutionArchive(ref)
	}
	mmGetExecutionArchive.t.Fatalf("Unexpected call to StateStorageMock.GetExecutionArchive. %v", ref)
	return
}

// GetExecutionArchiveAfterCounter returns a count of finished StateStorageMock.GetExecutionArchive invocations
func (mmGetExecutionArchive *StateStorageMock) GetExecutionArchiveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetExecutionArchive.afterGetExecutionArchiveCounter)
}

// GetExecutionArchiveBeforeCounter returns a count of StateStorageMock.GetExecutionArchive invocations
func (mmGetExecutionArchive *StateStorageMock) GetExecutionArchiveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetExecutionArchive.beforeGetExecutionArchiveCounter)
}

// Calls returns a list of arguments used in each call to StateStorageMock.GetExecutionArchive.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetExecutionArchive *mStateStorageMockGetExecutionArchive) Calls() []*StateStorageMockGetExecutionArchiveParams {
	mmGetExecutionArchive.mutex.RLock()

	argCopy := make([]*StateStorageMockGetExecutionArchiveParams, len(mmGetExecutionArchive.callArgs))
	copy(argCopy, mmGetExecutionArchive.callArgs)

	mmGetExecutionArchive.mutex.RUnlock()

	return argCopy
}

// MinimockGetExecutionArchiveDone returns true if the count of the GetExecutionArchive invocations corresponds
// the number of defined expectations
func (m *StateStorageMock) MinimockGetExecutionArchiveDone() bool {
	for _, e := range m.GetExecutionArchiveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetExecutionArchiveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetExecutionArchiveCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetExecutionArchive != nil && mm_atomic.LoadUint64(&m.afterGetExecutionArchiveCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetExecutionArchiveInspect logs each unmet expectation
func (m *StateStorageMock) MinimockGetExecutionArchiveInspect() {
	for _, e := range m.GetExecutionArchiveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StateStorageMock.GetExecutionArchive with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetExecutionArchiveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetExecutionArchiveCounter) < 1 {
		if m.GetExecutionArchiveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StateStorageMock.GetExecutionArchive")
		} else {
			m.t.Errorf("Expected call to StateStorageMock.GetExecutionArchive with params: %#v", *m.GetExecutionArchiveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetExecutionArchive != nil && mm_atomic.LoadUint64(&m.afterGetExecutionArchiveCounter) < 1 {
		m.t.Error("Expected call to StateStorageMock.GetExecutionArchive")
	}
}

type mStateStorageMockGetExecutionState struct {
	mock               *StateStorageMock
	defaultExpectation *StateStorageMockGetExecutionStateExpectation
	expectations       []*StateStorageMockGetExecutionStateExpectation

	callArgs []*StateStorageMockGetExecutionStateParams
	mutex    sync.RWMutex
}

// StateStorageMockGetExecutionStateExpectation specifies expectation struct of the StateStorage.GetExecutionState
type StateStorageMockGetExecutionStateExpectation struct {
	mock    *StateStorageMock
	params  *StateStorageMockGetExecutionStateParams
	results *StateStorageMockGetExecutionStateResults
	Counter uint64
}

// StateStorageMockGetExecutionStateParams contains parameters of the StateStorage.GetExecutionState
type StateStorageMockGetExecutionStateParams struct {
	ref insolar.Reference
}

// StateStorageMockGetExecutionStateResults contains results of the StateStorage.GetExecutionState
type StateStorageMockGetExecutionStateResults struct {
	b1 executionbroker.BrokerI
}

// Expect sets up expected params for StateStorage.GetExecutionState
func (mmGetExecutionState *mStateStorageMockGetExecutionState) Expect(ref insolar.Reference) *mStateStorageMockGetExecutionState {
	if mmGetExecutionState.mock.funcGetExecutionState != nil {
		mmGetExecutionState.mock.t.Fatalf("StateStorageMock.GetExecutionState mock is already set by Set")
	}

	if mmGetExecutionState.defaultExpectation == nil {
		mmGetExecutionState.defaultExpectation = &StateStorageMockGetExecutionStateExpectation{}
	}

	mmGetExecutionState.defaultExpectation.params = &StateStorageMockGetExecutionStateParams{ref}
	for _, e := range mmGetExecutionState.expectations {
		if minimock.Equal(e.params, mmGetExecutionState.defaultExpectation.params) {
			mmGetExecutionState.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetExecutionState.defaultExpectation.params)
		}
	}

	return mmGetExecutionState
}

// Inspect accepts an inspector function that has same arguments as the StateStorage.GetExecutionState
func (mmGetExecutionState *mStateStorageMockGetExecutionState) Inspect(f func(ref insolar.Reference)) *mStateStorageMockGetExecutionState {
	if mmGetExecutionState.mock.inspectFuncGetExecutionState != nil {
		mmGetExecutionState.mock.t.Fatalf("Inspect function is already set for StateStorageMock.GetExecutionState")
	}

	mmGetExecutionState.mock.inspectFuncGetExecutionState = f

	return mmGetExecutionState
}

// Return sets up results that will be returned by StateStorage.GetExecutionState
func (mmGetExecutionState *mStateStorageMockGetExecutionState) Return(b1 executionbroker.BrokerI) *StateStorageMock {
	if mmGetExecutionState.mock.funcGetExecutionState != nil {
		mmGetExecutionState.mock.t.Fatalf("StateStorageMock.GetExecutionState mock is already set by Set")
	}

	if mmGetExecutionState.defaultExpectation == nil {
		mmGetExecutionState.defaultExpectation = &StateStorageMockGetExecutionStateExpectation{mock: mmGetExecutionState.mock}
	}
	mmGetExecutionState.defaultExpectation.results = &StateStorageMockGetExecutionStateResults{b1}
	return mmGetExecutionState.mock
}

//Set uses given function f to mock the StateStorage.GetExecutionState method
func (mmGetExecutionState *mStateStorageMockGetExecutionState) Set(f func(ref insolar.Reference) (b1 executionbroker.BrokerI)) *StateStorageMock {
	if mmGetExecutionState.defaultExpectation != nil {
		mmGetExecutionState.mock.t.Fatalf("Default expectation is already set for the StateStorage.GetExecutionState method")
	}

	if len(mmGetExecutionState.expectations) > 0 {
		mmGetExecutionState.mock.t.Fatalf("Some expectations are already set for the StateStorage.GetExecutionState method")
	}

	mmGetExecutionState.mock.funcGetExecutionState = f
	return mmGetExecutionState.mock
}

// When sets expectation for the StateStorage.GetExecutionState which will trigger the result defined by the following
// Then helper
func (mmGetExecutionState *mStateStorageMockGetExecutionState) When(ref insolar.Reference) *StateStorageMockGetExecutionStateExpectation {
	if mmGetExecutionState.mock.funcGetExecutionState != nil {
		mmGetExecutionState.mock.t.Fatalf("StateStorageMock.GetExecutionState mock is already set by Set")
	}

	expectation := &StateStorageMockGetExecutionStateExpectation{
		mock:   mmGetExecutionState.mock,
		params: &StateStorageMockGetExecutionStateParams{ref},
	}
	mmGetExecutionState.expectations = append(mmGetExecutionState.expectations, expectation)
	return expectation
}

// Then sets up StateStorage.GetExecutionState return parameters for the expectation previously defined by the When method
func (e *StateStorageMockGetExecutionStateExpectation) Then(b1 executionbroker.BrokerI) *StateStorageMock {
	e.results = &StateStorageMockGetExecutionStateResults{b1}
	return e.mock
}

// GetExecutionState implements StateStorage
func (mmGetExecutionState *StateStorageMock) GetExecutionState(ref insolar.Reference) (b1 executionbroker.BrokerI) {
	mm_atomic.AddUint64(&mmGetExecutionState.beforeGetExecutionStateCounter, 1)
	defer mm_atomic.AddUint64(&mmGetExecutionState.afterGetExecutionStateCounter, 1)

	if mmGetExecutionState.inspectFuncGetExecutionState != nil {
		mmGetExecutionState.inspectFuncGetExecutionState(ref)
	}

	params := &StateStorageMockGetExecutionStateParams{ref}

	// Record call args
	mmGetExecutionState.GetExecutionStateMock.mutex.Lock()
	mmGetExecutionState.GetExecutionStateMock.callArgs = append(mmGetExecutionState.GetExecutionStateMock.callArgs, params)
	mmGetExecutionState.GetExecutionStateMock.mutex.Unlock()

	for _, e := range mmGetExecutionState.GetExecutionStateMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmGetExecutionState.GetExecutionStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetExecutionState.GetExecutionStateMock.defaultExpectation.Counter, 1)
		want := mmGetExecutionState.GetExecutionStateMock.defaultExpectation.params
		got := StateStorageMockGetExecutionStateParams{ref}
		if want != nil && !minimock.Equal(*want, got) {
			mmGetExecutionState.t.Errorf("StateStorageMock.GetExecutionState got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmGetExecutionState.GetExecutionStateMock.defaultExpectation.results
		if results == nil {
			mmGetExecutionState.t.Fatal("No results are set for the StateStorageMock.GetExecutionState")
		}
		return (*results).b1
	}
	if mmGetExecutionState.funcGetExecutionState != nil {
		return mmGetExecutionState.funcGetExecutionState(ref)
	}
	mmGetExecutionState.t.Fatalf("Unexpected call to StateStorageMock.GetExecutionState. %v", ref)
	return
}

// GetExecutionStateAfterCounter returns a count of finished StateStorageMock.GetExecutionState invocations
func (mmGetExecutionState *StateStorageMock) GetExecutionStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetExecutionState.afterGetExecutionStateCounter)
}

// GetExecutionStateBeforeCounter returns a count of StateStorageMock.GetExecutionState invocations
func (mmGetExecutionState *StateStorageMock) GetExecutionStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetExecutionState.beforeGetExecutionStateCounter)
}

// Calls returns a list of arguments used in each call to StateStorageMock.GetExecutionState.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetExecutionState *mStateStorageMockGetExecutionState) Calls() []*StateStorageMockGetExecutionStateParams {
	mmGetExecutionState.mutex.RLock()

	argCopy := make([]*StateStorageMockGetExecutionStateParams, len(mmGetExecutionState.callArgs))
	copy(argCopy, mmGetExecutionState.callArgs)

	mmGetExecutionState.mutex.RUnlock()

	return argCopy
}

// MinimockGetExecutionStateDone returns true if the count of the GetExecutionState invocations corresponds
// the number of defined expectations
func (m *StateStorageMock) MinimockGetExecutionStateDone() bool {
	for _, e := range m.GetExecutionStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetExecutionStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetExecutionStateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetExecutionState != nil && mm_atomic.LoadUint64(&m.afterGetExecutionStateCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetExecutionStateInspect logs each unmet expectation
func (m *StateStorageMock) MinimockGetExecutionStateInspect() {
	for _, e := range m.GetExecutionStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StateStorageMock.GetExecutionState with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetExecutionStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetExecutionStateCounter) < 1 {
		if m.GetExecutionStateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StateStorageMock.GetExecutionState")
		} else {
			m.t.Errorf("Expected call to StateStorageMock.GetExecutionState with params: %#v", *m.GetExecutionStateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetExecutionState != nil && mm_atomic.LoadUint64(&m.afterGetExecutionStateCounter) < 1 {
		m.t.Error("Expected call to StateStorageMock.GetExecutionState")
	}
}

type mStateStorageMockIsEmpty struct {
	mock               *StateStorageMock
	defaultExpectation *StateStorageMockIsEmptyExpectation
	expectations       []*StateStorageMockIsEmptyExpectation
}

// StateStorageMockIsEmptyExpectation specifies expectation struct of the StateStorage.IsEmpty
type StateStorageMockIsEmptyExpectation struct {
	mock *StateStorageMock

	results *StateStorageMockIsEmptyResults
	Counter uint64
}

// StateStorageMockIsEmptyResults contains results of the StateStorage.IsEmpty
type StateStorageMockIsEmptyResults struct {
	b1 bool
}

// Expect sets up expected params for StateStorage.IsEmpty
func (mmIsEmpty *mStateStorageMockIsEmpty) Expect() *mStateStorageMockIsEmpty {
	if mmIsEmpty.mock.funcIsEmpty != nil {
		mmIsEmpty.mock.t.Fatalf("StateStorageMock.IsEmpty mock is already set by Set")
	}

	if mmIsEmpty.defaultExpectation == nil {
		mmIsEmpty.defaultExpectation = &StateStorageMockIsEmptyExpectation{}
	}

	return mmIsEmpty
}

// Inspect accepts an inspector function that has same arguments as the StateStorage.IsEmpty
func (mmIsEmpty *mStateStorageMockIsEmpty) Inspect(f func()) *mStateStorageMockIsEmpty {
	if mmIsEmpty.mock.inspectFuncIsEmpty != nil {
		mmIsEmpty.mock.t.Fatalf("Inspect function is already set for StateStorageMock.IsEmpty")
	}

	mmIsEmpty.mock.inspectFuncIsEmpty = f

	return mmIsEmpty
}

// Return sets up results that will be returned by StateStorage.IsEmpty
func (mmIsEmpty *mStateStorageMockIsEmpty) Return(b1 bool) *StateStorageMock {
	if mmIsEmpty.mock.funcIsEmpty != nil {
		mmIsEmpty.mock.t.Fatalf("StateStorageMock.IsEmpty mock is already set by Set")
	}

	if mmIsEmpty.defaultExpectation == nil {
		mmIsEmpty.defaultExpectation = &StateStorageMockIsEmptyExpectation{mock: mmIsEmpty.mock}
	}
	mmIsEmpty.defaultExpectation.results = &StateStorageMockIsEmptyResults{b1}
	return mmIsEmpty.mock
}

//Set uses given function f to mock the StateStorage.IsEmpty method
func (mmIsEmpty *mStateStorageMockIsEmpty) Set(f func() (b1 bool)) *StateStorageMock {
	if mmIsEmpty.defaultExpectation != nil {
		mmIsEmpty.mock.t.Fatalf("Default expectation is already set for the StateStorage.IsEmpty method")
	}

	if len(mmIsEmpty.expectations) > 0 {
		mmIsEmpty.mock.t.Fatalf("Some expectations are already set for the StateStorage.IsEmpty method")
	}

	mmIsEmpty.mock.funcIsEmpty = f
	return mmIsEmpty.mock
}

// IsEmpty implements StateStorage
func (mmIsEmpty *StateStorageMock) IsEmpty() (b1 bool) {
	mm_atomic.AddUint64(&mmIsEmpty.beforeIsEmptyCounter, 1)
	defer mm_atomic.AddUint64(&mmIsEmpty.afterIsEmptyCounter, 1)

	if mmIsEmpty.inspectFuncIsEmpty != nil {
		mmIsEmpty.inspectFuncIsEmpty()
	}

	if mmIsEmpty.IsEmptyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsEmpty.IsEmptyMock.defaultExpectation.Counter, 1)

		results := mmIsEmpty.IsEmptyMock.defaultExpectation.results
		if results == nil {
			mmIsEmpty.t.Fatal("No results are set for the StateStorageMock.IsEmpty")
		}
		return (*results).b1
	}
	if mmIsEmpty.funcIsEmpty != nil {
		return mmIsEmpty.funcIsEmpty()
	}
	mmIsEmpty.t.Fatalf("Unexpected call to StateStorageMock.IsEmpty.")
	return
}

// IsEmptyAfterCounter returns a count of finished StateStorageMock.IsEmpty invocations
func (mmIsEmpty *StateStorageMock) IsEmptyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsEmpty.afterIsEmptyCounter)
}

// IsEmptyBeforeCounter returns a count of StateStorageMock.IsEmpty invocations
func (mmIsEmpty *StateStorageMock) IsEmptyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsEmpty.beforeIsEmptyCounter)
}

// MinimockIsEmptyDone returns true if the count of the IsEmpty invocations corresponds
// the number of defined expectations
func (m *StateStorageMock) MinimockIsEmptyDone() bool {
	for _, e := range m.IsEmptyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsEmptyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsEmptyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsEmpty != nil && mm_atomic.LoadUint64(&m.afterIsEmptyCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsEmptyInspect logs each unmet expectation
func (m *StateStorageMock) MinimockIsEmptyInspect() {
	for _, e := range m.IsEmptyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StateStorageMock.IsEmpty")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsEmptyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsEmptyCounter) < 1 {
		m.t.Error("Expected call to StateStorageMock.IsEmpty")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsEmpty != nil && mm_atomic.LoadUint64(&m.afterIsEmptyCounter) < 1 {
		m.t.Error("Expected call to StateStorageMock.IsEmpty")
	}
}

type mStateStorageMockLock struct {
	mock               *StateStorageMock
	defaultExpectation *StateStorageMockLockExpectation
	expectations       []*StateStorageMockLockExpectation
}

// StateStorageMockLockExpectation specifies expectation struct of the StateStorage.Lock
type StateStorageMockLockExpectation struct {
	mock *StateStorageMock

	Counter uint64
}

// Expect sets up expected params for StateStorage.Lock
func (mmLock *mStateStorageMockLock) Expect() *mStateStorageMockLock {
	if mmLock.mock.funcLock != nil {
		mmLock.mock.t.Fatalf("StateStorageMock.Lock mock is already set by Set")
	}

	if mmLock.defaultExpectation == nil {
		mmLock.defaultExpectation = &StateStorageMockLockExpectation{}
	}

	return mmLock
}

// Inspect accepts an inspector function that has same arguments as the StateStorage.Lock
func (mmLock *mStateStorageMockLock) Inspect(f func()) *mStateStorageMockLock {
	if mmLock.mock.inspectFuncLock != nil {
		mmLock.mock.t.Fatalf("Inspect function is already set for StateStorageMock.Lock")
	}

	mmLock.mock.inspectFuncLock = f

	return mmLock
}

// Return sets up results that will be returned by StateStorage.Lock
func (mmLock *mStateStorageMockLock) Return() *StateStorageMock {
	if mmLock.mock.funcLock != nil {
		mmLock.mock.t.Fatalf("StateStorageMock.Lock mock is already set by Set")
	}

	if mmLock.defaultExpectation == nil {
		mmLock.defaultExpectation = &StateStorageMockLockExpectation{mock: mmLock.mock}
	}

	return mmLock.mock
}

//Set uses given function f to mock the StateStorage.Lock method
func (mmLock *mStateStorageMockLock) Set(f func()) *StateStorageMock {
	if mmLock.defaultExpectation != nil {
		mmLock.mock.t.Fatalf("Default expectation is already set for the StateStorage.Lock method")
	}

	if len(mmLock.expectations) > 0 {
		mmLock.mock.t.Fatalf("Some expectations are already set for the StateStorage.Lock method")
	}

	mmLock.mock.funcLock = f
	return mmLock.mock
}

// Lock implements StateStorage
func (mmLock *StateStorageMock) Lock() {
	mm_atomic.AddUint64(&mmLock.beforeLockCounter, 1)
	defer mm_atomic.AddUint64(&mmLock.afterLockCounter, 1)

	if mmLock.inspectFuncLock != nil {
		mmLock.inspectFuncLock()
	}

	if mmLock.LockMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLock.LockMock.defaultExpectation.Counter, 1)

		return

	}
	if mmLock.funcLock != nil {
		mmLock.funcLock()
		return
	}
	mmLock.t.Fatalf("Unexpected call to StateStorageMock.Lock.")

}

// LockAfterCounter returns a count of finished StateStorageMock.Lock invocations
func (mmLock *StateStorageMock) LockAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLock.afterLockCounter)
}

// LockBeforeCounter returns a count of StateStorageMock.Lock invocations
func (mmLock *StateStorageMock) LockBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLock.beforeLockCounter)
}

// MinimockLockDone returns true if the count of the Lock invocations corresponds
// the number of defined expectations
func (m *StateStorageMock) MinimockLockDone() bool {
	for _, e := range m.LockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LockMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLockCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLock != nil && mm_atomic.LoadUint64(&m.afterLockCounter) < 1 {
		return false
	}
	return true
}

// MinimockLockInspect logs each unmet expectation
func (m *StateStorageMock) MinimockLockInspect() {
	for _, e := range m.LockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StateStorageMock.Lock")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LockMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLockCounter) < 1 {
		m.t.Error("Expected call to StateStorageMock.Lock")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLock != nil && mm_atomic.LoadUint64(&m.afterLockCounter) < 1 {
		m.t.Error("Expected call to StateStorageMock.Lock")
	}
}

type mStateStorageMockOnPulse struct {
	mock               *StateStorageMock
	defaultExpectation *StateStorageMockOnPulseExpectation
	expectations       []*StateStorageMockOnPulseExpectation

	callArgs []*StateStorageMockOnPulseParams
	mutex    sync.RWMutex
}

// StateStorageMockOnPulseExpectation specifies expectation struct of the StateStorage.OnPulse
type StateStorageMockOnPulseExpectation struct {
	mock    *StateStorageMock
	params  *StateStorageMockOnPulseParams
	results *StateStorageMockOnPulseResults
	Counter uint64
}

// StateStorageMockOnPulseParams contains parameters of the StateStorage.OnPulse
type StateStorageMockOnPulseParams struct {
	ctx   context.Context
	pulse insolar.Pulse
}

// StateStorageMockOnPulseResults contains results of the StateStorage.OnPulse
type StateStorageMockOnPulseResults struct {
	ma1 []insolar.Message
}

// Expect sets up expected params for StateStorage.OnPulse
func (mmOnPulse *mStateStorageMockOnPulse) Expect(ctx context.Context, pulse insolar.Pulse) *mStateStorageMockOnPulse {
	if mmOnPulse.mock.funcOnPulse != nil {
		mmOnPulse.mock.t.Fatalf("StateStorageMock.OnPulse mock is already set by Set")
	}

	if mmOnPulse.defaultExpectation == nil {
		mmOnPulse.defaultExpectation = &StateStorageMockOnPulseExpectation{}
	}

	mmOnPulse.defaultExpectation.params = &StateStorageMockOnPulseParams{ctx, pulse}
	for _, e := range mmOnPulse.expectations {
		if minimock.Equal(e.params, mmOnPulse.defaultExpectation.params) {
			mmOnPulse.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOnPulse.defaultExpectation.params)
		}
	}

	return mmOnPulse
}

// Inspect accepts an inspector function that has same arguments as the StateStorage.OnPulse
func (mmOnPulse *mStateStorageMockOnPulse) Inspect(f func(ctx context.Context, pulse insolar.Pulse)) *mStateStorageMockOnPulse {
	if mmOnPulse.mock.inspectFuncOnPulse != nil {
		mmOnPulse.mock.t.Fatalf("Inspect function is already set for StateStorageMock.OnPulse")
	}

	mmOnPulse.mock.inspectFuncOnPulse = f

	return mmOnPulse
}

// Return sets up results that will be returned by StateStorage.OnPulse
func (mmOnPulse *mStateStorageMockOnPulse) Return(ma1 []insolar.Message) *StateStorageMock {
	if mmOnPulse.mock.funcOnPulse != nil {
		mmOnPulse.mock.t.Fatalf("StateStorageMock.OnPulse mock is already set by Set")
	}

	if mmOnPulse.defaultExpectation == nil {
		mmOnPulse.defaultExpectation = &StateStorageMockOnPulseExpectation{mock: mmOnPulse.mock}
	}
	mmOnPulse.defaultExpectation.results = &StateStorageMockOnPulseResults{ma1}
	return mmOnPulse.mock
}

//Set uses given function f to mock the StateStorage.OnPulse method
func (mmOnPulse *mStateStorageMockOnPulse) Set(f func(ctx context.Context, pulse insolar.Pulse) (ma1 []insolar.Message)) *StateStorageMock {
	if mmOnPulse.defaultExpectation != nil {
		mmOnPulse.mock.t.Fatalf("Default expectation is already set for the StateStorage.OnPulse method")
	}

	if len(mmOnPulse.expectations) > 0 {
		mmOnPulse.mock.t.Fatalf("Some expectations are already set for the StateStorage.OnPulse method")
	}

	mmOnPulse.mock.funcOnPulse = f
	return mmOnPulse.mock
}

// When sets expectation for the StateStorage.OnPulse which will trigger the result defined by the following
// Then helper
func (mmOnPulse *mStateStorageMockOnPulse) When(ctx context.Context, pulse insolar.Pulse) *StateStorageMockOnPulseExpectation {
	if mmOnPulse.mock.funcOnPulse != nil {
		mmOnPulse.mock.t.Fatalf("StateStorageMock.OnPulse mock is already set by Set")
	}

	expectation := &StateStorageMockOnPulseExpectation{
		mock:   mmOnPulse.mock,
		params: &StateStorageMockOnPulseParams{ctx, pulse},
	}
	mmOnPulse.expectations = append(mmOnPulse.expectations, expectation)
	return expectation
}

// Then sets up StateStorage.OnPulse return parameters for the expectation previously defined by the When method
func (e *StateStorageMockOnPulseExpectation) Then(ma1 []insolar.Message) *StateStorageMock {
	e.results = &StateStorageMockOnPulseResults{ma1}
	return e.mock
}

// OnPulse implements StateStorage
func (mmOnPulse *StateStorageMock) OnPulse(ctx context.Context, pulse insolar.Pulse) (ma1 []insolar.Message) {
	mm_atomic.AddUint64(&mmOnPulse.beforeOnPulseCounter, 1)
	defer mm_atomic.AddUint64(&mmOnPulse.afterOnPulseCounter, 1)

	if mmOnPulse.inspectFuncOnPulse != nil {
		mmOnPulse.inspectFuncOnPulse(ctx, pulse)
	}

	params := &StateStorageMockOnPulseParams{ctx, pulse}

	// Record call args
	mmOnPulse.OnPulseMock.mutex.Lock()
	mmOnPulse.OnPulseMock.callArgs = append(mmOnPulse.OnPulseMock.callArgs, params)
	mmOnPulse.OnPulseMock.mutex.Unlock()

	for _, e := range mmOnPulse.OnPulseMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ma1
		}
	}

	if mmOnPulse.OnPulseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOnPulse.OnPulseMock.defaultExpectation.Counter, 1)
		want := mmOnPulse.OnPulseMock.defaultExpectation.params
		got := StateStorageMockOnPulseParams{ctx, pulse}
		if want != nil && !minimock.Equal(*want, got) {
			mmOnPulse.t.Errorf("StateStorageMock.OnPulse got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmOnPulse.OnPulseMock.defaultExpectation.results
		if results == nil {
			mmOnPulse.t.Fatal("No results are set for the StateStorageMock.OnPulse")
		}
		return (*results).ma1
	}
	if mmOnPulse.funcOnPulse != nil {
		return mmOnPulse.funcOnPulse(ctx, pulse)
	}
	mmOnPulse.t.Fatalf("Unexpected call to StateStorageMock.OnPulse. %v %v", ctx, pulse)
	return
}

// OnPulseAfterCounter returns a count of finished StateStorageMock.OnPulse invocations
func (mmOnPulse *StateStorageMock) OnPulseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOnPulse.afterOnPulseCounter)
}

// OnPulseBeforeCounter returns a count of StateStorageMock.OnPulse invocations
func (mmOnPulse *StateStorageMock) OnPulseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOnPulse.beforeOnPulseCounter)
}

// Calls returns a list of arguments used in each call to StateStorageMock.OnPulse.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOnPulse *mStateStorageMockOnPulse) Calls() []*StateStorageMockOnPulseParams {
	mmOnPulse.mutex.RLock()

	argCopy := make([]*StateStorageMockOnPulseParams, len(mmOnPulse.callArgs))
	copy(argCopy, mmOnPulse.callArgs)

	mmOnPulse.mutex.RUnlock()

	return argCopy
}

// MinimockOnPulseDone returns true if the count of the OnPulse invocations corresponds
// the number of defined expectations
func (m *StateStorageMock) MinimockOnPulseDone() bool {
	for _, e := range m.OnPulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OnPulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOnPulseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOnPulse != nil && mm_atomic.LoadUint64(&m.afterOnPulseCounter) < 1 {
		return false
	}
	return true
}

// MinimockOnPulseInspect logs each unmet expectation
func (m *StateStorageMock) MinimockOnPulseInspect() {
	for _, e := range m.OnPulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StateStorageMock.OnPulse with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OnPulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOnPulseCounter) < 1 {
		if m.OnPulseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StateStorageMock.OnPulse")
		} else {
			m.t.Errorf("Expected call to StateStorageMock.OnPulse with params: %#v", *m.OnPulseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOnPulse != nil && mm_atomic.LoadUint64(&m.afterOnPulseCounter) < 1 {
		m.t.Error("Expected call to StateStorageMock.OnPulse")
	}
}

type mStateStorageMockUnlock struct {
	mock               *StateStorageMock
	defaultExpectation *StateStorageMockUnlockExpectation
	expectations       []*StateStorageMockUnlockExpectation
}

// StateStorageMockUnlockExpectation specifies expectation struct of the StateStorage.Unlock
type StateStorageMockUnlockExpectation struct {
	mock *StateStorageMock

	Counter uint64
}

// Expect sets up expected params for StateStorage.Unlock
func (mmUnlock *mStateStorageMockUnlock) Expect() *mStateStorageMockUnlock {
	if mmUnlock.mock.funcUnlock != nil {
		mmUnlock.mock.t.Fatalf("StateStorageMock.Unlock mock is already set by Set")
	}

	if mmUnlock.defaultExpectation == nil {
		mmUnlock.defaultExpectation = &StateStorageMockUnlockExpectation{}
	}

	return mmUnlock
}

// Inspect accepts an inspector function that has same arguments as the StateStorage.Unlock
func (mmUnlock *mStateStorageMockUnlock) Inspect(f func()) *mStateStorageMockUnlock {
	if mmUnlock.mock.inspectFuncUnlock != nil {
		mmUnlock.mock.t.Fatalf("Inspect function is already set for StateStorageMock.Unlock")
	}

	mmUnlock.mock.inspectFuncUnlock = f

	return mmUnlock
}

// Return sets up results that will be returned by StateStorage.Unlock
func (mmUnlock *mStateStorageMockUnlock) Return() *StateStorageMock {
	if mmUnlock.mock.funcUnlock != nil {
		mmUnlock.mock.t.Fatalf("StateStorageMock.Unlock mock is already set by Set")
	}

	if mmUnlock.defaultExpectation == nil {
		mmUnlock.defaultExpectation = &StateStorageMockUnlockExpectation{mock: mmUnlock.mock}
	}

	return mmUnlock.mock
}

//Set uses given function f to mock the StateStorage.Unlock method
func (mmUnlock *mStateStorageMockUnlock) Set(f func()) *StateStorageMock {
	if mmUnlock.defaultExpectation != nil {
		mmUnlock.mock.t.Fatalf("Default expectation is already set for the StateStorage.Unlock method")
	}

	if len(mmUnlock.expectations) > 0 {
		mmUnlock.mock.t.Fatalf("Some expectations are already set for the StateStorage.Unlock method")
	}

	mmUnlock.mock.funcUnlock = f
	return mmUnlock.mock
}

// Unlock implements StateStorage
func (mmUnlock *StateStorageMock) Unlock() {
	mm_atomic.AddUint64(&mmUnlock.beforeUnlockCounter, 1)
	defer mm_atomic.AddUint64(&mmUnlock.afterUnlockCounter, 1)

	if mmUnlock.inspectFuncUnlock != nil {
		mmUnlock.inspectFuncUnlock()
	}

	if mmUnlock.UnlockMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUnlock.UnlockMock.defaultExpectation.Counter, 1)

		return

	}
	if mmUnlock.funcUnlock != nil {
		mmUnlock.funcUnlock()
		return
	}
	mmUnlock.t.Fatalf("Unexpected call to StateStorageMock.Unlock.")

}

// UnlockAfterCounter returns a count of finished StateStorageMock.Unlock invocations
func (mmUnlock *StateStorageMock) UnlockAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnlock.afterUnlockCounter)
}

// UnlockBeforeCounter returns a count of StateStorageMock.Unlock invocations
func (mmUnlock *StateStorageMock) UnlockBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnlock.beforeUnlockCounter)
}

// MinimockUnlockDone returns true if the count of the Unlock invocations corresponds
// the number of defined expectations
func (m *StateStorageMock) MinimockUnlockDone() bool {
	for _, e := range m.UnlockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnlockMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnlockCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnlock != nil && mm_atomic.LoadUint64(&m.afterUnlockCounter) < 1 {
		return false
	}
	return true
}

// MinimockUnlockInspect logs each unmet expectation
func (m *StateStorageMock) MinimockUnlockInspect() {
	for _, e := range m.UnlockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StateStorageMock.Unlock")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnlockMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnlockCounter) < 1 {
		m.t.Error("Expected call to StateStorageMock.Unlock")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnlock != nil && mm_atomic.LoadUint64(&m.afterUnlockCounter) < 1 {
		m.t.Error("Expected call to StateStorageMock.Unlock")
	}
}

type mStateStorageMockUpsertExecutionState struct {
	mock               *StateStorageMock
	defaultExpectation *StateStorageMockUpsertExecutionStateExpectation
	expectations       []*StateStorageMockUpsertExecutionStateExpectation

	callArgs []*StateStorageMockUpsertExecutionStateParams
	mutex    sync.RWMutex
}

// StateStorageMockUpsertExecutionStateExpectation specifies expectation struct of the StateStorage.UpsertExecutionState
type StateStorageMockUpsertExecutionStateExpectation struct {
	mock    *StateStorageMock
	params  *StateStorageMockUpsertExecutionStateParams
	results *StateStorageMockUpsertExecutionStateResults
	Counter uint64
}

// StateStorageMockUpsertExecutionStateParams contains parameters of the StateStorage.UpsertExecutionState
type StateStorageMockUpsertExecutionStateParams struct {
	ref insolar.Reference
}

// StateStorageMockUpsertExecutionStateResults contains results of the StateStorage.UpsertExecutionState
type StateStorageMockUpsertExecutionStateResults struct {
	b1 executionbroker.BrokerI
}

// Expect sets up expected params for StateStorage.UpsertExecutionState
func (mmUpsertExecutionState *mStateStorageMockUpsertExecutionState) Expect(ref insolar.Reference) *mStateStorageMockUpsertExecutionState {
	if mmUpsertExecutionState.mock.funcUpsertExecutionState != nil {
		mmUpsertExecutionState.mock.t.Fatalf("StateStorageMock.UpsertExecutionState mock is already set by Set")
	}

	if mmUpsertExecutionState.defaultExpectation == nil {
		mmUpsertExecutionState.defaultExpectation = &StateStorageMockUpsertExecutionStateExpectation{}
	}

	mmUpsertExecutionState.defaultExpectation.params = &StateStorageMockUpsertExecutionStateParams{ref}
	for _, e := range mmUpsertExecutionState.expectations {
		if minimock.Equal(e.params, mmUpsertExecutionState.defaultExpectation.params) {
			mmUpsertExecutionState.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpsertExecutionState.defaultExpectation.params)
		}
	}

	return mmUpsertExecutionState
}

// Inspect accepts an inspector function that has same arguments as the StateStorage.UpsertExecutionState
func (mmUpsertExecutionState *mStateStorageMockUpsertExecutionState) Inspect(f func(ref insolar.Reference)) *mStateStorageMockUpsertExecutionState {
	if mmUpsertExecutionState.mock.inspectFuncUpsertExecutionState != nil {
		mmUpsertExecutionState.mock.t.Fatalf("Inspect function is already set for StateStorageMock.UpsertExecutionState")
	}

	mmUpsertExecutionState.mock.inspectFuncUpsertExecutionState = f

	return mmUpsertExecutionState
}

// Return sets up results that will be returned by StateStorage.UpsertExecutionState
func (mmUpsertExecutionState *mStateStorageMockUpsertExecutionState) Return(b1 executionbroker.BrokerI) *StateStorageMock {
	if mmUpsertExecutionState.mock.funcUpsertExecutionState != nil {
		mmUpsertExecutionState.mock.t.Fatalf("StateStorageMock.UpsertExecutionState mock is already set by Set")
	}

	if mmUpsertExecutionState.defaultExpectation == nil {
		mmUpsertExecutionState.defaultExpectation = &StateStorageMockUpsertExecutionStateExpectation{mock: mmUpsertExecutionState.mock}
	}
	mmUpsertExecutionState.defaultExpectation.results = &StateStorageMockUpsertExecutionStateResults{b1}
	return mmUpsertExecutionState.mock
}

//Set uses given function f to mock the StateStorage.UpsertExecutionState method
func (mmUpsertExecutionState *mStateStorageMockUpsertExecutionState) Set(f func(ref insolar.Reference) (b1 executionbroker.BrokerI)) *StateStorageMock {
	if mmUpsertExecutionState.defaultExpectation != nil {
		mmUpsertExecutionState.mock.t.Fatalf("Default expectation is already set for the StateStorage.UpsertExecutionState method")
	}

	if len(mmUpsertExecutionState.expectations) > 0 {
		mmUpsertExecutionState.mock.t.Fatalf("Some expectations are already set for the StateStorage.UpsertExecutionState method")
	}

	mmUpsertExecutionState.mock.funcUpsertExecutionState = f
	return mmUpsertExecutionState.mock
}

// When sets expectation for the StateStorage.UpsertExecutionState which will trigger the result defined by the following
// Then helper
func (mmUpsertExecutionState *mStateStorageMockUpsertExecutionState) When(ref insolar.Reference) *StateStorageMockUpsertExecutionStateExpectation {
	if mmUpsertExecutionState.mock.funcUpsertExecutionState != nil {
		mmUpsertExecutionState.mock.t.Fatalf("StateStorageMock.UpsertExecutionState mock is already set by Set")
	}

	expectation := &StateStorageMockUpsertExecutionStateExpectation{
		mock:   mmUpsertExecutionState.mock,
		params: &StateStorageMockUpsertExecutionStateParams{ref},
	}
	mmUpsertExecutionState.expectations = append(mmUpsertExecutionState.expectations, expectation)
	return expectation
}

// Then sets up StateStorage.UpsertExecutionState return parameters for the expectation previously defined by the When method
func (e *StateStorageMockUpsertExecutionStateExpectation) Then(b1 executionbroker.BrokerI) *StateStorageMock {
	e.results = &StateStorageMockUpsertExecutionStateResults{b1}
	return e.mock
}

// UpsertExecutionState implements StateStorage
func (mmUpsertExecutionState *StateStorageMock) UpsertExecutionState(ref insolar.Reference) (b1 executionbroker.BrokerI) {
	mm_atomic.AddUint64(&mmUpsertExecutionState.beforeUpsertExecutionStateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpsertExecutionState.afterUpsertExecutionStateCounter, 1)

	if mmUpsertExecutionState.inspectFuncUpsertExecutionState != nil {
		mmUpsertExecutionState.inspectFuncUpsertExecutionState(ref)
	}

	params := &StateStorageMockUpsertExecutionStateParams{ref}

	// Record call args
	mmUpsertExecutionState.UpsertExecutionStateMock.mutex.Lock()
	mmUpsertExecutionState.UpsertExecutionStateMock.callArgs = append(mmUpsertExecutionState.UpsertExecutionStateMock.callArgs, params)
	mmUpsertExecutionState.UpsertExecutionStateMock.mutex.Unlock()

	for _, e := range mmUpsertExecutionState.UpsertExecutionStateMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmUpsertExecutionState.UpsertExecutionStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpsertExecutionState.UpsertExecutionStateMock.defaultExpectation.Counter, 1)
		want := mmUpsertExecutionState.UpsertExecutionStateMock.defaultExpectation.params
		got := StateStorageMockUpsertExecutionStateParams{ref}
		if want != nil && !minimock.Equal(*want, got) {
			mmUpsertExecutionState.t.Errorf("StateStorageMock.UpsertExecutionState got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmUpsertExecutionState.UpsertExecutionStateMock.defaultExpectation.results
		if results == nil {
			mmUpsertExecutionState.t.Fatal("No results are set for the StateStorageMock.UpsertExecutionState")
		}
		return (*results).b1
	}
	if mmUpsertExecutionState.funcUpsertExecutionState != nil {
		return mmUpsertExecutionState.funcUpsertExecutionState(ref)
	}
	mmUpsertExecutionState.t.Fatalf("Unexpected call to StateStorageMock.UpsertExecutionState. %v", ref)
	return
}

// UpsertExecutionStateAfterCounter returns a count of finished StateStorageMock.UpsertExecutionState invocations
func (mmUpsertExecutionState *StateStorageMock) UpsertExecutionStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertExecutionState.afterUpsertExecutionStateCounter)
}

// UpsertExecutionStateBeforeCounter returns a count of StateStorageMock.UpsertExecutionState invocations
func (mmUpsertExecutionState *StateStorageMock) UpsertExecutionStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertExecutionState.beforeUpsertExecutionStateCounter)
}

// Calls returns a list of arguments used in each call to StateStorageMock.UpsertExecutionState.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpsertExecutionState *mStateStorageMockUpsertExecutionState) Calls() []*StateStorageMockUpsertExecutionStateParams {
	mmUpsertExecutionState.mutex.RLock()

	argCopy := make([]*StateStorageMockUpsertExecutionStateParams, len(mmUpsertExecutionState.callArgs))
	copy(argCopy, mmUpsertExecutionState.callArgs)

	mmUpsertExecutionState.mutex.RUnlock()

	return argCopy
}

// MinimockUpsertExecutionStateDone returns true if the count of the UpsertExecutionState invocations corresponds
// the number of defined expectations
func (m *StateStorageMock) MinimockUpsertExecutionStateDone() bool {
	for _, e := range m.UpsertExecutionStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertExecutionStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpsertExecutionStateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertExecutionState != nil && mm_atomic.LoadUint64(&m.afterUpsertExecutionStateCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpsertExecutionStateInspect logs each unmet expectation
func (m *StateStorageMock) MinimockUpsertExecutionStateInspect() {
	for _, e := range m.UpsertExecutionStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StateStorageMock.UpsertExecutionState with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertExecutionStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpsertExecutionStateCounter) < 1 {
		if m.UpsertExecutionStateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StateStorageMock.UpsertExecutionState")
		} else {
			m.t.Errorf("Expected call to StateStorageMock.UpsertExecutionState with params: %#v", *m.UpsertExecutionStateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertExecutionState != nil && mm_atomic.LoadUint64(&m.afterUpsertExecutionStateCounter) < 1 {
		m.t.Error("Expected call to StateStorageMock.UpsertExecutionState")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StateStorageMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetExecutionArchiveInspect()

		m.MinimockGetExecutionStateInspect()

		m.MinimockIsEmptyInspect()

		m.MinimockLockInspect()

		m.MinimockOnPulseInspect()

		m.MinimockUnlockInspect()

		m.MinimockUpsertExecutionStateInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StateStorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StateStorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetExecutionArchiveDone() &&
		m.MinimockGetExecutionStateDone() &&
		m.MinimockIsEmptyDone() &&
		m.MinimockLockDone() &&
		m.MinimockOnPulseDone() &&
		m.MinimockUnlockDone() &&
		m.MinimockUpsertExecutionStateDone()
}
