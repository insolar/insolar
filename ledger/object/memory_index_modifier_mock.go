package object

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/insolar/insolar/ledger/object.MemoryIndexModifier -o ./memory_index_modifier_mock.go

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/insolar"
	"github.com/insolar/insolar/insolar/record"
)

// MemoryIndexModifierMock implements MemoryIndexModifier
type MemoryIndexModifierMock struct {
	t minimock.Tester

	funcSet          func(ctx context.Context, pn insolar.PulseNumber, index record.Index)
	inspectFuncSet   func(ctx context.Context, pn insolar.PulseNumber, index record.Index)
	afterSetCounter  uint64
	beforeSetCounter uint64
	SetMock          mMemoryIndexModifierMockSet

	funcSetIfNone          func(ctx context.Context, pn insolar.PulseNumber, index record.Index)
	inspectFuncSetIfNone   func(ctx context.Context, pn insolar.PulseNumber, index record.Index)
	afterSetIfNoneCounter  uint64
	beforeSetIfNoneCounter uint64
	SetIfNoneMock          mMemoryIndexModifierMockSetIfNone
}

// NewMemoryIndexModifierMock returns a mock for MemoryIndexModifier
func NewMemoryIndexModifierMock(t minimock.Tester) *MemoryIndexModifierMock {
	m := &MemoryIndexModifierMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.SetMock = mMemoryIndexModifierMockSet{mock: m}
	m.SetMock.callArgs = []*MemoryIndexModifierMockSetParams{}

	m.SetIfNoneMock = mMemoryIndexModifierMockSetIfNone{mock: m}
	m.SetIfNoneMock.callArgs = []*MemoryIndexModifierMockSetIfNoneParams{}

	return m
}

type mMemoryIndexModifierMockSet struct {
	mock               *MemoryIndexModifierMock
	defaultExpectation *MemoryIndexModifierMockSetExpectation
	expectations       []*MemoryIndexModifierMockSetExpectation

	callArgs []*MemoryIndexModifierMockSetParams
	mutex    sync.RWMutex
}

// MemoryIndexModifierMockSetExpectation specifies expectation struct of the MemoryIndexModifier.Set
type MemoryIndexModifierMockSetExpectation struct {
	mock   *MemoryIndexModifierMock
	params *MemoryIndexModifierMockSetParams

	Counter uint64
}

// MemoryIndexModifierMockSetParams contains parameters of the MemoryIndexModifier.Set
type MemoryIndexModifierMockSetParams struct {
	ctx   context.Context
	pn    insolar.PulseNumber
	index record.Index
}

// Expect sets up expected params for MemoryIndexModifier.Set
func (mmSet *mMemoryIndexModifierMockSet) Expect(ctx context.Context, pn insolar.PulseNumber, index record.Index) *mMemoryIndexModifierMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("MemoryIndexModifierMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &MemoryIndexModifierMockSetExpectation{}
	}

	mmSet.defaultExpectation.params = &MemoryIndexModifierMockSetParams{ctx, pn, index}
	for _, e := range mmSet.expectations {
		if minimock.Equal(e.params, mmSet.defaultExpectation.params) {
			mmSet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSet.defaultExpectation.params)
		}
	}

	return mmSet
}

// Inspect accepts an inspector function that has same arguments as the MemoryIndexModifier.Set
func (mmSet *mMemoryIndexModifierMockSet) Inspect(f func(ctx context.Context, pn insolar.PulseNumber, index record.Index)) *mMemoryIndexModifierMockSet {
	if mmSet.mock.inspectFuncSet != nil {
		mmSet.mock.t.Fatalf("Inspect function is already set for MemoryIndexModifierMock.Set")
	}

	mmSet.mock.inspectFuncSet = f

	return mmSet
}

// Return sets up results that will be returned by MemoryIndexModifier.Set
func (mmSet *mMemoryIndexModifierMockSet) Return() *MemoryIndexModifierMock {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("MemoryIndexModifierMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &MemoryIndexModifierMockSetExpectation{mock: mmSet.mock}
	}

	return mmSet.mock
}

//Set uses given function f to mock the MemoryIndexModifier.Set method
func (mmSet *mMemoryIndexModifierMockSet) Set(f func(ctx context.Context, pn insolar.PulseNumber, index record.Index)) *MemoryIndexModifierMock {
	if mmSet.defaultExpectation != nil {
		mmSet.mock.t.Fatalf("Default expectation is already set for the MemoryIndexModifier.Set method")
	}

	if len(mmSet.expectations) > 0 {
		mmSet.mock.t.Fatalf("Some expectations are already set for the MemoryIndexModifier.Set method")
	}

	mmSet.mock.funcSet = f
	return mmSet.mock
}

// Set implements MemoryIndexModifier
func (mmSet *MemoryIndexModifierMock) Set(ctx context.Context, pn insolar.PulseNumber, index record.Index) {
	mm_atomic.AddUint64(&mmSet.beforeSetCounter, 1)
	defer mm_atomic.AddUint64(&mmSet.afterSetCounter, 1)

	if mmSet.inspectFuncSet != nil {
		mmSet.inspectFuncSet(ctx, pn, index)
	}

	params := &MemoryIndexModifierMockSetParams{ctx, pn, index}

	// Record call args
	mmSet.SetMock.mutex.Lock()
	mmSet.SetMock.callArgs = append(mmSet.SetMock.callArgs, params)
	mmSet.SetMock.mutex.Unlock()

	for _, e := range mmSet.SetMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSet.SetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSet.SetMock.defaultExpectation.Counter, 1)
		want := mmSet.SetMock.defaultExpectation.params
		got := MemoryIndexModifierMockSetParams{ctx, pn, index}
		if want != nil && !minimock.Equal(*want, got) {
			mmSet.t.Errorf("MemoryIndexModifierMock.Set got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmSet.funcSet != nil {
		mmSet.funcSet(ctx, pn, index)
		return
	}
	mmSet.t.Fatalf("Unexpected call to MemoryIndexModifierMock.Set. %v %v %v", ctx, pn, index)

}

// SetAfterCounter returns a count of finished MemoryIndexModifierMock.Set invocations
func (mmSet *MemoryIndexModifierMock) SetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSet.afterSetCounter)
}

// SetBeforeCounter returns a count of MemoryIndexModifierMock.Set invocations
func (mmSet *MemoryIndexModifierMock) SetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSet.beforeSetCounter)
}

// Calls returns a list of arguments used in each call to MemoryIndexModifierMock.Set.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSet *mMemoryIndexModifierMockSet) Calls() []*MemoryIndexModifierMockSetParams {
	mmSet.mutex.RLock()

	argCopy := make([]*MemoryIndexModifierMockSetParams, len(mmSet.callArgs))
	copy(argCopy, mmSet.callArgs)

	mmSet.mutex.RUnlock()

	return argCopy
}

// MinimockSetDone returns true if the count of the Set invocations corresponds
// the number of defined expectations
func (m *MemoryIndexModifierMock) MinimockSetDone() bool {
	for _, e := range m.SetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSet != nil && mm_atomic.LoadUint64(&m.afterSetCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetInspect logs each unmet expectation
func (m *MemoryIndexModifierMock) MinimockSetInspect() {
	for _, e := range m.SetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MemoryIndexModifierMock.Set with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetCounter) < 1 {
		if m.SetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MemoryIndexModifierMock.Set")
		} else {
			m.t.Errorf("Expected call to MemoryIndexModifierMock.Set with params: %#v", *m.SetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSet != nil && mm_atomic.LoadUint64(&m.afterSetCounter) < 1 {
		m.t.Error("Expected call to MemoryIndexModifierMock.Set")
	}
}

type mMemoryIndexModifierMockSetIfNone struct {
	mock               *MemoryIndexModifierMock
	defaultExpectation *MemoryIndexModifierMockSetIfNoneExpectation
	expectations       []*MemoryIndexModifierMockSetIfNoneExpectation

	callArgs []*MemoryIndexModifierMockSetIfNoneParams
	mutex    sync.RWMutex
}

// MemoryIndexModifierMockSetIfNoneExpectation specifies expectation struct of the MemoryIndexModifier.SetIfNone
type MemoryIndexModifierMockSetIfNoneExpectation struct {
	mock   *MemoryIndexModifierMock
	params *MemoryIndexModifierMockSetIfNoneParams

	Counter uint64
}

// MemoryIndexModifierMockSetIfNoneParams contains parameters of the MemoryIndexModifier.SetIfNone
type MemoryIndexModifierMockSetIfNoneParams struct {
	ctx   context.Context
	pn    insolar.PulseNumber
	index record.Index
}

// Expect sets up expected params for MemoryIndexModifier.SetIfNone
func (mmSetIfNone *mMemoryIndexModifierMockSetIfNone) Expect(ctx context.Context, pn insolar.PulseNumber, index record.Index) *mMemoryIndexModifierMockSetIfNone {
	if mmSetIfNone.mock.funcSetIfNone != nil {
		mmSetIfNone.mock.t.Fatalf("MemoryIndexModifierMock.SetIfNone mock is already set by Set")
	}

	if mmSetIfNone.defaultExpectation == nil {
		mmSetIfNone.defaultExpectation = &MemoryIndexModifierMockSetIfNoneExpectation{}
	}

	mmSetIfNone.defaultExpectation.params = &MemoryIndexModifierMockSetIfNoneParams{ctx, pn, index}
	for _, e := range mmSetIfNone.expectations {
		if minimock.Equal(e.params, mmSetIfNone.defaultExpectation.params) {
			mmSetIfNone.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetIfNone.defaultExpectation.params)
		}
	}

	return mmSetIfNone
}

// Inspect accepts an inspector function that has same arguments as the MemoryIndexModifier.SetIfNone
func (mmSetIfNone *mMemoryIndexModifierMockSetIfNone) Inspect(f func(ctx context.Context, pn insolar.PulseNumber, index record.Index)) *mMemoryIndexModifierMockSetIfNone {
	if mmSetIfNone.mock.inspectFuncSetIfNone != nil {
		mmSetIfNone.mock.t.Fatalf("Inspect function is already set for MemoryIndexModifierMock.SetIfNone")
	}

	mmSetIfNone.mock.inspectFuncSetIfNone = f

	return mmSetIfNone
}

// Return sets up results that will be returned by MemoryIndexModifier.SetIfNone
func (mmSetIfNone *mMemoryIndexModifierMockSetIfNone) Return() *MemoryIndexModifierMock {
	if mmSetIfNone.mock.funcSetIfNone != nil {
		mmSetIfNone.mock.t.Fatalf("MemoryIndexModifierMock.SetIfNone mock is already set by Set")
	}

	if mmSetIfNone.defaultExpectation == nil {
		mmSetIfNone.defaultExpectation = &MemoryIndexModifierMockSetIfNoneExpectation{mock: mmSetIfNone.mock}
	}

	return mmSetIfNone.mock
}

//Set uses given function f to mock the MemoryIndexModifier.SetIfNone method
func (mmSetIfNone *mMemoryIndexModifierMockSetIfNone) Set(f func(ctx context.Context, pn insolar.PulseNumber, index record.Index)) *MemoryIndexModifierMock {
	if mmSetIfNone.defaultExpectation != nil {
		mmSetIfNone.mock.t.Fatalf("Default expectation is already set for the MemoryIndexModifier.SetIfNone method")
	}

	if len(mmSetIfNone.expectations) > 0 {
		mmSetIfNone.mock.t.Fatalf("Some expectations are already set for the MemoryIndexModifier.SetIfNone method")
	}

	mmSetIfNone.mock.funcSetIfNone = f
	return mmSetIfNone.mock
}

// SetIfNone implements MemoryIndexModifier
func (mmSetIfNone *MemoryIndexModifierMock) SetIfNone(ctx context.Context, pn insolar.PulseNumber, index record.Index) {
	mm_atomic.AddUint64(&mmSetIfNone.beforeSetIfNoneCounter, 1)
	defer mm_atomic.AddUint64(&mmSetIfNone.afterSetIfNoneCounter, 1)

	if mmSetIfNone.inspectFuncSetIfNone != nil {
		mmSetIfNone.inspectFuncSetIfNone(ctx, pn, index)
	}

	params := &MemoryIndexModifierMockSetIfNoneParams{ctx, pn, index}

	// Record call args
	mmSetIfNone.SetIfNoneMock.mutex.Lock()
	mmSetIfNone.SetIfNoneMock.callArgs = append(mmSetIfNone.SetIfNoneMock.callArgs, params)
	mmSetIfNone.SetIfNoneMock.mutex.Unlock()

	for _, e := range mmSetIfNone.SetIfNoneMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetIfNone.SetIfNoneMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetIfNone.SetIfNoneMock.defaultExpectation.Counter, 1)
		want := mmSetIfNone.SetIfNoneMock.defaultExpectation.params
		got := MemoryIndexModifierMockSetIfNoneParams{ctx, pn, index}
		if want != nil && !minimock.Equal(*want, got) {
			mmSetIfNone.t.Errorf("MemoryIndexModifierMock.SetIfNone got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmSetIfNone.funcSetIfNone != nil {
		mmSetIfNone.funcSetIfNone(ctx, pn, index)
		return
	}
	mmSetIfNone.t.Fatalf("Unexpected call to MemoryIndexModifierMock.SetIfNone. %v %v %v", ctx, pn, index)

}

// SetIfNoneAfterCounter returns a count of finished MemoryIndexModifierMock.SetIfNone invocations
func (mmSetIfNone *MemoryIndexModifierMock) SetIfNoneAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetIfNone.afterSetIfNoneCounter)
}

// SetIfNoneBeforeCounter returns a count of MemoryIndexModifierMock.SetIfNone invocations
func (mmSetIfNone *MemoryIndexModifierMock) SetIfNoneBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetIfNone.beforeSetIfNoneCounter)
}

// Calls returns a list of arguments used in each call to MemoryIndexModifierMock.SetIfNone.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetIfNone *mMemoryIndexModifierMockSetIfNone) Calls() []*MemoryIndexModifierMockSetIfNoneParams {
	mmSetIfNone.mutex.RLock()

	argCopy := make([]*MemoryIndexModifierMockSetIfNoneParams, len(mmSetIfNone.callArgs))
	copy(argCopy, mmSetIfNone.callArgs)

	mmSetIfNone.mutex.RUnlock()

	return argCopy
}

// MinimockSetIfNoneDone returns true if the count of the SetIfNone invocations corresponds
// the number of defined expectations
func (m *MemoryIndexModifierMock) MinimockSetIfNoneDone() bool {
	for _, e := range m.SetIfNoneMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetIfNoneMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetIfNoneCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetIfNone != nil && mm_atomic.LoadUint64(&m.afterSetIfNoneCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetIfNoneInspect logs each unmet expectation
func (m *MemoryIndexModifierMock) MinimockSetIfNoneInspect() {
	for _, e := range m.SetIfNoneMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MemoryIndexModifierMock.SetIfNone with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetIfNoneMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetIfNoneCounter) < 1 {
		if m.SetIfNoneMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MemoryIndexModifierMock.SetIfNone")
		} else {
			m.t.Errorf("Expected call to MemoryIndexModifierMock.SetIfNone with params: %#v", *m.SetIfNoneMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetIfNone != nil && mm_atomic.LoadUint64(&m.afterSetIfNoneCounter) < 1 {
		m.t.Error("Expected call to MemoryIndexModifierMock.SetIfNone")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *MemoryIndexModifierMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockSetInspect()

		m.MinimockSetIfNoneInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *MemoryIndexModifierMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *MemoryIndexModifierMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockSetDone() &&
		m.MinimockSetIfNoneDone()
}
