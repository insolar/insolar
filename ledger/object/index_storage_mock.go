package object

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/insolar/insolar"
	"github.com/insolar/insolar/insolar/record"
)

// IndexStorageMock implements IndexStorage
type IndexStorageMock struct {
	t minimock.Tester

	funcForID          func(ctx context.Context, pn insolar.PulseNumber, objID insolar.ID) (i1 record.Index, err error)
	inspectFuncForID   func(ctx context.Context, pn insolar.PulseNumber, objID insolar.ID)
	afterForIDCounter  uint64
	beforeForIDCounter uint64
	ForIDMock          mIndexStorageMockForID

	funcForPulse          func(ctx context.Context, pn insolar.PulseNumber) (ia1 []record.Index, err error)
	inspectFuncForPulse   func(ctx context.Context, pn insolar.PulseNumber)
	afterForPulseCounter  uint64
	beforeForPulseCounter uint64
	ForPulseMock          mIndexStorageMockForPulse

	funcLastKnownForID          func(ctx context.Context, objID insolar.ID) (i1 record.Index, err error)
	inspectFuncLastKnownForID   func(ctx context.Context, objID insolar.ID)
	afterLastKnownForIDCounter  uint64
	beforeLastKnownForIDCounter uint64
	LastKnownForIDMock          mIndexStorageMockLastKnownForID

	funcSetIndex          func(ctx context.Context, pn insolar.PulseNumber, index record.Index) (err error)
	inspectFuncSetIndex   func(ctx context.Context, pn insolar.PulseNumber, index record.Index)
	afterSetIndexCounter  uint64
	beforeSetIndexCounter uint64
	SetIndexMock          mIndexStorageMockSetIndex

	funcUpdateLastKnownPulse          func(ctx context.Context, pn insolar.PulseNumber) (err error)
	inspectFuncUpdateLastKnownPulse   func(ctx context.Context, pn insolar.PulseNumber)
	afterUpdateLastKnownPulseCounter  uint64
	beforeUpdateLastKnownPulseCounter uint64
	UpdateLastKnownPulseMock          mIndexStorageMockUpdateLastKnownPulse
}

// NewIndexStorageMock returns a mock for IndexStorage
func NewIndexStorageMock(t minimock.Tester) *IndexStorageMock {
	m := &IndexStorageMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ForIDMock = mIndexStorageMockForID{mock: m}
	m.ForIDMock.callArgs = []*IndexStorageMockForIDParams{}

	m.ForPulseMock = mIndexStorageMockForPulse{mock: m}
	m.ForPulseMock.callArgs = []*IndexStorageMockForPulseParams{}

	m.LastKnownForIDMock = mIndexStorageMockLastKnownForID{mock: m}
	m.LastKnownForIDMock.callArgs = []*IndexStorageMockLastKnownForIDParams{}

	m.SetIndexMock = mIndexStorageMockSetIndex{mock: m}
	m.SetIndexMock.callArgs = []*IndexStorageMockSetIndexParams{}

	m.UpdateLastKnownPulseMock = mIndexStorageMockUpdateLastKnownPulse{mock: m}
	m.UpdateLastKnownPulseMock.callArgs = []*IndexStorageMockUpdateLastKnownPulseParams{}

	return m
}

type mIndexStorageMockForID struct {
	mock               *IndexStorageMock
	defaultExpectation *IndexStorageMockForIDExpectation
	expectations       []*IndexStorageMockForIDExpectation

	callArgs []*IndexStorageMockForIDParams
	mutex    sync.RWMutex
}

// IndexStorageMockForIDExpectation specifies expectation struct of the IndexStorage.ForID
type IndexStorageMockForIDExpectation struct {
	mock    *IndexStorageMock
	params  *IndexStorageMockForIDParams
	results *IndexStorageMockForIDResults
	Counter uint64
}

// IndexStorageMockForIDParams contains parameters of the IndexStorage.ForID
type IndexStorageMockForIDParams struct {
	ctx   context.Context
	pn    insolar.PulseNumber
	objID insolar.ID
}

// IndexStorageMockForIDResults contains results of the IndexStorage.ForID
type IndexStorageMockForIDResults struct {
	i1  record.Index
	err error
}

// Expect sets up expected params for IndexStorage.ForID
func (mmForID *mIndexStorageMockForID) Expect(ctx context.Context, pn insolar.PulseNumber, objID insolar.ID) *mIndexStorageMockForID {
	if mmForID.mock.funcForID != nil {
		mmForID.mock.t.Fatalf("IndexStorageMock.ForID mock is already set by Set")
	}

	if mmForID.defaultExpectation == nil {
		mmForID.defaultExpectation = &IndexStorageMockForIDExpectation{}
	}

	mmForID.defaultExpectation.params = &IndexStorageMockForIDParams{ctx, pn, objID}
	for _, e := range mmForID.expectations {
		if minimock.Equal(e.params, mmForID.defaultExpectation.params) {
			mmForID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmForID.defaultExpectation.params)
		}
	}

	return mmForID
}

// Inspect accepts an inspector function that has same arguments as the IndexStorage.ForID
func (mmForID *mIndexStorageMockForID) Inspect(f func(ctx context.Context, pn insolar.PulseNumber, objID insolar.ID)) *mIndexStorageMockForID {
	if mmForID.mock.inspectFuncForID != nil {
		mmForID.mock.t.Fatalf("Inspect function is already set for IndexStorageMock.ForID")
	}

	mmForID.mock.inspectFuncForID = f

	return mmForID
}

// Return sets up results that will be returned by IndexStorage.ForID
func (mmForID *mIndexStorageMockForID) Return(i1 record.Index, err error) *IndexStorageMock {
	if mmForID.mock.funcForID != nil {
		mmForID.mock.t.Fatalf("IndexStorageMock.ForID mock is already set by Set")
	}

	if mmForID.defaultExpectation == nil {
		mmForID.defaultExpectation = &IndexStorageMockForIDExpectation{mock: mmForID.mock}
	}
	mmForID.defaultExpectation.results = &IndexStorageMockForIDResults{i1, err}
	return mmForID.mock
}

//Set uses given function f to mock the IndexStorage.ForID method
func (mmForID *mIndexStorageMockForID) Set(f func(ctx context.Context, pn insolar.PulseNumber, objID insolar.ID) (i1 record.Index, err error)) *IndexStorageMock {
	if mmForID.defaultExpectation != nil {
		mmForID.mock.t.Fatalf("Default expectation is already set for the IndexStorage.ForID method")
	}

	if len(mmForID.expectations) > 0 {
		mmForID.mock.t.Fatalf("Some expectations are already set for the IndexStorage.ForID method")
	}

	mmForID.mock.funcForID = f
	return mmForID.mock
}

// When sets expectation for the IndexStorage.ForID which will trigger the result defined by the following
// Then helper
func (mmForID *mIndexStorageMockForID) When(ctx context.Context, pn insolar.PulseNumber, objID insolar.ID) *IndexStorageMockForIDExpectation {
	if mmForID.mock.funcForID != nil {
		mmForID.mock.t.Fatalf("IndexStorageMock.ForID mock is already set by Set")
	}

	expectation := &IndexStorageMockForIDExpectation{
		mock:   mmForID.mock,
		params: &IndexStorageMockForIDParams{ctx, pn, objID},
	}
	mmForID.expectations = append(mmForID.expectations, expectation)
	return expectation
}

// Then sets up IndexStorage.ForID return parameters for the expectation previously defined by the When method
func (e *IndexStorageMockForIDExpectation) Then(i1 record.Index, err error) *IndexStorageMock {
	e.results = &IndexStorageMockForIDResults{i1, err}
	return e.mock
}

// ForID implements IndexStorage
func (mmForID *IndexStorageMock) ForID(ctx context.Context, pn insolar.PulseNumber, objID insolar.ID) (i1 record.Index, err error) {
	mm_atomic.AddUint64(&mmForID.beforeForIDCounter, 1)
	defer mm_atomic.AddUint64(&mmForID.afterForIDCounter, 1)

	if mmForID.inspectFuncForID != nil {
		mmForID.inspectFuncForID(ctx, pn, objID)
	}

	mm_params := &IndexStorageMockForIDParams{ctx, pn, objID}

	// Record call args
	mmForID.ForIDMock.mutex.Lock()
	mmForID.ForIDMock.callArgs = append(mmForID.ForIDMock.callArgs, mm_params)
	mmForID.ForIDMock.mutex.Unlock()

	for _, e := range mmForID.ForIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmForID.ForIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmForID.ForIDMock.defaultExpectation.Counter, 1)
		mm_want := mmForID.ForIDMock.defaultExpectation.params
		mm_got := IndexStorageMockForIDParams{ctx, pn, objID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmForID.t.Errorf("IndexStorageMock.ForID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmForID.ForIDMock.defaultExpectation.results
		if mm_results == nil {
			mmForID.t.Fatal("No results are set for the IndexStorageMock.ForID")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmForID.funcForID != nil {
		return mmForID.funcForID(ctx, pn, objID)
	}
	mmForID.t.Fatalf("Unexpected call to IndexStorageMock.ForID. %v %v %v", ctx, pn, objID)
	return
}

// ForIDAfterCounter returns a count of finished IndexStorageMock.ForID invocations
func (mmForID *IndexStorageMock) ForIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmForID.afterForIDCounter)
}

// ForIDBeforeCounter returns a count of IndexStorageMock.ForID invocations
func (mmForID *IndexStorageMock) ForIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmForID.beforeForIDCounter)
}

// Calls returns a list of arguments used in each call to IndexStorageMock.ForID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmForID *mIndexStorageMockForID) Calls() []*IndexStorageMockForIDParams {
	mmForID.mutex.RLock()

	argCopy := make([]*IndexStorageMockForIDParams, len(mmForID.callArgs))
	copy(argCopy, mmForID.callArgs)

	mmForID.mutex.RUnlock()

	return argCopy
}

// MinimockForIDDone returns true if the count of the ForID invocations corresponds
// the number of defined expectations
func (m *IndexStorageMock) MinimockForIDDone() bool {
	for _, e := range m.ForIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ForIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterForIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcForID != nil && mm_atomic.LoadUint64(&m.afterForIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockForIDInspect logs each unmet expectation
func (m *IndexStorageMock) MinimockForIDInspect() {
	for _, e := range m.ForIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IndexStorageMock.ForID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ForIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterForIDCounter) < 1 {
		if m.ForIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IndexStorageMock.ForID")
		} else {
			m.t.Errorf("Expected call to IndexStorageMock.ForID with params: %#v", *m.ForIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcForID != nil && mm_atomic.LoadUint64(&m.afterForIDCounter) < 1 {
		m.t.Error("Expected call to IndexStorageMock.ForID")
	}
}

type mIndexStorageMockForPulse struct {
	mock               *IndexStorageMock
	defaultExpectation *IndexStorageMockForPulseExpectation
	expectations       []*IndexStorageMockForPulseExpectation

	callArgs []*IndexStorageMockForPulseParams
	mutex    sync.RWMutex
}

// IndexStorageMockForPulseExpectation specifies expectation struct of the IndexStorage.ForPulse
type IndexStorageMockForPulseExpectation struct {
	mock    *IndexStorageMock
	params  *IndexStorageMockForPulseParams
	results *IndexStorageMockForPulseResults
	Counter uint64
}

// IndexStorageMockForPulseParams contains parameters of the IndexStorage.ForPulse
type IndexStorageMockForPulseParams struct {
	ctx context.Context
	pn  insolar.PulseNumber
}

// IndexStorageMockForPulseResults contains results of the IndexStorage.ForPulse
type IndexStorageMockForPulseResults struct {
	ia1 []record.Index
	err error
}

// Expect sets up expected params for IndexStorage.ForPulse
func (mmForPulse *mIndexStorageMockForPulse) Expect(ctx context.Context, pn insolar.PulseNumber) *mIndexStorageMockForPulse {
	if mmForPulse.mock.funcForPulse != nil {
		mmForPulse.mock.t.Fatalf("IndexStorageMock.ForPulse mock is already set by Set")
	}

	if mmForPulse.defaultExpectation == nil {
		mmForPulse.defaultExpectation = &IndexStorageMockForPulseExpectation{}
	}

	mmForPulse.defaultExpectation.params = &IndexStorageMockForPulseParams{ctx, pn}
	for _, e := range mmForPulse.expectations {
		if minimock.Equal(e.params, mmForPulse.defaultExpectation.params) {
			mmForPulse.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmForPulse.defaultExpectation.params)
		}
	}

	return mmForPulse
}

// Inspect accepts an inspector function that has same arguments as the IndexStorage.ForPulse
func (mmForPulse *mIndexStorageMockForPulse) Inspect(f func(ctx context.Context, pn insolar.PulseNumber)) *mIndexStorageMockForPulse {
	if mmForPulse.mock.inspectFuncForPulse != nil {
		mmForPulse.mock.t.Fatalf("Inspect function is already set for IndexStorageMock.ForPulse")
	}

	mmForPulse.mock.inspectFuncForPulse = f

	return mmForPulse
}

// Return sets up results that will be returned by IndexStorage.ForPulse
func (mmForPulse *mIndexStorageMockForPulse) Return(ia1 []record.Index, err error) *IndexStorageMock {
	if mmForPulse.mock.funcForPulse != nil {
		mmForPulse.mock.t.Fatalf("IndexStorageMock.ForPulse mock is already set by Set")
	}

	if mmForPulse.defaultExpectation == nil {
		mmForPulse.defaultExpectation = &IndexStorageMockForPulseExpectation{mock: mmForPulse.mock}
	}
	mmForPulse.defaultExpectation.results = &IndexStorageMockForPulseResults{ia1, err}
	return mmForPulse.mock
}

//Set uses given function f to mock the IndexStorage.ForPulse method
func (mmForPulse *mIndexStorageMockForPulse) Set(f func(ctx context.Context, pn insolar.PulseNumber) (ia1 []record.Index, err error)) *IndexStorageMock {
	if mmForPulse.defaultExpectation != nil {
		mmForPulse.mock.t.Fatalf("Default expectation is already set for the IndexStorage.ForPulse method")
	}

	if len(mmForPulse.expectations) > 0 {
		mmForPulse.mock.t.Fatalf("Some expectations are already set for the IndexStorage.ForPulse method")
	}

	mmForPulse.mock.funcForPulse = f
	return mmForPulse.mock
}

// When sets expectation for the IndexStorage.ForPulse which will trigger the result defined by the following
// Then helper
func (mmForPulse *mIndexStorageMockForPulse) When(ctx context.Context, pn insolar.PulseNumber) *IndexStorageMockForPulseExpectation {
	if mmForPulse.mock.funcForPulse != nil {
		mmForPulse.mock.t.Fatalf("IndexStorageMock.ForPulse mock is already set by Set")
	}

	expectation := &IndexStorageMockForPulseExpectation{
		mock:   mmForPulse.mock,
		params: &IndexStorageMockForPulseParams{ctx, pn},
	}
	mmForPulse.expectations = append(mmForPulse.expectations, expectation)
	return expectation
}

// Then sets up IndexStorage.ForPulse return parameters for the expectation previously defined by the When method
func (e *IndexStorageMockForPulseExpectation) Then(ia1 []record.Index, err error) *IndexStorageMock {
	e.results = &IndexStorageMockForPulseResults{ia1, err}
	return e.mock
}

// ForPulse implements IndexStorage
func (mmForPulse *IndexStorageMock) ForPulse(ctx context.Context, pn insolar.PulseNumber) (ia1 []record.Index, err error) {
	mm_atomic.AddUint64(&mmForPulse.beforeForPulseCounter, 1)
	defer mm_atomic.AddUint64(&mmForPulse.afterForPulseCounter, 1)

	if mmForPulse.inspectFuncForPulse != nil {
		mmForPulse.inspectFuncForPulse(ctx, pn)
	}

	mm_params := &IndexStorageMockForPulseParams{ctx, pn}

	// Record call args
	mmForPulse.ForPulseMock.mutex.Lock()
	mmForPulse.ForPulseMock.callArgs = append(mmForPulse.ForPulseMock.callArgs, mm_params)
	mmForPulse.ForPulseMock.mutex.Unlock()

	for _, e := range mmForPulse.ForPulseMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ia1, e.results.err
		}
	}

	if mmForPulse.ForPulseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmForPulse.ForPulseMock.defaultExpectation.Counter, 1)
		mm_want := mmForPulse.ForPulseMock.defaultExpectation.params
		mm_got := IndexStorageMockForPulseParams{ctx, pn}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmForPulse.t.Errorf("IndexStorageMock.ForPulse got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmForPulse.ForPulseMock.defaultExpectation.results
		if mm_results == nil {
			mmForPulse.t.Fatal("No results are set for the IndexStorageMock.ForPulse")
		}
		return (*mm_results).ia1, (*mm_results).err
	}
	if mmForPulse.funcForPulse != nil {
		return mmForPulse.funcForPulse(ctx, pn)
	}
	mmForPulse.t.Fatalf("Unexpected call to IndexStorageMock.ForPulse. %v %v", ctx, pn)
	return
}

// ForPulseAfterCounter returns a count of finished IndexStorageMock.ForPulse invocations
func (mmForPulse *IndexStorageMock) ForPulseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmForPulse.afterForPulseCounter)
}

// ForPulseBeforeCounter returns a count of IndexStorageMock.ForPulse invocations
func (mmForPulse *IndexStorageMock) ForPulseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmForPulse.beforeForPulseCounter)
}

// Calls returns a list of arguments used in each call to IndexStorageMock.ForPulse.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmForPulse *mIndexStorageMockForPulse) Calls() []*IndexStorageMockForPulseParams {
	mmForPulse.mutex.RLock()

	argCopy := make([]*IndexStorageMockForPulseParams, len(mmForPulse.callArgs))
	copy(argCopy, mmForPulse.callArgs)

	mmForPulse.mutex.RUnlock()

	return argCopy
}

// MinimockForPulseDone returns true if the count of the ForPulse invocations corresponds
// the number of defined expectations
func (m *IndexStorageMock) MinimockForPulseDone() bool {
	for _, e := range m.ForPulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ForPulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterForPulseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcForPulse != nil && mm_atomic.LoadUint64(&m.afterForPulseCounter) < 1 {
		return false
	}
	return true
}

// MinimockForPulseInspect logs each unmet expectation
func (m *IndexStorageMock) MinimockForPulseInspect() {
	for _, e := range m.ForPulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IndexStorageMock.ForPulse with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ForPulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterForPulseCounter) < 1 {
		if m.ForPulseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IndexStorageMock.ForPulse")
		} else {
			m.t.Errorf("Expected call to IndexStorageMock.ForPulse with params: %#v", *m.ForPulseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcForPulse != nil && mm_atomic.LoadUint64(&m.afterForPulseCounter) < 1 {
		m.t.Error("Expected call to IndexStorageMock.ForPulse")
	}
}

type mIndexStorageMockLastKnownForID struct {
	mock               *IndexStorageMock
	defaultExpectation *IndexStorageMockLastKnownForIDExpectation
	expectations       []*IndexStorageMockLastKnownForIDExpectation

	callArgs []*IndexStorageMockLastKnownForIDParams
	mutex    sync.RWMutex
}

// IndexStorageMockLastKnownForIDExpectation specifies expectation struct of the IndexStorage.LastKnownForID
type IndexStorageMockLastKnownForIDExpectation struct {
	mock    *IndexStorageMock
	params  *IndexStorageMockLastKnownForIDParams
	results *IndexStorageMockLastKnownForIDResults
	Counter uint64
}

// IndexStorageMockLastKnownForIDParams contains parameters of the IndexStorage.LastKnownForID
type IndexStorageMockLastKnownForIDParams struct {
	ctx   context.Context
	objID insolar.ID
}

// IndexStorageMockLastKnownForIDResults contains results of the IndexStorage.LastKnownForID
type IndexStorageMockLastKnownForIDResults struct {
	i1  record.Index
	err error
}

// Expect sets up expected params for IndexStorage.LastKnownForID
func (mmLastKnownForID *mIndexStorageMockLastKnownForID) Expect(ctx context.Context, objID insolar.ID) *mIndexStorageMockLastKnownForID {
	if mmLastKnownForID.mock.funcLastKnownForID != nil {
		mmLastKnownForID.mock.t.Fatalf("IndexStorageMock.LastKnownForID mock is already set by Set")
	}

	if mmLastKnownForID.defaultExpectation == nil {
		mmLastKnownForID.defaultExpectation = &IndexStorageMockLastKnownForIDExpectation{}
	}

	mmLastKnownForID.defaultExpectation.params = &IndexStorageMockLastKnownForIDParams{ctx, objID}
	for _, e := range mmLastKnownForID.expectations {
		if minimock.Equal(e.params, mmLastKnownForID.defaultExpectation.params) {
			mmLastKnownForID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLastKnownForID.defaultExpectation.params)
		}
	}

	return mmLastKnownForID
}

// Inspect accepts an inspector function that has same arguments as the IndexStorage.LastKnownForID
func (mmLastKnownForID *mIndexStorageMockLastKnownForID) Inspect(f func(ctx context.Context, objID insolar.ID)) *mIndexStorageMockLastKnownForID {
	if mmLastKnownForID.mock.inspectFuncLastKnownForID != nil {
		mmLastKnownForID.mock.t.Fatalf("Inspect function is already set for IndexStorageMock.LastKnownForID")
	}

	mmLastKnownForID.mock.inspectFuncLastKnownForID = f

	return mmLastKnownForID
}

// Return sets up results that will be returned by IndexStorage.LastKnownForID
func (mmLastKnownForID *mIndexStorageMockLastKnownForID) Return(i1 record.Index, err error) *IndexStorageMock {
	if mmLastKnownForID.mock.funcLastKnownForID != nil {
		mmLastKnownForID.mock.t.Fatalf("IndexStorageMock.LastKnownForID mock is already set by Set")
	}

	if mmLastKnownForID.defaultExpectation == nil {
		mmLastKnownForID.defaultExpectation = &IndexStorageMockLastKnownForIDExpectation{mock: mmLastKnownForID.mock}
	}
	mmLastKnownForID.defaultExpectation.results = &IndexStorageMockLastKnownForIDResults{i1, err}
	return mmLastKnownForID.mock
}

//Set uses given function f to mock the IndexStorage.LastKnownForID method
func (mmLastKnownForID *mIndexStorageMockLastKnownForID) Set(f func(ctx context.Context, objID insolar.ID) (i1 record.Index, err error)) *IndexStorageMock {
	if mmLastKnownForID.defaultExpectation != nil {
		mmLastKnownForID.mock.t.Fatalf("Default expectation is already set for the IndexStorage.LastKnownForID method")
	}

	if len(mmLastKnownForID.expectations) > 0 {
		mmLastKnownForID.mock.t.Fatalf("Some expectations are already set for the IndexStorage.LastKnownForID method")
	}

	mmLastKnownForID.mock.funcLastKnownForID = f
	return mmLastKnownForID.mock
}

// When sets expectation for the IndexStorage.LastKnownForID which will trigger the result defined by the following
// Then helper
func (mmLastKnownForID *mIndexStorageMockLastKnownForID) When(ctx context.Context, objID insolar.ID) *IndexStorageMockLastKnownForIDExpectation {
	if mmLastKnownForID.mock.funcLastKnownForID != nil {
		mmLastKnownForID.mock.t.Fatalf("IndexStorageMock.LastKnownForID mock is already set by Set")
	}

	expectation := &IndexStorageMockLastKnownForIDExpectation{
		mock:   mmLastKnownForID.mock,
		params: &IndexStorageMockLastKnownForIDParams{ctx, objID},
	}
	mmLastKnownForID.expectations = append(mmLastKnownForID.expectations, expectation)
	return expectation
}

// Then sets up IndexStorage.LastKnownForID return parameters for the expectation previously defined by the When method
func (e *IndexStorageMockLastKnownForIDExpectation) Then(i1 record.Index, err error) *IndexStorageMock {
	e.results = &IndexStorageMockLastKnownForIDResults{i1, err}
	return e.mock
}

// LastKnownForID implements IndexStorage
func (mmLastKnownForID *IndexStorageMock) LastKnownForID(ctx context.Context, objID insolar.ID) (i1 record.Index, err error) {
	mm_atomic.AddUint64(&mmLastKnownForID.beforeLastKnownForIDCounter, 1)
	defer mm_atomic.AddUint64(&mmLastKnownForID.afterLastKnownForIDCounter, 1)

	if mmLastKnownForID.inspectFuncLastKnownForID != nil {
		mmLastKnownForID.inspectFuncLastKnownForID(ctx, objID)
	}

	mm_params := &IndexStorageMockLastKnownForIDParams{ctx, objID}

	// Record call args
	mmLastKnownForID.LastKnownForIDMock.mutex.Lock()
	mmLastKnownForID.LastKnownForIDMock.callArgs = append(mmLastKnownForID.LastKnownForIDMock.callArgs, mm_params)
	mmLastKnownForID.LastKnownForIDMock.mutex.Unlock()

	for _, e := range mmLastKnownForID.LastKnownForIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmLastKnownForID.LastKnownForIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLastKnownForID.LastKnownForIDMock.defaultExpectation.Counter, 1)
		mm_want := mmLastKnownForID.LastKnownForIDMock.defaultExpectation.params
		mm_got := IndexStorageMockLastKnownForIDParams{ctx, objID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLastKnownForID.t.Errorf("IndexStorageMock.LastKnownForID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLastKnownForID.LastKnownForIDMock.defaultExpectation.results
		if mm_results == nil {
			mmLastKnownForID.t.Fatal("No results are set for the IndexStorageMock.LastKnownForID")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmLastKnownForID.funcLastKnownForID != nil {
		return mmLastKnownForID.funcLastKnownForID(ctx, objID)
	}
	mmLastKnownForID.t.Fatalf("Unexpected call to IndexStorageMock.LastKnownForID. %v %v", ctx, objID)
	return
}

// LastKnownForIDAfterCounter returns a count of finished IndexStorageMock.LastKnownForID invocations
func (mmLastKnownForID *IndexStorageMock) LastKnownForIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLastKnownForID.afterLastKnownForIDCounter)
}

// LastKnownForIDBeforeCounter returns a count of IndexStorageMock.LastKnownForID invocations
func (mmLastKnownForID *IndexStorageMock) LastKnownForIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLastKnownForID.beforeLastKnownForIDCounter)
}

// Calls returns a list of arguments used in each call to IndexStorageMock.LastKnownForID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLastKnownForID *mIndexStorageMockLastKnownForID) Calls() []*IndexStorageMockLastKnownForIDParams {
	mmLastKnownForID.mutex.RLock()

	argCopy := make([]*IndexStorageMockLastKnownForIDParams, len(mmLastKnownForID.callArgs))
	copy(argCopy, mmLastKnownForID.callArgs)

	mmLastKnownForID.mutex.RUnlock()

	return argCopy
}

// MinimockLastKnownForIDDone returns true if the count of the LastKnownForID invocations corresponds
// the number of defined expectations
func (m *IndexStorageMock) MinimockLastKnownForIDDone() bool {
	for _, e := range m.LastKnownForIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LastKnownForIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLastKnownForIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLastKnownForID != nil && mm_atomic.LoadUint64(&m.afterLastKnownForIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockLastKnownForIDInspect logs each unmet expectation
func (m *IndexStorageMock) MinimockLastKnownForIDInspect() {
	for _, e := range m.LastKnownForIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IndexStorageMock.LastKnownForID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LastKnownForIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLastKnownForIDCounter) < 1 {
		if m.LastKnownForIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IndexStorageMock.LastKnownForID")
		} else {
			m.t.Errorf("Expected call to IndexStorageMock.LastKnownForID with params: %#v", *m.LastKnownForIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLastKnownForID != nil && mm_atomic.LoadUint64(&m.afterLastKnownForIDCounter) < 1 {
		m.t.Error("Expected call to IndexStorageMock.LastKnownForID")
	}
}

type mIndexStorageMockSetIndex struct {
	mock               *IndexStorageMock
	defaultExpectation *IndexStorageMockSetIndexExpectation
	expectations       []*IndexStorageMockSetIndexExpectation

	callArgs []*IndexStorageMockSetIndexParams
	mutex    sync.RWMutex
}

// IndexStorageMockSetIndexExpectation specifies expectation struct of the IndexStorage.SetIndex
type IndexStorageMockSetIndexExpectation struct {
	mock    *IndexStorageMock
	params  *IndexStorageMockSetIndexParams
	results *IndexStorageMockSetIndexResults
	Counter uint64
}

// IndexStorageMockSetIndexParams contains parameters of the IndexStorage.SetIndex
type IndexStorageMockSetIndexParams struct {
	ctx   context.Context
	pn    insolar.PulseNumber
	index record.Index
}

// IndexStorageMockSetIndexResults contains results of the IndexStorage.SetIndex
type IndexStorageMockSetIndexResults struct {
	err error
}

// Expect sets up expected params for IndexStorage.SetIndex
func (mmSetIndex *mIndexStorageMockSetIndex) Expect(ctx context.Context, pn insolar.PulseNumber, index record.Index) *mIndexStorageMockSetIndex {
	if mmSetIndex.mock.funcSetIndex != nil {
		mmSetIndex.mock.t.Fatalf("IndexStorageMock.SetIndex mock is already set by Set")
	}

	if mmSetIndex.defaultExpectation == nil {
		mmSetIndex.defaultExpectation = &IndexStorageMockSetIndexExpectation{}
	}

	mmSetIndex.defaultExpectation.params = &IndexStorageMockSetIndexParams{ctx, pn, index}
	for _, e := range mmSetIndex.expectations {
		if minimock.Equal(e.params, mmSetIndex.defaultExpectation.params) {
			mmSetIndex.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetIndex.defaultExpectation.params)
		}
	}

	return mmSetIndex
}

// Inspect accepts an inspector function that has same arguments as the IndexStorage.SetIndex
func (mmSetIndex *mIndexStorageMockSetIndex) Inspect(f func(ctx context.Context, pn insolar.PulseNumber, index record.Index)) *mIndexStorageMockSetIndex {
	if mmSetIndex.mock.inspectFuncSetIndex != nil {
		mmSetIndex.mock.t.Fatalf("Inspect function is already set for IndexStorageMock.SetIndex")
	}

	mmSetIndex.mock.inspectFuncSetIndex = f

	return mmSetIndex
}

// Return sets up results that will be returned by IndexStorage.SetIndex
func (mmSetIndex *mIndexStorageMockSetIndex) Return(err error) *IndexStorageMock {
	if mmSetIndex.mock.funcSetIndex != nil {
		mmSetIndex.mock.t.Fatalf("IndexStorageMock.SetIndex mock is already set by Set")
	}

	if mmSetIndex.defaultExpectation == nil {
		mmSetIndex.defaultExpectation = &IndexStorageMockSetIndexExpectation{mock: mmSetIndex.mock}
	}
	mmSetIndex.defaultExpectation.results = &IndexStorageMockSetIndexResults{err}
	return mmSetIndex.mock
}

//Set uses given function f to mock the IndexStorage.SetIndex method
func (mmSetIndex *mIndexStorageMockSetIndex) Set(f func(ctx context.Context, pn insolar.PulseNumber, index record.Index) (err error)) *IndexStorageMock {
	if mmSetIndex.defaultExpectation != nil {
		mmSetIndex.mock.t.Fatalf("Default expectation is already set for the IndexStorage.SetIndex method")
	}

	if len(mmSetIndex.expectations) > 0 {
		mmSetIndex.mock.t.Fatalf("Some expectations are already set for the IndexStorage.SetIndex method")
	}

	mmSetIndex.mock.funcSetIndex = f
	return mmSetIndex.mock
}

// When sets expectation for the IndexStorage.SetIndex which will trigger the result defined by the following
// Then helper
func (mmSetIndex *mIndexStorageMockSetIndex) When(ctx context.Context, pn insolar.PulseNumber, index record.Index) *IndexStorageMockSetIndexExpectation {
	if mmSetIndex.mock.funcSetIndex != nil {
		mmSetIndex.mock.t.Fatalf("IndexStorageMock.SetIndex mock is already set by Set")
	}

	expectation := &IndexStorageMockSetIndexExpectation{
		mock:   mmSetIndex.mock,
		params: &IndexStorageMockSetIndexParams{ctx, pn, index},
	}
	mmSetIndex.expectations = append(mmSetIndex.expectations, expectation)
	return expectation
}

// Then sets up IndexStorage.SetIndex return parameters for the expectation previously defined by the When method
func (e *IndexStorageMockSetIndexExpectation) Then(err error) *IndexStorageMock {
	e.results = &IndexStorageMockSetIndexResults{err}
	return e.mock
}

// SetIndex implements IndexStorage
func (mmSetIndex *IndexStorageMock) SetIndex(ctx context.Context, pn insolar.PulseNumber, index record.Index) (err error) {
	mm_atomic.AddUint64(&mmSetIndex.beforeSetIndexCounter, 1)
	defer mm_atomic.AddUint64(&mmSetIndex.afterSetIndexCounter, 1)

	if mmSetIndex.inspectFuncSetIndex != nil {
		mmSetIndex.inspectFuncSetIndex(ctx, pn, index)
	}

	mm_params := &IndexStorageMockSetIndexParams{ctx, pn, index}

	// Record call args
	mmSetIndex.SetIndexMock.mutex.Lock()
	mmSetIndex.SetIndexMock.callArgs = append(mmSetIndex.SetIndexMock.callArgs, mm_params)
	mmSetIndex.SetIndexMock.mutex.Unlock()

	for _, e := range mmSetIndex.SetIndexMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetIndex.SetIndexMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetIndex.SetIndexMock.defaultExpectation.Counter, 1)
		mm_want := mmSetIndex.SetIndexMock.defaultExpectation.params
		mm_got := IndexStorageMockSetIndexParams{ctx, pn, index}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetIndex.t.Errorf("IndexStorageMock.SetIndex got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetIndex.SetIndexMock.defaultExpectation.results
		if mm_results == nil {
			mmSetIndex.t.Fatal("No results are set for the IndexStorageMock.SetIndex")
		}
		return (*mm_results).err
	}
	if mmSetIndex.funcSetIndex != nil {
		return mmSetIndex.funcSetIndex(ctx, pn, index)
	}
	mmSetIndex.t.Fatalf("Unexpected call to IndexStorageMock.SetIndex. %v %v %v", ctx, pn, index)
	return
}

// SetIndexAfterCounter returns a count of finished IndexStorageMock.SetIndex invocations
func (mmSetIndex *IndexStorageMock) SetIndexAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetIndex.afterSetIndexCounter)
}

// SetIndexBeforeCounter returns a count of IndexStorageMock.SetIndex invocations
func (mmSetIndex *IndexStorageMock) SetIndexBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetIndex.beforeSetIndexCounter)
}

// Calls returns a list of arguments used in each call to IndexStorageMock.SetIndex.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetIndex *mIndexStorageMockSetIndex) Calls() []*IndexStorageMockSetIndexParams {
	mmSetIndex.mutex.RLock()

	argCopy := make([]*IndexStorageMockSetIndexParams, len(mmSetIndex.callArgs))
	copy(argCopy, mmSetIndex.callArgs)

	mmSetIndex.mutex.RUnlock()

	return argCopy
}

// MinimockSetIndexDone returns true if the count of the SetIndex invocations corresponds
// the number of defined expectations
func (m *IndexStorageMock) MinimockSetIndexDone() bool {
	for _, e := range m.SetIndexMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetIndexMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetIndexCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetIndex != nil && mm_atomic.LoadUint64(&m.afterSetIndexCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetIndexInspect logs each unmet expectation
func (m *IndexStorageMock) MinimockSetIndexInspect() {
	for _, e := range m.SetIndexMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IndexStorageMock.SetIndex with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetIndexMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetIndexCounter) < 1 {
		if m.SetIndexMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IndexStorageMock.SetIndex")
		} else {
			m.t.Errorf("Expected call to IndexStorageMock.SetIndex with params: %#v", *m.SetIndexMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetIndex != nil && mm_atomic.LoadUint64(&m.afterSetIndexCounter) < 1 {
		m.t.Error("Expected call to IndexStorageMock.SetIndex")
	}
}

type mIndexStorageMockUpdateLastKnownPulse struct {
	mock               *IndexStorageMock
	defaultExpectation *IndexStorageMockUpdateLastKnownPulseExpectation
	expectations       []*IndexStorageMockUpdateLastKnownPulseExpectation

	callArgs []*IndexStorageMockUpdateLastKnownPulseParams
	mutex    sync.RWMutex
}

// IndexStorageMockUpdateLastKnownPulseExpectation specifies expectation struct of the IndexStorage.UpdateLastKnownPulse
type IndexStorageMockUpdateLastKnownPulseExpectation struct {
	mock    *IndexStorageMock
	params  *IndexStorageMockUpdateLastKnownPulseParams
	results *IndexStorageMockUpdateLastKnownPulseResults
	Counter uint64
}

// IndexStorageMockUpdateLastKnownPulseParams contains parameters of the IndexStorage.UpdateLastKnownPulse
type IndexStorageMockUpdateLastKnownPulseParams struct {
	ctx context.Context
	pn  insolar.PulseNumber
}

// IndexStorageMockUpdateLastKnownPulseResults contains results of the IndexStorage.UpdateLastKnownPulse
type IndexStorageMockUpdateLastKnownPulseResults struct {
	err error
}

// Expect sets up expected params for IndexStorage.UpdateLastKnownPulse
func (mmUpdateLastKnownPulse *mIndexStorageMockUpdateLastKnownPulse) Expect(ctx context.Context, pn insolar.PulseNumber) *mIndexStorageMockUpdateLastKnownPulse {
	if mmUpdateLastKnownPulse.mock.funcUpdateLastKnownPulse != nil {
		mmUpdateLastKnownPulse.mock.t.Fatalf("IndexStorageMock.UpdateLastKnownPulse mock is already set by Set")
	}

	if mmUpdateLastKnownPulse.defaultExpectation == nil {
		mmUpdateLastKnownPulse.defaultExpectation = &IndexStorageMockUpdateLastKnownPulseExpectation{}
	}

	mmUpdateLastKnownPulse.defaultExpectation.params = &IndexStorageMockUpdateLastKnownPulseParams{ctx, pn}
	for _, e := range mmUpdateLastKnownPulse.expectations {
		if minimock.Equal(e.params, mmUpdateLastKnownPulse.defaultExpectation.params) {
			mmUpdateLastKnownPulse.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateLastKnownPulse.defaultExpectation.params)
		}
	}

	return mmUpdateLastKnownPulse
}

// Inspect accepts an inspector function that has same arguments as the IndexStorage.UpdateLastKnownPulse
func (mmUpdateLastKnownPulse *mIndexStorageMockUpdateLastKnownPulse) Inspect(f func(ctx context.Context, pn insolar.PulseNumber)) *mIndexStorageMockUpdateLastKnownPulse {
	if mmUpdateLastKnownPulse.mock.inspectFuncUpdateLastKnownPulse != nil {
		mmUpdateLastKnownPulse.mock.t.Fatalf("Inspect function is already set for IndexStorageMock.UpdateLastKnownPulse")
	}

	mmUpdateLastKnownPulse.mock.inspectFuncUpdateLastKnownPulse = f

	return mmUpdateLastKnownPulse
}

// Return sets up results that will be returned by IndexStorage.UpdateLastKnownPulse
func (mmUpdateLastKnownPulse *mIndexStorageMockUpdateLastKnownPulse) Return(err error) *IndexStorageMock {
	if mmUpdateLastKnownPulse.mock.funcUpdateLastKnownPulse != nil {
		mmUpdateLastKnownPulse.mock.t.Fatalf("IndexStorageMock.UpdateLastKnownPulse mock is already set by Set")
	}

	if mmUpdateLastKnownPulse.defaultExpectation == nil {
		mmUpdateLastKnownPulse.defaultExpectation = &IndexStorageMockUpdateLastKnownPulseExpectation{mock: mmUpdateLastKnownPulse.mock}
	}
	mmUpdateLastKnownPulse.defaultExpectation.results = &IndexStorageMockUpdateLastKnownPulseResults{err}
	return mmUpdateLastKnownPulse.mock
}

//Set uses given function f to mock the IndexStorage.UpdateLastKnownPulse method
func (mmUpdateLastKnownPulse *mIndexStorageMockUpdateLastKnownPulse) Set(f func(ctx context.Context, pn insolar.PulseNumber) (err error)) *IndexStorageMock {
	if mmUpdateLastKnownPulse.defaultExpectation != nil {
		mmUpdateLastKnownPulse.mock.t.Fatalf("Default expectation is already set for the IndexStorage.UpdateLastKnownPulse method")
	}

	if len(mmUpdateLastKnownPulse.expectations) > 0 {
		mmUpdateLastKnownPulse.mock.t.Fatalf("Some expectations are already set for the IndexStorage.UpdateLastKnownPulse method")
	}

	mmUpdateLastKnownPulse.mock.funcUpdateLastKnownPulse = f
	return mmUpdateLastKnownPulse.mock
}

// When sets expectation for the IndexStorage.UpdateLastKnownPulse which will trigger the result defined by the following
// Then helper
func (mmUpdateLastKnownPulse *mIndexStorageMockUpdateLastKnownPulse) When(ctx context.Context, pn insolar.PulseNumber) *IndexStorageMockUpdateLastKnownPulseExpectation {
	if mmUpdateLastKnownPulse.mock.funcUpdateLastKnownPulse != nil {
		mmUpdateLastKnownPulse.mock.t.Fatalf("IndexStorageMock.UpdateLastKnownPulse mock is already set by Set")
	}

	expectation := &IndexStorageMockUpdateLastKnownPulseExpectation{
		mock:   mmUpdateLastKnownPulse.mock,
		params: &IndexStorageMockUpdateLastKnownPulseParams{ctx, pn},
	}
	mmUpdateLastKnownPulse.expectations = append(mmUpdateLastKnownPulse.expectations, expectation)
	return expectation
}

// Then sets up IndexStorage.UpdateLastKnownPulse return parameters for the expectation previously defined by the When method
func (e *IndexStorageMockUpdateLastKnownPulseExpectation) Then(err error) *IndexStorageMock {
	e.results = &IndexStorageMockUpdateLastKnownPulseResults{err}
	return e.mock
}

// UpdateLastKnownPulse implements IndexStorage
func (mmUpdateLastKnownPulse *IndexStorageMock) UpdateLastKnownPulse(ctx context.Context, pn insolar.PulseNumber) (err error) {
	mm_atomic.AddUint64(&mmUpdateLastKnownPulse.beforeUpdateLastKnownPulseCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateLastKnownPulse.afterUpdateLastKnownPulseCounter, 1)

	if mmUpdateLastKnownPulse.inspectFuncUpdateLastKnownPulse != nil {
		mmUpdateLastKnownPulse.inspectFuncUpdateLastKnownPulse(ctx, pn)
	}

	mm_params := &IndexStorageMockUpdateLastKnownPulseParams{ctx, pn}

	// Record call args
	mmUpdateLastKnownPulse.UpdateLastKnownPulseMock.mutex.Lock()
	mmUpdateLastKnownPulse.UpdateLastKnownPulseMock.callArgs = append(mmUpdateLastKnownPulse.UpdateLastKnownPulseMock.callArgs, mm_params)
	mmUpdateLastKnownPulse.UpdateLastKnownPulseMock.mutex.Unlock()

	for _, e := range mmUpdateLastKnownPulse.UpdateLastKnownPulseMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateLastKnownPulse.UpdateLastKnownPulseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateLastKnownPulse.UpdateLastKnownPulseMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateLastKnownPulse.UpdateLastKnownPulseMock.defaultExpectation.params
		mm_got := IndexStorageMockUpdateLastKnownPulseParams{ctx, pn}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateLastKnownPulse.t.Errorf("IndexStorageMock.UpdateLastKnownPulse got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateLastKnownPulse.UpdateLastKnownPulseMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateLastKnownPulse.t.Fatal("No results are set for the IndexStorageMock.UpdateLastKnownPulse")
		}
		return (*mm_results).err
	}
	if mmUpdateLastKnownPulse.funcUpdateLastKnownPulse != nil {
		return mmUpdateLastKnownPulse.funcUpdateLastKnownPulse(ctx, pn)
	}
	mmUpdateLastKnownPulse.t.Fatalf("Unexpected call to IndexStorageMock.UpdateLastKnownPulse. %v %v", ctx, pn)
	return
}

// UpdateLastKnownPulseAfterCounter returns a count of finished IndexStorageMock.UpdateLastKnownPulse invocations
func (mmUpdateLastKnownPulse *IndexStorageMock) UpdateLastKnownPulseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateLastKnownPulse.afterUpdateLastKnownPulseCounter)
}

// UpdateLastKnownPulseBeforeCounter returns a count of IndexStorageMock.UpdateLastKnownPulse invocations
func (mmUpdateLastKnownPulse *IndexStorageMock) UpdateLastKnownPulseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateLastKnownPulse.beforeUpdateLastKnownPulseCounter)
}

// Calls returns a list of arguments used in each call to IndexStorageMock.UpdateLastKnownPulse.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateLastKnownPulse *mIndexStorageMockUpdateLastKnownPulse) Calls() []*IndexStorageMockUpdateLastKnownPulseParams {
	mmUpdateLastKnownPulse.mutex.RLock()

	argCopy := make([]*IndexStorageMockUpdateLastKnownPulseParams, len(mmUpdateLastKnownPulse.callArgs))
	copy(argCopy, mmUpdateLastKnownPulse.callArgs)

	mmUpdateLastKnownPulse.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateLastKnownPulseDone returns true if the count of the UpdateLastKnownPulse invocations corresponds
// the number of defined expectations
func (m *IndexStorageMock) MinimockUpdateLastKnownPulseDone() bool {
	for _, e := range m.UpdateLastKnownPulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateLastKnownPulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateLastKnownPulseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateLastKnownPulse != nil && mm_atomic.LoadUint64(&m.afterUpdateLastKnownPulseCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateLastKnownPulseInspect logs each unmet expectation
func (m *IndexStorageMock) MinimockUpdateLastKnownPulseInspect() {
	for _, e := range m.UpdateLastKnownPulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IndexStorageMock.UpdateLastKnownPulse with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateLastKnownPulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateLastKnownPulseCounter) < 1 {
		if m.UpdateLastKnownPulseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IndexStorageMock.UpdateLastKnownPulse")
		} else {
			m.t.Errorf("Expected call to IndexStorageMock.UpdateLastKnownPulse with params: %#v", *m.UpdateLastKnownPulseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateLastKnownPulse != nil && mm_atomic.LoadUint64(&m.afterUpdateLastKnownPulseCounter) < 1 {
		m.t.Error("Expected call to IndexStorageMock.UpdateLastKnownPulse")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IndexStorageMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockForIDInspect()

		m.MinimockForPulseInspect()

		m.MinimockLastKnownForIDInspect()

		m.MinimockSetIndexInspect()

		m.MinimockUpdateLastKnownPulseInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IndexStorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IndexStorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockForIDDone() &&
		m.MinimockForPulseDone() &&
		m.MinimockLastKnownForIDDone() &&
		m.MinimockSetIndexDone() &&
		m.MinimockUpdateLastKnownPulseDone()
}
