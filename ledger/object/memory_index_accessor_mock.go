package object

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/insolar/insolar"
	"github.com/insolar/insolar/insolar/record"
)

// MemoryIndexAccessorMock implements MemoryIndexAccessor
type MemoryIndexAccessorMock struct {
	t minimock.Tester

	funcForID          func(ctx context.Context, pn insolar.PulseNumber, objID insolar.ID) (i1 record.Index, err error)
	inspectFuncForID   func(ctx context.Context, pn insolar.PulseNumber, objID insolar.ID)
	afterForIDCounter  uint64
	beforeForIDCounter uint64
	ForIDMock          mMemoryIndexAccessorMockForID

	funcForPulse          func(ctx context.Context, pn insolar.PulseNumber) (ia1 []record.Index, err error)
	inspectFuncForPulse   func(ctx context.Context, pn insolar.PulseNumber)
	afterForPulseCounter  uint64
	beforeForPulseCounter uint64
	ForPulseMock          mMemoryIndexAccessorMockForPulse
}

// NewMemoryIndexAccessorMock returns a mock for MemoryIndexAccessor
func NewMemoryIndexAccessorMock(t minimock.Tester) *MemoryIndexAccessorMock {
	m := &MemoryIndexAccessorMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ForIDMock = mMemoryIndexAccessorMockForID{mock: m}
	m.ForIDMock.callArgs = []*MemoryIndexAccessorMockForIDParams{}

	m.ForPulseMock = mMemoryIndexAccessorMockForPulse{mock: m}
	m.ForPulseMock.callArgs = []*MemoryIndexAccessorMockForPulseParams{}

	return m
}

type mMemoryIndexAccessorMockForID struct {
	mock               *MemoryIndexAccessorMock
	defaultExpectation *MemoryIndexAccessorMockForIDExpectation
	expectations       []*MemoryIndexAccessorMockForIDExpectation

	callArgs []*MemoryIndexAccessorMockForIDParams
	mutex    sync.RWMutex
}

// MemoryIndexAccessorMockForIDExpectation specifies expectation struct of the MemoryIndexAccessor.ForID
type MemoryIndexAccessorMockForIDExpectation struct {
	mock    *MemoryIndexAccessorMock
	params  *MemoryIndexAccessorMockForIDParams
	results *MemoryIndexAccessorMockForIDResults
	Counter uint64
}

// MemoryIndexAccessorMockForIDParams contains parameters of the MemoryIndexAccessor.ForID
type MemoryIndexAccessorMockForIDParams struct {
	ctx   context.Context
	pn    insolar.PulseNumber
	objID insolar.ID
}

// MemoryIndexAccessorMockForIDResults contains results of the MemoryIndexAccessor.ForID
type MemoryIndexAccessorMockForIDResults struct {
	i1  record.Index
	err error
}

// Expect sets up expected params for MemoryIndexAccessor.ForID
func (mmForID *mMemoryIndexAccessorMockForID) Expect(ctx context.Context, pn insolar.PulseNumber, objID insolar.ID) *mMemoryIndexAccessorMockForID {
	if mmForID.mock.funcForID != nil {
		mmForID.mock.t.Fatalf("MemoryIndexAccessorMock.ForID mock is already set by Set")
	}

	if mmForID.defaultExpectation == nil {
		mmForID.defaultExpectation = &MemoryIndexAccessorMockForIDExpectation{}
	}

	mmForID.defaultExpectation.params = &MemoryIndexAccessorMockForIDParams{ctx, pn, objID}
	for _, e := range mmForID.expectations {
		if minimock.Equal(e.params, mmForID.defaultExpectation.params) {
			mmForID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmForID.defaultExpectation.params)
		}
	}

	return mmForID
}

// Inspect accepts an inspector function that has same arguments as the MemoryIndexAccessor.ForID
func (mmForID *mMemoryIndexAccessorMockForID) Inspect(f func(ctx context.Context, pn insolar.PulseNumber, objID insolar.ID)) *mMemoryIndexAccessorMockForID {
	if mmForID.mock.inspectFuncForID != nil {
		mmForID.mock.t.Fatalf("Inspect function is already set for MemoryIndexAccessorMock.ForID")
	}

	mmForID.mock.inspectFuncForID = f

	return mmForID
}

// Return sets up results that will be returned by MemoryIndexAccessor.ForID
func (mmForID *mMemoryIndexAccessorMockForID) Return(i1 record.Index, err error) *MemoryIndexAccessorMock {
	if mmForID.mock.funcForID != nil {
		mmForID.mock.t.Fatalf("MemoryIndexAccessorMock.ForID mock is already set by Set")
	}

	if mmForID.defaultExpectation == nil {
		mmForID.defaultExpectation = &MemoryIndexAccessorMockForIDExpectation{mock: mmForID.mock}
	}
	mmForID.defaultExpectation.results = &MemoryIndexAccessorMockForIDResults{i1, err}
	return mmForID.mock
}

//Set uses given function f to mock the MemoryIndexAccessor.ForID method
func (mmForID *mMemoryIndexAccessorMockForID) Set(f func(ctx context.Context, pn insolar.PulseNumber, objID insolar.ID) (i1 record.Index, err error)) *MemoryIndexAccessorMock {
	if mmForID.defaultExpectation != nil {
		mmForID.mock.t.Fatalf("Default expectation is already set for the MemoryIndexAccessor.ForID method")
	}

	if len(mmForID.expectations) > 0 {
		mmForID.mock.t.Fatalf("Some expectations are already set for the MemoryIndexAccessor.ForID method")
	}

	mmForID.mock.funcForID = f
	return mmForID.mock
}

// When sets expectation for the MemoryIndexAccessor.ForID which will trigger the result defined by the following
// Then helper
func (mmForID *mMemoryIndexAccessorMockForID) When(ctx context.Context, pn insolar.PulseNumber, objID insolar.ID) *MemoryIndexAccessorMockForIDExpectation {
	if mmForID.mock.funcForID != nil {
		mmForID.mock.t.Fatalf("MemoryIndexAccessorMock.ForID mock is already set by Set")
	}

	expectation := &MemoryIndexAccessorMockForIDExpectation{
		mock:   mmForID.mock,
		params: &MemoryIndexAccessorMockForIDParams{ctx, pn, objID},
	}
	mmForID.expectations = append(mmForID.expectations, expectation)
	return expectation
}

// Then sets up MemoryIndexAccessor.ForID return parameters for the expectation previously defined by the When method
func (e *MemoryIndexAccessorMockForIDExpectation) Then(i1 record.Index, err error) *MemoryIndexAccessorMock {
	e.results = &MemoryIndexAccessorMockForIDResults{i1, err}
	return e.mock
}

// ForID implements MemoryIndexAccessor
func (mmForID *MemoryIndexAccessorMock) ForID(ctx context.Context, pn insolar.PulseNumber, objID insolar.ID) (i1 record.Index, err error) {
	mm_atomic.AddUint64(&mmForID.beforeForIDCounter, 1)
	defer mm_atomic.AddUint64(&mmForID.afterForIDCounter, 1)

	if mmForID.inspectFuncForID != nil {
		mmForID.inspectFuncForID(ctx, pn, objID)
	}

	mm_params := &MemoryIndexAccessorMockForIDParams{ctx, pn, objID}

	// Record call args
	mmForID.ForIDMock.mutex.Lock()
	mmForID.ForIDMock.callArgs = append(mmForID.ForIDMock.callArgs, mm_params)
	mmForID.ForIDMock.mutex.Unlock()

	for _, e := range mmForID.ForIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmForID.ForIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmForID.ForIDMock.defaultExpectation.Counter, 1)
		mm_want := mmForID.ForIDMock.defaultExpectation.params
		mm_got := MemoryIndexAccessorMockForIDParams{ctx, pn, objID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmForID.t.Errorf("MemoryIndexAccessorMock.ForID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmForID.ForIDMock.defaultExpectation.results
		if mm_results == nil {
			mmForID.t.Fatal("No results are set for the MemoryIndexAccessorMock.ForID")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmForID.funcForID != nil {
		return mmForID.funcForID(ctx, pn, objID)
	}
	mmForID.t.Fatalf("Unexpected call to MemoryIndexAccessorMock.ForID. %v %v %v", ctx, pn, objID)
	return
}

// ForIDAfterCounter returns a count of finished MemoryIndexAccessorMock.ForID invocations
func (mmForID *MemoryIndexAccessorMock) ForIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmForID.afterForIDCounter)
}

// ForIDBeforeCounter returns a count of MemoryIndexAccessorMock.ForID invocations
func (mmForID *MemoryIndexAccessorMock) ForIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmForID.beforeForIDCounter)
}

// Calls returns a list of arguments used in each call to MemoryIndexAccessorMock.ForID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmForID *mMemoryIndexAccessorMockForID) Calls() []*MemoryIndexAccessorMockForIDParams {
	mmForID.mutex.RLock()

	argCopy := make([]*MemoryIndexAccessorMockForIDParams, len(mmForID.callArgs))
	copy(argCopy, mmForID.callArgs)

	mmForID.mutex.RUnlock()

	return argCopy
}

// MinimockForIDDone returns true if the count of the ForID invocations corresponds
// the number of defined expectations
func (m *MemoryIndexAccessorMock) MinimockForIDDone() bool {
	for _, e := range m.ForIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ForIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterForIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcForID != nil && mm_atomic.LoadUint64(&m.afterForIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockForIDInspect logs each unmet expectation
func (m *MemoryIndexAccessorMock) MinimockForIDInspect() {
	for _, e := range m.ForIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MemoryIndexAccessorMock.ForID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ForIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterForIDCounter) < 1 {
		if m.ForIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MemoryIndexAccessorMock.ForID")
		} else {
			m.t.Errorf("Expected call to MemoryIndexAccessorMock.ForID with params: %#v", *m.ForIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcForID != nil && mm_atomic.LoadUint64(&m.afterForIDCounter) < 1 {
		m.t.Error("Expected call to MemoryIndexAccessorMock.ForID")
	}
}

type mMemoryIndexAccessorMockForPulse struct {
	mock               *MemoryIndexAccessorMock
	defaultExpectation *MemoryIndexAccessorMockForPulseExpectation
	expectations       []*MemoryIndexAccessorMockForPulseExpectation

	callArgs []*MemoryIndexAccessorMockForPulseParams
	mutex    sync.RWMutex
}

// MemoryIndexAccessorMockForPulseExpectation specifies expectation struct of the MemoryIndexAccessor.ForPulse
type MemoryIndexAccessorMockForPulseExpectation struct {
	mock    *MemoryIndexAccessorMock
	params  *MemoryIndexAccessorMockForPulseParams
	results *MemoryIndexAccessorMockForPulseResults
	Counter uint64
}

// MemoryIndexAccessorMockForPulseParams contains parameters of the MemoryIndexAccessor.ForPulse
type MemoryIndexAccessorMockForPulseParams struct {
	ctx context.Context
	pn  insolar.PulseNumber
}

// MemoryIndexAccessorMockForPulseResults contains results of the MemoryIndexAccessor.ForPulse
type MemoryIndexAccessorMockForPulseResults struct {
	ia1 []record.Index
	err error
}

// Expect sets up expected params for MemoryIndexAccessor.ForPulse
func (mmForPulse *mMemoryIndexAccessorMockForPulse) Expect(ctx context.Context, pn insolar.PulseNumber) *mMemoryIndexAccessorMockForPulse {
	if mmForPulse.mock.funcForPulse != nil {
		mmForPulse.mock.t.Fatalf("MemoryIndexAccessorMock.ForPulse mock is already set by Set")
	}

	if mmForPulse.defaultExpectation == nil {
		mmForPulse.defaultExpectation = &MemoryIndexAccessorMockForPulseExpectation{}
	}

	mmForPulse.defaultExpectation.params = &MemoryIndexAccessorMockForPulseParams{ctx, pn}
	for _, e := range mmForPulse.expectations {
		if minimock.Equal(e.params, mmForPulse.defaultExpectation.params) {
			mmForPulse.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmForPulse.defaultExpectation.params)
		}
	}

	return mmForPulse
}

// Inspect accepts an inspector function that has same arguments as the MemoryIndexAccessor.ForPulse
func (mmForPulse *mMemoryIndexAccessorMockForPulse) Inspect(f func(ctx context.Context, pn insolar.PulseNumber)) *mMemoryIndexAccessorMockForPulse {
	if mmForPulse.mock.inspectFuncForPulse != nil {
		mmForPulse.mock.t.Fatalf("Inspect function is already set for MemoryIndexAccessorMock.ForPulse")
	}

	mmForPulse.mock.inspectFuncForPulse = f

	return mmForPulse
}

// Return sets up results that will be returned by MemoryIndexAccessor.ForPulse
func (mmForPulse *mMemoryIndexAccessorMockForPulse) Return(ia1 []record.Index, err error) *MemoryIndexAccessorMock {
	if mmForPulse.mock.funcForPulse != nil {
		mmForPulse.mock.t.Fatalf("MemoryIndexAccessorMock.ForPulse mock is already set by Set")
	}

	if mmForPulse.defaultExpectation == nil {
		mmForPulse.defaultExpectation = &MemoryIndexAccessorMockForPulseExpectation{mock: mmForPulse.mock}
	}
	mmForPulse.defaultExpectation.results = &MemoryIndexAccessorMockForPulseResults{ia1, err}
	return mmForPulse.mock
}

//Set uses given function f to mock the MemoryIndexAccessor.ForPulse method
func (mmForPulse *mMemoryIndexAccessorMockForPulse) Set(f func(ctx context.Context, pn insolar.PulseNumber) (ia1 []record.Index, err error)) *MemoryIndexAccessorMock {
	if mmForPulse.defaultExpectation != nil {
		mmForPulse.mock.t.Fatalf("Default expectation is already set for the MemoryIndexAccessor.ForPulse method")
	}

	if len(mmForPulse.expectations) > 0 {
		mmForPulse.mock.t.Fatalf("Some expectations are already set for the MemoryIndexAccessor.ForPulse method")
	}

	mmForPulse.mock.funcForPulse = f
	return mmForPulse.mock
}

// When sets expectation for the MemoryIndexAccessor.ForPulse which will trigger the result defined by the following
// Then helper
func (mmForPulse *mMemoryIndexAccessorMockForPulse) When(ctx context.Context, pn insolar.PulseNumber) *MemoryIndexAccessorMockForPulseExpectation {
	if mmForPulse.mock.funcForPulse != nil {
		mmForPulse.mock.t.Fatalf("MemoryIndexAccessorMock.ForPulse mock is already set by Set")
	}

	expectation := &MemoryIndexAccessorMockForPulseExpectation{
		mock:   mmForPulse.mock,
		params: &MemoryIndexAccessorMockForPulseParams{ctx, pn},
	}
	mmForPulse.expectations = append(mmForPulse.expectations, expectation)
	return expectation
}

// Then sets up MemoryIndexAccessor.ForPulse return parameters for the expectation previously defined by the When method
func (e *MemoryIndexAccessorMockForPulseExpectation) Then(ia1 []record.Index, err error) *MemoryIndexAccessorMock {
	e.results = &MemoryIndexAccessorMockForPulseResults{ia1, err}
	return e.mock
}

// ForPulse implements MemoryIndexAccessor
func (mmForPulse *MemoryIndexAccessorMock) ForPulse(ctx context.Context, pn insolar.PulseNumber) (ia1 []record.Index, err error) {
	mm_atomic.AddUint64(&mmForPulse.beforeForPulseCounter, 1)
	defer mm_atomic.AddUint64(&mmForPulse.afterForPulseCounter, 1)

	if mmForPulse.inspectFuncForPulse != nil {
		mmForPulse.inspectFuncForPulse(ctx, pn)
	}

	mm_params := &MemoryIndexAccessorMockForPulseParams{ctx, pn}

	// Record call args
	mmForPulse.ForPulseMock.mutex.Lock()
	mmForPulse.ForPulseMock.callArgs = append(mmForPulse.ForPulseMock.callArgs, mm_params)
	mmForPulse.ForPulseMock.mutex.Unlock()

	for _, e := range mmForPulse.ForPulseMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ia1, e.results.err
		}
	}

	if mmForPulse.ForPulseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmForPulse.ForPulseMock.defaultExpectation.Counter, 1)
		mm_want := mmForPulse.ForPulseMock.defaultExpectation.params
		mm_got := MemoryIndexAccessorMockForPulseParams{ctx, pn}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmForPulse.t.Errorf("MemoryIndexAccessorMock.ForPulse got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmForPulse.ForPulseMock.defaultExpectation.results
		if mm_results == nil {
			mmForPulse.t.Fatal("No results are set for the MemoryIndexAccessorMock.ForPulse")
		}
		return (*mm_results).ia1, (*mm_results).err
	}
	if mmForPulse.funcForPulse != nil {
		return mmForPulse.funcForPulse(ctx, pn)
	}
	mmForPulse.t.Fatalf("Unexpected call to MemoryIndexAccessorMock.ForPulse. %v %v", ctx, pn)
	return
}

// ForPulseAfterCounter returns a count of finished MemoryIndexAccessorMock.ForPulse invocations
func (mmForPulse *MemoryIndexAccessorMock) ForPulseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmForPulse.afterForPulseCounter)
}

// ForPulseBeforeCounter returns a count of MemoryIndexAccessorMock.ForPulse invocations
func (mmForPulse *MemoryIndexAccessorMock) ForPulseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmForPulse.beforeForPulseCounter)
}

// Calls returns a list of arguments used in each call to MemoryIndexAccessorMock.ForPulse.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmForPulse *mMemoryIndexAccessorMockForPulse) Calls() []*MemoryIndexAccessorMockForPulseParams {
	mmForPulse.mutex.RLock()

	argCopy := make([]*MemoryIndexAccessorMockForPulseParams, len(mmForPulse.callArgs))
	copy(argCopy, mmForPulse.callArgs)

	mmForPulse.mutex.RUnlock()

	return argCopy
}

// MinimockForPulseDone returns true if the count of the ForPulse invocations corresponds
// the number of defined expectations
func (m *MemoryIndexAccessorMock) MinimockForPulseDone() bool {
	for _, e := range m.ForPulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ForPulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterForPulseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcForPulse != nil && mm_atomic.LoadUint64(&m.afterForPulseCounter) < 1 {
		return false
	}
	return true
}

// MinimockForPulseInspect logs each unmet expectation
func (m *MemoryIndexAccessorMock) MinimockForPulseInspect() {
	for _, e := range m.ForPulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MemoryIndexAccessorMock.ForPulse with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ForPulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterForPulseCounter) < 1 {
		if m.ForPulseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MemoryIndexAccessorMock.ForPulse")
		} else {
			m.t.Errorf("Expected call to MemoryIndexAccessorMock.ForPulse with params: %#v", *m.ForPulseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcForPulse != nil && mm_atomic.LoadUint64(&m.afterForPulseCounter) < 1 {
		m.t.Error("Expected call to MemoryIndexAccessorMock.ForPulse")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *MemoryIndexAccessorMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockForIDInspect()

		m.MinimockForPulseInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *MemoryIndexAccessorMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *MemoryIndexAccessorMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockForIDDone() &&
		m.MinimockForPulseDone()
}
