package artifact

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/insolar"
	"github.com/insolar/insolar/insolar/record"
)

// ManagerMock implements Manager
type ManagerMock struct {
	t minimock.Tester

	funcActivateObject          func(ctx context.Context, domain insolar.Reference, obj insolar.Reference, parent insolar.Reference, prototype insolar.Reference, memory []byte) (err error)
	inspectFuncActivateObject   func(ctx context.Context, domain insolar.Reference, obj insolar.Reference, parent insolar.Reference, prototype insolar.Reference, memory []byte)
	afterActivateObjectCounter  uint64
	beforeActivateObjectCounter uint64
	ActivateObjectMock          mManagerMockActivateObject

	funcDeployCode          func(ctx context.Context, domain insolar.Reference, request insolar.Reference, code []byte, machineType insolar.MachineType) (ip1 *insolar.ID, err error)
	inspectFuncDeployCode   func(ctx context.Context, domain insolar.Reference, request insolar.Reference, code []byte, machineType insolar.MachineType)
	afterDeployCodeCounter  uint64
	beforeDeployCodeCounter uint64
	DeployCodeMock          mManagerMockDeployCode

	funcGetObject          func(ctx context.Context, head insolar.Reference) (o1 ObjectDescriptor, err error)
	inspectFuncGetObject   func(ctx context.Context, head insolar.Reference)
	afterGetObjectCounter  uint64
	beforeGetObjectCounter uint64
	GetObjectMock          mManagerMockGetObject

	funcRegisterRequest          func(ctx context.Context, req record.IncomingRequest) (ip1 *insolar.ID, err error)
	inspectFuncRegisterRequest   func(ctx context.Context, req record.IncomingRequest)
	afterRegisterRequestCounter  uint64
	beforeRegisterRequestCounter uint64
	RegisterRequestMock          mManagerMockRegisterRequest

	funcRegisterResult          func(ctx context.Context, obj insolar.Reference, request insolar.Reference, payload []byte) (ip1 *insolar.ID, err error)
	inspectFuncRegisterResult   func(ctx context.Context, obj insolar.Reference, request insolar.Reference, payload []byte)
	afterRegisterResultCounter  uint64
	beforeRegisterResultCounter uint64
	RegisterResultMock          mManagerMockRegisterResult

	funcUpdateObject          func(ctx context.Context, domain insolar.Reference, request insolar.Reference, obj ObjectDescriptor, memory []byte) (err error)
	inspectFuncUpdateObject   func(ctx context.Context, domain insolar.Reference, request insolar.Reference, obj ObjectDescriptor, memory []byte)
	afterUpdateObjectCounter  uint64
	beforeUpdateObjectCounter uint64
	UpdateObjectMock          mManagerMockUpdateObject
}

// NewManagerMock returns a mock for Manager
func NewManagerMock(t minimock.Tester) *ManagerMock {
	m := &ManagerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ActivateObjectMock = mManagerMockActivateObject{mock: m}
	m.ActivateObjectMock.callArgs = []*ManagerMockActivateObjectParams{}

	m.DeployCodeMock = mManagerMockDeployCode{mock: m}
	m.DeployCodeMock.callArgs = []*ManagerMockDeployCodeParams{}

	m.GetObjectMock = mManagerMockGetObject{mock: m}
	m.GetObjectMock.callArgs = []*ManagerMockGetObjectParams{}

	m.RegisterRequestMock = mManagerMockRegisterRequest{mock: m}
	m.RegisterRequestMock.callArgs = []*ManagerMockRegisterRequestParams{}

	m.RegisterResultMock = mManagerMockRegisterResult{mock: m}
	m.RegisterResultMock.callArgs = []*ManagerMockRegisterResultParams{}

	m.UpdateObjectMock = mManagerMockUpdateObject{mock: m}
	m.UpdateObjectMock.callArgs = []*ManagerMockUpdateObjectParams{}

	return m
}

type mManagerMockActivateObject struct {
	mock               *ManagerMock
	defaultExpectation *ManagerMockActivateObjectExpectation
	expectations       []*ManagerMockActivateObjectExpectation

	callArgs []*ManagerMockActivateObjectParams
	mutex    sync.RWMutex
}

// ManagerMockActivateObjectExpectation specifies expectation struct of the Manager.ActivateObject
type ManagerMockActivateObjectExpectation struct {
	mock    *ManagerMock
	params  *ManagerMockActivateObjectParams
	results *ManagerMockActivateObjectResults
	Counter uint64
}

// ManagerMockActivateObjectParams contains parameters of the Manager.ActivateObject
type ManagerMockActivateObjectParams struct {
	ctx       context.Context
	domain    insolar.Reference
	obj       insolar.Reference
	parent    insolar.Reference
	prototype insolar.Reference
	memory    []byte
}

// ManagerMockActivateObjectResults contains results of the Manager.ActivateObject
type ManagerMockActivateObjectResults struct {
	err error
}

// Expect sets up expected params for Manager.ActivateObject
func (mmActivateObject *mManagerMockActivateObject) Expect(ctx context.Context, domain insolar.Reference, obj insolar.Reference, parent insolar.Reference, prototype insolar.Reference, memory []byte) *mManagerMockActivateObject {
	if mmActivateObject.mock.funcActivateObject != nil {
		mmActivateObject.mock.t.Fatalf("ManagerMock.ActivateObject mock is already set by Set")
	}

	if mmActivateObject.defaultExpectation == nil {
		mmActivateObject.defaultExpectation = &ManagerMockActivateObjectExpectation{}
	}

	mmActivateObject.defaultExpectation.params = &ManagerMockActivateObjectParams{ctx, domain, obj, parent, prototype, memory}
	for _, e := range mmActivateObject.expectations {
		if minimock.Equal(e.params, mmActivateObject.defaultExpectation.params) {
			mmActivateObject.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmActivateObject.defaultExpectation.params)
		}
	}

	return mmActivateObject
}

// Inspect accepts an inspector function that has same arguments as the Manager.ActivateObject
func (mmActivateObject *mManagerMockActivateObject) Inspect(f func(ctx context.Context, domain insolar.Reference, obj insolar.Reference, parent insolar.Reference, prototype insolar.Reference, memory []byte)) *mManagerMockActivateObject {
	if mmActivateObject.mock.inspectFuncActivateObject != nil {
		mmActivateObject.mock.t.Fatalf("Inspect function is already set for ManagerMock.ActivateObject")
	}

	mmActivateObject.mock.inspectFuncActivateObject = f

	return mmActivateObject
}

// Return sets up results that will be returned by Manager.ActivateObject
func (mmActivateObject *mManagerMockActivateObject) Return(err error) *ManagerMock {
	if mmActivateObject.mock.funcActivateObject != nil {
		mmActivateObject.mock.t.Fatalf("ManagerMock.ActivateObject mock is already set by Set")
	}

	if mmActivateObject.defaultExpectation == nil {
		mmActivateObject.defaultExpectation = &ManagerMockActivateObjectExpectation{mock: mmActivateObject.mock}
	}
	mmActivateObject.defaultExpectation.results = &ManagerMockActivateObjectResults{err}
	return mmActivateObject.mock
}

//Set uses given function f to mock the Manager.ActivateObject method
func (mmActivateObject *mManagerMockActivateObject) Set(f func(ctx context.Context, domain insolar.Reference, obj insolar.Reference, parent insolar.Reference, prototype insolar.Reference, memory []byte) (err error)) *ManagerMock {
	if mmActivateObject.defaultExpectation != nil {
		mmActivateObject.mock.t.Fatalf("Default expectation is already set for the Manager.ActivateObject method")
	}

	if len(mmActivateObject.expectations) > 0 {
		mmActivateObject.mock.t.Fatalf("Some expectations are already set for the Manager.ActivateObject method")
	}

	mmActivateObject.mock.funcActivateObject = f
	return mmActivateObject.mock
}

// When sets expectation for the Manager.ActivateObject which will trigger the result defined by the following
// Then helper
func (mmActivateObject *mManagerMockActivateObject) When(ctx context.Context, domain insolar.Reference, obj insolar.Reference, parent insolar.Reference, prototype insolar.Reference, memory []byte) *ManagerMockActivateObjectExpectation {
	if mmActivateObject.mock.funcActivateObject != nil {
		mmActivateObject.mock.t.Fatalf("ManagerMock.ActivateObject mock is already set by Set")
	}

	expectation := &ManagerMockActivateObjectExpectation{
		mock:   mmActivateObject.mock,
		params: &ManagerMockActivateObjectParams{ctx, domain, obj, parent, prototype, memory},
	}
	mmActivateObject.expectations = append(mmActivateObject.expectations, expectation)
	return expectation
}

// Then sets up Manager.ActivateObject return parameters for the expectation previously defined by the When method
func (e *ManagerMockActivateObjectExpectation) Then(err error) *ManagerMock {
	e.results = &ManagerMockActivateObjectResults{err}
	return e.mock
}

// ActivateObject implements Manager
func (mmActivateObject *ManagerMock) ActivateObject(ctx context.Context, domain insolar.Reference, obj insolar.Reference, parent insolar.Reference, prototype insolar.Reference, memory []byte) (err error) {
	mm_atomic.AddUint64(&mmActivateObject.beforeActivateObjectCounter, 1)
	defer mm_atomic.AddUint64(&mmActivateObject.afterActivateObjectCounter, 1)

	if mmActivateObject.inspectFuncActivateObject != nil {
		mmActivateObject.inspectFuncActivateObject(ctx, domain, obj, parent, prototype, memory)
	}

	params := &ManagerMockActivateObjectParams{ctx, domain, obj, parent, prototype, memory}

	// Record call args
	mmActivateObject.ActivateObjectMock.mutex.Lock()
	mmActivateObject.ActivateObjectMock.callArgs = append(mmActivateObject.ActivateObjectMock.callArgs, params)
	mmActivateObject.ActivateObjectMock.mutex.Unlock()

	for _, e := range mmActivateObject.ActivateObjectMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmActivateObject.ActivateObjectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmActivateObject.ActivateObjectMock.defaultExpectation.Counter, 1)
		want := mmActivateObject.ActivateObjectMock.defaultExpectation.params
		got := ManagerMockActivateObjectParams{ctx, domain, obj, parent, prototype, memory}
		if want != nil && !minimock.Equal(*want, got) {
			mmActivateObject.t.Errorf("ManagerMock.ActivateObject got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmActivateObject.ActivateObjectMock.defaultExpectation.results
		if results == nil {
			mmActivateObject.t.Fatal("No results are set for the ManagerMock.ActivateObject")
		}
		return (*results).err
	}
	if mmActivateObject.funcActivateObject != nil {
		return mmActivateObject.funcActivateObject(ctx, domain, obj, parent, prototype, memory)
	}
	mmActivateObject.t.Fatalf("Unexpected call to ManagerMock.ActivateObject. %v %v %v %v %v %v", ctx, domain, obj, parent, prototype, memory)
	return
}

// ActivateObjectAfterCounter returns a count of finished ManagerMock.ActivateObject invocations
func (mmActivateObject *ManagerMock) ActivateObjectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmActivateObject.afterActivateObjectCounter)
}

// ActivateObjectBeforeCounter returns a count of ManagerMock.ActivateObject invocations
func (mmActivateObject *ManagerMock) ActivateObjectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmActivateObject.beforeActivateObjectCounter)
}

// Calls returns a list of arguments used in each call to ManagerMock.ActivateObject.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmActivateObject *mManagerMockActivateObject) Calls() []*ManagerMockActivateObjectParams {
	mmActivateObject.mutex.RLock()

	argCopy := make([]*ManagerMockActivateObjectParams, len(mmActivateObject.callArgs))
	copy(argCopy, mmActivateObject.callArgs)

	mmActivateObject.mutex.RUnlock()

	return argCopy
}

// MinimockActivateObjectDone returns true if the count of the ActivateObject invocations corresponds
// the number of defined expectations
func (m *ManagerMock) MinimockActivateObjectDone() bool {
	for _, e := range m.ActivateObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ActivateObjectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterActivateObjectCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcActivateObject != nil && mm_atomic.LoadUint64(&m.afterActivateObjectCounter) < 1 {
		return false
	}
	return true
}

// MinimockActivateObjectInspect logs each unmet expectation
func (m *ManagerMock) MinimockActivateObjectInspect() {
	for _, e := range m.ActivateObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ManagerMock.ActivateObject with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ActivateObjectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterActivateObjectCounter) < 1 {
		if m.ActivateObjectMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ManagerMock.ActivateObject")
		} else {
			m.t.Errorf("Expected call to ManagerMock.ActivateObject with params: %#v", *m.ActivateObjectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcActivateObject != nil && mm_atomic.LoadUint64(&m.afterActivateObjectCounter) < 1 {
		m.t.Error("Expected call to ManagerMock.ActivateObject")
	}
}

type mManagerMockDeployCode struct {
	mock               *ManagerMock
	defaultExpectation *ManagerMockDeployCodeExpectation
	expectations       []*ManagerMockDeployCodeExpectation

	callArgs []*ManagerMockDeployCodeParams
	mutex    sync.RWMutex
}

// ManagerMockDeployCodeExpectation specifies expectation struct of the Manager.DeployCode
type ManagerMockDeployCodeExpectation struct {
	mock    *ManagerMock
	params  *ManagerMockDeployCodeParams
	results *ManagerMockDeployCodeResults
	Counter uint64
}

// ManagerMockDeployCodeParams contains parameters of the Manager.DeployCode
type ManagerMockDeployCodeParams struct {
	ctx         context.Context
	domain      insolar.Reference
	request     insolar.Reference
	code        []byte
	machineType insolar.MachineType
}

// ManagerMockDeployCodeResults contains results of the Manager.DeployCode
type ManagerMockDeployCodeResults struct {
	ip1 *insolar.ID
	err error
}

// Expect sets up expected params for Manager.DeployCode
func (mmDeployCode *mManagerMockDeployCode) Expect(ctx context.Context, domain insolar.Reference, request insolar.Reference, code []byte, machineType insolar.MachineType) *mManagerMockDeployCode {
	if mmDeployCode.mock.funcDeployCode != nil {
		mmDeployCode.mock.t.Fatalf("ManagerMock.DeployCode mock is already set by Set")
	}

	if mmDeployCode.defaultExpectation == nil {
		mmDeployCode.defaultExpectation = &ManagerMockDeployCodeExpectation{}
	}

	mmDeployCode.defaultExpectation.params = &ManagerMockDeployCodeParams{ctx, domain, request, code, machineType}
	for _, e := range mmDeployCode.expectations {
		if minimock.Equal(e.params, mmDeployCode.defaultExpectation.params) {
			mmDeployCode.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeployCode.defaultExpectation.params)
		}
	}

	return mmDeployCode
}

// Inspect accepts an inspector function that has same arguments as the Manager.DeployCode
func (mmDeployCode *mManagerMockDeployCode) Inspect(f func(ctx context.Context, domain insolar.Reference, request insolar.Reference, code []byte, machineType insolar.MachineType)) *mManagerMockDeployCode {
	if mmDeployCode.mock.inspectFuncDeployCode != nil {
		mmDeployCode.mock.t.Fatalf("Inspect function is already set for ManagerMock.DeployCode")
	}

	mmDeployCode.mock.inspectFuncDeployCode = f

	return mmDeployCode
}

// Return sets up results that will be returned by Manager.DeployCode
func (mmDeployCode *mManagerMockDeployCode) Return(ip1 *insolar.ID, err error) *ManagerMock {
	if mmDeployCode.mock.funcDeployCode != nil {
		mmDeployCode.mock.t.Fatalf("ManagerMock.DeployCode mock is already set by Set")
	}

	if mmDeployCode.defaultExpectation == nil {
		mmDeployCode.defaultExpectation = &ManagerMockDeployCodeExpectation{mock: mmDeployCode.mock}
	}
	mmDeployCode.defaultExpectation.results = &ManagerMockDeployCodeResults{ip1, err}
	return mmDeployCode.mock
}

//Set uses given function f to mock the Manager.DeployCode method
func (mmDeployCode *mManagerMockDeployCode) Set(f func(ctx context.Context, domain insolar.Reference, request insolar.Reference, code []byte, machineType insolar.MachineType) (ip1 *insolar.ID, err error)) *ManagerMock {
	if mmDeployCode.defaultExpectation != nil {
		mmDeployCode.mock.t.Fatalf("Default expectation is already set for the Manager.DeployCode method")
	}

	if len(mmDeployCode.expectations) > 0 {
		mmDeployCode.mock.t.Fatalf("Some expectations are already set for the Manager.DeployCode method")
	}

	mmDeployCode.mock.funcDeployCode = f
	return mmDeployCode.mock
}

// When sets expectation for the Manager.DeployCode which will trigger the result defined by the following
// Then helper
func (mmDeployCode *mManagerMockDeployCode) When(ctx context.Context, domain insolar.Reference, request insolar.Reference, code []byte, machineType insolar.MachineType) *ManagerMockDeployCodeExpectation {
	if mmDeployCode.mock.funcDeployCode != nil {
		mmDeployCode.mock.t.Fatalf("ManagerMock.DeployCode mock is already set by Set")
	}

	expectation := &ManagerMockDeployCodeExpectation{
		mock:   mmDeployCode.mock,
		params: &ManagerMockDeployCodeParams{ctx, domain, request, code, machineType},
	}
	mmDeployCode.expectations = append(mmDeployCode.expectations, expectation)
	return expectation
}

// Then sets up Manager.DeployCode return parameters for the expectation previously defined by the When method
func (e *ManagerMockDeployCodeExpectation) Then(ip1 *insolar.ID, err error) *ManagerMock {
	e.results = &ManagerMockDeployCodeResults{ip1, err}
	return e.mock
}

// DeployCode implements Manager
func (mmDeployCode *ManagerMock) DeployCode(ctx context.Context, domain insolar.Reference, request insolar.Reference, code []byte, machineType insolar.MachineType) (ip1 *insolar.ID, err error) {
	mm_atomic.AddUint64(&mmDeployCode.beforeDeployCodeCounter, 1)
	defer mm_atomic.AddUint64(&mmDeployCode.afterDeployCodeCounter, 1)

	if mmDeployCode.inspectFuncDeployCode != nil {
		mmDeployCode.inspectFuncDeployCode(ctx, domain, request, code, machineType)
	}

	params := &ManagerMockDeployCodeParams{ctx, domain, request, code, machineType}

	// Record call args
	mmDeployCode.DeployCodeMock.mutex.Lock()
	mmDeployCode.DeployCodeMock.callArgs = append(mmDeployCode.DeployCodeMock.callArgs, params)
	mmDeployCode.DeployCodeMock.mutex.Unlock()

	for _, e := range mmDeployCode.DeployCodeMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ip1, e.results.err
		}
	}

	if mmDeployCode.DeployCodeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeployCode.DeployCodeMock.defaultExpectation.Counter, 1)
		want := mmDeployCode.DeployCodeMock.defaultExpectation.params
		got := ManagerMockDeployCodeParams{ctx, domain, request, code, machineType}
		if want != nil && !minimock.Equal(*want, got) {
			mmDeployCode.t.Errorf("ManagerMock.DeployCode got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmDeployCode.DeployCodeMock.defaultExpectation.results
		if results == nil {
			mmDeployCode.t.Fatal("No results are set for the ManagerMock.DeployCode")
		}
		return (*results).ip1, (*results).err
	}
	if mmDeployCode.funcDeployCode != nil {
		return mmDeployCode.funcDeployCode(ctx, domain, request, code, machineType)
	}
	mmDeployCode.t.Fatalf("Unexpected call to ManagerMock.DeployCode. %v %v %v %v %v", ctx, domain, request, code, machineType)
	return
}

// DeployCodeAfterCounter returns a count of finished ManagerMock.DeployCode invocations
func (mmDeployCode *ManagerMock) DeployCodeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeployCode.afterDeployCodeCounter)
}

// DeployCodeBeforeCounter returns a count of ManagerMock.DeployCode invocations
func (mmDeployCode *ManagerMock) DeployCodeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeployCode.beforeDeployCodeCounter)
}

// Calls returns a list of arguments used in each call to ManagerMock.DeployCode.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeployCode *mManagerMockDeployCode) Calls() []*ManagerMockDeployCodeParams {
	mmDeployCode.mutex.RLock()

	argCopy := make([]*ManagerMockDeployCodeParams, len(mmDeployCode.callArgs))
	copy(argCopy, mmDeployCode.callArgs)

	mmDeployCode.mutex.RUnlock()

	return argCopy
}

// MinimockDeployCodeDone returns true if the count of the DeployCode invocations corresponds
// the number of defined expectations
func (m *ManagerMock) MinimockDeployCodeDone() bool {
	for _, e := range m.DeployCodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeployCodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeployCodeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeployCode != nil && mm_atomic.LoadUint64(&m.afterDeployCodeCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeployCodeInspect logs each unmet expectation
func (m *ManagerMock) MinimockDeployCodeInspect() {
	for _, e := range m.DeployCodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ManagerMock.DeployCode with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeployCodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeployCodeCounter) < 1 {
		if m.DeployCodeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ManagerMock.DeployCode")
		} else {
			m.t.Errorf("Expected call to ManagerMock.DeployCode with params: %#v", *m.DeployCodeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeployCode != nil && mm_atomic.LoadUint64(&m.afterDeployCodeCounter) < 1 {
		m.t.Error("Expected call to ManagerMock.DeployCode")
	}
}

type mManagerMockGetObject struct {
	mock               *ManagerMock
	defaultExpectation *ManagerMockGetObjectExpectation
	expectations       []*ManagerMockGetObjectExpectation

	callArgs []*ManagerMockGetObjectParams
	mutex    sync.RWMutex
}

// ManagerMockGetObjectExpectation specifies expectation struct of the Manager.GetObject
type ManagerMockGetObjectExpectation struct {
	mock    *ManagerMock
	params  *ManagerMockGetObjectParams
	results *ManagerMockGetObjectResults
	Counter uint64
}

// ManagerMockGetObjectParams contains parameters of the Manager.GetObject
type ManagerMockGetObjectParams struct {
	ctx  context.Context
	head insolar.Reference
}

// ManagerMockGetObjectResults contains results of the Manager.GetObject
type ManagerMockGetObjectResults struct {
	o1  ObjectDescriptor
	err error
}

// Expect sets up expected params for Manager.GetObject
func (mmGetObject *mManagerMockGetObject) Expect(ctx context.Context, head insolar.Reference) *mManagerMockGetObject {
	if mmGetObject.mock.funcGetObject != nil {
		mmGetObject.mock.t.Fatalf("ManagerMock.GetObject mock is already set by Set")
	}

	if mmGetObject.defaultExpectation == nil {
		mmGetObject.defaultExpectation = &ManagerMockGetObjectExpectation{}
	}

	mmGetObject.defaultExpectation.params = &ManagerMockGetObjectParams{ctx, head}
	for _, e := range mmGetObject.expectations {
		if minimock.Equal(e.params, mmGetObject.defaultExpectation.params) {
			mmGetObject.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetObject.defaultExpectation.params)
		}
	}

	return mmGetObject
}

// Inspect accepts an inspector function that has same arguments as the Manager.GetObject
func (mmGetObject *mManagerMockGetObject) Inspect(f func(ctx context.Context, head insolar.Reference)) *mManagerMockGetObject {
	if mmGetObject.mock.inspectFuncGetObject != nil {
		mmGetObject.mock.t.Fatalf("Inspect function is already set for ManagerMock.GetObject")
	}

	mmGetObject.mock.inspectFuncGetObject = f

	return mmGetObject
}

// Return sets up results that will be returned by Manager.GetObject
func (mmGetObject *mManagerMockGetObject) Return(o1 ObjectDescriptor, err error) *ManagerMock {
	if mmGetObject.mock.funcGetObject != nil {
		mmGetObject.mock.t.Fatalf("ManagerMock.GetObject mock is already set by Set")
	}

	if mmGetObject.defaultExpectation == nil {
		mmGetObject.defaultExpectation = &ManagerMockGetObjectExpectation{mock: mmGetObject.mock}
	}
	mmGetObject.defaultExpectation.results = &ManagerMockGetObjectResults{o1, err}
	return mmGetObject.mock
}

//Set uses given function f to mock the Manager.GetObject method
func (mmGetObject *mManagerMockGetObject) Set(f func(ctx context.Context, head insolar.Reference) (o1 ObjectDescriptor, err error)) *ManagerMock {
	if mmGetObject.defaultExpectation != nil {
		mmGetObject.mock.t.Fatalf("Default expectation is already set for the Manager.GetObject method")
	}

	if len(mmGetObject.expectations) > 0 {
		mmGetObject.mock.t.Fatalf("Some expectations are already set for the Manager.GetObject method")
	}

	mmGetObject.mock.funcGetObject = f
	return mmGetObject.mock
}

// When sets expectation for the Manager.GetObject which will trigger the result defined by the following
// Then helper
func (mmGetObject *mManagerMockGetObject) When(ctx context.Context, head insolar.Reference) *ManagerMockGetObjectExpectation {
	if mmGetObject.mock.funcGetObject != nil {
		mmGetObject.mock.t.Fatalf("ManagerMock.GetObject mock is already set by Set")
	}

	expectation := &ManagerMockGetObjectExpectation{
		mock:   mmGetObject.mock,
		params: &ManagerMockGetObjectParams{ctx, head},
	}
	mmGetObject.expectations = append(mmGetObject.expectations, expectation)
	return expectation
}

// Then sets up Manager.GetObject return parameters for the expectation previously defined by the When method
func (e *ManagerMockGetObjectExpectation) Then(o1 ObjectDescriptor, err error) *ManagerMock {
	e.results = &ManagerMockGetObjectResults{o1, err}
	return e.mock
}

// GetObject implements Manager
func (mmGetObject *ManagerMock) GetObject(ctx context.Context, head insolar.Reference) (o1 ObjectDescriptor, err error) {
	mm_atomic.AddUint64(&mmGetObject.beforeGetObjectCounter, 1)
	defer mm_atomic.AddUint64(&mmGetObject.afterGetObjectCounter, 1)

	if mmGetObject.inspectFuncGetObject != nil {
		mmGetObject.inspectFuncGetObject(ctx, head)
	}

	params := &ManagerMockGetObjectParams{ctx, head}

	// Record call args
	mmGetObject.GetObjectMock.mutex.Lock()
	mmGetObject.GetObjectMock.callArgs = append(mmGetObject.GetObjectMock.callArgs, params)
	mmGetObject.GetObjectMock.mutex.Unlock()

	for _, e := range mmGetObject.GetObjectMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o1, e.results.err
		}
	}

	if mmGetObject.GetObjectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetObject.GetObjectMock.defaultExpectation.Counter, 1)
		want := mmGetObject.GetObjectMock.defaultExpectation.params
		got := ManagerMockGetObjectParams{ctx, head}
		if want != nil && !minimock.Equal(*want, got) {
			mmGetObject.t.Errorf("ManagerMock.GetObject got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmGetObject.GetObjectMock.defaultExpectation.results
		if results == nil {
			mmGetObject.t.Fatal("No results are set for the ManagerMock.GetObject")
		}
		return (*results).o1, (*results).err
	}
	if mmGetObject.funcGetObject != nil {
		return mmGetObject.funcGetObject(ctx, head)
	}
	mmGetObject.t.Fatalf("Unexpected call to ManagerMock.GetObject. %v %v", ctx, head)
	return
}

// GetObjectAfterCounter returns a count of finished ManagerMock.GetObject invocations
func (mmGetObject *ManagerMock) GetObjectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObject.afterGetObjectCounter)
}

// GetObjectBeforeCounter returns a count of ManagerMock.GetObject invocations
func (mmGetObject *ManagerMock) GetObjectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObject.beforeGetObjectCounter)
}

// Calls returns a list of arguments used in each call to ManagerMock.GetObject.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetObject *mManagerMockGetObject) Calls() []*ManagerMockGetObjectParams {
	mmGetObject.mutex.RLock()

	argCopy := make([]*ManagerMockGetObjectParams, len(mmGetObject.callArgs))
	copy(argCopy, mmGetObject.callArgs)

	mmGetObject.mutex.RUnlock()

	return argCopy
}

// MinimockGetObjectDone returns true if the count of the GetObject invocations corresponds
// the number of defined expectations
func (m *ManagerMock) MinimockGetObjectDone() bool {
	for _, e := range m.GetObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetObjectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetObjectCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetObject != nil && mm_atomic.LoadUint64(&m.afterGetObjectCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetObjectInspect logs each unmet expectation
func (m *ManagerMock) MinimockGetObjectInspect() {
	for _, e := range m.GetObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ManagerMock.GetObject with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetObjectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetObjectCounter) < 1 {
		if m.GetObjectMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ManagerMock.GetObject")
		} else {
			m.t.Errorf("Expected call to ManagerMock.GetObject with params: %#v", *m.GetObjectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetObject != nil && mm_atomic.LoadUint64(&m.afterGetObjectCounter) < 1 {
		m.t.Error("Expected call to ManagerMock.GetObject")
	}
}

type mManagerMockRegisterRequest struct {
	mock               *ManagerMock
	defaultExpectation *ManagerMockRegisterRequestExpectation
	expectations       []*ManagerMockRegisterRequestExpectation

	callArgs []*ManagerMockRegisterRequestParams
	mutex    sync.RWMutex
}

// ManagerMockRegisterRequestExpectation specifies expectation struct of the Manager.RegisterRequest
type ManagerMockRegisterRequestExpectation struct {
	mock    *ManagerMock
	params  *ManagerMockRegisterRequestParams
	results *ManagerMockRegisterRequestResults
	Counter uint64
}

// ManagerMockRegisterRequestParams contains parameters of the Manager.RegisterRequest
type ManagerMockRegisterRequestParams struct {
	ctx context.Context
	req record.IncomingRequest
}

// ManagerMockRegisterRequestResults contains results of the Manager.RegisterRequest
type ManagerMockRegisterRequestResults struct {
	ip1 *insolar.ID
	err error
}

// Expect sets up expected params for Manager.RegisterRequest
func (mmRegisterRequest *mManagerMockRegisterRequest) Expect(ctx context.Context, req record.IncomingRequest) *mManagerMockRegisterRequest {
	if mmRegisterRequest.mock.funcRegisterRequest != nil {
		mmRegisterRequest.mock.t.Fatalf("ManagerMock.RegisterRequest mock is already set by Set")
	}

	if mmRegisterRequest.defaultExpectation == nil {
		mmRegisterRequest.defaultExpectation = &ManagerMockRegisterRequestExpectation{}
	}

	mmRegisterRequest.defaultExpectation.params = &ManagerMockRegisterRequestParams{ctx, req}
	for _, e := range mmRegisterRequest.expectations {
		if minimock.Equal(e.params, mmRegisterRequest.defaultExpectation.params) {
			mmRegisterRequest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegisterRequest.defaultExpectation.params)
		}
	}

	return mmRegisterRequest
}

// Inspect accepts an inspector function that has same arguments as the Manager.RegisterRequest
func (mmRegisterRequest *mManagerMockRegisterRequest) Inspect(f func(ctx context.Context, req record.IncomingRequest)) *mManagerMockRegisterRequest {
	if mmRegisterRequest.mock.inspectFuncRegisterRequest != nil {
		mmRegisterRequest.mock.t.Fatalf("Inspect function is already set for ManagerMock.RegisterRequest")
	}

	mmRegisterRequest.mock.inspectFuncRegisterRequest = f

	return mmRegisterRequest
}

// Return sets up results that will be returned by Manager.RegisterRequest
func (mmRegisterRequest *mManagerMockRegisterRequest) Return(ip1 *insolar.ID, err error) *ManagerMock {
	if mmRegisterRequest.mock.funcRegisterRequest != nil {
		mmRegisterRequest.mock.t.Fatalf("ManagerMock.RegisterRequest mock is already set by Set")
	}

	if mmRegisterRequest.defaultExpectation == nil {
		mmRegisterRequest.defaultExpectation = &ManagerMockRegisterRequestExpectation{mock: mmRegisterRequest.mock}
	}
	mmRegisterRequest.defaultExpectation.results = &ManagerMockRegisterRequestResults{ip1, err}
	return mmRegisterRequest.mock
}

//Set uses given function f to mock the Manager.RegisterRequest method
func (mmRegisterRequest *mManagerMockRegisterRequest) Set(f func(ctx context.Context, req record.IncomingRequest) (ip1 *insolar.ID, err error)) *ManagerMock {
	if mmRegisterRequest.defaultExpectation != nil {
		mmRegisterRequest.mock.t.Fatalf("Default expectation is already set for the Manager.RegisterRequest method")
	}

	if len(mmRegisterRequest.expectations) > 0 {
		mmRegisterRequest.mock.t.Fatalf("Some expectations are already set for the Manager.RegisterRequest method")
	}

	mmRegisterRequest.mock.funcRegisterRequest = f
	return mmRegisterRequest.mock
}

// When sets expectation for the Manager.RegisterRequest which will trigger the result defined by the following
// Then helper
func (mmRegisterRequest *mManagerMockRegisterRequest) When(ctx context.Context, req record.IncomingRequest) *ManagerMockRegisterRequestExpectation {
	if mmRegisterRequest.mock.funcRegisterRequest != nil {
		mmRegisterRequest.mock.t.Fatalf("ManagerMock.RegisterRequest mock is already set by Set")
	}

	expectation := &ManagerMockRegisterRequestExpectation{
		mock:   mmRegisterRequest.mock,
		params: &ManagerMockRegisterRequestParams{ctx, req},
	}
	mmRegisterRequest.expectations = append(mmRegisterRequest.expectations, expectation)
	return expectation
}

// Then sets up Manager.RegisterRequest return parameters for the expectation previously defined by the When method
func (e *ManagerMockRegisterRequestExpectation) Then(ip1 *insolar.ID, err error) *ManagerMock {
	e.results = &ManagerMockRegisterRequestResults{ip1, err}
	return e.mock
}

// RegisterRequest implements Manager
func (mmRegisterRequest *ManagerMock) RegisterRequest(ctx context.Context, req record.IncomingRequest) (ip1 *insolar.ID, err error) {
	mm_atomic.AddUint64(&mmRegisterRequest.beforeRegisterRequestCounter, 1)
	defer mm_atomic.AddUint64(&mmRegisterRequest.afterRegisterRequestCounter, 1)

	if mmRegisterRequest.inspectFuncRegisterRequest != nil {
		mmRegisterRequest.inspectFuncRegisterRequest(ctx, req)
	}

	params := &ManagerMockRegisterRequestParams{ctx, req}

	// Record call args
	mmRegisterRequest.RegisterRequestMock.mutex.Lock()
	mmRegisterRequest.RegisterRequestMock.callArgs = append(mmRegisterRequest.RegisterRequestMock.callArgs, params)
	mmRegisterRequest.RegisterRequestMock.mutex.Unlock()

	for _, e := range mmRegisterRequest.RegisterRequestMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ip1, e.results.err
		}
	}

	if mmRegisterRequest.RegisterRequestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegisterRequest.RegisterRequestMock.defaultExpectation.Counter, 1)
		want := mmRegisterRequest.RegisterRequestMock.defaultExpectation.params
		got := ManagerMockRegisterRequestParams{ctx, req}
		if want != nil && !minimock.Equal(*want, got) {
			mmRegisterRequest.t.Errorf("ManagerMock.RegisterRequest got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmRegisterRequest.RegisterRequestMock.defaultExpectation.results
		if results == nil {
			mmRegisterRequest.t.Fatal("No results are set for the ManagerMock.RegisterRequest")
		}
		return (*results).ip1, (*results).err
	}
	if mmRegisterRequest.funcRegisterRequest != nil {
		return mmRegisterRequest.funcRegisterRequest(ctx, req)
	}
	mmRegisterRequest.t.Fatalf("Unexpected call to ManagerMock.RegisterRequest. %v %v", ctx, req)
	return
}

// RegisterRequestAfterCounter returns a count of finished ManagerMock.RegisterRequest invocations
func (mmRegisterRequest *ManagerMock) RegisterRequestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterRequest.afterRegisterRequestCounter)
}

// RegisterRequestBeforeCounter returns a count of ManagerMock.RegisterRequest invocations
func (mmRegisterRequest *ManagerMock) RegisterRequestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterRequest.beforeRegisterRequestCounter)
}

// Calls returns a list of arguments used in each call to ManagerMock.RegisterRequest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegisterRequest *mManagerMockRegisterRequest) Calls() []*ManagerMockRegisterRequestParams {
	mmRegisterRequest.mutex.RLock()

	argCopy := make([]*ManagerMockRegisterRequestParams, len(mmRegisterRequest.callArgs))
	copy(argCopy, mmRegisterRequest.callArgs)

	mmRegisterRequest.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterRequestDone returns true if the count of the RegisterRequest invocations corresponds
// the number of defined expectations
func (m *ManagerMock) MinimockRegisterRequestDone() bool {
	for _, e := range m.RegisterRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterRequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterRequestCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterRequest != nil && mm_atomic.LoadUint64(&m.afterRegisterRequestCounter) < 1 {
		return false
	}
	return true
}

// MinimockRegisterRequestInspect logs each unmet expectation
func (m *ManagerMock) MinimockRegisterRequestInspect() {
	for _, e := range m.RegisterRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ManagerMock.RegisterRequest with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterRequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterRequestCounter) < 1 {
		if m.RegisterRequestMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ManagerMock.RegisterRequest")
		} else {
			m.t.Errorf("Expected call to ManagerMock.RegisterRequest with params: %#v", *m.RegisterRequestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterRequest != nil && mm_atomic.LoadUint64(&m.afterRegisterRequestCounter) < 1 {
		m.t.Error("Expected call to ManagerMock.RegisterRequest")
	}
}

type mManagerMockRegisterResult struct {
	mock               *ManagerMock
	defaultExpectation *ManagerMockRegisterResultExpectation
	expectations       []*ManagerMockRegisterResultExpectation

	callArgs []*ManagerMockRegisterResultParams
	mutex    sync.RWMutex
}

// ManagerMockRegisterResultExpectation specifies expectation struct of the Manager.RegisterResult
type ManagerMockRegisterResultExpectation struct {
	mock    *ManagerMock
	params  *ManagerMockRegisterResultParams
	results *ManagerMockRegisterResultResults
	Counter uint64
}

// ManagerMockRegisterResultParams contains parameters of the Manager.RegisterResult
type ManagerMockRegisterResultParams struct {
	ctx     context.Context
	obj     insolar.Reference
	request insolar.Reference
	payload []byte
}

// ManagerMockRegisterResultResults contains results of the Manager.RegisterResult
type ManagerMockRegisterResultResults struct {
	ip1 *insolar.ID
	err error
}

// Expect sets up expected params for Manager.RegisterResult
func (mmRegisterResult *mManagerMockRegisterResult) Expect(ctx context.Context, obj insolar.Reference, request insolar.Reference, payload []byte) *mManagerMockRegisterResult {
	if mmRegisterResult.mock.funcRegisterResult != nil {
		mmRegisterResult.mock.t.Fatalf("ManagerMock.RegisterResult mock is already set by Set")
	}

	if mmRegisterResult.defaultExpectation == nil {
		mmRegisterResult.defaultExpectation = &ManagerMockRegisterResultExpectation{}
	}

	mmRegisterResult.defaultExpectation.params = &ManagerMockRegisterResultParams{ctx, obj, request, payload}
	for _, e := range mmRegisterResult.expectations {
		if minimock.Equal(e.params, mmRegisterResult.defaultExpectation.params) {
			mmRegisterResult.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegisterResult.defaultExpectation.params)
		}
	}

	return mmRegisterResult
}

// Inspect accepts an inspector function that has same arguments as the Manager.RegisterResult
func (mmRegisterResult *mManagerMockRegisterResult) Inspect(f func(ctx context.Context, obj insolar.Reference, request insolar.Reference, payload []byte)) *mManagerMockRegisterResult {
	if mmRegisterResult.mock.inspectFuncRegisterResult != nil {
		mmRegisterResult.mock.t.Fatalf("Inspect function is already set for ManagerMock.RegisterResult")
	}

	mmRegisterResult.mock.inspectFuncRegisterResult = f

	return mmRegisterResult
}

// Return sets up results that will be returned by Manager.RegisterResult
func (mmRegisterResult *mManagerMockRegisterResult) Return(ip1 *insolar.ID, err error) *ManagerMock {
	if mmRegisterResult.mock.funcRegisterResult != nil {
		mmRegisterResult.mock.t.Fatalf("ManagerMock.RegisterResult mock is already set by Set")
	}

	if mmRegisterResult.defaultExpectation == nil {
		mmRegisterResult.defaultExpectation = &ManagerMockRegisterResultExpectation{mock: mmRegisterResult.mock}
	}
	mmRegisterResult.defaultExpectation.results = &ManagerMockRegisterResultResults{ip1, err}
	return mmRegisterResult.mock
}

//Set uses given function f to mock the Manager.RegisterResult method
func (mmRegisterResult *mManagerMockRegisterResult) Set(f func(ctx context.Context, obj insolar.Reference, request insolar.Reference, payload []byte) (ip1 *insolar.ID, err error)) *ManagerMock {
	if mmRegisterResult.defaultExpectation != nil {
		mmRegisterResult.mock.t.Fatalf("Default expectation is already set for the Manager.RegisterResult method")
	}

	if len(mmRegisterResult.expectations) > 0 {
		mmRegisterResult.mock.t.Fatalf("Some expectations are already set for the Manager.RegisterResult method")
	}

	mmRegisterResult.mock.funcRegisterResult = f
	return mmRegisterResult.mock
}

// When sets expectation for the Manager.RegisterResult which will trigger the result defined by the following
// Then helper
func (mmRegisterResult *mManagerMockRegisterResult) When(ctx context.Context, obj insolar.Reference, request insolar.Reference, payload []byte) *ManagerMockRegisterResultExpectation {
	if mmRegisterResult.mock.funcRegisterResult != nil {
		mmRegisterResult.mock.t.Fatalf("ManagerMock.RegisterResult mock is already set by Set")
	}

	expectation := &ManagerMockRegisterResultExpectation{
		mock:   mmRegisterResult.mock,
		params: &ManagerMockRegisterResultParams{ctx, obj, request, payload},
	}
	mmRegisterResult.expectations = append(mmRegisterResult.expectations, expectation)
	return expectation
}

// Then sets up Manager.RegisterResult return parameters for the expectation previously defined by the When method
func (e *ManagerMockRegisterResultExpectation) Then(ip1 *insolar.ID, err error) *ManagerMock {
	e.results = &ManagerMockRegisterResultResults{ip1, err}
	return e.mock
}

// RegisterResult implements Manager
func (mmRegisterResult *ManagerMock) RegisterResult(ctx context.Context, obj insolar.Reference, request insolar.Reference, payload []byte) (ip1 *insolar.ID, err error) {
	mm_atomic.AddUint64(&mmRegisterResult.beforeRegisterResultCounter, 1)
	defer mm_atomic.AddUint64(&mmRegisterResult.afterRegisterResultCounter, 1)

	if mmRegisterResult.inspectFuncRegisterResult != nil {
		mmRegisterResult.inspectFuncRegisterResult(ctx, obj, request, payload)
	}

	params := &ManagerMockRegisterResultParams{ctx, obj, request, payload}

	// Record call args
	mmRegisterResult.RegisterResultMock.mutex.Lock()
	mmRegisterResult.RegisterResultMock.callArgs = append(mmRegisterResult.RegisterResultMock.callArgs, params)
	mmRegisterResult.RegisterResultMock.mutex.Unlock()

	for _, e := range mmRegisterResult.RegisterResultMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ip1, e.results.err
		}
	}

	if mmRegisterResult.RegisterResultMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegisterResult.RegisterResultMock.defaultExpectation.Counter, 1)
		want := mmRegisterResult.RegisterResultMock.defaultExpectation.params
		got := ManagerMockRegisterResultParams{ctx, obj, request, payload}
		if want != nil && !minimock.Equal(*want, got) {
			mmRegisterResult.t.Errorf("ManagerMock.RegisterResult got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmRegisterResult.RegisterResultMock.defaultExpectation.results
		if results == nil {
			mmRegisterResult.t.Fatal("No results are set for the ManagerMock.RegisterResult")
		}
		return (*results).ip1, (*results).err
	}
	if mmRegisterResult.funcRegisterResult != nil {
		return mmRegisterResult.funcRegisterResult(ctx, obj, request, payload)
	}
	mmRegisterResult.t.Fatalf("Unexpected call to ManagerMock.RegisterResult. %v %v %v %v", ctx, obj, request, payload)
	return
}

// RegisterResultAfterCounter returns a count of finished ManagerMock.RegisterResult invocations
func (mmRegisterResult *ManagerMock) RegisterResultAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterResult.afterRegisterResultCounter)
}

// RegisterResultBeforeCounter returns a count of ManagerMock.RegisterResult invocations
func (mmRegisterResult *ManagerMock) RegisterResultBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterResult.beforeRegisterResultCounter)
}

// Calls returns a list of arguments used in each call to ManagerMock.RegisterResult.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegisterResult *mManagerMockRegisterResult) Calls() []*ManagerMockRegisterResultParams {
	mmRegisterResult.mutex.RLock()

	argCopy := make([]*ManagerMockRegisterResultParams, len(mmRegisterResult.callArgs))
	copy(argCopy, mmRegisterResult.callArgs)

	mmRegisterResult.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterResultDone returns true if the count of the RegisterResult invocations corresponds
// the number of defined expectations
func (m *ManagerMock) MinimockRegisterResultDone() bool {
	for _, e := range m.RegisterResultMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterResultMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterResultCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterResult != nil && mm_atomic.LoadUint64(&m.afterRegisterResultCounter) < 1 {
		return false
	}
	return true
}

// MinimockRegisterResultInspect logs each unmet expectation
func (m *ManagerMock) MinimockRegisterResultInspect() {
	for _, e := range m.RegisterResultMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ManagerMock.RegisterResult with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterResultMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterResultCounter) < 1 {
		if m.RegisterResultMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ManagerMock.RegisterResult")
		} else {
			m.t.Errorf("Expected call to ManagerMock.RegisterResult with params: %#v", *m.RegisterResultMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterResult != nil && mm_atomic.LoadUint64(&m.afterRegisterResultCounter) < 1 {
		m.t.Error("Expected call to ManagerMock.RegisterResult")
	}
}

type mManagerMockUpdateObject struct {
	mock               *ManagerMock
	defaultExpectation *ManagerMockUpdateObjectExpectation
	expectations       []*ManagerMockUpdateObjectExpectation

	callArgs []*ManagerMockUpdateObjectParams
	mutex    sync.RWMutex
}

// ManagerMockUpdateObjectExpectation specifies expectation struct of the Manager.UpdateObject
type ManagerMockUpdateObjectExpectation struct {
	mock    *ManagerMock
	params  *ManagerMockUpdateObjectParams
	results *ManagerMockUpdateObjectResults
	Counter uint64
}

// ManagerMockUpdateObjectParams contains parameters of the Manager.UpdateObject
type ManagerMockUpdateObjectParams struct {
	ctx     context.Context
	domain  insolar.Reference
	request insolar.Reference
	obj     ObjectDescriptor
	memory  []byte
}

// ManagerMockUpdateObjectResults contains results of the Manager.UpdateObject
type ManagerMockUpdateObjectResults struct {
	err error
}

// Expect sets up expected params for Manager.UpdateObject
func (mmUpdateObject *mManagerMockUpdateObject) Expect(ctx context.Context, domain insolar.Reference, request insolar.Reference, obj ObjectDescriptor, memory []byte) *mManagerMockUpdateObject {
	if mmUpdateObject.mock.funcUpdateObject != nil {
		mmUpdateObject.mock.t.Fatalf("ManagerMock.UpdateObject mock is already set by Set")
	}

	if mmUpdateObject.defaultExpectation == nil {
		mmUpdateObject.defaultExpectation = &ManagerMockUpdateObjectExpectation{}
	}

	mmUpdateObject.defaultExpectation.params = &ManagerMockUpdateObjectParams{ctx, domain, request, obj, memory}
	for _, e := range mmUpdateObject.expectations {
		if minimock.Equal(e.params, mmUpdateObject.defaultExpectation.params) {
			mmUpdateObject.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateObject.defaultExpectation.params)
		}
	}

	return mmUpdateObject
}

// Inspect accepts an inspector function that has same arguments as the Manager.UpdateObject
func (mmUpdateObject *mManagerMockUpdateObject) Inspect(f func(ctx context.Context, domain insolar.Reference, request insolar.Reference, obj ObjectDescriptor, memory []byte)) *mManagerMockUpdateObject {
	if mmUpdateObject.mock.inspectFuncUpdateObject != nil {
		mmUpdateObject.mock.t.Fatalf("Inspect function is already set for ManagerMock.UpdateObject")
	}

	mmUpdateObject.mock.inspectFuncUpdateObject = f

	return mmUpdateObject
}

// Return sets up results that will be returned by Manager.UpdateObject
func (mmUpdateObject *mManagerMockUpdateObject) Return(err error) *ManagerMock {
	if mmUpdateObject.mock.funcUpdateObject != nil {
		mmUpdateObject.mock.t.Fatalf("ManagerMock.UpdateObject mock is already set by Set")
	}

	if mmUpdateObject.defaultExpectation == nil {
		mmUpdateObject.defaultExpectation = &ManagerMockUpdateObjectExpectation{mock: mmUpdateObject.mock}
	}
	mmUpdateObject.defaultExpectation.results = &ManagerMockUpdateObjectResults{err}
	return mmUpdateObject.mock
}

//Set uses given function f to mock the Manager.UpdateObject method
func (mmUpdateObject *mManagerMockUpdateObject) Set(f func(ctx context.Context, domain insolar.Reference, request insolar.Reference, obj ObjectDescriptor, memory []byte) (err error)) *ManagerMock {
	if mmUpdateObject.defaultExpectation != nil {
		mmUpdateObject.mock.t.Fatalf("Default expectation is already set for the Manager.UpdateObject method")
	}

	if len(mmUpdateObject.expectations) > 0 {
		mmUpdateObject.mock.t.Fatalf("Some expectations are already set for the Manager.UpdateObject method")
	}

	mmUpdateObject.mock.funcUpdateObject = f
	return mmUpdateObject.mock
}

// When sets expectation for the Manager.UpdateObject which will trigger the result defined by the following
// Then helper
func (mmUpdateObject *mManagerMockUpdateObject) When(ctx context.Context, domain insolar.Reference, request insolar.Reference, obj ObjectDescriptor, memory []byte) *ManagerMockUpdateObjectExpectation {
	if mmUpdateObject.mock.funcUpdateObject != nil {
		mmUpdateObject.mock.t.Fatalf("ManagerMock.UpdateObject mock is already set by Set")
	}

	expectation := &ManagerMockUpdateObjectExpectation{
		mock:   mmUpdateObject.mock,
		params: &ManagerMockUpdateObjectParams{ctx, domain, request, obj, memory},
	}
	mmUpdateObject.expectations = append(mmUpdateObject.expectations, expectation)
	return expectation
}

// Then sets up Manager.UpdateObject return parameters for the expectation previously defined by the When method
func (e *ManagerMockUpdateObjectExpectation) Then(err error) *ManagerMock {
	e.results = &ManagerMockUpdateObjectResults{err}
	return e.mock
}

// UpdateObject implements Manager
func (mmUpdateObject *ManagerMock) UpdateObject(ctx context.Context, domain insolar.Reference, request insolar.Reference, obj ObjectDescriptor, memory []byte) (err error) {
	mm_atomic.AddUint64(&mmUpdateObject.beforeUpdateObjectCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateObject.afterUpdateObjectCounter, 1)

	if mmUpdateObject.inspectFuncUpdateObject != nil {
		mmUpdateObject.inspectFuncUpdateObject(ctx, domain, request, obj, memory)
	}

	params := &ManagerMockUpdateObjectParams{ctx, domain, request, obj, memory}

	// Record call args
	mmUpdateObject.UpdateObjectMock.mutex.Lock()
	mmUpdateObject.UpdateObjectMock.callArgs = append(mmUpdateObject.UpdateObjectMock.callArgs, params)
	mmUpdateObject.UpdateObjectMock.mutex.Unlock()

	for _, e := range mmUpdateObject.UpdateObjectMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateObject.UpdateObjectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateObject.UpdateObjectMock.defaultExpectation.Counter, 1)
		want := mmUpdateObject.UpdateObjectMock.defaultExpectation.params
		got := ManagerMockUpdateObjectParams{ctx, domain, request, obj, memory}
		if want != nil && !minimock.Equal(*want, got) {
			mmUpdateObject.t.Errorf("ManagerMock.UpdateObject got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmUpdateObject.UpdateObjectMock.defaultExpectation.results
		if results == nil {
			mmUpdateObject.t.Fatal("No results are set for the ManagerMock.UpdateObject")
		}
		return (*results).err
	}
	if mmUpdateObject.funcUpdateObject != nil {
		return mmUpdateObject.funcUpdateObject(ctx, domain, request, obj, memory)
	}
	mmUpdateObject.t.Fatalf("Unexpected call to ManagerMock.UpdateObject. %v %v %v %v %v", ctx, domain, request, obj, memory)
	return
}

// UpdateObjectAfterCounter returns a count of finished ManagerMock.UpdateObject invocations
func (mmUpdateObject *ManagerMock) UpdateObjectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateObject.afterUpdateObjectCounter)
}

// UpdateObjectBeforeCounter returns a count of ManagerMock.UpdateObject invocations
func (mmUpdateObject *ManagerMock) UpdateObjectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateObject.beforeUpdateObjectCounter)
}

// Calls returns a list of arguments used in each call to ManagerMock.UpdateObject.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateObject *mManagerMockUpdateObject) Calls() []*ManagerMockUpdateObjectParams {
	mmUpdateObject.mutex.RLock()

	argCopy := make([]*ManagerMockUpdateObjectParams, len(mmUpdateObject.callArgs))
	copy(argCopy, mmUpdateObject.callArgs)

	mmUpdateObject.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateObjectDone returns true if the count of the UpdateObject invocations corresponds
// the number of defined expectations
func (m *ManagerMock) MinimockUpdateObjectDone() bool {
	for _, e := range m.UpdateObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateObjectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateObjectCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateObject != nil && mm_atomic.LoadUint64(&m.afterUpdateObjectCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateObjectInspect logs each unmet expectation
func (m *ManagerMock) MinimockUpdateObjectInspect() {
	for _, e := range m.UpdateObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ManagerMock.UpdateObject with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateObjectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateObjectCounter) < 1 {
		if m.UpdateObjectMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ManagerMock.UpdateObject")
		} else {
			m.t.Errorf("Expected call to ManagerMock.UpdateObject with params: %#v", *m.UpdateObjectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateObject != nil && mm_atomic.LoadUint64(&m.afterUpdateObjectCounter) < 1 {
		m.t.Error("Expected call to ManagerMock.UpdateObject")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ManagerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockActivateObjectInspect()

		m.MinimockDeployCodeInspect()

		m.MinimockGetObjectInspect()

		m.MinimockRegisterRequestInspect()

		m.MinimockRegisterResultInspect()

		m.MinimockUpdateObjectInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ManagerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ManagerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockActivateObjectDone() &&
		m.MinimockDeployCodeDone() &&
		m.MinimockGetObjectDone() &&
		m.MinimockRegisterRequestDone() &&
		m.MinimockRegisterResultDone() &&
		m.MinimockUpdateObjectDone()
}
