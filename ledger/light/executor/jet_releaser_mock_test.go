package executor

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/insolar"
)

// JetReleaserMock implements JetReleaser
type JetReleaserMock struct {
	t minimock.Tester

	funcCloseAllUntil          func(ctx context.Context, pulse insolar.PulseNumber)
	inspectFuncCloseAllUntil   func(ctx context.Context, pulse insolar.PulseNumber)
	afterCloseAllUntilCounter  uint64
	beforeCloseAllUntilCounter uint64
	CloseAllUntilMock          mJetReleaserMockCloseAllUntil

	funcUnlock          func(ctx context.Context, pulse insolar.PulseNumber, jetID insolar.JetID) (err error)
	inspectFuncUnlock   func(ctx context.Context, pulse insolar.PulseNumber, jetID insolar.JetID)
	afterUnlockCounter  uint64
	beforeUnlockCounter uint64
	UnlockMock          mJetReleaserMockUnlock
}

// NewJetReleaserMock returns a mock for JetReleaser
func NewJetReleaserMock(t minimock.Tester) *JetReleaserMock {
	m := &JetReleaserMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CloseAllUntilMock = mJetReleaserMockCloseAllUntil{mock: m}
	m.CloseAllUntilMock.callArgs = []*JetReleaserMockCloseAllUntilParams{}

	m.UnlockMock = mJetReleaserMockUnlock{mock: m}
	m.UnlockMock.callArgs = []*JetReleaserMockUnlockParams{}

	return m
}

type mJetReleaserMockCloseAllUntil struct {
	mock               *JetReleaserMock
	defaultExpectation *JetReleaserMockCloseAllUntilExpectation
	expectations       []*JetReleaserMockCloseAllUntilExpectation

	callArgs []*JetReleaserMockCloseAllUntilParams
	mutex    sync.RWMutex
}

// JetReleaserMockCloseAllUntilExpectation specifies expectation struct of the JetReleaser.CloseAllUntil
type JetReleaserMockCloseAllUntilExpectation struct {
	mock   *JetReleaserMock
	params *JetReleaserMockCloseAllUntilParams

	Counter uint64
}

// JetReleaserMockCloseAllUntilParams contains parameters of the JetReleaser.CloseAllUntil
type JetReleaserMockCloseAllUntilParams struct {
	ctx   context.Context
	pulse insolar.PulseNumber
}

// Expect sets up expected params for JetReleaser.CloseAllUntil
func (mmCloseAllUntil *mJetReleaserMockCloseAllUntil) Expect(ctx context.Context, pulse insolar.PulseNumber) *mJetReleaserMockCloseAllUntil {
	if mmCloseAllUntil.mock.funcCloseAllUntil != nil {
		mmCloseAllUntil.mock.t.Fatalf("JetReleaserMock.CloseAllUntil mock is already set by Set")
	}

	if mmCloseAllUntil.defaultExpectation == nil {
		mmCloseAllUntil.defaultExpectation = &JetReleaserMockCloseAllUntilExpectation{}
	}

	mmCloseAllUntil.defaultExpectation.params = &JetReleaserMockCloseAllUntilParams{ctx, pulse}
	for _, e := range mmCloseAllUntil.expectations {
		if minimock.Equal(e.params, mmCloseAllUntil.defaultExpectation.params) {
			mmCloseAllUntil.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCloseAllUntil.defaultExpectation.params)
		}
	}

	return mmCloseAllUntil
}

// Inspect accepts an inspector function that has same arguments as the JetReleaser.CloseAllUntil
func (mmCloseAllUntil *mJetReleaserMockCloseAllUntil) Inspect(f func(ctx context.Context, pulse insolar.PulseNumber)) *mJetReleaserMockCloseAllUntil {
	if mmCloseAllUntil.mock.inspectFuncCloseAllUntil != nil {
		mmCloseAllUntil.mock.t.Fatalf("Inspect function is already set for JetReleaserMock.CloseAllUntil")
	}

	mmCloseAllUntil.mock.inspectFuncCloseAllUntil = f

	return mmCloseAllUntil
}

// Return sets up results that will be returned by JetReleaser.CloseAllUntil
func (mmCloseAllUntil *mJetReleaserMockCloseAllUntil) Return() *JetReleaserMock {
	if mmCloseAllUntil.mock.funcCloseAllUntil != nil {
		mmCloseAllUntil.mock.t.Fatalf("JetReleaserMock.CloseAllUntil mock is already set by Set")
	}

	if mmCloseAllUntil.defaultExpectation == nil {
		mmCloseAllUntil.defaultExpectation = &JetReleaserMockCloseAllUntilExpectation{mock: mmCloseAllUntil.mock}
	}

	return mmCloseAllUntil.mock
}

//Set uses given function f to mock the JetReleaser.CloseAllUntil method
func (mmCloseAllUntil *mJetReleaserMockCloseAllUntil) Set(f func(ctx context.Context, pulse insolar.PulseNumber)) *JetReleaserMock {
	if mmCloseAllUntil.defaultExpectation != nil {
		mmCloseAllUntil.mock.t.Fatalf("Default expectation is already set for the JetReleaser.CloseAllUntil method")
	}

	if len(mmCloseAllUntil.expectations) > 0 {
		mmCloseAllUntil.mock.t.Fatalf("Some expectations are already set for the JetReleaser.CloseAllUntil method")
	}

	mmCloseAllUntil.mock.funcCloseAllUntil = f
	return mmCloseAllUntil.mock
}

// CloseAllUntil implements JetReleaser
func (mmCloseAllUntil *JetReleaserMock) CloseAllUntil(ctx context.Context, pulse insolar.PulseNumber) {
	mm_atomic.AddUint64(&mmCloseAllUntil.beforeCloseAllUntilCounter, 1)
	defer mm_atomic.AddUint64(&mmCloseAllUntil.afterCloseAllUntilCounter, 1)

	if mmCloseAllUntil.inspectFuncCloseAllUntil != nil {
		mmCloseAllUntil.inspectFuncCloseAllUntil(ctx, pulse)
	}

	params := &JetReleaserMockCloseAllUntilParams{ctx, pulse}

	// Record call args
	mmCloseAllUntil.CloseAllUntilMock.mutex.Lock()
	mmCloseAllUntil.CloseAllUntilMock.callArgs = append(mmCloseAllUntil.CloseAllUntilMock.callArgs, params)
	mmCloseAllUntil.CloseAllUntilMock.mutex.Unlock()

	for _, e := range mmCloseAllUntil.CloseAllUntilMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmCloseAllUntil.CloseAllUntilMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCloseAllUntil.CloseAllUntilMock.defaultExpectation.Counter, 1)
		want := mmCloseAllUntil.CloseAllUntilMock.defaultExpectation.params
		got := JetReleaserMockCloseAllUntilParams{ctx, pulse}
		if want != nil && !minimock.Equal(*want, got) {
			mmCloseAllUntil.t.Errorf("JetReleaserMock.CloseAllUntil got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmCloseAllUntil.funcCloseAllUntil != nil {
		mmCloseAllUntil.funcCloseAllUntil(ctx, pulse)
		return
	}
	mmCloseAllUntil.t.Fatalf("Unexpected call to JetReleaserMock.CloseAllUntil. %v %v", ctx, pulse)

}

// CloseAllUntilAfterCounter returns a count of finished JetReleaserMock.CloseAllUntil invocations
func (mmCloseAllUntil *JetReleaserMock) CloseAllUntilAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCloseAllUntil.afterCloseAllUntilCounter)
}

// CloseAllUntilBeforeCounter returns a count of JetReleaserMock.CloseAllUntil invocations
func (mmCloseAllUntil *JetReleaserMock) CloseAllUntilBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCloseAllUntil.beforeCloseAllUntilCounter)
}

// Calls returns a list of arguments used in each call to JetReleaserMock.CloseAllUntil.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCloseAllUntil *mJetReleaserMockCloseAllUntil) Calls() []*JetReleaserMockCloseAllUntilParams {
	mmCloseAllUntil.mutex.RLock()

	argCopy := make([]*JetReleaserMockCloseAllUntilParams, len(mmCloseAllUntil.callArgs))
	copy(argCopy, mmCloseAllUntil.callArgs)

	mmCloseAllUntil.mutex.RUnlock()

	return argCopy
}

// MinimockCloseAllUntilDone returns true if the count of the CloseAllUntil invocations corresponds
// the number of defined expectations
func (m *JetReleaserMock) MinimockCloseAllUntilDone() bool {
	for _, e := range m.CloseAllUntilMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseAllUntilMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseAllUntilCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCloseAllUntil != nil && mm_atomic.LoadUint64(&m.afterCloseAllUntilCounter) < 1 {
		return false
	}
	return true
}

// MinimockCloseAllUntilInspect logs each unmet expectation
func (m *JetReleaserMock) MinimockCloseAllUntilInspect() {
	for _, e := range m.CloseAllUntilMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to JetReleaserMock.CloseAllUntil with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseAllUntilMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseAllUntilCounter) < 1 {
		if m.CloseAllUntilMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to JetReleaserMock.CloseAllUntil")
		} else {
			m.t.Errorf("Expected call to JetReleaserMock.CloseAllUntil with params: %#v", *m.CloseAllUntilMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCloseAllUntil != nil && mm_atomic.LoadUint64(&m.afterCloseAllUntilCounter) < 1 {
		m.t.Error("Expected call to JetReleaserMock.CloseAllUntil")
	}
}

type mJetReleaserMockUnlock struct {
	mock               *JetReleaserMock
	defaultExpectation *JetReleaserMockUnlockExpectation
	expectations       []*JetReleaserMockUnlockExpectation

	callArgs []*JetReleaserMockUnlockParams
	mutex    sync.RWMutex
}

// JetReleaserMockUnlockExpectation specifies expectation struct of the JetReleaser.Unlock
type JetReleaserMockUnlockExpectation struct {
	mock    *JetReleaserMock
	params  *JetReleaserMockUnlockParams
	results *JetReleaserMockUnlockResults
	Counter uint64
}

// JetReleaserMockUnlockParams contains parameters of the JetReleaser.Unlock
type JetReleaserMockUnlockParams struct {
	ctx   context.Context
	pulse insolar.PulseNumber
	jetID insolar.JetID
}

// JetReleaserMockUnlockResults contains results of the JetReleaser.Unlock
type JetReleaserMockUnlockResults struct {
	err error
}

// Expect sets up expected params for JetReleaser.Unlock
func (mmUnlock *mJetReleaserMockUnlock) Expect(ctx context.Context, pulse insolar.PulseNumber, jetID insolar.JetID) *mJetReleaserMockUnlock {
	if mmUnlock.mock.funcUnlock != nil {
		mmUnlock.mock.t.Fatalf("JetReleaserMock.Unlock mock is already set by Set")
	}

	if mmUnlock.defaultExpectation == nil {
		mmUnlock.defaultExpectation = &JetReleaserMockUnlockExpectation{}
	}

	mmUnlock.defaultExpectation.params = &JetReleaserMockUnlockParams{ctx, pulse, jetID}
	for _, e := range mmUnlock.expectations {
		if minimock.Equal(e.params, mmUnlock.defaultExpectation.params) {
			mmUnlock.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUnlock.defaultExpectation.params)
		}
	}

	return mmUnlock
}

// Inspect accepts an inspector function that has same arguments as the JetReleaser.Unlock
func (mmUnlock *mJetReleaserMockUnlock) Inspect(f func(ctx context.Context, pulse insolar.PulseNumber, jetID insolar.JetID)) *mJetReleaserMockUnlock {
	if mmUnlock.mock.inspectFuncUnlock != nil {
		mmUnlock.mock.t.Fatalf("Inspect function is already set for JetReleaserMock.Unlock")
	}

	mmUnlock.mock.inspectFuncUnlock = f

	return mmUnlock
}

// Return sets up results that will be returned by JetReleaser.Unlock
func (mmUnlock *mJetReleaserMockUnlock) Return(err error) *JetReleaserMock {
	if mmUnlock.mock.funcUnlock != nil {
		mmUnlock.mock.t.Fatalf("JetReleaserMock.Unlock mock is already set by Set")
	}

	if mmUnlock.defaultExpectation == nil {
		mmUnlock.defaultExpectation = &JetReleaserMockUnlockExpectation{mock: mmUnlock.mock}
	}
	mmUnlock.defaultExpectation.results = &JetReleaserMockUnlockResults{err}
	return mmUnlock.mock
}

//Set uses given function f to mock the JetReleaser.Unlock method
func (mmUnlock *mJetReleaserMockUnlock) Set(f func(ctx context.Context, pulse insolar.PulseNumber, jetID insolar.JetID) (err error)) *JetReleaserMock {
	if mmUnlock.defaultExpectation != nil {
		mmUnlock.mock.t.Fatalf("Default expectation is already set for the JetReleaser.Unlock method")
	}

	if len(mmUnlock.expectations) > 0 {
		mmUnlock.mock.t.Fatalf("Some expectations are already set for the JetReleaser.Unlock method")
	}

	mmUnlock.mock.funcUnlock = f
	return mmUnlock.mock
}

// When sets expectation for the JetReleaser.Unlock which will trigger the result defined by the following
// Then helper
func (mmUnlock *mJetReleaserMockUnlock) When(ctx context.Context, pulse insolar.PulseNumber, jetID insolar.JetID) *JetReleaserMockUnlockExpectation {
	if mmUnlock.mock.funcUnlock != nil {
		mmUnlock.mock.t.Fatalf("JetReleaserMock.Unlock mock is already set by Set")
	}

	expectation := &JetReleaserMockUnlockExpectation{
		mock:   mmUnlock.mock,
		params: &JetReleaserMockUnlockParams{ctx, pulse, jetID},
	}
	mmUnlock.expectations = append(mmUnlock.expectations, expectation)
	return expectation
}

// Then sets up JetReleaser.Unlock return parameters for the expectation previously defined by the When method
func (e *JetReleaserMockUnlockExpectation) Then(err error) *JetReleaserMock {
	e.results = &JetReleaserMockUnlockResults{err}
	return e.mock
}

// Unlock implements JetReleaser
func (mmUnlock *JetReleaserMock) Unlock(ctx context.Context, pulse insolar.PulseNumber, jetID insolar.JetID) (err error) {
	mm_atomic.AddUint64(&mmUnlock.beforeUnlockCounter, 1)
	defer mm_atomic.AddUint64(&mmUnlock.afterUnlockCounter, 1)

	if mmUnlock.inspectFuncUnlock != nil {
		mmUnlock.inspectFuncUnlock(ctx, pulse, jetID)
	}

	params := &JetReleaserMockUnlockParams{ctx, pulse, jetID}

	// Record call args
	mmUnlock.UnlockMock.mutex.Lock()
	mmUnlock.UnlockMock.callArgs = append(mmUnlock.UnlockMock.callArgs, params)
	mmUnlock.UnlockMock.mutex.Unlock()

	for _, e := range mmUnlock.UnlockMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUnlock.UnlockMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUnlock.UnlockMock.defaultExpectation.Counter, 1)
		want := mmUnlock.UnlockMock.defaultExpectation.params
		got := JetReleaserMockUnlockParams{ctx, pulse, jetID}
		if want != nil && !minimock.Equal(*want, got) {
			mmUnlock.t.Errorf("JetReleaserMock.Unlock got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmUnlock.UnlockMock.defaultExpectation.results
		if results == nil {
			mmUnlock.t.Fatal("No results are set for the JetReleaserMock.Unlock")
		}
		return (*results).err
	}
	if mmUnlock.funcUnlock != nil {
		return mmUnlock.funcUnlock(ctx, pulse, jetID)
	}
	mmUnlock.t.Fatalf("Unexpected call to JetReleaserMock.Unlock. %v %v %v", ctx, pulse, jetID)
	return
}

// UnlockAfterCounter returns a count of finished JetReleaserMock.Unlock invocations
func (mmUnlock *JetReleaserMock) UnlockAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnlock.afterUnlockCounter)
}

// UnlockBeforeCounter returns a count of JetReleaserMock.Unlock invocations
func (mmUnlock *JetReleaserMock) UnlockBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnlock.beforeUnlockCounter)
}

// Calls returns a list of arguments used in each call to JetReleaserMock.Unlock.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUnlock *mJetReleaserMockUnlock) Calls() []*JetReleaserMockUnlockParams {
	mmUnlock.mutex.RLock()

	argCopy := make([]*JetReleaserMockUnlockParams, len(mmUnlock.callArgs))
	copy(argCopy, mmUnlock.callArgs)

	mmUnlock.mutex.RUnlock()

	return argCopy
}

// MinimockUnlockDone returns true if the count of the Unlock invocations corresponds
// the number of defined expectations
func (m *JetReleaserMock) MinimockUnlockDone() bool {
	for _, e := range m.UnlockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnlockMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnlockCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnlock != nil && mm_atomic.LoadUint64(&m.afterUnlockCounter) < 1 {
		return false
	}
	return true
}

// MinimockUnlockInspect logs each unmet expectation
func (m *JetReleaserMock) MinimockUnlockInspect() {
	for _, e := range m.UnlockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to JetReleaserMock.Unlock with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnlockMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnlockCounter) < 1 {
		if m.UnlockMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to JetReleaserMock.Unlock")
		} else {
			m.t.Errorf("Expected call to JetReleaserMock.Unlock with params: %#v", *m.UnlockMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnlock != nil && mm_atomic.LoadUint64(&m.afterUnlockCounter) < 1 {
		m.t.Error("Expected call to JetReleaserMock.Unlock")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *JetReleaserMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCloseAllUntilInspect()

		m.MinimockUnlockInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *JetReleaserMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *JetReleaserMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCloseAllUntilDone() &&
		m.MinimockUnlockDone()
}
